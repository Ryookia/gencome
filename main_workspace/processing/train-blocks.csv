"id"$"block_code"$"contents"
"CollectionUtils.java:1"$0$"/*"
"CollectionUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"CollectionUtils.java:3"$0$" *"
"CollectionUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CollectionUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"CollectionUtils.java:6"$0$" * You may obtain a copy of the License at"
"CollectionUtils.java:7"$0$" *"
"CollectionUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CollectionUtils.java:9"$0$" *"
"CollectionUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CollectionUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CollectionUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CollectionUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"CollectionUtils.java:14"$0$" * limitations under the License."
"CollectionUtils.java:15"$0$" */"
"CollectionUtils.java:16"$0$""
"CollectionUtils.java:17"$0$"package org.springframework.util;"
"CollectionUtils.java:18"$0$""
"CollectionUtils.java:19"$0$"import java.io.Serializable;"
"CollectionUtils.java:20"$0$"import java.util.ArrayList;"
"CollectionUtils.java:21"$0$"import java.util.Arrays;"
"CollectionUtils.java:22"$0$"import java.util.Collection;"
"CollectionUtils.java:23"$0$"import java.util.Collections;"
"CollectionUtils.java:24"$0$"import java.util.Enumeration;"
"CollectionUtils.java:25"$0$"import java.util.Iterator;"
"CollectionUtils.java:26"$0$"import java.util.LinkedHashMap;"
"CollectionUtils.java:27"$0$"import java.util.LinkedList;"
"CollectionUtils.java:28"$0$"import java.util.List;"
"CollectionUtils.java:29"$0$"import java.util.Map;"
"CollectionUtils.java:30"$0$"import java.util.Properties;"
"CollectionUtils.java:31"$0$"import java.util.Set;"
"CollectionUtils.java:32"$0$"import java.util.SortedSet;"
"CollectionUtils.java:33"$0$""
"CollectionUtils.java:34"$0$"import org.springframework.lang.Nullable;"
"CollectionUtils.java:35"$0$""
"CollectionUtils.java:36"$0$"/**"
"CollectionUtils.java:37"$0$" * Miscellaneous collection utility methods."
"CollectionUtils.java:38"$0$" * Mainly for internal use within the framework."
"CollectionUtils.java:39"$0$" *"
"CollectionUtils.java:40"$0$" * @author Juergen Hoeller"
"CollectionUtils.java:41"$0$" * @author Rob Harrop"
"CollectionUtils.java:42"$0$" * @author Arjen Poutsma"
"CollectionUtils.java:43"$0$" * @since 1.1.3"
"CollectionUtils.java:44"$0$" */"
"CollectionUtils.java:45"$1$"public abstract class CollectionUtils {"
"CollectionUtils.java:46"$1$""
"CollectionUtils.java:47"$1$"	/**"
"CollectionUtils.java:48"$1$"	 * Return {@code true} if the supplied Collection is {@code null} or empty."
"CollectionUtils.java:49"$1$"	 * Otherwise, return {@code false}."
"CollectionUtils.java:50"$1$"	 * @param collection the Collection to check"
"CollectionUtils.java:51"$1$"	 * @return whether the given Collection is empty"
"CollectionUtils.java:52"$1$"	 */"
"CollectionUtils.java:53"$1$"	public static boolean isEmpty(@Nullable Collection<?> collection) {"
"CollectionUtils.java:54"$1$"		return (collection == null || collection.isEmpty());"
"CollectionUtils.java:55"$1$"	}"
"CollectionUtils.java:56"$0$""
"CollectionUtils.java:57"$0$"	/**"
"CollectionUtils.java:58"$1$"	 * Return {@code true} if the supplied Map is {@code null} or empty."
"CollectionUtils.java:59"$1$"	 * Otherwise, return {@code false}."
"CollectionUtils.java:60"$0$"	 * @param map the Map to check"
"CollectionUtils.java:61"$0$"	 * @return whether the given Map is empty"
"CollectionUtils.java:62"$0$"	 */"
"CollectionUtils.java:63"$1$"	public static boolean isEmpty(@Nullable Map<?, ?> map) {"
"CollectionUtils.java:64"$1$"		return (map == null || map.isEmpty());"
"CollectionUtils.java:65"$1$"	}"
"CollectionUtils.java:66"$0$""
"CollectionUtils.java:67"$0$"	/**"
"CollectionUtils.java:68"$0$"	 * Convert the supplied array into a List. A primitive array gets converted"
"CollectionUtils.java:69"$0$"	 * into a List of the appropriate wrapper type."
"CollectionUtils.java:70"$1$"	 * <p><b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method."
"CollectionUtils.java:71"$1$"	 * This {@code arrayToList} method is just meant to deal with an incoming Object"
"CollectionUtils.java:72"$1$"	 * value that might be an {@code Object[]} or a primitive array at runtime."
"CollectionUtils.java:73"$1$"	 * <p>A {@code null} source value will be converted to an empty List."
"CollectionUtils.java:74"$0$"	 * @param source the (potentially primitive) array"
"CollectionUtils.java:75"$0$"	 * @return the converted List result"
"CollectionUtils.java:76"$0$"	 * @see ObjectUtils#toObjectArray(Object)"
"CollectionUtils.java:77"$0$"	 * @see Arrays#asList(Object[])"
"CollectionUtils.java:78"$0$"	 */"
"CollectionUtils.java:79"$0$"	@SuppressWarnings(""rawtypes"")"
"CollectionUtils.java:80"$1$"	public static List arrayToList(@Nullable Object source) {"
"CollectionUtils.java:81"$1$"		return Arrays.asList(ObjectUtils.toObjectArray(source));"
"CollectionUtils.java:82"$1$"	}"
"CollectionUtils.java:83"$0$""
"CollectionUtils.java:84"$0$"	/**"
"CollectionUtils.java:85"$0$"	 * Merge the given array into the given Collection."
"CollectionUtils.java:86"$1$"	 * @param array the array to merge (may be {@code null})"
"CollectionUtils.java:87"$0$"	 * @param collection the target Collection to merge the array into"
"CollectionUtils.java:88"$0$"	 */"
"CollectionUtils.java:89"$0$"	@SuppressWarnings(""unchecked"")"
"CollectionUtils.java:90"$1$"	public static <E> void mergeArrayIntoCollection(@Nullable Object array, Collection<E> collection) {"
"CollectionUtils.java:91"$1$"		Object[] arr = ObjectUtils.toObjectArray(array);"
"CollectionUtils.java:92"$1$"		for (Object elem : arr) {"
"CollectionUtils.java:93"$1$"			collection.add((E) elem);"
"CollectionUtils.java:94"$1$"		}"
"CollectionUtils.java:95"$0$"	}"
"CollectionUtils.java:96"$0$""
"CollectionUtils.java:97"$0$"	/**"
"CollectionUtils.java:98"$0$"	 * Merge the given Properties instance into the given Map,"
"CollectionUtils.java:99"$0$"	 * copying all properties (key-value pairs) over."
"CollectionUtils.java:100"$1$"	 * <p>Uses {@code Properties.propertyNames()} to even catch"
"CollectionUtils.java:101"$0$"	 * default properties linked into the original Properties instance."
"CollectionUtils.java:102"$1$"	 * @param props the Properties instance to merge (may be {@code null})"
"CollectionUtils.java:103"$0$"	 * @param map the target Map to merge the properties into"
"CollectionUtils.java:104"$0$"	 */"
"CollectionUtils.java:105"$0$"	@SuppressWarnings(""unchecked"")"
"CollectionUtils.java:106"$1$"	public static <K, V> void mergePropertiesIntoMap(@Nullable Properties props, Map<K, V> map) {"
"CollectionUtils.java:107"$1$"		if (props != null) {"
"CollectionUtils.java:108"$1$"			for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {"
"CollectionUtils.java:109"$1$"				String key = (String) en.nextElement();"
"CollectionUtils.java:110"$1$"				Object value = props.get(key);"
"CollectionUtils.java:111"$1$"				if (value == null) {"
"CollectionUtils.java:112"$0$"					// Allow for defaults fallback or potentially overridden accessor..."
"CollectionUtils.java:113"$1$"					value = props.getProperty(key);"
"CollectionUtils.java:114"$1$"				}"
"CollectionUtils.java:115"$0$"				map.put((K) key, (V) value);"
"CollectionUtils.java:116"$0$"			}"
"CollectionUtils.java:117"$0$"		}"
"CollectionUtils.java:118"$0$"	}"
"CollectionUtils.java:119"$0$""
"CollectionUtils.java:120"$0$""
"CollectionUtils.java:121"$0$"	/**"
"CollectionUtils.java:122"$0$"	 * Check whether the given Iterator contains the given element."
"CollectionUtils.java:123"$0$"	 * @param iterator the Iterator to check"
"CollectionUtils.java:124"$0$"	 * @param element the element to look for"
"CollectionUtils.java:125"$1$"	 * @return {@code true} if found, {@code false} otherwise"
"CollectionUtils.java:126"$0$"	 */"
"CollectionUtils.java:127"$1$"	public static boolean contains(@Nullable Iterator<?> iterator, Object element) {"
"CollectionUtils.java:128"$1$"		if (iterator != null) {"
"CollectionUtils.java:129"$1$"			while (iterator.hasNext()) {"
"CollectionUtils.java:130"$1$"				Object candidate = iterator.next();"
"CollectionUtils.java:131"$1$"				if (ObjectUtils.nullSafeEquals(candidate, element)) {"
"CollectionUtils.java:132"$1$"					return true;"
"CollectionUtils.java:133"$1$"				}"
"CollectionUtils.java:134"$0$"			}"
"CollectionUtils.java:135"$0$"		}"
"CollectionUtils.java:136"$0$"		return false;"
"CollectionUtils.java:137"$0$"	}"
"CollectionUtils.java:138"$0$""
"CollectionUtils.java:139"$0$"	/**"
"CollectionUtils.java:140"$0$"	 * Check whether the given Enumeration contains the given element."
"CollectionUtils.java:141"$0$"	 * @param enumeration the Enumeration to check"
"CollectionUtils.java:142"$0$"	 * @param element the element to look for"
"CollectionUtils.java:143"$1$"	 * @return {@code true} if found, {@code false} otherwise"
"CollectionUtils.java:144"$0$"	 */"
"CollectionUtils.java:145"$1$"	public static boolean contains(@Nullable Enumeration<?> enumeration, Object element) {"
"CollectionUtils.java:146"$1$"		if (enumeration != null) {"
"CollectionUtils.java:147"$1$"			while (enumeration.hasMoreElements()) {"
"CollectionUtils.java:148"$1$"				Object candidate = enumeration.nextElement();"
"CollectionUtils.java:149"$1$"				if (ObjectUtils.nullSafeEquals(candidate, element)) {"
"CollectionUtils.java:150"$1$"					return true;"
"CollectionUtils.java:151"$1$"				}"
"CollectionUtils.java:152"$0$"			}"
"CollectionUtils.java:153"$0$"		}"
"CollectionUtils.java:154"$0$"		return false;"
"CollectionUtils.java:155"$0$"	}"
"CollectionUtils.java:156"$0$""
"CollectionUtils.java:157"$0$"	/**"
"CollectionUtils.java:158"$0$"	 * Check whether the given Collection contains the given element instance."
"CollectionUtils.java:159"$0$"	 * <p>Enforces the given instance to be present, rather than returning"
"CollectionUtils.java:160"$1$"	 * {@code true} for an equal element as well."
"CollectionUtils.java:161"$0$"	 * @param collection the Collection to check"
"CollectionUtils.java:162"$0$"	 * @param element the element to look for"
"CollectionUtils.java:163"$1$"	 * @return {@code true} if found, {@code false} otherwise"
"CollectionUtils.java:164"$0$"	 */"
"CollectionUtils.java:165"$1$"	public static boolean containsInstance(@Nullable Collection<?> collection, Object element) {"
"CollectionUtils.java:166"$1$"		if (collection != null) {"
"CollectionUtils.java:167"$1$"			for (Object candidate : collection) {"
"CollectionUtils.java:168"$1$"				if (candidate == element) {"
"CollectionUtils.java:169"$1$"					return true;"
"CollectionUtils.java:170"$1$"				}"
"CollectionUtils.java:171"$0$"			}"
"CollectionUtils.java:172"$0$"		}"
"CollectionUtils.java:173"$0$"		return false;"
"CollectionUtils.java:174"$0$"	}"
"CollectionUtils.java:175"$0$""
"CollectionUtils.java:176"$0$"	/**"
"CollectionUtils.java:177"$1$"	 * Return {@code true} if any element in '{@code candidates}' is"
"CollectionUtils.java:178"$1$"	 * contained in '{@code source}'; otherwise returns {@code false}."
"CollectionUtils.java:179"$0$"	 * @param source the source Collection"
"CollectionUtils.java:180"$0$"	 * @param candidates the candidates to search for"
"CollectionUtils.java:181"$0$"	 * @return whether any of the candidates has been found"
"CollectionUtils.java:182"$0$"	 */"
"CollectionUtils.java:183"$1$"	public static boolean containsAny(Collection<?> source, Collection<?> candidates) {"
"CollectionUtils.java:184"$1$"		return findFirstMatch(source, candidates) != null;"
"CollectionUtils.java:185"$1$"	}"
"CollectionUtils.java:186"$0$""
"CollectionUtils.java:187"$0$"	/**"
"CollectionUtils.java:188"$1$"	 * Return the first element in '{@code candidates}' that is contained in"
"CollectionUtils.java:189"$1$"	 * '{@code source}'. If no element in '{@code candidates}' is present in"
"CollectionUtils.java:190"$1$"	 * '{@code source}' returns {@code null}. Iteration order is"
"CollectionUtils.java:191"$1$"	 * {@link Collection} implementation specific."
"CollectionUtils.java:192"$0$"	 * @param source the source Collection"
"CollectionUtils.java:193"$0$"	 * @param candidates the candidates to search for"
"CollectionUtils.java:194"$1$"	 * @return the first present object, or {@code null} if not found"
"CollectionUtils.java:195"$0$"	 */"
"CollectionUtils.java:196"$0$"	@SuppressWarnings(""unchecked"")"
"CollectionUtils.java:197"$0$"	@Nullable"
"CollectionUtils.java:198"$1$"	public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {"
"CollectionUtils.java:199"$1$"		if (isEmpty(source) || isEmpty(candidates)) {"
"CollectionUtils.java:200"$1$"			return null;"
"CollectionUtils.java:201"$1$"		}"
"CollectionUtils.java:202"$1$"		for (Object candidate : candidates) {"
"CollectionUtils.java:203"$1$"			if (source.contains(candidate)) {"
"CollectionUtils.java:204"$1$"				return (E) candidate;"
"CollectionUtils.java:205"$1$"			}"
"CollectionUtils.java:206"$0$"		}"
"CollectionUtils.java:207"$0$"		return null;"
"CollectionUtils.java:208"$0$"	}"
"CollectionUtils.java:209"$0$""
"CollectionUtils.java:210"$0$"	/**"
"CollectionUtils.java:211"$0$"	 * Find a single value of the given type in the given Collection."
"CollectionUtils.java:212"$0$"	 * @param collection the Collection to search"
"CollectionUtils.java:213"$0$"	 * @param type the type to look for"
"CollectionUtils.java:214"$0$"	 * @return a value of the given type found if there is a clear match,"
"CollectionUtils.java:215"$1$"	 * or {@code null} if none or more than one such value found"
"CollectionUtils.java:216"$0$"	 */"
"CollectionUtils.java:217"$0$"	@SuppressWarnings(""unchecked"")"
"CollectionUtils.java:218"$0$"	@Nullable"
"CollectionUtils.java:219"$1$"	public static <T> T findValueOfType(Collection<?> collection, @Nullable Class<T> type) {"
"CollectionUtils.java:220"$1$"		if (isEmpty(collection)) {"
"CollectionUtils.java:221"$1$"			return null;"
"CollectionUtils.java:222"$1$"		}"
"CollectionUtils.java:223"$0$"		T value = null;"
"CollectionUtils.java:224"$1$"		for (Object element : collection) {"
"CollectionUtils.java:225"$1$"			if (type == null || type.isInstance(element)) {"
"CollectionUtils.java:226"$1$"				if (value != null) {"
"CollectionUtils.java:227"$0$"					// More than one value found... no clear single value."
"CollectionUtils.java:228"$1$"					return null;"
"CollectionUtils.java:229"$1$"				}"
"CollectionUtils.java:230"$0$"				value = (T) element;"
"CollectionUtils.java:231"$0$"			}"
"CollectionUtils.java:232"$0$"		}"
"CollectionUtils.java:233"$0$"		return value;"
"CollectionUtils.java:234"$0$"	}"
"CollectionUtils.java:235"$0$""
"CollectionUtils.java:236"$0$"	/**"
"CollectionUtils.java:237"$0$"	 * Find a single value of one of the given types in the given Collection:"
"CollectionUtils.java:238"$0$"	 * searching the Collection for a value of the first type, then"
"CollectionUtils.java:239"$0$"	 * searching for a value of the second type, etc."
"CollectionUtils.java:240"$0$"	 * @param collection the collection to search"
"CollectionUtils.java:241"$0$"	 * @param types the types to look for, in prioritized order"
"CollectionUtils.java:242"$0$"	 * @return a value of one of the given types found if there is a clear match,"
"CollectionUtils.java:243"$1$"	 * or {@code null} if none or more than one such value found"
"CollectionUtils.java:244"$0$"	 */"
"CollectionUtils.java:245"$0$"	@Nullable"
"CollectionUtils.java:246"$1$"	public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {"
"CollectionUtils.java:247"$1$"		if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {"
"CollectionUtils.java:248"$1$"			return null;"
"CollectionUtils.java:249"$1$"		}"
"CollectionUtils.java:250"$1$"		for (Class<?> type : types) {"
"CollectionUtils.java:251"$1$"			Object value = findValueOfType(collection, type);"
"CollectionUtils.java:252"$1$"			if (value != null) {"
"CollectionUtils.java:253"$1$"				return value;"
"CollectionUtils.java:254"$1$"			}"
"CollectionUtils.java:255"$0$"		}"
"CollectionUtils.java:256"$0$"		return null;"
"CollectionUtils.java:257"$0$"	}"
"CollectionUtils.java:258"$0$""
"CollectionUtils.java:259"$0$"	/**"
"CollectionUtils.java:260"$0$"	 * Determine whether the given Collection only contains a single unique object."
"CollectionUtils.java:261"$0$"	 * @param collection the Collection to check"
"CollectionUtils.java:262"$1$"	 * @return {@code true} if the collection contains a single reference or"
"CollectionUtils.java:263"$1$"	 * multiple references to the same instance, {@code false} otherwise"
"CollectionUtils.java:264"$0$"	 */"
"CollectionUtils.java:265"$1$"	public static boolean hasUniqueObject(Collection<?> collection) {"
"CollectionUtils.java:266"$1$"		if (isEmpty(collection)) {"
"CollectionUtils.java:267"$1$"			return false;"
"CollectionUtils.java:268"$1$"		}"
"CollectionUtils.java:269"$0$"		boolean hasCandidate = false;"
"CollectionUtils.java:270"$0$"		Object candidate = null;"
"CollectionUtils.java:271"$1$"		for (Object elem : collection) {"
"CollectionUtils.java:272"$1$"			if (!hasCandidate) {"
"CollectionUtils.java:273"$1$"				hasCandidate = true;"
"CollectionUtils.java:274"$1$"				candidate = elem;"
"CollectionUtils.java:275"$1$"			}"
"CollectionUtils.java:276"$1$"			else if (candidate != elem) {"
"CollectionUtils.java:277"$1$"				return false;"
"CollectionUtils.java:278"$1$"			}"
"CollectionUtils.java:279"$0$"		}"
"CollectionUtils.java:280"$0$"		return true;"
"CollectionUtils.java:281"$0$"	}"
"CollectionUtils.java:282"$0$""
"CollectionUtils.java:283"$0$"	/**"
"CollectionUtils.java:284"$0$"	 * Find the common element type of the given Collection, if any."
"CollectionUtils.java:285"$0$"	 * @param collection the Collection to check"
"CollectionUtils.java:286"$1$"	 * @return the common element type, or {@code null} if no clear"
"CollectionUtils.java:287"$0$"	 * common type has been found (or the collection was empty)"
"CollectionUtils.java:288"$0$"	 */"
"CollectionUtils.java:289"$0$"	@Nullable"
"CollectionUtils.java:290"$1$"	public static Class<?> findCommonElementType(Collection<?> collection) {"
"CollectionUtils.java:291"$1$"		if (isEmpty(collection)) {"
"CollectionUtils.java:292"$1$"			return null;"
"CollectionUtils.java:293"$1$"		}"
"CollectionUtils.java:294"$0$"		Class<?> candidate = null;"
"CollectionUtils.java:295"$1$"		for (Object val : collection) {"
"CollectionUtils.java:296"$1$"			if (val != null) {"
"CollectionUtils.java:297"$1$"				if (candidate == null) {"
"CollectionUtils.java:298"$1$"					candidate = val.getClass();"
"CollectionUtils.java:299"$1$"				}"
"CollectionUtils.java:300"$1$"				else if (candidate != val.getClass()) {"
"CollectionUtils.java:301"$1$"					return null;"
"CollectionUtils.java:302"$1$"				}"
"CollectionUtils.java:303"$0$"			}"
"CollectionUtils.java:304"$0$"		}"
"CollectionUtils.java:305"$0$"		return candidate;"
"CollectionUtils.java:306"$0$"	}"
"CollectionUtils.java:307"$0$""
"CollectionUtils.java:308"$0$"	/**"
"CollectionUtils.java:309"$1$"	 * Retrieve the first element of the given Set, using {@link SortedSet#first()}"
"CollectionUtils.java:310"$0$"	 * or otherwise using the iterator."
"CollectionUtils.java:311"$1$"	 * @param set the Set to check (may be {@code null} or empty)"
"CollectionUtils.java:312"$1$"	 * @return the first element, or {@code null} if none"
"CollectionUtils.java:313"$0$"	 * @since 5.2.3"
"CollectionUtils.java:314"$0$"	 * @see SortedSet"
"CollectionUtils.java:315"$0$"	 * @see LinkedHashMap#keySet()"
"CollectionUtils.java:316"$0$"	 * @see java.util.LinkedHashSet"
"CollectionUtils.java:317"$0$"	 */"
"CollectionUtils.java:318"$0$"	@Nullable"
"CollectionUtils.java:319"$1$"	public static <T> T firstElement(@Nullable Set<T> set) {"
"CollectionUtils.java:320"$1$"		if (isEmpty(set)) {"
"CollectionUtils.java:321"$1$"			return null;"
"CollectionUtils.java:322"$1$"		}"
"CollectionUtils.java:323"$1$"		if (set instanceof SortedSet) {"
"CollectionUtils.java:324"$1$"			return ((SortedSet<T>) set).first();"
"CollectionUtils.java:325"$1$"		}"
"CollectionUtils.java:326"$0$""
"CollectionUtils.java:327"$0$"		Iterator<T> it = set.iterator();"
"CollectionUtils.java:328"$0$"		T first = null;"
"CollectionUtils.java:329"$1$"		if (it.hasNext()) {"
"CollectionUtils.java:330"$1$"			first = it.next();"
"CollectionUtils.java:331"$1$"		}"
"CollectionUtils.java:332"$0$"		return first;"
"CollectionUtils.java:333"$0$"	}"
"CollectionUtils.java:334"$0$""
"CollectionUtils.java:335"$0$"	/**"
"CollectionUtils.java:336"$0$"	 * Retrieve the first element of the given List, accessing the zero index."
"CollectionUtils.java:337"$1$"	 * @param list the List to check (may be {@code null} or empty)"
"CollectionUtils.java:338"$1$"	 * @return the first element, or {@code null} if none"
"CollectionUtils.java:339"$0$"	 * @since 5.2.3"
"CollectionUtils.java:340"$0$"	 */"
"CollectionUtils.java:341"$0$"	@Nullable"
"CollectionUtils.java:342"$1$"	public static <T> T firstElement(@Nullable List<T> list) {"
"CollectionUtils.java:343"$1$"		if (isEmpty(list)) {"
"CollectionUtils.java:344"$1$"			return null;"
"CollectionUtils.java:345"$1$"		}"
"CollectionUtils.java:346"$0$"		return list.get(0);"
"CollectionUtils.java:347"$0$"	}"
"CollectionUtils.java:348"$0$""
"CollectionUtils.java:349"$0$"	/**"
"CollectionUtils.java:350"$1$"	 * Retrieve the last element of the given Set, using {@link SortedSet#last()}"
"CollectionUtils.java:351"$0$"	 * or otherwise iterating over all elements (assuming a linked set)."
"CollectionUtils.java:352"$1$"	 * @param set the Set to check (may be {@code null} or empty)"
"CollectionUtils.java:353"$1$"	 * @return the last element, or {@code null} if none"
"CollectionUtils.java:354"$0$"	 * @since 5.0.3"
"CollectionUtils.java:355"$0$"	 * @see SortedSet"
"CollectionUtils.java:356"$0$"	 * @see LinkedHashMap#keySet()"
"CollectionUtils.java:357"$0$"	 * @see java.util.LinkedHashSet"
"CollectionUtils.java:358"$0$"	 */"
"CollectionUtils.java:359"$0$"	@Nullable"
"CollectionUtils.java:360"$1$"	public static <T> T lastElement(@Nullable Set<T> set) {"
"CollectionUtils.java:361"$1$"		if (isEmpty(set)) {"
"CollectionUtils.java:362"$1$"			return null;"
"CollectionUtils.java:363"$1$"		}"
"CollectionUtils.java:364"$1$"		if (set instanceof SortedSet) {"
"CollectionUtils.java:365"$1$"			return ((SortedSet<T>) set).last();"
"CollectionUtils.java:366"$1$"		}"
"CollectionUtils.java:367"$0$""
"CollectionUtils.java:368"$0$"		// Full iteration necessary..."
"CollectionUtils.java:369"$0$"		Iterator<T> it = set.iterator();"
"CollectionUtils.java:370"$0$"		T last = null;"
"CollectionUtils.java:371"$1$"		while (it.hasNext()) {"
"CollectionUtils.java:372"$1$"			last = it.next();"
"CollectionUtils.java:373"$1$"		}"
"CollectionUtils.java:374"$0$"		return last;"
"CollectionUtils.java:375"$0$"	}"
"CollectionUtils.java:376"$0$""
"CollectionUtils.java:377"$0$"	/**"
"CollectionUtils.java:378"$0$"	 * Retrieve the last element of the given List, accessing the highest index."
"CollectionUtils.java:379"$1$"	 * @param list the List to check (may be {@code null} or empty)"
"CollectionUtils.java:380"$1$"	 * @return the last element, or {@code null} if none"
"CollectionUtils.java:381"$0$"	 * @since 5.0.3"
"CollectionUtils.java:382"$0$"	 */"
"CollectionUtils.java:383"$0$"	@Nullable"
"CollectionUtils.java:384"$1$"	public static <T> T lastElement(@Nullable List<T> list) {"
"CollectionUtils.java:385"$1$"		if (isEmpty(list)) {"
"CollectionUtils.java:386"$1$"			return null;"
"CollectionUtils.java:387"$1$"		}"
"CollectionUtils.java:388"$0$"		return list.get(list.size() - 1);"
"CollectionUtils.java:389"$0$"	}"
"CollectionUtils.java:390"$0$""
"CollectionUtils.java:391"$0$"	/**"
"CollectionUtils.java:392"$0$"	 * Marshal the elements from the given enumeration into an array of the given type."
"CollectionUtils.java:393"$0$"	 * Enumeration elements must be assignable to the type of the given array. The array"
"CollectionUtils.java:394"$0$"	 * returned will be a different instance than the array given."
"CollectionUtils.java:395"$0$"	 */"
"CollectionUtils.java:396"$1$"	public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {"
"CollectionUtils.java:397"$1$"		ArrayList<A> elements = new ArrayList<>();"
"CollectionUtils.java:398"$1$"		while (enumeration.hasMoreElements()) {"
"CollectionUtils.java:399"$1$"			elements.add(enumeration.nextElement());"
"CollectionUtils.java:400"$1$"		}"
"CollectionUtils.java:401"$0$"		return elements.toArray(array);"
"CollectionUtils.java:402"$0$"	}"
"CollectionUtils.java:403"$0$""
"CollectionUtils.java:404"$0$"	/**"
"CollectionUtils.java:405"$1$"	 * Adapt an {@link Enumeration} to an {@link Iterator}."
"CollectionUtils.java:406"$1$"	 * @param enumeration the original {@code Enumeration}"
"CollectionUtils.java:407"$1$"	 * @return the adapted {@code Iterator}"
"CollectionUtils.java:408"$0$"	 */"
"CollectionUtils.java:409"$1$"	public static <E> Iterator<E> toIterator(@Nullable Enumeration<E> enumeration) {"
"CollectionUtils.java:410"$1$"		return (enumeration != null ? new EnumerationIterator<>(enumeration) : Collections.emptyIterator());"
"CollectionUtils.java:411"$1$"	}"
"CollectionUtils.java:412"$0$""
"CollectionUtils.java:413"$0$"	/**"
"CollectionUtils.java:414"$1$"	 * Adapt a {@code Map<K, List<V>>} to an {@code MultiValueMap<K, V>}."
"CollectionUtils.java:415"$0$"	 * @param map the original map"
"CollectionUtils.java:416"$0$"	 * @return the multi-value map"
"CollectionUtils.java:417"$0$"	 * @since 3.1"
"CollectionUtils.java:418"$0$"	 */"
"CollectionUtils.java:419"$1$"	public static <K, V> MultiValueMap<K, V> toMultiValueMap(Map<K, List<V>> map) {"
"CollectionUtils.java:420"$1$"		return new MultiValueMapAdapter<>(map);"
"CollectionUtils.java:421"$1$"	}"
"CollectionUtils.java:422"$0$""
"CollectionUtils.java:423"$0$"	/**"
"CollectionUtils.java:424"$0$"	 * Return an unmodifiable view of the specified multi-value map."
"CollectionUtils.java:425"$0$"	 * @param  map the map for which an unmodifiable view is to be returned."
"CollectionUtils.java:426"$0$"	 * @return an unmodifiable view of the specified multi-value map."
"CollectionUtils.java:427"$0$"	 * @since 3.1"
"CollectionUtils.java:428"$0$"	 */"
"CollectionUtils.java:429"$0$"	@SuppressWarnings(""unchecked"")"
"CollectionUtils.java:430"$1$"	public static <K, V> MultiValueMap<K, V> unmodifiableMultiValueMap(MultiValueMap<? extends K, ? extends V> map) {"
"CollectionUtils.java:431"$1$"		Assert.notNull(map, ""'map' must not be null"");"
"CollectionUtils.java:432"$1$"		Map<K, List<V>> result = new LinkedHashMap<>(map.size());"
"CollectionUtils.java:433"$1$"		map.forEach((key, value) -> {"
"CollectionUtils.java:434"$1$"			List<? extends V> values = Collections.unmodifiableList(value);"
"CollectionUtils.java:435"$1$"			result.put(key, (List<V>) values);"
"CollectionUtils.java:436"$1$"		});"
"CollectionUtils.java:437"$0$"		Map<K, List<V>> unmodifiableMap = Collections.unmodifiableMap(result);"
"CollectionUtils.java:438"$0$"		return toMultiValueMap(unmodifiableMap);"
"CollectionUtils.java:439"$0$"	}"
"CollectionUtils.java:440"$0$""
"CollectionUtils.java:441"$0$""
"CollectionUtils.java:442"$0$"	/**"
"CollectionUtils.java:443"$0$"	 * Iterator wrapping an Enumeration."
"CollectionUtils.java:444"$0$"	 */"
"CollectionUtils.java:445"$1$"	private static class EnumerationIterator<E> implements Iterator<E> {"
"CollectionUtils.java:446"$1$""
"CollectionUtils.java:447"$1$"		private final Enumeration<E> enumeration;"
"CollectionUtils.java:448"$1$""
"CollectionUtils.java:449"$1$"		public EnumerationIterator(Enumeration<E> enumeration) {"
"CollectionUtils.java:450"$1$"			this.enumeration = enumeration;"
"CollectionUtils.java:451"$1$"		}"
"CollectionUtils.java:452"$0$""
"CollectionUtils.java:453"$0$"		@Override"
"CollectionUtils.java:454"$1$"		public boolean hasNext() {"
"CollectionUtils.java:455"$1$"			return this.enumeration.hasMoreElements();"
"CollectionUtils.java:456"$1$"		}"
"CollectionUtils.java:457"$0$""
"CollectionUtils.java:458"$0$"		@Override"
"CollectionUtils.java:459"$1$"		public E next() {"
"CollectionUtils.java:460"$1$"			return this.enumeration.nextElement();"
"CollectionUtils.java:461"$1$"		}"
"CollectionUtils.java:462"$0$""
"CollectionUtils.java:463"$0$"		@Override"
"CollectionUtils.java:464"$1$"		public void remove() throws UnsupportedOperationException {"
"CollectionUtils.java:465"$1$"			throw new UnsupportedOperationException(""Not supported"");"
"CollectionUtils.java:466"$1$"		}"
"CollectionUtils.java:467"$0$"	}"
"CollectionUtils.java:468"$0$""
"CollectionUtils.java:469"$0$""
"CollectionUtils.java:470"$0$"	/**"
"CollectionUtils.java:471"$0$"	 * Adapts a Map to the MultiValueMap contract."
"CollectionUtils.java:472"$0$"	 */"
"CollectionUtils.java:473"$0$"	@SuppressWarnings(""serial"")"
"CollectionUtils.java:474"$1$"	private static class MultiValueMapAdapter<K, V> implements MultiValueMap<K, V>, Serializable {"
"CollectionUtils.java:475"$1$""
"CollectionUtils.java:476"$1$"		private final Map<K, List<V>> map;"
"CollectionUtils.java:477"$1$""
"CollectionUtils.java:478"$1$"		public MultiValueMapAdapter(Map<K, List<V>> map) {"
"CollectionUtils.java:479"$1$"			Assert.notNull(map, ""'map' must not be null"");"
"CollectionUtils.java:480"$1$"			this.map = map;"
"CollectionUtils.java:481"$1$"		}"
"CollectionUtils.java:482"$0$""
"CollectionUtils.java:483"$0$"		@Override"
"CollectionUtils.java:484"$0$"		@Nullable"
"CollectionUtils.java:485"$1$"		public V getFirst(K key) {"
"CollectionUtils.java:486"$1$"			List<V> values = this.map.get(key);"
"CollectionUtils.java:487"$1$"			return (values != null ? values.get(0) : null);"
"CollectionUtils.java:488"$1$"		}"
"CollectionUtils.java:489"$0$""
"CollectionUtils.java:490"$0$"		@Override"
"CollectionUtils.java:491"$1$"		public void add(K key, @Nullable V value) {"
"CollectionUtils.java:492"$1$"			List<V> values = this.map.computeIfAbsent(key, k -> new LinkedList<>());"
"CollectionUtils.java:493"$1$"			values.add(value);"
"CollectionUtils.java:494"$1$"		}"
"CollectionUtils.java:495"$0$""
"CollectionUtils.java:496"$0$"		@Override"
"CollectionUtils.java:497"$1$"		public void addAll(K key, List<? extends V> values) {"
"CollectionUtils.java:498"$1$"			List<V> currentValues = this.map.computeIfAbsent(key, k -> new LinkedList<>());"
"CollectionUtils.java:499"$1$"			currentValues.addAll(values);"
"CollectionUtils.java:500"$1$"		}"
"CollectionUtils.java:501"$0$""
"CollectionUtils.java:502"$0$"		@Override"
"CollectionUtils.java:503"$1$"		public void addAll(MultiValueMap<K, V> values) {"
"CollectionUtils.java:504"$1$"			for (Entry<K, List<V>> entry : values.entrySet()) {"
"CollectionUtils.java:505"$1$"				addAll(entry.getKey(), entry.getValue());"
"CollectionUtils.java:506"$1$"			}"
"CollectionUtils.java:507"$0$"		}"
"CollectionUtils.java:508"$0$""
"CollectionUtils.java:509"$0$"		@Override"
"CollectionUtils.java:510"$1$"		public void set(K key, @Nullable V value) {"
"CollectionUtils.java:511"$1$"			List<V> values = new LinkedList<>();"
"CollectionUtils.java:512"$1$"			values.add(value);"
"CollectionUtils.java:513"$1$"			this.map.put(key, values);"
"CollectionUtils.java:514"$1$"		}"
"CollectionUtils.java:515"$0$""
"CollectionUtils.java:516"$0$"		@Override"
"CollectionUtils.java:517"$1$"		public void setAll(Map<K, V> values) {"
"CollectionUtils.java:518"$1$"			values.forEach(this::set);"
"CollectionUtils.java:519"$1$"		}"
"CollectionUtils.java:520"$0$""
"CollectionUtils.java:521"$0$"		@Override"
"CollectionUtils.java:522"$1$"		public Map<K, V> toSingleValueMap() {"
"CollectionUtils.java:523"$1$"			LinkedHashMap<K, V> singleValueMap = new LinkedHashMap<>(this.map.size());"
"CollectionUtils.java:524"$1$"			this.map.forEach((key, value) -> singleValueMap.put(key, value.get(0)));"
"CollectionUtils.java:525"$1$"			return singleValueMap;"
"CollectionUtils.java:526"$1$"		}"
"CollectionUtils.java:527"$0$""
"CollectionUtils.java:528"$0$"		@Override"
"CollectionUtils.java:529"$1$"		public int size() {"
"CollectionUtils.java:530"$1$"			return this.map.size();"
"CollectionUtils.java:531"$1$"		}"
"CollectionUtils.java:532"$0$""
"CollectionUtils.java:533"$0$"		@Override"
"CollectionUtils.java:534"$1$"		public boolean isEmpty() {"
"CollectionUtils.java:535"$1$"			return this.map.isEmpty();"
"CollectionUtils.java:536"$1$"		}"
"CollectionUtils.java:537"$0$""
"CollectionUtils.java:538"$0$"		@Override"
"CollectionUtils.java:539"$1$"		public boolean containsKey(Object key) {"
"CollectionUtils.java:540"$1$"			return this.map.containsKey(key);"
"CollectionUtils.java:541"$1$"		}"
"CollectionUtils.java:542"$0$""
"CollectionUtils.java:543"$0$"		@Override"
"CollectionUtils.java:544"$1$"		public boolean containsValue(Object value) {"
"CollectionUtils.java:545"$1$"			return this.map.containsValue(value);"
"CollectionUtils.java:546"$1$"		}"
"CollectionUtils.java:547"$0$""
"CollectionUtils.java:548"$0$"		@Override"
"CollectionUtils.java:549"$1$"		public List<V> get(Object key) {"
"CollectionUtils.java:550"$1$"			return this.map.get(key);"
"CollectionUtils.java:551"$1$"		}"
"CollectionUtils.java:552"$0$""
"CollectionUtils.java:553"$0$"		@Override"
"CollectionUtils.java:554"$1$"		public List<V> put(K key, List<V> value) {"
"CollectionUtils.java:555"$1$"			return this.map.put(key, value);"
"CollectionUtils.java:556"$1$"		}"
"CollectionUtils.java:557"$0$""
"CollectionUtils.java:558"$0$"		@Override"
"CollectionUtils.java:559"$1$"		public List<V> remove(Object key) {"
"CollectionUtils.java:560"$1$"			return this.map.remove(key);"
"CollectionUtils.java:561"$1$"		}"
"CollectionUtils.java:562"$0$""
"CollectionUtils.java:563"$0$"		@Override"
"CollectionUtils.java:564"$1$"		public void putAll(Map<? extends K, ? extends List<V>> map) {"
"CollectionUtils.java:565"$1$"			this.map.putAll(map);"
"CollectionUtils.java:566"$1$"		}"
"CollectionUtils.java:567"$0$""
"CollectionUtils.java:568"$0$"		@Override"
"CollectionUtils.java:569"$1$"		public void clear() {"
"CollectionUtils.java:570"$1$"			this.map.clear();"
"CollectionUtils.java:571"$1$"		}"
"CollectionUtils.java:572"$0$""
"CollectionUtils.java:573"$0$"		@Override"
"CollectionUtils.java:574"$1$"		public Set<K> keySet() {"
"CollectionUtils.java:575"$1$"			return this.map.keySet();"
"CollectionUtils.java:576"$1$"		}"
"CollectionUtils.java:577"$0$""
"CollectionUtils.java:578"$0$"		@Override"
"CollectionUtils.java:579"$1$"		public Collection<List<V>> values() {"
"CollectionUtils.java:580"$1$"			return this.map.values();"
"CollectionUtils.java:581"$1$"		}"
"CollectionUtils.java:582"$0$""
"CollectionUtils.java:583"$0$"		@Override"
"CollectionUtils.java:584"$1$"		public Set<Entry<K, List<V>>> entrySet() {"
"CollectionUtils.java:585"$1$"			return this.map.entrySet();"
"CollectionUtils.java:586"$1$"		}"
"CollectionUtils.java:587"$0$""
"CollectionUtils.java:588"$0$"		@Override"
"CollectionUtils.java:589"$1$"		public boolean equals(@Nullable Object other) {"
"CollectionUtils.java:590"$1$"			if (this == other) {"
"CollectionUtils.java:591"$1$"				return true;"
"CollectionUtils.java:592"$1$"			}"
"CollectionUtils.java:593"$0$"			return this.map.equals(other);"
"CollectionUtils.java:594"$0$"		}"
"CollectionUtils.java:595"$0$""
"CollectionUtils.java:596"$0$"		@Override"
"CollectionUtils.java:597"$1$"		public int hashCode() {"
"CollectionUtils.java:598"$1$"			return this.map.hashCode();"
"CollectionUtils.java:599"$1$"		}"
"CollectionUtils.java:600"$0$""
"CollectionUtils.java:601"$0$"		@Override"
"CollectionUtils.java:602"$1$"		public String toString() {"
"CollectionUtils.java:603"$1$"			return this.map.toString();"
"CollectionUtils.java:604"$1$"		}"
"CollectionUtils.java:605"$0$"	}"
"CollectionUtils.java:606"$0$""
"CollectionUtils.java:607"$0$"}"
"AutoPopulatingList.java:1"$0$"/*"
"AutoPopulatingList.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"AutoPopulatingList.java:3"$0$" *"
"AutoPopulatingList.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AutoPopulatingList.java:5"$0$" * you may not use this file except in compliance with the License."
"AutoPopulatingList.java:6"$0$" * You may obtain a copy of the License at"
"AutoPopulatingList.java:7"$0$" *"
"AutoPopulatingList.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AutoPopulatingList.java:9"$0$" *"
"AutoPopulatingList.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AutoPopulatingList.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AutoPopulatingList.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AutoPopulatingList.java:13"$0$" * See the License for the specific language governing permissions and"
"AutoPopulatingList.java:14"$0$" * limitations under the License."
"AutoPopulatingList.java:15"$0$" */"
"AutoPopulatingList.java:16"$0$""
"AutoPopulatingList.java:17"$0$"package org.springframework.util;"
"AutoPopulatingList.java:18"$0$""
"AutoPopulatingList.java:19"$0$"import java.io.Serializable;"
"AutoPopulatingList.java:20"$0$"import java.lang.reflect.InvocationTargetException;"
"AutoPopulatingList.java:21"$0$"import java.lang.reflect.Modifier;"
"AutoPopulatingList.java:22"$0$"import java.util.ArrayList;"
"AutoPopulatingList.java:23"$0$"import java.util.Collection;"
"AutoPopulatingList.java:24"$0$"import java.util.Iterator;"
"AutoPopulatingList.java:25"$0$"import java.util.List;"
"AutoPopulatingList.java:26"$0$"import java.util.ListIterator;"
"AutoPopulatingList.java:27"$0$""
"AutoPopulatingList.java:28"$0$"import org.springframework.lang.Nullable;"
"AutoPopulatingList.java:29"$0$""
"AutoPopulatingList.java:30"$0$"/**"
"AutoPopulatingList.java:31"$1$" * Simple {@link List} wrapper class that allows for elements to be"
"AutoPopulatingList.java:32"$0$" * automatically populated as they are requested. This is particularly"
"AutoPopulatingList.java:33"$1$" * useful for data binding to {@link List Lists}, allowing for elements"
"AutoPopulatingList.java:34"$1$" * to be created and added to the {@link List} in a ""just in time"" fashion."
"AutoPopulatingList.java:35"$0$" *"
"AutoPopulatingList.java:36"$0$" * <p>Note: This class is not thread-safe. To create a thread-safe version,"
"AutoPopulatingList.java:37"$1$" * use the {@link java.util.Collections#synchronizedList} utility methods."
"AutoPopulatingList.java:38"$0$" *"
"AutoPopulatingList.java:39"$1$" * <p>Inspired by {@code LazyList} from Commons Collections."
"AutoPopulatingList.java:40"$0$" *"
"AutoPopulatingList.java:41"$0$" * @author Rob Harrop"
"AutoPopulatingList.java:42"$0$" * @author Juergen Hoeller"
"AutoPopulatingList.java:43"$0$" * @since 2.0"
"AutoPopulatingList.java:44"$0$" * @param <E> the element type"
"AutoPopulatingList.java:45"$0$" */"
"AutoPopulatingList.java:46"$0$"SuppressWarnings(""serial"")"
"AutoPopulatingList.java:47"$1$"public class AutoPopulatingList<E> implements List<E>, Serializable {"
"AutoPopulatingList.java:48"$1$""
"AutoPopulatingList.java:49"$1$"	/**"
"AutoPopulatingList.java:50"$1$"	 * The {@link List} that all operations are eventually delegated to."
"AutoPopulatingList.java:51"$1$"	 */"
"AutoPopulatingList.java:52"$1$"	private final List<E> backingList;"
"AutoPopulatingList.java:53"$1$""
"AutoPopulatingList.java:54"$1$"	/**"
"AutoPopulatingList.java:55"$1$"	 * The {@link ElementFactory} to use to create new {@link List} elements"
"AutoPopulatingList.java:56"$1$"	 * on demand."
"AutoPopulatingList.java:57"$1$"	 */"
"AutoPopulatingList.java:58"$1$"	private final ElementFactory<E> elementFactory;"
"AutoPopulatingList.java:59"$1$""
"AutoPopulatingList.java:60"$1$""
"AutoPopulatingList.java:61"$1$"	/**"
"AutoPopulatingList.java:62"$1$"	 * Creates a new {@code AutoPopulatingList} that is backed by a standard"
"AutoPopulatingList.java:63"$1$"	 * {@link ArrayList} and adds new instances of the supplied {@link Class element Class}"
"AutoPopulatingList.java:64"$1$"	 * to the backing {@link List} on demand."
"AutoPopulatingList.java:65"$1$"	 */"
"AutoPopulatingList.java:66"$1$"	public AutoPopulatingList(Class<? extends E> elementClass) {"
"AutoPopulatingList.java:67"$1$"		this(new ArrayList<>(), elementClass);"
"AutoPopulatingList.java:68"$1$"	}"
"AutoPopulatingList.java:69"$0$""
"AutoPopulatingList.java:70"$0$"	/**"
"AutoPopulatingList.java:71"$1$"	 * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}"
"AutoPopulatingList.java:72"$1$"	 * and adds new instances of the supplied {@link Class element Class} to the backing"
"AutoPopulatingList.java:73"$1$"	 * {@link List} on demand."
"AutoPopulatingList.java:74"$0$"	 */"
"AutoPopulatingList.java:75"$1$"	public AutoPopulatingList(List<E> backingList, Class<? extends E> elementClass) {"
"AutoPopulatingList.java:76"$1$"		this(backingList, new ReflectiveElementFactory<>(elementClass));"
"AutoPopulatingList.java:77"$1$"	}"
"AutoPopulatingList.java:78"$0$""
"AutoPopulatingList.java:79"$0$"	/**"
"AutoPopulatingList.java:80"$1$"	 * Creates a new {@code AutoPopulatingList} that is backed by a standard"
"AutoPopulatingList.java:81"$1$"	 * {@link ArrayList} and creates new elements on demand using the supplied {@link ElementFactory}."
"AutoPopulatingList.java:82"$0$"	 */"
"AutoPopulatingList.java:83"$1$"	public AutoPopulatingList(ElementFactory<E> elementFactory) {"
"AutoPopulatingList.java:84"$1$"		this(new ArrayList<>(), elementFactory);"
"AutoPopulatingList.java:85"$1$"	}"
"AutoPopulatingList.java:86"$0$""
"AutoPopulatingList.java:87"$0$"	/**"
"AutoPopulatingList.java:88"$1$"	 * Creates a new {@code AutoPopulatingList} that is backed by the supplied {@link List}"
"AutoPopulatingList.java:89"$1$"	 * and creates new elements on demand using the supplied {@link ElementFactory}."
"AutoPopulatingList.java:90"$0$"	 */"
"AutoPopulatingList.java:91"$1$"	public AutoPopulatingList(List<E> backingList, ElementFactory<E> elementFactory) {"
"AutoPopulatingList.java:92"$1$"		Assert.notNull(backingList, ""Backing List must not be null"");"
"AutoPopulatingList.java:93"$1$"		Assert.notNull(elementFactory, ""Element factory must not be null"");"
"AutoPopulatingList.java:94"$1$"		this.backingList = backingList;"
"AutoPopulatingList.java:95"$1$"		this.elementFactory = elementFactory;"
"AutoPopulatingList.java:96"$1$"	}"
"AutoPopulatingList.java:97"$0$""
"AutoPopulatingList.java:98"$0$""
"AutoPopulatingList.java:99"$0$"	@Override"
"AutoPopulatingList.java:100"$1$"	public void add(int index, E element) {"
"AutoPopulatingList.java:101"$1$"		this.backingList.add(index, element);"
"AutoPopulatingList.java:102"$1$"	}"
"AutoPopulatingList.java:103"$0$""
"AutoPopulatingList.java:104"$0$"	@Override"
"AutoPopulatingList.java:105"$1$"	public boolean add(E o) {"
"AutoPopulatingList.java:106"$1$"		return this.backingList.add(o);"
"AutoPopulatingList.java:107"$1$"	}"
"AutoPopulatingList.java:108"$0$""
"AutoPopulatingList.java:109"$0$"	@Override"
"AutoPopulatingList.java:110"$1$"	public boolean addAll(Collection<? extends E> c) {"
"AutoPopulatingList.java:111"$1$"		return this.backingList.addAll(c);"
"AutoPopulatingList.java:112"$1$"	}"
"AutoPopulatingList.java:113"$0$""
"AutoPopulatingList.java:114"$0$"	@Override"
"AutoPopulatingList.java:115"$1$"	public boolean addAll(int index, Collection<? extends E> c) {"
"AutoPopulatingList.java:116"$1$"		return this.backingList.addAll(index, c);"
"AutoPopulatingList.java:117"$1$"	}"
"AutoPopulatingList.java:118"$0$""
"AutoPopulatingList.java:119"$0$"	@Override"
"AutoPopulatingList.java:120"$1$"	public void clear() {"
"AutoPopulatingList.java:121"$1$"		this.backingList.clear();"
"AutoPopulatingList.java:122"$1$"	}"
"AutoPopulatingList.java:123"$0$""
"AutoPopulatingList.java:124"$0$"	@Override"
"AutoPopulatingList.java:125"$1$"	public boolean contains(Object o) {"
"AutoPopulatingList.java:126"$1$"		return this.backingList.contains(o);"
"AutoPopulatingList.java:127"$1$"	}"
"AutoPopulatingList.java:128"$0$""
"AutoPopulatingList.java:129"$0$"	@Override"
"AutoPopulatingList.java:130"$1$"	public boolean containsAll(Collection<?> c) {"
"AutoPopulatingList.java:131"$1$"		return this.backingList.containsAll(c);"
"AutoPopulatingList.java:132"$1$"	}"
"AutoPopulatingList.java:133"$0$""
"AutoPopulatingList.java:134"$0$"	/**"
"AutoPopulatingList.java:135"$0$"	 * Get the element at the supplied index, creating it if there is"
"AutoPopulatingList.java:136"$0$"	 * no element at that index."
"AutoPopulatingList.java:137"$0$"	 */"
"AutoPopulatingList.java:138"$0$"	@Override"
"AutoPopulatingList.java:139"$1$"	public E get(int index) {"
"AutoPopulatingList.java:140"$1$"		int backingListSize = this.backingList.size();"
"AutoPopulatingList.java:141"$1$"		E element = null;"
"AutoPopulatingList.java:142"$1$"		if (index < backingListSize) {"
"AutoPopulatingList.java:143"$1$"			element = this.backingList.get(index);"
"AutoPopulatingList.java:144"$1$"			if (element == null) {"
"AutoPopulatingList.java:145"$1$"				element = this.elementFactory.createElement(index);"
"AutoPopulatingList.java:146"$1$"				this.backingList.set(index, element);"
"AutoPopulatingList.java:147"$1$"			}"
"AutoPopulatingList.java:148"$0$"		}"
"AutoPopulatingList.java:149"$1$"		else {"
"AutoPopulatingList.java:150"$1$"			for (int x = backingListSize; x < index; x++) {"
"AutoPopulatingList.java:151"$1$"				this.backingList.add(null);"
"AutoPopulatingList.java:152"$1$"			}"
"AutoPopulatingList.java:153"$0$"			element = this.elementFactory.createElement(index);"
"AutoPopulatingList.java:154"$0$"			this.backingList.add(element);"
"AutoPopulatingList.java:155"$0$"		}"
"AutoPopulatingList.java:156"$0$"		return element;"
"AutoPopulatingList.java:157"$0$"	}"
"AutoPopulatingList.java:158"$0$""
"AutoPopulatingList.java:159"$0$"	@Override"
"AutoPopulatingList.java:160"$1$"	public int indexOf(Object o) {"
"AutoPopulatingList.java:161"$1$"		return this.backingList.indexOf(o);"
"AutoPopulatingList.java:162"$1$"	}"
"AutoPopulatingList.java:163"$0$""
"AutoPopulatingList.java:164"$0$"	@Override"
"AutoPopulatingList.java:165"$1$"	public boolean isEmpty() {"
"AutoPopulatingList.java:166"$1$"		return this.backingList.isEmpty();"
"AutoPopulatingList.java:167"$1$"	}"
"AutoPopulatingList.java:168"$0$""
"AutoPopulatingList.java:169"$0$"	@Override"
"AutoPopulatingList.java:170"$1$"	public Iterator<E> iterator() {"
"AutoPopulatingList.java:171"$1$"		return this.backingList.iterator();"
"AutoPopulatingList.java:172"$1$"	}"
"AutoPopulatingList.java:173"$0$""
"AutoPopulatingList.java:174"$0$"	@Override"
"AutoPopulatingList.java:175"$1$"	public int lastIndexOf(Object o) {"
"AutoPopulatingList.java:176"$1$"		return this.backingList.lastIndexOf(o);"
"AutoPopulatingList.java:177"$1$"	}"
"AutoPopulatingList.java:178"$0$""
"AutoPopulatingList.java:179"$0$"	@Override"
"AutoPopulatingList.java:180"$1$"	public ListIterator<E> listIterator() {"
"AutoPopulatingList.java:181"$1$"		return this.backingList.listIterator();"
"AutoPopulatingList.java:182"$1$"	}"
"AutoPopulatingList.java:183"$0$""
"AutoPopulatingList.java:184"$0$"	@Override"
"AutoPopulatingList.java:185"$1$"	public ListIterator<E> listIterator(int index) {"
"AutoPopulatingList.java:186"$1$"		return this.backingList.listIterator(index);"
"AutoPopulatingList.java:187"$1$"	}"
"AutoPopulatingList.java:188"$0$""
"AutoPopulatingList.java:189"$0$"	@Override"
"AutoPopulatingList.java:190"$1$"	public E remove(int index) {"
"AutoPopulatingList.java:191"$1$"		return this.backingList.remove(index);"
"AutoPopulatingList.java:192"$1$"	}"
"AutoPopulatingList.java:193"$0$""
"AutoPopulatingList.java:194"$0$"	@Override"
"AutoPopulatingList.java:195"$1$"	public boolean remove(Object o) {"
"AutoPopulatingList.java:196"$1$"		return this.backingList.remove(o);"
"AutoPopulatingList.java:197"$1$"	}"
"AutoPopulatingList.java:198"$0$""
"AutoPopulatingList.java:199"$0$"	@Override"
"AutoPopulatingList.java:200"$1$"	public boolean removeAll(Collection<?> c) {"
"AutoPopulatingList.java:201"$1$"		return this.backingList.removeAll(c);"
"AutoPopulatingList.java:202"$1$"	}"
"AutoPopulatingList.java:203"$0$""
"AutoPopulatingList.java:204"$0$"	@Override"
"AutoPopulatingList.java:205"$1$"	public boolean retainAll(Collection<?> c) {"
"AutoPopulatingList.java:206"$1$"		return this.backingList.retainAll(c);"
"AutoPopulatingList.java:207"$1$"	}"
"AutoPopulatingList.java:208"$0$""
"AutoPopulatingList.java:209"$0$"	@Override"
"AutoPopulatingList.java:210"$1$"	public E set(int index, E element) {"
"AutoPopulatingList.java:211"$1$"		return this.backingList.set(index, element);"
"AutoPopulatingList.java:212"$1$"	}"
"AutoPopulatingList.java:213"$0$""
"AutoPopulatingList.java:214"$0$"	@Override"
"AutoPopulatingList.java:215"$1$"	public int size() {"
"AutoPopulatingList.java:216"$1$"		return this.backingList.size();"
"AutoPopulatingList.java:217"$1$"	}"
"AutoPopulatingList.java:218"$0$""
"AutoPopulatingList.java:219"$0$"	@Override"
"AutoPopulatingList.java:220"$1$"	public List<E> subList(int fromIndex, int toIndex) {"
"AutoPopulatingList.java:221"$1$"		return this.backingList.subList(fromIndex, toIndex);"
"AutoPopulatingList.java:222"$1$"	}"
"AutoPopulatingList.java:223"$0$""
"AutoPopulatingList.java:224"$0$"	@Override"
"AutoPopulatingList.java:225"$1$"	public Object[] toArray() {"
"AutoPopulatingList.java:226"$1$"		return this.backingList.toArray();"
"AutoPopulatingList.java:227"$1$"	}"
"AutoPopulatingList.java:228"$0$""
"AutoPopulatingList.java:229"$0$"	@Override"
"AutoPopulatingList.java:230"$1$"	public <T> T[] toArray(T[] a) {"
"AutoPopulatingList.java:231"$1$"		return this.backingList.toArray(a);"
"AutoPopulatingList.java:232"$1$"	}"
"AutoPopulatingList.java:233"$0$""
"AutoPopulatingList.java:234"$0$""
"AutoPopulatingList.java:235"$0$"	@Override"
"AutoPopulatingList.java:236"$1$"	public boolean equals(@Nullable Object other) {"
"AutoPopulatingList.java:237"$1$"		return this.backingList.equals(other);"
"AutoPopulatingList.java:238"$1$"	}"
"AutoPopulatingList.java:239"$0$""
"AutoPopulatingList.java:240"$0$"	@Override"
"AutoPopulatingList.java:241"$1$"	public int hashCode() {"
"AutoPopulatingList.java:242"$1$"		return this.backingList.hashCode();"
"AutoPopulatingList.java:243"$1$"	}"
"AutoPopulatingList.java:244"$0$""
"AutoPopulatingList.java:245"$0$""
"AutoPopulatingList.java:246"$0$"	/**"
"AutoPopulatingList.java:247"$0$"	 * Factory interface for creating elements for an index-based access"
"AutoPopulatingList.java:248"$1$"	 * data structure such as a {@link java.util.List}."
"AutoPopulatingList.java:249"$0$"	 *"
"AutoPopulatingList.java:250"$0$"	 * @param <E> the element type"
"AutoPopulatingList.java:251"$0$"	 */"
"AutoPopulatingList.java:252"$0$"	@FunctionalInterface"
"AutoPopulatingList.java:253"$1$"	public interface ElementFactory<E> {"
"AutoPopulatingList.java:254"$1$""
"AutoPopulatingList.java:255"$1$"		/**"
"AutoPopulatingList.java:256"$1$"		 * Create the element for the supplied index."
"AutoPopulatingList.java:257"$1$"		 * @return the element object"
"AutoPopulatingList.java:258"$1$"		 * @throws ElementInstantiationException if the instantiation process failed"
"AutoPopulatingList.java:259"$1$"		 * (any exception thrown by a target constructor should be propagated as-is)"
"AutoPopulatingList.java:260"$1$"		 */"
"AutoPopulatingList.java:261"$1$"		E createElement(int index) throws ElementInstantiationException;"
"AutoPopulatingList.java:262"$1$"	}"
"AutoPopulatingList.java:263"$0$""
"AutoPopulatingList.java:264"$0$""
"AutoPopulatingList.java:265"$0$"	/**"
"AutoPopulatingList.java:266"$0$"	 * Exception to be thrown from ElementFactory."
"AutoPopulatingList.java:267"$0$"	 */"
"AutoPopulatingList.java:268"$1$"	public static class ElementInstantiationException extends RuntimeException {"
"AutoPopulatingList.java:269"$1$""
"AutoPopulatingList.java:270"$1$"		public ElementInstantiationException(String msg) {"
"AutoPopulatingList.java:271"$1$"			super(msg);"
"AutoPopulatingList.java:272"$1$"		}"
"AutoPopulatingList.java:273"$0$""
"AutoPopulatingList.java:274"$1$"		public ElementInstantiationException(String message, Throwable cause) {"
"AutoPopulatingList.java:275"$1$"			super(message, cause);"
"AutoPopulatingList.java:276"$1$"		}"
"AutoPopulatingList.java:277"$0$"	}"
"AutoPopulatingList.java:278"$0$""
"AutoPopulatingList.java:279"$0$""
"AutoPopulatingList.java:280"$0$"	/**"
"AutoPopulatingList.java:281"$0$"	 * Reflective implementation of the ElementFactory interface, using"
"AutoPopulatingList.java:282"$1$"	 * {@code Class.getDeclaredConstructor().newInstance()} on a given element class."
"AutoPopulatingList.java:283"$0$"	 */"
"AutoPopulatingList.java:284"$1$"	private static class ReflectiveElementFactory<E> implements ElementFactory<E>, Serializable {"
"AutoPopulatingList.java:285"$1$""
"AutoPopulatingList.java:286"$1$"		private final Class<? extends E> elementClass;"
"AutoPopulatingList.java:287"$1$""
"AutoPopulatingList.java:288"$1$"		public ReflectiveElementFactory(Class<? extends E> elementClass) {"
"AutoPopulatingList.java:289"$1$"			Assert.notNull(elementClass, ""Element class must not be null"");"
"AutoPopulatingList.java:290"$1$"			Assert.isTrue(!elementClass.isInterface(), ""Element class must not be an interface type"");"
"AutoPopulatingList.java:291"$1$"			Assert.isTrue(!Modifier.isAbstract(elementClass.getModifiers()), ""Element class cannot be an abstract class"");"
"AutoPopulatingList.java:292"$1$"			this.elementClass = elementClass;"
"AutoPopulatingList.java:293"$1$"		}"
"AutoPopulatingList.java:294"$0$""
"AutoPopulatingList.java:295"$0$"		@Override"
"AutoPopulatingList.java:296"$1$"		public E createElement(int index) {"
"AutoPopulatingList.java:297"$1$"			try {"
"AutoPopulatingList.java:298"$1$"				return ReflectionUtils.accessibleConstructor(this.elementClass).newInstance();"
"AutoPopulatingList.java:299"$1$"			}"
"AutoPopulatingList.java:300"$1$"			catch (NoSuchMethodException ex) {"
"AutoPopulatingList.java:301"$1$"				throw new ElementInstantiationException("
"AutoPopulatingList.java:302"$1$"						""No default constructor on element class: "" + this.elementClass.getName(), ex);"
"AutoPopulatingList.java:303"$1$"			}"
"AutoPopulatingList.java:304"$1$"			catch (InstantiationException ex) {"
"AutoPopulatingList.java:305"$1$"				throw new ElementInstantiationException("
"AutoPopulatingList.java:306"$1$"						""Unable to instantiate element class: "" + this.elementClass.getName(), ex);"
"AutoPopulatingList.java:307"$1$"			}"
"AutoPopulatingList.java:308"$1$"			catch (IllegalAccessException ex) {"
"AutoPopulatingList.java:309"$1$"				throw new ElementInstantiationException("
"AutoPopulatingList.java:310"$1$"						""Could not access element constructor: "" + this.elementClass.getName(), ex);"
"AutoPopulatingList.java:311"$1$"			}"
"AutoPopulatingList.java:312"$1$"			catch (InvocationTargetException ex) {"
"AutoPopulatingList.java:313"$1$"				throw new ElementInstantiationException("
"AutoPopulatingList.java:314"$1$"						""Failed to invoke element constructor: "" + this.elementClass.getName(), ex.getTargetException());"
"AutoPopulatingList.java:315"$1$"			}"
"AutoPopulatingList.java:316"$0$"		}"
"AutoPopulatingList.java:317"$0$"	}"
"AutoPopulatingList.java:318"$0$""
"AutoPopulatingList.java:319"$0$"}"
"FileCopyUtils.java:1"$0$"/*"
"FileCopyUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"FileCopyUtils.java:3"$0$" *"
"FileCopyUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"FileCopyUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"FileCopyUtils.java:6"$0$" * You may obtain a copy of the License at"
"FileCopyUtils.java:7"$0$" *"
"FileCopyUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"FileCopyUtils.java:9"$0$" *"
"FileCopyUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"FileCopyUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"FileCopyUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"FileCopyUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"FileCopyUtils.java:14"$0$" * limitations under the License."
"FileCopyUtils.java:15"$0$" */"
"FileCopyUtils.java:16"$0$""
"FileCopyUtils.java:17"$0$"package org.springframework.util;"
"FileCopyUtils.java:18"$0$""
"FileCopyUtils.java:19"$0$"import java.io.ByteArrayInputStream;"
"FileCopyUtils.java:20"$0$"import java.io.ByteArrayOutputStream;"
"FileCopyUtils.java:21"$0$"import java.io.Closeable;"
"FileCopyUtils.java:22"$0$"import java.io.File;"
"FileCopyUtils.java:23"$0$"import java.io.IOException;"
"FileCopyUtils.java:24"$0$"import java.io.InputStream;"
"FileCopyUtils.java:25"$0$"import java.io.OutputStream;"
"FileCopyUtils.java:26"$0$"import java.io.Reader;"
"FileCopyUtils.java:27"$0$"import java.io.StringWriter;"
"FileCopyUtils.java:28"$0$"import java.io.Writer;"
"FileCopyUtils.java:29"$0$"import java.nio.file.Files;"
"FileCopyUtils.java:30"$0$""
"FileCopyUtils.java:31"$0$"import org.springframework.lang.Nullable;"
"FileCopyUtils.java:32"$0$""
"FileCopyUtils.java:33"$0$"/**"
"FileCopyUtils.java:34"$0$" * Simple utility methods for file and stream copying. All copy methods use a block size"
"FileCopyUtils.java:35"$0$" * of 4096 bytes, and close all affected streams when done. A variation of the copy"
"FileCopyUtils.java:36"$1$" * methods from this class that leave streams open can be found in {@link StreamUtils}."
"FileCopyUtils.java:37"$0$" *"
"FileCopyUtils.java:38"$0$" * <p>Mainly for use within the framework, but also useful for application code."
"FileCopyUtils.java:39"$0$" *"
"FileCopyUtils.java:40"$0$" * @author Juergen Hoeller"
"FileCopyUtils.java:41"$0$" * @author Hyunjin Choi"
"FileCopyUtils.java:42"$0$" * @since 06.10.2003"
"FileCopyUtils.java:43"$0$" * @see StreamUtils"
"FileCopyUtils.java:44"$0$" * @see FileSystemUtils"
"FileCopyUtils.java:45"$0$" */"
"FileCopyUtils.java:46"$1$"public abstract class FileCopyUtils {"
"FileCopyUtils.java:47"$1$""
"FileCopyUtils.java:48"$1$"	/**"
"FileCopyUtils.java:49"$1$"	 * The default buffer size used when copying bytes."
"FileCopyUtils.java:50"$1$"	 */"
"FileCopyUtils.java:51"$1$"	public static final int BUFFER_SIZE = StreamUtils.BUFFER_SIZE;"
"FileCopyUtils.java:52"$1$""
"FileCopyUtils.java:53"$1$""
"FileCopyUtils.java:54"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:55"$0$"	// Copy methods for java.io.File"
"FileCopyUtils.java:56"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:57"$1$""
"FileCopyUtils.java:58"$1$"	/**"
"FileCopyUtils.java:59"$1$"	 * Copy the contents of the given input File to the given output File."
"FileCopyUtils.java:60"$1$"	 * @param in the file to copy from"
"FileCopyUtils.java:61"$1$"	 * @param out the file to copy to"
"FileCopyUtils.java:62"$1$"	 * @return the number of bytes copied"
"FileCopyUtils.java:63"$1$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:64"$1$"	 */"
"FileCopyUtils.java:65"$1$"	public static int copy(File in, File out) throws IOException {"
"FileCopyUtils.java:66"$1$"		Assert.notNull(in, ""No input File specified"");"
"FileCopyUtils.java:67"$1$"		Assert.notNull(out, ""No output File specified"");"
"FileCopyUtils.java:68"$1$"		return copy(Files.newInputStream(in.toPath()), Files.newOutputStream(out.toPath()));"
"FileCopyUtils.java:69"$1$"	}"
"FileCopyUtils.java:70"$0$""
"FileCopyUtils.java:71"$0$"	/**"
"FileCopyUtils.java:72"$0$"	 * Copy the contents of the given byte array to the given output File."
"FileCopyUtils.java:73"$0$"	 * @param in the byte array to copy from"
"FileCopyUtils.java:74"$0$"	 * @param out the file to copy to"
"FileCopyUtils.java:75"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:76"$0$"	 */"
"FileCopyUtils.java:77"$1$"	public static void copy(byte[] in, File out) throws IOException {"
"FileCopyUtils.java:78"$1$"		Assert.notNull(in, ""No input byte array specified"");"
"FileCopyUtils.java:79"$1$"		Assert.notNull(out, ""No output File specified"");"
"FileCopyUtils.java:80"$1$"		copy(new ByteArrayInputStream(in), Files.newOutputStream(out.toPath()));"
"FileCopyUtils.java:81"$1$"	}"
"FileCopyUtils.java:82"$0$""
"FileCopyUtils.java:83"$0$"	/**"
"FileCopyUtils.java:84"$0$"	 * Copy the contents of the given input File into a new byte array."
"FileCopyUtils.java:85"$0$"	 * @param in the file to copy from"
"FileCopyUtils.java:86"$0$"	 * @return the new byte array that has been copied to"
"FileCopyUtils.java:87"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:88"$0$"	 */"
"FileCopyUtils.java:89"$1$"	public static byte[] copyToByteArray(File in) throws IOException {"
"FileCopyUtils.java:90"$1$"		Assert.notNull(in, ""No input File specified"");"
"FileCopyUtils.java:91"$1$"		return copyToByteArray(Files.newInputStream(in.toPath()));"
"FileCopyUtils.java:92"$1$"	}"
"FileCopyUtils.java:93"$0$""
"FileCopyUtils.java:94"$0$""
"FileCopyUtils.java:95"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:96"$0$"	// Copy methods for java.io.InputStream / java.io.OutputStream"
"FileCopyUtils.java:97"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:98"$0$""
"FileCopyUtils.java:99"$0$"	/**"
"FileCopyUtils.java:100"$0$"	 * Copy the contents of the given InputStream to the given OutputStream."
"FileCopyUtils.java:101"$0$"	 * Closes both streams when done."
"FileCopyUtils.java:102"$0$"	 * @param in the stream to copy from"
"FileCopyUtils.java:103"$0$"	 * @param out the stream to copy to"
"FileCopyUtils.java:104"$0$"	 * @return the number of bytes copied"
"FileCopyUtils.java:105"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:106"$0$"	 */"
"FileCopyUtils.java:107"$1$"	public static int copy(InputStream in, OutputStream out) throws IOException {"
"FileCopyUtils.java:108"$1$"		Assert.notNull(in, ""No InputStream specified"");"
"FileCopyUtils.java:109"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"FileCopyUtils.java:110"$1$""
"FileCopyUtils.java:111"$1$"		try {"
"FileCopyUtils.java:112"$1$"			return StreamUtils.copy(in, out);"
"FileCopyUtils.java:113"$1$"		}"
"FileCopyUtils.java:114"$1$"		finally {"
"FileCopyUtils.java:115"$1$"			close(in);"
"FileCopyUtils.java:116"$1$"			close(out);"
"FileCopyUtils.java:117"$1$"		}"
"FileCopyUtils.java:118"$0$"	}"
"FileCopyUtils.java:119"$0$""
"FileCopyUtils.java:120"$0$"	/**"
"FileCopyUtils.java:121"$0$"	 * Copy the contents of the given byte array to the given OutputStream."
"FileCopyUtils.java:122"$0$"	 * Closes the stream when done."
"FileCopyUtils.java:123"$0$"	 * @param in the byte array to copy from"
"FileCopyUtils.java:124"$0$"	 * @param out the OutputStream to copy to"
"FileCopyUtils.java:125"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:126"$0$"	 */"
"FileCopyUtils.java:127"$1$"	public static void copy(byte[] in, OutputStream out) throws IOException {"
"FileCopyUtils.java:128"$1$"		Assert.notNull(in, ""No input byte array specified"");"
"FileCopyUtils.java:129"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"FileCopyUtils.java:130"$1$""
"FileCopyUtils.java:131"$1$"		try {"
"FileCopyUtils.java:132"$1$"			out.write(in);"
"FileCopyUtils.java:133"$1$"		}"
"FileCopyUtils.java:134"$1$"		finally {"
"FileCopyUtils.java:135"$1$"			close(out);"
"FileCopyUtils.java:136"$1$"		}"
"FileCopyUtils.java:137"$0$"	}"
"FileCopyUtils.java:138"$0$""
"FileCopyUtils.java:139"$0$"	/**"
"FileCopyUtils.java:140"$0$"	 * Copy the contents of the given InputStream into a new byte array."
"FileCopyUtils.java:141"$0$"	 * Closes the stream when done."
"FileCopyUtils.java:142"$1$"	 * @param in the stream to copy from (may be {@code null} or empty)"
"FileCopyUtils.java:143"$0$"	 * @return the new byte array that has been copied to (possibly empty)"
"FileCopyUtils.java:144"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:145"$0$"	 */"
"FileCopyUtils.java:146"$1$"	public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {"
"FileCopyUtils.java:147"$1$"		if (in == null) {"
"FileCopyUtils.java:148"$1$"			return new byte[0];"
"FileCopyUtils.java:149"$1$"		}"
"FileCopyUtils.java:150"$0$""
"FileCopyUtils.java:151"$0$"		ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE);"
"FileCopyUtils.java:152"$0$"		copy(in, out);"
"FileCopyUtils.java:153"$0$"		return out.toByteArray();"
"FileCopyUtils.java:154"$0$"	}"
"FileCopyUtils.java:155"$0$""
"FileCopyUtils.java:156"$0$""
"FileCopyUtils.java:157"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:158"$0$"	// Copy methods for java.io.Reader / java.io.Writer"
"FileCopyUtils.java:159"$0$"	//---------------------------------------------------------------------"
"FileCopyUtils.java:160"$0$""
"FileCopyUtils.java:161"$0$"	/**"
"FileCopyUtils.java:162"$0$"	 * Copy the contents of the given Reader to the given Writer."
"FileCopyUtils.java:163"$0$"	 * Closes both when done."
"FileCopyUtils.java:164"$0$"	 * @param in the Reader to copy from"
"FileCopyUtils.java:165"$0$"	 * @param out the Writer to copy to"
"FileCopyUtils.java:166"$0$"	 * @return the number of characters copied"
"FileCopyUtils.java:167"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:168"$0$"	 */"
"FileCopyUtils.java:169"$1$"	public static int copy(Reader in, Writer out) throws IOException {"
"FileCopyUtils.java:170"$1$"		Assert.notNull(in, ""No Reader specified"");"
"FileCopyUtils.java:171"$1$"		Assert.notNull(out, ""No Writer specified"");"
"FileCopyUtils.java:172"$1$""
"FileCopyUtils.java:173"$1$"		try {"
"FileCopyUtils.java:174"$1$"			int byteCount = 0;"
"FileCopyUtils.java:175"$1$"			char[] buffer = new char[BUFFER_SIZE];"
"FileCopyUtils.java:176"$1$"			int bytesRead = -1;"
"FileCopyUtils.java:177"$1$"			while ((bytesRead = in.read(buffer)) != -1) {"
"FileCopyUtils.java:178"$1$"				out.write(buffer, 0, bytesRead);"
"FileCopyUtils.java:179"$1$"				byteCount += bytesRead;"
"FileCopyUtils.java:180"$1$"			}"
"FileCopyUtils.java:181"$0$"			out.flush();"
"FileCopyUtils.java:182"$0$"			return byteCount;"
"FileCopyUtils.java:183"$0$"		}"
"FileCopyUtils.java:184"$1$"		finally {"
"FileCopyUtils.java:185"$1$"			close(in);"
"FileCopyUtils.java:186"$1$"			close(out);"
"FileCopyUtils.java:187"$1$"		}"
"FileCopyUtils.java:188"$0$"	}"
"FileCopyUtils.java:189"$0$""
"FileCopyUtils.java:190"$0$"	/**"
"FileCopyUtils.java:191"$0$"	 * Copy the contents of the given String to the given output Writer."
"FileCopyUtils.java:192"$0$"	 * Closes the writer when done."
"FileCopyUtils.java:193"$0$"	 * @param in the String to copy from"
"FileCopyUtils.java:194"$0$"	 * @param out the Writer to copy to"
"FileCopyUtils.java:195"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:196"$0$"	 */"
"FileCopyUtils.java:197"$1$"	public static void copy(String in, Writer out) throws IOException {"
"FileCopyUtils.java:198"$1$"		Assert.notNull(in, ""No input String specified"");"
"FileCopyUtils.java:199"$1$"		Assert.notNull(out, ""No Writer specified"");"
"FileCopyUtils.java:200"$1$""
"FileCopyUtils.java:201"$1$"		try {"
"FileCopyUtils.java:202"$1$"			out.write(in);"
"FileCopyUtils.java:203"$1$"		}"
"FileCopyUtils.java:204"$1$"		finally {"
"FileCopyUtils.java:205"$1$"			close(out);"
"FileCopyUtils.java:206"$1$"		}"
"FileCopyUtils.java:207"$0$"	}"
"FileCopyUtils.java:208"$0$""
"FileCopyUtils.java:209"$0$"	/**"
"FileCopyUtils.java:210"$0$"	 * Copy the contents of the given Reader into a String."
"FileCopyUtils.java:211"$0$"	 * Closes the reader when done."
"FileCopyUtils.java:212"$1$"	 * @param in the reader to copy from (may be {@code null} or empty)"
"FileCopyUtils.java:213"$0$"	 * @return the String that has been copied to (possibly empty)"
"FileCopyUtils.java:214"$0$"	 * @throws IOException in case of I/O errors"
"FileCopyUtils.java:215"$0$"	 */"
"FileCopyUtils.java:216"$1$"	public static String copyToString(@Nullable Reader in) throws IOException {"
"FileCopyUtils.java:217"$1$"		if (in == null) {"
"FileCopyUtils.java:218"$1$"			return """";"
"FileCopyUtils.java:219"$1$"		}"
"FileCopyUtils.java:220"$0$""
"FileCopyUtils.java:221"$0$"		StringWriter out = new StringWriter();"
"FileCopyUtils.java:222"$0$"		copy(in, out);"
"FileCopyUtils.java:223"$0$"		return out.toString();"
"FileCopyUtils.java:224"$0$"	}"
"FileCopyUtils.java:225"$0$""
"FileCopyUtils.java:226"$0$"	/**"
"FileCopyUtils.java:227"$1$"	 * Attempt to close the supplied {@link Closeable}, silently swallowing any"
"FileCopyUtils.java:228"$0$"	 * exceptions."
"FileCopyUtils.java:229"$1$"	 * @param closeable the {@code Closeable} to close"
"FileCopyUtils.java:230"$0$"	 */"
"FileCopyUtils.java:231"$1$"	private static void close(Closeable closeable) {"
"FileCopyUtils.java:232"$1$"		try {"
"FileCopyUtils.java:233"$1$"			closeable.close();"
"FileCopyUtils.java:234"$1$"		}"
"FileCopyUtils.java:235"$1$"		catch (IOException ex) {"
"FileCopyUtils.java:236"$0$"			// ignore"
"FileCopyUtils.java:237"$1$"		}"
"FileCopyUtils.java:238"$0$"	}"
"FileCopyUtils.java:239"$0$""
"FileCopyUtils.java:240"$0$"}"
"ToStringCreator.java:1"$0$"/*"
"ToStringCreator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ToStringCreator.java:3"$0$" *"
"ToStringCreator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ToStringCreator.java:5"$0$" * you may not use this file except in compliance with the License."
"ToStringCreator.java:6"$0$" * You may obtain a copy of the License at"
"ToStringCreator.java:7"$0$" *"
"ToStringCreator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ToStringCreator.java:9"$0$" *"
"ToStringCreator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ToStringCreator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ToStringCreator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ToStringCreator.java:13"$0$" * See the License for the specific language governing permissions and"
"ToStringCreator.java:14"$0$" * limitations under the License."
"ToStringCreator.java:15"$0$" */"
"ToStringCreator.java:16"$0$""
"ToStringCreator.java:17"$0$"package org.springframework.core.style;"
"ToStringCreator.java:18"$0$""
"ToStringCreator.java:19"$0$"import org.springframework.lang.Nullable;"
"ToStringCreator.java:20"$0$"import org.springframework.util.Assert;"
"ToStringCreator.java:21"$0$""
"ToStringCreator.java:22"$0$"/**"
"ToStringCreator.java:23"$1$" * Utility class that builds pretty-printing {@code toString()} methods"
"ToStringCreator.java:24"$0$" * with pluggable styling conventions. By default, ToStringCreator adheres"
"ToStringCreator.java:25"$1$" * to Spring's {@code toString()} styling conventions."
"ToStringCreator.java:26"$0$" *"
"ToStringCreator.java:27"$0$" * @author Keith Donald"
"ToStringCreator.java:28"$0$" * @author Juergen Hoeller"
"ToStringCreator.java:29"$0$" * @since 1.2.2"
"ToStringCreator.java:30"$0$" */"
"ToStringCreator.java:31"$1$"public class ToStringCreator {"
"ToStringCreator.java:32"$1$""
"ToStringCreator.java:33"$1$"	/**"
"ToStringCreator.java:34"$1$"	 * Default ToStringStyler instance used by this ToStringCreator."
"ToStringCreator.java:35"$1$"	 */"
"ToStringCreator.java:36"$1$"	private static final ToStringStyler DEFAULT_TO_STRING_STYLER ="
"ToStringCreator.java:37"$1$"			new DefaultToStringStyler(StylerUtils.DEFAULT_VALUE_STYLER);"
"ToStringCreator.java:38"$1$""
"ToStringCreator.java:39"$1$""
"ToStringCreator.java:40"$1$"	private final StringBuilder buffer = new StringBuilder(256);"
"ToStringCreator.java:41"$1$""
"ToStringCreator.java:42"$1$"	private final ToStringStyler styler;"
"ToStringCreator.java:43"$1$""
"ToStringCreator.java:44"$1$"	private final Object object;"
"ToStringCreator.java:45"$1$""
"ToStringCreator.java:46"$1$"	private boolean styledFirstField;"
"ToStringCreator.java:47"$1$""
"ToStringCreator.java:48"$1$""
"ToStringCreator.java:49"$1$"	/**"
"ToStringCreator.java:50"$1$"	 * Create a ToStringCreator for the given object."
"ToStringCreator.java:51"$1$"	 * @param obj the object to be stringified"
"ToStringCreator.java:52"$1$"	 */"
"ToStringCreator.java:53"$1$"	public ToStringCreator(Object obj) {"
"ToStringCreator.java:54"$1$"		this(obj, (ToStringStyler) null);"
"ToStringCreator.java:55"$1$"	}"
"ToStringCreator.java:56"$0$""
"ToStringCreator.java:57"$0$"	/**"
"ToStringCreator.java:58"$0$"	 * Create a ToStringCreator for the given object, using the provided style."
"ToStringCreator.java:59"$0$"	 * @param obj the object to be stringified"
"ToStringCreator.java:60"$0$"	 * @param styler the ValueStyler encapsulating pretty-print instructions"
"ToStringCreator.java:61"$0$"	 */"
"ToStringCreator.java:62"$1$"	public ToStringCreator(Object obj, @Nullable ValueStyler styler) {"
"ToStringCreator.java:63"$1$"		this(obj, new DefaultToStringStyler(styler != null ? styler : StylerUtils.DEFAULT_VALUE_STYLER));"
"ToStringCreator.java:64"$1$"	}"
"ToStringCreator.java:65"$0$""
"ToStringCreator.java:66"$0$"	/**"
"ToStringCreator.java:67"$0$"	 * Create a ToStringCreator for the given object, using the provided style."
"ToStringCreator.java:68"$0$"	 * @param obj the object to be stringified"
"ToStringCreator.java:69"$0$"	 * @param styler the ToStringStyler encapsulating pretty-print instructions"
"ToStringCreator.java:70"$0$"	 */"
"ToStringCreator.java:71"$1$"	public ToStringCreator(Object obj, @Nullable ToStringStyler styler) {"
"ToStringCreator.java:72"$1$"		Assert.notNull(obj, ""The object to be styled must not be null"");"
"ToStringCreator.java:73"$1$"		this.object = obj;"
"ToStringCreator.java:74"$1$"		this.styler = (styler != null ? styler : DEFAULT_TO_STRING_STYLER);"
"ToStringCreator.java:75"$1$"		this.styler.styleStart(this.buffer, this.object);"
"ToStringCreator.java:76"$1$"	}"
"ToStringCreator.java:77"$0$""
"ToStringCreator.java:78"$0$""
"ToStringCreator.java:79"$0$"	/**"
"ToStringCreator.java:80"$0$"	 * Append a byte field value."
"ToStringCreator.java:81"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:82"$0$"	 * @param value the field value"
"ToStringCreator.java:83"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:84"$0$"	 */"
"ToStringCreator.java:85"$1$"	public ToStringCreator append(String fieldName, byte value) {"
"ToStringCreator.java:86"$1$"		return append(fieldName, Byte.valueOf(value));"
"ToStringCreator.java:87"$1$"	}"
"ToStringCreator.java:88"$0$""
"ToStringCreator.java:89"$0$"	/**"
"ToStringCreator.java:90"$0$"	 * Append a short field value."
"ToStringCreator.java:91"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:92"$0$"	 * @param value the field value"
"ToStringCreator.java:93"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:94"$0$"	 */"
"ToStringCreator.java:95"$1$"	public ToStringCreator append(String fieldName, short value) {"
"ToStringCreator.java:96"$1$"		return append(fieldName, Short.valueOf(value));"
"ToStringCreator.java:97"$1$"	}"
"ToStringCreator.java:98"$0$""
"ToStringCreator.java:99"$0$"	/**"
"ToStringCreator.java:100"$0$"	 * Append a integer field value."
"ToStringCreator.java:101"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:102"$0$"	 * @param value the field value"
"ToStringCreator.java:103"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:104"$0$"	 */"
"ToStringCreator.java:105"$1$"	public ToStringCreator append(String fieldName, int value) {"
"ToStringCreator.java:106"$1$"		return append(fieldName, Integer.valueOf(value));"
"ToStringCreator.java:107"$1$"	}"
"ToStringCreator.java:108"$0$""
"ToStringCreator.java:109"$0$"	/**"
"ToStringCreator.java:110"$0$"	 * Append a long field value."
"ToStringCreator.java:111"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:112"$0$"	 * @param value the field value"
"ToStringCreator.java:113"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:114"$0$"	 */"
"ToStringCreator.java:115"$1$"	public ToStringCreator append(String fieldName, long value) {"
"ToStringCreator.java:116"$1$"		return append(fieldName, Long.valueOf(value));"
"ToStringCreator.java:117"$1$"	}"
"ToStringCreator.java:118"$0$""
"ToStringCreator.java:119"$0$"	/**"
"ToStringCreator.java:120"$0$"	 * Append a float field value."
"ToStringCreator.java:121"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:122"$0$"	 * @param value the field value"
"ToStringCreator.java:123"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:124"$0$"	 */"
"ToStringCreator.java:125"$1$"	public ToStringCreator append(String fieldName, float value) {"
"ToStringCreator.java:126"$1$"		return append(fieldName, Float.valueOf(value));"
"ToStringCreator.java:127"$1$"	}"
"ToStringCreator.java:128"$0$""
"ToStringCreator.java:129"$0$"	/**"
"ToStringCreator.java:130"$0$"	 * Append a double field value."
"ToStringCreator.java:131"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:132"$0$"	 * @param value the field value"
"ToStringCreator.java:133"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:134"$0$"	 */"
"ToStringCreator.java:135"$1$"	public ToStringCreator append(String fieldName, double value) {"
"ToStringCreator.java:136"$1$"		return append(fieldName, Double.valueOf(value));"
"ToStringCreator.java:137"$1$"	}"
"ToStringCreator.java:138"$0$""
"ToStringCreator.java:139"$0$"	/**"
"ToStringCreator.java:140"$0$"	 * Append a boolean field value."
"ToStringCreator.java:141"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:142"$0$"	 * @param value the field value"
"ToStringCreator.java:143"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:144"$0$"	 */"
"ToStringCreator.java:145"$1$"	public ToStringCreator append(String fieldName, boolean value) {"
"ToStringCreator.java:146"$1$"		return append(fieldName, Boolean.valueOf(value));"
"ToStringCreator.java:147"$1$"	}"
"ToStringCreator.java:148"$0$""
"ToStringCreator.java:149"$0$"	/**"
"ToStringCreator.java:150"$0$"	 * Append a field value."
"ToStringCreator.java:151"$0$"	 * @param fieldName the name of the field, usually the member variable name"
"ToStringCreator.java:152"$0$"	 * @param value the field value"
"ToStringCreator.java:153"$0$"	 * @return this, to support call-chaining"
"ToStringCreator.java:154"$0$"	 */"
"ToStringCreator.java:155"$1$"	public ToStringCreator append(String fieldName, @Nullable Object value) {"
"ToStringCreator.java:156"$1$"		printFieldSeparatorIfNecessary();"
"ToStringCreator.java:157"$1$"		this.styler.styleField(this.buffer, fieldName, value);"
"ToStringCreator.java:158"$1$"		return this;"
"ToStringCreator.java:159"$1$"	}"
"ToStringCreator.java:160"$0$""
"ToStringCreator.java:161"$1$"	private void printFieldSeparatorIfNecessary() {"
"ToStringCreator.java:162"$1$"		if (this.styledFirstField) {"
"ToStringCreator.java:163"$1$"			this.styler.styleFieldSeparator(this.buffer);"
"ToStringCreator.java:164"$1$"		}"
"ToStringCreator.java:165"$1$"		else {"
"ToStringCreator.java:166"$1$"			this.styledFirstField = true;"
"ToStringCreator.java:167"$1$"		}"
"ToStringCreator.java:168"$0$"	}"
"ToStringCreator.java:169"$0$""
"ToStringCreator.java:170"$0$"	/**"
"ToStringCreator.java:171"$0$"	 * Append the provided value."
"ToStringCreator.java:172"$0$"	 * @param value the value to append"
"ToStringCreator.java:173"$0$"	 * @return this, to support call-chaining."
"ToStringCreator.java:174"$0$"	 */"
"ToStringCreator.java:175"$1$"	public ToStringCreator append(Object value) {"
"ToStringCreator.java:176"$1$"		this.styler.styleValue(this.buffer, value);"
"ToStringCreator.java:177"$1$"		return this;"
"ToStringCreator.java:178"$1$"	}"
"ToStringCreator.java:179"$0$""
"ToStringCreator.java:180"$0$""
"ToStringCreator.java:181"$0$"	/**"
"ToStringCreator.java:182"$0$"	 * Return the String representation that this ToStringCreator built."
"ToStringCreator.java:183"$0$"	 */"
"ToStringCreator.java:184"$0$"	@Override"
"ToStringCreator.java:185"$1$"	public String toString() {"
"ToStringCreator.java:186"$1$"		this.styler.styleEnd(this.buffer, this.object);"
"ToStringCreator.java:187"$1$"		return this.buffer.toString();"
"ToStringCreator.java:188"$1$"	}"
"ToStringCreator.java:189"$0$""
"ToStringCreator.java:190"$0$"}"
"CollectionToCollectionConverter.java:1"$0$"/*"
"CollectionToCollectionConverter.java:2"$0$" * Copyright 2002-2014 the original author or authors."
"CollectionToCollectionConverter.java:3"$0$" *"
"CollectionToCollectionConverter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CollectionToCollectionConverter.java:5"$0$" * you may not use this file except in compliance with the License."
"CollectionToCollectionConverter.java:6"$0$" * You may obtain a copy of the License at"
"CollectionToCollectionConverter.java:7"$0$" *"
"CollectionToCollectionConverter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CollectionToCollectionConverter.java:9"$0$" *"
"CollectionToCollectionConverter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CollectionToCollectionConverter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CollectionToCollectionConverter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CollectionToCollectionConverter.java:13"$0$" * See the License for the specific language governing permissions and"
"CollectionToCollectionConverter.java:14"$0$" * limitations under the License."
"CollectionToCollectionConverter.java:15"$0$" */"
"CollectionToCollectionConverter.java:16"$0$""
"CollectionToCollectionConverter.java:17"$0$"package org.springframework.core.convert.support;"
"CollectionToCollectionConverter.java:18"$0$""
"CollectionToCollectionConverter.java:19"$0$"import java.util.Collection;"
"CollectionToCollectionConverter.java:20"$0$"import java.util.Collections;"
"CollectionToCollectionConverter.java:21"$0$"import java.util.Set;"
"CollectionToCollectionConverter.java:22"$0$""
"CollectionToCollectionConverter.java:23"$0$"import org.springframework.core.CollectionFactory;"
"CollectionToCollectionConverter.java:24"$0$"import org.springframework.core.convert.ConversionService;"
"CollectionToCollectionConverter.java:25"$0$"import org.springframework.core.convert.TypeDescriptor;"
"CollectionToCollectionConverter.java:26"$0$"import org.springframework.core.convert.converter.ConditionalGenericConverter;"
"CollectionToCollectionConverter.java:27"$0$"import org.springframework.lang.Nullable;"
"CollectionToCollectionConverter.java:28"$0$""
"CollectionToCollectionConverter.java:29"$0$"/**"
"CollectionToCollectionConverter.java:30"$0$" * Converts from a Collection to another Collection."
"CollectionToCollectionConverter.java:31"$0$" *"
"CollectionToCollectionConverter.java:32"$0$" * <p>First, creates a new Collection of the requested targetType with a size equal to the"
"CollectionToCollectionConverter.java:33"$0$" * size of the source Collection. Then copies each element in the source collection to the"
"CollectionToCollectionConverter.java:34"$0$" * target collection. Will perform an element conversion from the source collection's"
"CollectionToCollectionConverter.java:35"$0$" * parameterized type to the target collection's parameterized type if necessary."
"CollectionToCollectionConverter.java:36"$0$" *"
"CollectionToCollectionConverter.java:37"$0$" * @author Keith Donald"
"CollectionToCollectionConverter.java:38"$0$" * @author Juergen Hoeller"
"CollectionToCollectionConverter.java:39"$0$" * @since 3.0"
"CollectionToCollectionConverter.java:40"$0$" */"
"CollectionToCollectionConverter.java:41"$1$"final class CollectionToCollectionConverter implements ConditionalGenericConverter {"
"CollectionToCollectionConverter.java:42"$1$""
"CollectionToCollectionConverter.java:43"$1$"	private final ConversionService conversionService;"
"CollectionToCollectionConverter.java:44"$1$""
"CollectionToCollectionConverter.java:45"$1$""
"CollectionToCollectionConverter.java:46"$1$"	public CollectionToCollectionConverter(ConversionService conversionService) {"
"CollectionToCollectionConverter.java:47"$1$"		this.conversionService = conversionService;"
"CollectionToCollectionConverter.java:48"$1$"	}"
"CollectionToCollectionConverter.java:49"$0$""
"CollectionToCollectionConverter.java:50"$0$""
"CollectionToCollectionConverter.java:51"$0$"	@Override"
"CollectionToCollectionConverter.java:52"$1$"	public Set<ConvertiblePair> getConvertibleTypes() {"
"CollectionToCollectionConverter.java:53"$1$"		return Collections.singleton(new ConvertiblePair(Collection.class, Collection.class));"
"CollectionToCollectionConverter.java:54"$1$"	}"
"CollectionToCollectionConverter.java:55"$0$""
"CollectionToCollectionConverter.java:56"$0$"	@Override"
"CollectionToCollectionConverter.java:57"$1$"	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"CollectionToCollectionConverter.java:58"$1$"		return ConversionUtils.canConvertElements("
"CollectionToCollectionConverter.java:59"$1$"				sourceType.getElementTypeDescriptor(), targetType.getElementTypeDescriptor(), this.conversionService);"
"CollectionToCollectionConverter.java:60"$1$"	}"
"CollectionToCollectionConverter.java:61"$0$""
"CollectionToCollectionConverter.java:62"$0$"	@Override"
"CollectionToCollectionConverter.java:63"$0$"	@Nullable"
"CollectionToCollectionConverter.java:64"$1$"	public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"CollectionToCollectionConverter.java:65"$1$"		if (source == null) {"
"CollectionToCollectionConverter.java:66"$1$"			return null;"
"CollectionToCollectionConverter.java:67"$1$"		}"
"CollectionToCollectionConverter.java:68"$0$"		Collection<?> sourceCollection = (Collection<?>) source;"
"CollectionToCollectionConverter.java:69"$0$""
"CollectionToCollectionConverter.java:70"$0$"		// Shortcut if possible..."
"CollectionToCollectionConverter.java:71"$0$"		boolean copyRequired = !targetType.getType().isInstance(source);"
"CollectionToCollectionConverter.java:72"$1$"		if (!copyRequired && sourceCollection.isEmpty()) {"
"CollectionToCollectionConverter.java:73"$1$"			return source;"
"CollectionToCollectionConverter.java:74"$1$"		}"
"CollectionToCollectionConverter.java:75"$0$"		TypeDescriptor elementDesc = targetType.getElementTypeDescriptor();"
"CollectionToCollectionConverter.java:76"$1$"		if (elementDesc == null && !copyRequired) {"
"CollectionToCollectionConverter.java:77"$1$"			return source;"
"CollectionToCollectionConverter.java:78"$1$"		}"
"CollectionToCollectionConverter.java:79"$0$""
"CollectionToCollectionConverter.java:80"$0$"		// At this point, we need a collection copy in any case, even if just for finding out about element copies..."
"CollectionToCollectionConverter.java:81"$0$"		Collection<Object> target = CollectionFactory.createCollection(targetType.getType(),"
"CollectionToCollectionConverter.java:82"$0$"				(elementDesc != null ? elementDesc.getType() : null), sourceCollection.size());"
"CollectionToCollectionConverter.java:83"$0$""
"CollectionToCollectionConverter.java:84"$1$"		if (elementDesc == null) {"
"CollectionToCollectionConverter.java:85"$1$"			target.addAll(sourceCollection);"
"CollectionToCollectionConverter.java:86"$1$"		}"
"CollectionToCollectionConverter.java:87"$1$"		else {"
"CollectionToCollectionConverter.java:88"$1$"			for (Object sourceElement : sourceCollection) {"
"CollectionToCollectionConverter.java:89"$1$"				Object targetElement = this.conversionService.convert(sourceElement,"
"CollectionToCollectionConverter.java:90"$1$"						sourceType.elementTypeDescriptor(sourceElement), elementDesc);"
"CollectionToCollectionConverter.java:91"$1$"				target.add(targetElement);"
"CollectionToCollectionConverter.java:92"$1$"				if (sourceElement != targetElement) {"
"CollectionToCollectionConverter.java:93"$1$"					copyRequired = true;"
"CollectionToCollectionConverter.java:94"$1$"				}"
"CollectionToCollectionConverter.java:95"$0$"			}"
"CollectionToCollectionConverter.java:96"$0$"		}"
"CollectionToCollectionConverter.java:97"$0$""
"CollectionToCollectionConverter.java:98"$0$"		return (copyRequired ? target : source);"
"CollectionToCollectionConverter.java:99"$0$"	}"
"CollectionToCollectionConverter.java:100"$0$""
"CollectionToCollectionConverter.java:101"$0$"}"
"JOptCommandLinePropertySource.java:1"$0$"/*"
"JOptCommandLinePropertySource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"JOptCommandLinePropertySource.java:3"$0$" *"
"JOptCommandLinePropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"JOptCommandLinePropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"JOptCommandLinePropertySource.java:6"$0$" * You may obtain a copy of the License at"
"JOptCommandLinePropertySource.java:7"$0$" *"
"JOptCommandLinePropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"JOptCommandLinePropertySource.java:9"$0$" *"
"JOptCommandLinePropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"JOptCommandLinePropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"JOptCommandLinePropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"JOptCommandLinePropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"JOptCommandLinePropertySource.java:14"$0$" * limitations under the License."
"JOptCommandLinePropertySource.java:15"$0$" */"
"JOptCommandLinePropertySource.java:16"$0$""
"JOptCommandLinePropertySource.java:17"$0$"package org.springframework.core.env;"
"JOptCommandLinePropertySource.java:18"$0$""
"JOptCommandLinePropertySource.java:19"$0$"import java.util.ArrayList;"
"JOptCommandLinePropertySource.java:20"$0$"import java.util.Collections;"
"JOptCommandLinePropertySource.java:21"$0$"import java.util.List;"
"JOptCommandLinePropertySource.java:22"$0$""
"JOptCommandLinePropertySource.java:23"$0$"import joptsimple.OptionSet;"
"JOptCommandLinePropertySource.java:24"$0$"import joptsimple.OptionSpec;"
"JOptCommandLinePropertySource.java:25"$0$""
"JOptCommandLinePropertySource.java:26"$0$"import org.springframework.lang.Nullable;"
"JOptCommandLinePropertySource.java:27"$0$"import org.springframework.util.CollectionUtils;"
"JOptCommandLinePropertySource.java:28"$0$"import org.springframework.util.StringUtils;"
"JOptCommandLinePropertySource.java:29"$0$""
"JOptCommandLinePropertySource.java:30"$0$"/**"
"JOptCommandLinePropertySource.java:31"$1$" * {@link CommandLinePropertySource} implementation backed by a JOpt {@link OptionSet}."
"JOptCommandLinePropertySource.java:32"$0$" *"
"JOptCommandLinePropertySource.java:33"$0$" * <h2>Typical usage</h2>"
"JOptCommandLinePropertySource.java:34"$0$" *"
"JOptCommandLinePropertySource.java:35"$1$" * Configure and execute an {@code OptionParser} against the {@code String[]} of arguments"
"JOptCommandLinePropertySource.java:36"$1$" * supplied to the {@code main} method, and create a {@link JOptCommandLinePropertySource}"
"JOptCommandLinePropertySource.java:37"$1$" * using the resulting {@code OptionSet} object:"
"JOptCommandLinePropertySource.java:38"$0$" *"
"JOptCommandLinePropertySource.java:39"$0$" * <pre class=""code"">"
"JOptCommandLinePropertySource.java:40"$1$" * public static void main(String[] args) {"
"JOptCommandLinePropertySource.java:41"$1$" *     OptionParser parser = new OptionParser();"
"JOptCommandLinePropertySource.java:42"$1$" *     parser.accepts(""option1"");"
"JOptCommandLinePropertySource.java:43"$1$" *     parser.accepts(""option2"").withRequiredArg();"
"JOptCommandLinePropertySource.java:44"$1$" *     OptionSet options = parser.parse(args);"
"JOptCommandLinePropertySource.java:45"$1$" *     PropertySource<?> ps = new JOptCommandLinePropertySource(options);"
"JOptCommandLinePropertySource.java:46"$1$" *     // ..."
"JOptCommandLinePropertySource.java:47"$1$" * }</pre>"
"JOptCommandLinePropertySource.java:48"$0$" *"
"JOptCommandLinePropertySource.java:49"$1$" * See {@link CommandLinePropertySource} for complete general usage examples."
"JOptCommandLinePropertySource.java:50"$0$" *"
"JOptCommandLinePropertySource.java:51"$0$" * <p>Requires JOpt Simple version 4.3 or higher. Tested against JOpt up until 5.0."
"JOptCommandLinePropertySource.java:52"$0$" *"
"JOptCommandLinePropertySource.java:53"$0$" * @author Chris Beams"
"JOptCommandLinePropertySource.java:54"$0$" * @author Juergen Hoeller"
"JOptCommandLinePropertySource.java:55"$0$" * @author Dave Syer"
"JOptCommandLinePropertySource.java:56"$0$" * @since 3.1"
"JOptCommandLinePropertySource.java:57"$0$" * @see CommandLinePropertySource"
"JOptCommandLinePropertySource.java:58"$0$" * @see joptsimple.OptionParser"
"JOptCommandLinePropertySource.java:59"$0$" * @see joptsimple.OptionSet"
"JOptCommandLinePropertySource.java:60"$0$" */"
"JOptCommandLinePropertySource.java:61"$1$"public class JOptCommandLinePropertySource extends CommandLinePropertySource<OptionSet> {"
"JOptCommandLinePropertySource.java:62"$1$""
"JOptCommandLinePropertySource.java:63"$1$"	/**"
"JOptCommandLinePropertySource.java:64"$1$"	 * Create a new {@code JOptCommandLinePropertySource} having the default name"
"JOptCommandLinePropertySource.java:65"$1$"	 * and backed by the given {@code OptionSet}."
"JOptCommandLinePropertySource.java:66"$1$"	 * @see CommandLinePropertySource#COMMAND_LINE_PROPERTY_SOURCE_NAME"
"JOptCommandLinePropertySource.java:67"$1$"	 * @see CommandLinePropertySource#CommandLinePropertySource(Object)"
"JOptCommandLinePropertySource.java:68"$1$"	 */"
"JOptCommandLinePropertySource.java:69"$1$"	public JOptCommandLinePropertySource(OptionSet options) {"
"JOptCommandLinePropertySource.java:70"$1$"		super(options);"
"JOptCommandLinePropertySource.java:71"$1$"	}"
"JOptCommandLinePropertySource.java:72"$0$""
"JOptCommandLinePropertySource.java:73"$0$"	/**"
"JOptCommandLinePropertySource.java:74"$1$"	 * Create a new {@code JOptCommandLinePropertySource} having the given name"
"JOptCommandLinePropertySource.java:75"$1$"	 * and backed by the given {@code OptionSet}."
"JOptCommandLinePropertySource.java:76"$0$"	 */"
"JOptCommandLinePropertySource.java:77"$1$"	public JOptCommandLinePropertySource(String name, OptionSet options) {"
"JOptCommandLinePropertySource.java:78"$1$"		super(name, options);"
"JOptCommandLinePropertySource.java:79"$1$"	}"
"JOptCommandLinePropertySource.java:80"$0$""
"JOptCommandLinePropertySource.java:81"$0$""
"JOptCommandLinePropertySource.java:82"$0$"	@Override"
"JOptCommandLinePropertySource.java:83"$1$"	protected boolean containsOption(String name) {"
"JOptCommandLinePropertySource.java:84"$1$"		return this.source.has(name);"
"JOptCommandLinePropertySource.java:85"$1$"	}"
"JOptCommandLinePropertySource.java:86"$0$""
"JOptCommandLinePropertySource.java:87"$0$"	@Override"
"JOptCommandLinePropertySource.java:88"$1$"	public String[] getPropertyNames() {"
"JOptCommandLinePropertySource.java:89"$1$"		List<String> names = new ArrayList<>();"
"JOptCommandLinePropertySource.java:90"$1$"		for (OptionSpec<?> spec : this.source.specs()) {"
"JOptCommandLinePropertySource.java:91"$1$"			String lastOption = CollectionUtils.lastElement(spec.options());"
"JOptCommandLinePropertySource.java:92"$1$"			if (lastOption != null) {"
"JOptCommandLinePropertySource.java:93"$0$"				// Only the longest name is used for enumerating"
"JOptCommandLinePropertySource.java:94"$1$"				names.add(lastOption);"
"JOptCommandLinePropertySource.java:95"$1$"			}"
"JOptCommandLinePropertySource.java:96"$0$"		}"
"JOptCommandLinePropertySource.java:97"$0$"		return StringUtils.toStringArray(names);"
"JOptCommandLinePropertySource.java:98"$0$"	}"
"JOptCommandLinePropertySource.java:99"$0$""
"JOptCommandLinePropertySource.java:100"$0$"	@Override"
"JOptCommandLinePropertySource.java:101"$0$"	@Nullable"
"JOptCommandLinePropertySource.java:102"$1$"	public List<String> getOptionValues(String name) {"
"JOptCommandLinePropertySource.java:103"$1$"		List<?> argValues = this.source.valuesOf(name);"
"JOptCommandLinePropertySource.java:104"$1$"		List<String> stringArgValues = new ArrayList<>();"
"JOptCommandLinePropertySource.java:105"$1$"		for (Object argValue : argValues) {"
"JOptCommandLinePropertySource.java:106"$1$"			stringArgValues.add(argValue.toString());"
"JOptCommandLinePropertySource.java:107"$1$"		}"
"JOptCommandLinePropertySource.java:108"$1$"		if (stringArgValues.isEmpty()) {"
"JOptCommandLinePropertySource.java:109"$1$"			return (this.source.has(name) ? Collections.emptyList() : null);"
"JOptCommandLinePropertySource.java:110"$1$"		}"
"JOptCommandLinePropertySource.java:111"$0$"		return Collections.unmodifiableList(stringArgValues);"
"JOptCommandLinePropertySource.java:112"$0$"	}"
"JOptCommandLinePropertySource.java:113"$0$""
"JOptCommandLinePropertySource.java:114"$0$"	@Override"
"JOptCommandLinePropertySource.java:115"$1$"	protected List<String> getNonOptionArgs() {"
"JOptCommandLinePropertySource.java:116"$1$"		List<?> argValues = this.source.nonOptionArguments();"
"JOptCommandLinePropertySource.java:117"$1$"		List<String> stringArgValues = new ArrayList<>();"
"JOptCommandLinePropertySource.java:118"$1$"		for (Object argValue : argValues) {"
"JOptCommandLinePropertySource.java:119"$1$"			stringArgValues.add(argValue.toString());"
"JOptCommandLinePropertySource.java:120"$1$"		}"
"JOptCommandLinePropertySource.java:121"$0$"		return (stringArgValues.isEmpty() ? Collections.emptyList() :"
"JOptCommandLinePropertySource.java:122"$0$"				Collections.unmodifiableList(stringArgValues));"
"JOptCommandLinePropertySource.java:123"$0$"	}"
"JOptCommandLinePropertySource.java:124"$0$""
"JOptCommandLinePropertySource.java:125"$0$"}"
"Resource.java:1"$0$"/*"
"Resource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"Resource.java:3"$0$" *"
"Resource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Resource.java:5"$0$" * you may not use this file except in compliance with the License."
"Resource.java:6"$0$" * You may obtain a copy of the License at"
"Resource.java:7"$0$" *"
"Resource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Resource.java:9"$0$" *"
"Resource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Resource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Resource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Resource.java:13"$0$" * See the License for the specific language governing permissions and"
"Resource.java:14"$0$" * limitations under the License."
"Resource.java:15"$0$" */"
"Resource.java:16"$0$""
"Resource.java:17"$0$"package org.springframework.core.io;"
"Resource.java:18"$0$""
"Resource.java:19"$0$"import java.io.File;"
"Resource.java:20"$0$"import java.io.IOException;"
"Resource.java:21"$0$"import java.io.InputStream;"
"Resource.java:22"$0$"import java.net.URI;"
"Resource.java:23"$0$"import java.net.URL;"
"Resource.java:24"$0$"import java.nio.channels.Channels;"
"Resource.java:25"$0$"import java.nio.channels.ReadableByteChannel;"
"Resource.java:26"$0$""
"Resource.java:27"$0$"import org.springframework.lang.Nullable;"
"Resource.java:28"$0$""
"Resource.java:29"$0$"/**"
"Resource.java:30"$0$" * Interface for a resource descriptor that abstracts from the actual"
"Resource.java:31"$0$" * type of underlying resource, such as a file or class path resource."
"Resource.java:32"$0$" *"
"Resource.java:33"$0$" * <p>An InputStream can be opened for every resource if it exists in"
"Resource.java:34"$0$" * physical form, but a URL or File handle can just be returned for"
"Resource.java:35"$0$" * certain resources. The actual behavior is implementation-specific."
"Resource.java:36"$0$" *"
"Resource.java:37"$0$" * @author Juergen Hoeller"
"Resource.java:38"$0$" * @since 28.12.2003"
"Resource.java:39"$0$" * @see #getInputStream()"
"Resource.java:40"$0$" * @see #getURL()"
"Resource.java:41"$0$" * @see #getURI()"
"Resource.java:42"$0$" * @see #getFile()"
"Resource.java:43"$0$" * @see WritableResource"
"Resource.java:44"$0$" * @see ContextResource"
"Resource.java:45"$0$" * @see UrlResource"
"Resource.java:46"$0$" * @see FileUrlResource"
"Resource.java:47"$0$" * @see FileSystemResource"
"Resource.java:48"$0$" * @see ClassPathResource"
"Resource.java:49"$0$" * @see ByteArrayResource"
"Resource.java:50"$0$" * @see InputStreamResource"
"Resource.java:51"$0$" */"
"Resource.java:52"$1$"public interface Resource extends InputStreamSource {"
"Resource.java:53"$1$""
"Resource.java:54"$1$"	/**"
"Resource.java:55"$1$"	 * Determine whether this resource actually exists in physical form."
"Resource.java:56"$1$"	 * <p>This method performs a definitive existence check, whereas the"
"Resource.java:57"$1$"	 * existence of a {@code Resource} handle only guarantees a valid"
"Resource.java:58"$1$"	 * descriptor handle."
"Resource.java:59"$1$"	 */"
"Resource.java:60"$1$"	boolean exists();"
"Resource.java:61"$1$""
"Resource.java:62"$1$"	/**"
"Resource.java:63"$1$"	 * Indicate whether non-empty contents of this resource can be read via"
"Resource.java:64"$1$"	 * {@link #getInputStream()}."
"Resource.java:65"$1$"	 * <p>Will be {@code true} for typical resource descriptors that exist"
"Resource.java:66"$1$"	 * since it strictly implies {@link #exists()} semantics as of 5.1."
"Resource.java:67"$1$"	 * Note that actual content reading may still fail when attempted."
"Resource.java:68"$1$"	 * However, a value of {@code false} is a definitive indication"
"Resource.java:69"$1$"	 * that the resource content cannot be read."
"Resource.java:70"$1$"	 * @see #getInputStream()"
"Resource.java:71"$1$"	 * @see #exists()"
"Resource.java:72"$1$"	 */"
"Resource.java:73"$1$"	default boolean isReadable() {"
"Resource.java:74"$1$"		return exists();"
"Resource.java:75"$1$"	}"
"Resource.java:76"$0$""
"Resource.java:77"$0$"	/**"
"Resource.java:78"$0$"	 * Indicate whether this resource represents a handle with an open stream."
"Resource.java:79"$1$"	 * If {@code true}, the InputStream cannot be read multiple times,"
"Resource.java:80"$0$"	 * and must be read and closed to avoid resource leaks."
"Resource.java:81"$1$"	 * <p>Will be {@code false} for typical resource descriptors."
"Resource.java:82"$0$"	 */"
"Resource.java:83"$1$"	default boolean isOpen() {"
"Resource.java:84"$1$"		return false;"
"Resource.java:85"$1$"	}"
"Resource.java:86"$0$""
"Resource.java:87"$0$"	/**"
"Resource.java:88"$0$"	 * Determine whether this resource represents a file in a file system."
"Resource.java:89"$1$"	 * A value of {@code true} strongly suggests (but does not guarantee)"
"Resource.java:90"$1$"	 * that a {@link #getFile()} call will succeed."
"Resource.java:91"$1$"	 * <p>This is conservatively {@code false} by default."
"Resource.java:92"$0$"	 * @since 5.0"
"Resource.java:93"$0$"	 * @see #getFile()"
"Resource.java:94"$0$"	 */"
"Resource.java:95"$1$"	default boolean isFile() {"
"Resource.java:96"$1$"		return false;"
"Resource.java:97"$1$"	}"
"Resource.java:98"$0$""
"Resource.java:99"$0$"	/**"
"Resource.java:100"$0$"	 * Return a URL handle for this resource."
"Resource.java:101"$0$"	 * @throws IOException if the resource cannot be resolved as URL,"
"Resource.java:102"$0$"	 * i.e. if the resource is not available as descriptor"
"Resource.java:103"$0$"	 */"
"Resource.java:104"$0$"	URL getURL() throws IOException;"
"Resource.java:105"$0$""
"Resource.java:106"$0$"	/**"
"Resource.java:107"$0$"	 * Return a URI handle for this resource."
"Resource.java:108"$0$"	 * @throws IOException if the resource cannot be resolved as URI,"
"Resource.java:109"$0$"	 * i.e. if the resource is not available as descriptor"
"Resource.java:110"$0$"	 * @since 2.5"
"Resource.java:111"$0$"	 */"
"Resource.java:112"$0$"	URI getURI() throws IOException;"
"Resource.java:113"$0$""
"Resource.java:114"$0$"	/**"
"Resource.java:115"$0$"	 * Return a File handle for this resource."
"Resource.java:116"$0$"	 * @throws java.io.FileNotFoundException if the resource cannot be resolved as"
"Resource.java:117"$0$"	 * absolute file path, i.e. if the resource is not available in a file system"
"Resource.java:118"$0$"	 * @throws IOException in case of general resolution/reading failures"
"Resource.java:119"$0$"	 * @see #getInputStream()"
"Resource.java:120"$0$"	 */"
"Resource.java:121"$0$"	File getFile() throws IOException;"
"Resource.java:122"$0$""
"Resource.java:123"$0$"	/**"
"Resource.java:124"$1$"	 * Return a {@link ReadableByteChannel}."
"Resource.java:125"$0$"	 * <p>It is expected that each call creates a <i>fresh</i> channel."
"Resource.java:126"$1$"	 * <p>The default implementation returns {@link Channels#newChannel(InputStream)}"
"Resource.java:127"$1$"	 * with the result of {@link #getInputStream()}."
"Resource.java:128"$1$"	 * @return the byte channel for the underlying resource (must not be {@code null})"
"Resource.java:129"$0$"	 * @throws java.io.FileNotFoundException if the underlying resource doesn't exist"
"Resource.java:130"$0$"	 * @throws IOException if the content channel could not be opened"
"Resource.java:131"$0$"	 * @since 5.0"
"Resource.java:132"$0$"	 * @see #getInputStream()"
"Resource.java:133"$0$"	 */"
"Resource.java:134"$1$"	default ReadableByteChannel readableChannel() throws IOException {"
"Resource.java:135"$1$"		return Channels.newChannel(getInputStream());"
"Resource.java:136"$1$"	}"
"Resource.java:137"$0$""
"Resource.java:138"$0$"	/**"
"Resource.java:139"$0$"	 * Determine the content length for this resource."
"Resource.java:140"$0$"	 * @throws IOException if the resource cannot be resolved"
"Resource.java:141"$0$"	 * (in the file system or as some other known physical resource type)"
"Resource.java:142"$0$"	 */"
"Resource.java:143"$0$"	long contentLength() throws IOException;"
"Resource.java:144"$0$""
"Resource.java:145"$0$"	/**"
"Resource.java:146"$0$"	 * Determine the last-modified timestamp for this resource."
"Resource.java:147"$0$"	 * @throws IOException if the resource cannot be resolved"
"Resource.java:148"$0$"	 * (in the file system or as some other known physical resource type)"
"Resource.java:149"$0$"	 */"
"Resource.java:150"$0$"	long lastModified() throws IOException;"
"Resource.java:151"$0$""
"Resource.java:152"$0$"	/**"
"Resource.java:153"$0$"	 * Create a resource relative to this resource."
"Resource.java:154"$0$"	 * @param relativePath the relative path (relative to this resource)"
"Resource.java:155"$0$"	 * @return the resource handle for the relative resource"
"Resource.java:156"$0$"	 * @throws IOException if the relative resource cannot be determined"
"Resource.java:157"$0$"	 */"
"Resource.java:158"$0$"	Resource createRelative(String relativePath) throws IOException;"
"Resource.java:159"$0$""
"Resource.java:160"$0$"	/**"
"Resource.java:161"$0$"	 * Determine a filename for this resource, i.e. typically the last"
"Resource.java:162"$0$"	 * part of the path: for example, ""myfile.txt""."
"Resource.java:163"$1$"	 * <p>Returns {@code null} if this type of resource does not"
"Resource.java:164"$0$"	 * have a filename."
"Resource.java:165"$0$"	 */"
"Resource.java:166"$0$"	@Nullable"
"Resource.java:167"$0$"	String getFilename();"
"Resource.java:168"$0$""
"Resource.java:169"$0$"	/**"
"Resource.java:170"$0$"	 * Return a description for this resource,"
"Resource.java:171"$0$"	 * to be used for error output when working with the resource."
"Resource.java:172"$0$"	 * <p>Implementations are also encouraged to return this value"
"Resource.java:173"$1$"	 * from their {@code toString} method."
"Resource.java:174"$0$"	 * @see Object#toString()"
"Resource.java:175"$0$"	 */"
"Resource.java:176"$0$"	String getDescription();"
"Resource.java:177"$0$""
"Resource.java:178"$0$"}"
"AnnotationUtils.java:1"$0$"/*"
"AnnotationUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"AnnotationUtils.java:3"$0$" *"
"AnnotationUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationUtils.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationUtils.java:7"$0$" *"
"AnnotationUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationUtils.java:9"$0$" *"
"AnnotationUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationUtils.java:14"$0$" * limitations under the License."
"AnnotationUtils.java:15"$0$" */"
"AnnotationUtils.java:16"$0$""
"AnnotationUtils.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationUtils.java:18"$0$""
"AnnotationUtils.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotationUtils.java:20"$0$"import java.lang.reflect.AnnotatedElement;"
"AnnotationUtils.java:21"$0$"import java.lang.reflect.Array;"
"AnnotationUtils.java:22"$0$"import java.lang.reflect.InvocationTargetException;"
"AnnotationUtils.java:23"$0$"import java.lang.reflect.Method;"
"AnnotationUtils.java:24"$0$"import java.lang.reflect.Modifier;"
"AnnotationUtils.java:25"$0$"import java.util.Collection;"
"AnnotationUtils.java:26"$0$"import java.util.Collections;"
"AnnotationUtils.java:27"$0$"import java.util.LinkedHashMap;"
"AnnotationUtils.java:28"$0$"import java.util.List;"
"AnnotationUtils.java:29"$0$"import java.util.Map;"
"AnnotationUtils.java:30"$0$"import java.util.NoSuchElementException;"
"AnnotationUtils.java:31"$0$"import java.util.Set;"
"AnnotationUtils.java:32"$0$""
"AnnotationUtils.java:33"$0$"import org.springframework.core.BridgeMethodResolver;"
"AnnotationUtils.java:34"$0$"import org.springframework.core.annotation.AnnotationTypeMapping.MirrorSets.MirrorSet;"
"AnnotationUtils.java:35"$0$"import org.springframework.core.annotation.MergedAnnotation.Adapt;"
"AnnotationUtils.java:36"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"AnnotationUtils.java:37"$0$"import org.springframework.lang.Nullable;"
"AnnotationUtils.java:38"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"AnnotationUtils.java:39"$0$"import org.springframework.util.ReflectionUtils;"
"AnnotationUtils.java:40"$0$"import org.springframework.util.StringUtils;"
"AnnotationUtils.java:41"$0$""
"AnnotationUtils.java:42"$0$"/**"
"AnnotationUtils.java:43"$0$" * General utility methods for working with annotations, handling meta-annotations,"
"AnnotationUtils.java:44"$0$" * bridge methods (which the compiler generates for generic declarations) as well"
"AnnotationUtils.java:45"$0$" * as super methods (for optional <em>annotation inheritance</em>)."
"AnnotationUtils.java:46"$0$" *"
"AnnotationUtils.java:47"$0$" * <p>Note that most of the features of this class are not provided by the"
"AnnotationUtils.java:48"$0$" * JDK's introspection facilities themselves."
"AnnotationUtils.java:49"$0$" *"
"AnnotationUtils.java:50"$0$" * <p>As a general rule for runtime-retained application annotations (e.g. for"
"AnnotationUtils.java:51"$0$" * transaction control, authorization, or service exposure), always use the"
"AnnotationUtils.java:52"$1$" * lookup methods on this class (e.g. {@link #findAnnotation(Method, Class)} or"
"AnnotationUtils.java:53"$1$" * {@link #getAnnotation(Method, Class)}) instead of the plain annotation lookup"
"AnnotationUtils.java:54"$0$" * methods in the JDK. You can still explicitly choose between a <em>get</em>"
"AnnotationUtils.java:55"$1$" * lookup on the given class level only ({@link #getAnnotation(Method, Class)})"
"AnnotationUtils.java:56"$0$" * and a <em>find</em> lookup in the entire inheritance hierarchy of the given"
"AnnotationUtils.java:57"$1$" * method ({@link #findAnnotation(Method, Class)})."
"AnnotationUtils.java:58"$0$" *"
"AnnotationUtils.java:59"$0$" * <h3>Terminology</h3>"
"AnnotationUtils.java:60"$0$" * The terms <em>directly present</em>, <em>indirectly present</em>, and"
"AnnotationUtils.java:61"$0$" * <em>present</em> have the same meanings as defined in the class-level"
"AnnotationUtils.java:62"$1$" * javadoc for {@link AnnotatedElement} (in Java 8)."
"AnnotationUtils.java:63"$0$" *"
"AnnotationUtils.java:64"$0$" * <p>An annotation is <em>meta-present</em> on an element if the annotation"
"AnnotationUtils.java:65"$0$" * is declared as a meta-annotation on some other annotation which is"
"AnnotationUtils.java:66"$1$" * <em>present</em> on the element. Annotation {@code A} is <em>meta-present</em>"
"AnnotationUtils.java:67"$1$" * on another annotation if {@code A} is either <em>directly present</em> or"
"AnnotationUtils.java:68"$0$" * <em>meta-present</em> on the other annotation."
"AnnotationUtils.java:69"$0$" *"
"AnnotationUtils.java:70"$0$" * <h3>Meta-annotation Support</h3>"
"AnnotationUtils.java:71"$1$" * <p>Most {@code find*()} methods and some {@code get*()} methods in this class"
"AnnotationUtils.java:72"$0$" * provide support for finding annotations used as meta-annotations. Consult the"
"AnnotationUtils.java:73"$0$" * javadoc for each method in this class for details. For fine-grained support for"
"AnnotationUtils.java:74"$0$" * meta-annotations with <em>attribute overrides</em> in <em>composed annotations</em>,"
"AnnotationUtils.java:75"$1$" * consider using {@link AnnotatedElementUtils}'s more specific methods instead."
"AnnotationUtils.java:76"$0$" *"
"AnnotationUtils.java:77"$0$" * <h3>Attribute Aliases</h3>"
"AnnotationUtils.java:78"$0$" * <p>All public methods in this class that return annotations, arrays of"
"AnnotationUtils.java:79"$1$" * annotations, or {@link AnnotationAttributes} transparently support attribute"
"AnnotationUtils.java:80"$1$" * aliases configured via {@link AliasFor @AliasFor}. Consult the various"
"AnnotationUtils.java:81"$1$" * {@code synthesizeAnnotation*(..)} methods for details."
"AnnotationUtils.java:82"$0$" *"
"AnnotationUtils.java:83"$0$" * <h3>Search Scope</h3>"
"AnnotationUtils.java:84"$0$" * <p>The search algorithms used by methods in this class stop searching for"
"AnnotationUtils.java:85"$0$" * an annotation once the first annotation of the specified type has been"
"AnnotationUtils.java:86"$0$" * found. As a consequence, additional annotations of the specified type will"
"AnnotationUtils.java:87"$0$" * be silently ignored."
"AnnotationUtils.java:88"$0$" *"
"AnnotationUtils.java:89"$0$" * @author Rob Harrop"
"AnnotationUtils.java:90"$0$" * @author Juergen Hoeller"
"AnnotationUtils.java:91"$0$" * @author Sam Brannen"
"AnnotationUtils.java:92"$0$" * @author Mark Fisher"
"AnnotationUtils.java:93"$0$" * @author Chris Beams"
"AnnotationUtils.java:94"$0$" * @author Phillip Webb"
"AnnotationUtils.java:95"$0$" * @author Oleg Zhurakousky"
"AnnotationUtils.java:96"$0$" * @since 2.0"
"AnnotationUtils.java:97"$0$" * @see AliasFor"
"AnnotationUtils.java:98"$0$" * @see AnnotationAttributes"
"AnnotationUtils.java:99"$0$" * @see AnnotatedElementUtils"
"AnnotationUtils.java:100"$0$" * @see BridgeMethodResolver"
"AnnotationUtils.java:101"$0$" * @see java.lang.reflect.AnnotatedElement#getAnnotations()"
"AnnotationUtils.java:102"$0$" * @see java.lang.reflect.AnnotatedElement#getAnnotation(Class)"
"AnnotationUtils.java:103"$0$" * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotations()"
"AnnotationUtils.java:104"$0$" */"
"AnnotationUtils.java:105"$1$"public abstract class AnnotationUtils {"
"AnnotationUtils.java:106"$1$""
"AnnotationUtils.java:107"$1$"	/**"
"AnnotationUtils.java:108"$1$"	 * The attribute name for annotations with a single element."
"AnnotationUtils.java:109"$1$"	 */"
"AnnotationUtils.java:110"$1$"	public static final String VALUE = MergedAnnotation.VALUE;"
"AnnotationUtils.java:111"$1$""
"AnnotationUtils.java:112"$1$"	private static final AnnotationFilter JAVA_LANG_ANNOTATION_FILTER ="
"AnnotationUtils.java:113"$1$"			AnnotationFilter.packages(""java.lang.annotation"");"
"AnnotationUtils.java:114"$1$""
"AnnotationUtils.java:115"$1$"	private static final Map<Class<? extends Annotation>, Map<String, DefaultValueHolder>> defaultValuesCache ="
"AnnotationUtils.java:116"$1$"			new ConcurrentReferenceHashMap<>();"
"AnnotationUtils.java:117"$1$""
"AnnotationUtils.java:118"$1$""
"AnnotationUtils.java:119"$1$"	/**"
"AnnotationUtils.java:120"$1$"	 * Determine whether the given class is a candidate for carrying one of the specified"
"AnnotationUtils.java:121"$1$"	 * annotations (at type, method or field level)."
"AnnotationUtils.java:122"$1$"	 * @param clazz the class to introspect"
"AnnotationUtils.java:123"$1$"	 * @param annotationTypes the searchable annotation types"
"AnnotationUtils.java:124"$1$"	 * @return {@code false} if the class is known to have no such annotations at any level;"
"AnnotationUtils.java:125"$1$"	 * {@code true} otherwise. Callers will usually perform full method/field introspection"
"AnnotationUtils.java:126"$1$"	 * if {@code true} is being returned here."
"AnnotationUtils.java:127"$1$"	 * @since 5.2"
"AnnotationUtils.java:128"$1$"	 * @see #isCandidateClass(Class, Class)"
"AnnotationUtils.java:129"$1$"	 * @see #isCandidateClass(Class, String)"
"AnnotationUtils.java:130"$1$"	 */"
"AnnotationUtils.java:131"$1$"	public static boolean isCandidateClass(Class<?> clazz, Collection<Class<? extends Annotation>> annotationTypes) {"
"AnnotationUtils.java:132"$1$"		for (Class<? extends Annotation> annotationType : annotationTypes) {"
"AnnotationUtils.java:133"$1$"			if (isCandidateClass(clazz, annotationType)) {"
"AnnotationUtils.java:134"$1$"				return true;"
"AnnotationUtils.java:135"$1$"			}"
"AnnotationUtils.java:136"$0$"		}"
"AnnotationUtils.java:137"$0$"		return false;"
"AnnotationUtils.java:138"$0$"	}"
"AnnotationUtils.java:139"$0$""
"AnnotationUtils.java:140"$0$"	/**"
"AnnotationUtils.java:141"$0$"	 * Determine whether the given class is a candidate for carrying the specified annotation"
"AnnotationUtils.java:142"$0$"	 * (at type, method or field level)."
"AnnotationUtils.java:143"$0$"	 * @param clazz the class to introspect"
"AnnotationUtils.java:144"$0$"	 * @param annotationType the searchable annotation type"
"AnnotationUtils.java:145"$1$"	 * @return {@code false} if the class is known to have no such annotations at any level;"
"AnnotationUtils.java:146"$1$"	 * {@code true} otherwise. Callers will usually perform full method/field introspection"
"AnnotationUtils.java:147"$1$"	 * if {@code true} is being returned here."
"AnnotationUtils.java:148"$0$"	 * @since 5.2"
"AnnotationUtils.java:149"$0$"	 * @see #isCandidateClass(Class, String)"
"AnnotationUtils.java:150"$0$"	 */"
"AnnotationUtils.java:151"$1$"	public static boolean isCandidateClass(Class<?> clazz, Class<? extends Annotation> annotationType) {"
"AnnotationUtils.java:152"$1$"		return isCandidateClass(clazz, annotationType.getName());"
"AnnotationUtils.java:153"$1$"	}"
"AnnotationUtils.java:154"$0$""
"AnnotationUtils.java:155"$0$"	/**"
"AnnotationUtils.java:156"$0$"	 * Determine whether the given class is a candidate for carrying the specified annotation"
"AnnotationUtils.java:157"$0$"	 * (at type, method or field level)."
"AnnotationUtils.java:158"$0$"	 * @param clazz the class to introspect"
"AnnotationUtils.java:159"$0$"	 * @param annotationName the fully-qualified name of the searchable annotation type"
"AnnotationUtils.java:160"$1$"	 * @return {@code false} if the class is known to have no such annotations at any level;"
"AnnotationUtils.java:161"$1$"	 * {@code true} otherwise. Callers will usually perform full method/field introspection"
"AnnotationUtils.java:162"$1$"	 * if {@code true} is being returned here."
"AnnotationUtils.java:163"$0$"	 * @since 5.2"
"AnnotationUtils.java:164"$0$"	 * @see #isCandidateClass(Class, Class)"
"AnnotationUtils.java:165"$0$"	 */"
"AnnotationUtils.java:166"$1$"	public static boolean isCandidateClass(Class<?> clazz, String annotationName) {"
"AnnotationUtils.java:167"$1$"		if (annotationName.startsWith(""java."")) {"
"AnnotationUtils.java:168"$1$"			return true;"
"AnnotationUtils.java:169"$1$"		}"
"AnnotationUtils.java:170"$1$"		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {"
"AnnotationUtils.java:171"$1$"			return false;"
"AnnotationUtils.java:172"$1$"		}"
"AnnotationUtils.java:173"$0$"		return true;"
"AnnotationUtils.java:174"$0$"	}"
"AnnotationUtils.java:175"$0$""
"AnnotationUtils.java:176"$0$"	/**"
"AnnotationUtils.java:177"$1$"	 * Get a single {@link Annotation} of {@code annotationType} from the supplied"
"AnnotationUtils.java:178"$0$"	 * annotation: either the given annotation itself or a direct meta-annotation"
"AnnotationUtils.java:179"$0$"	 * thereof."
"AnnotationUtils.java:180"$0$"	 * <p>Note that this method supports only a single level of meta-annotations."
"AnnotationUtils.java:181"$0$"	 * For support for arbitrary levels of meta-annotations, use one of the"
"AnnotationUtils.java:182"$1$"	 * {@code find*()} methods instead."
"AnnotationUtils.java:183"$0$"	 * @param annotation the Annotation to check"
"AnnotationUtils.java:184"$0$"	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation"
"AnnotationUtils.java:185"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:186"$0$"	 * @since 4.0"
"AnnotationUtils.java:187"$0$"	 */"
"AnnotationUtils.java:188"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationUtils.java:189"$0$"	@Nullable"
"AnnotationUtils.java:190"$1$"	public static <A extends Annotation> A getAnnotation(Annotation annotation, Class<A> annotationType) {"
"AnnotationUtils.java:191"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:192"$1$"		if (annotationType.isInstance(annotation)) {"
"AnnotationUtils.java:193"$1$"			return synthesizeAnnotation((A) annotation, annotationType);"
"AnnotationUtils.java:194"$1$"		}"
"AnnotationUtils.java:195"$0$"		// Shortcut: no searchable annotations to be found on plain Java classes and core Spring types..."
"AnnotationUtils.java:196"$1$"		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotation)) {"
"AnnotationUtils.java:197"$1$"			return null;"
"AnnotationUtils.java:198"$1$"		}"
"AnnotationUtils.java:199"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:200"$1$"		return MergedAnnotations.from(annotation, new Annotation[] {annotation}, RepeatableContainers.none())"
"AnnotationUtils.java:201"$0$"				.get(annotationType).withNonMergedAttributes()"
"AnnotationUtils.java:202"$0$"				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);"
"AnnotationUtils.java:203"$0$"	}"
"AnnotationUtils.java:204"$0$""
"AnnotationUtils.java:205"$0$"	/**"
"AnnotationUtils.java:206"$1$"	 * Get a single {@link Annotation} of {@code annotationType} from the supplied"
"AnnotationUtils.java:207"$1$"	 * {@link AnnotatedElement}, where the annotation is either <em>present</em> or"
"AnnotationUtils.java:208"$1$"	 * <em>meta-present</em> on the {@code AnnotatedElement}."
"AnnotationUtils.java:209"$0$"	 * <p>Note that this method supports only a single level of meta-annotations."
"AnnotationUtils.java:210"$0$"	 * For support for arbitrary levels of meta-annotations, use"
"AnnotationUtils.java:211"$1$"	 * {@link #findAnnotation(AnnotatedElement, Class)} instead."
"AnnotationUtils.java:212"$1$"	 * @param annotatedElement the {@code AnnotatedElement} from which to get the annotation"
"AnnotationUtils.java:213"$0$"	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation"
"AnnotationUtils.java:214"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:215"$0$"	 * @since 3.1"
"AnnotationUtils.java:216"$0$"	 */"
"AnnotationUtils.java:217"$0$"	@Nullable"
"AnnotationUtils.java:218"$1$"	public static <A extends Annotation> A getAnnotation(AnnotatedElement annotatedElement, Class<A> annotationType) {"
"AnnotationUtils.java:219"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:220"$1$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotationUtils.java:221"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {"
"AnnotationUtils.java:222"$1$"			return annotatedElement.getAnnotation(annotationType);"
"AnnotationUtils.java:223"$1$"		}"
"AnnotationUtils.java:224"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:225"$0$"		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())"
"AnnotationUtils.java:226"$0$"				.get(annotationType).withNonMergedAttributes()"
"AnnotationUtils.java:227"$0$"				.synthesize(AnnotationUtils::isSingleLevelPresent).orElse(null);"
"AnnotationUtils.java:228"$0$"	}"
"AnnotationUtils.java:229"$0$""
"AnnotationUtils.java:230"$1$"	private static <A extends Annotation> boolean isSingleLevelPresent(MergedAnnotation<A> mergedAnnotation) {"
"AnnotationUtils.java:231"$1$"		int distance = mergedAnnotation.getDistance();"
"AnnotationUtils.java:232"$1$"		return (distance == 0 || distance == 1);"
"AnnotationUtils.java:233"$1$"	}"
"AnnotationUtils.java:234"$0$""
"AnnotationUtils.java:235"$0$"	/**"
"AnnotationUtils.java:236"$1$"	 * Get a single {@link Annotation} of {@code annotationType} from the"
"AnnotationUtils.java:237"$1$"	 * supplied {@link Method}, where the annotation is either <em>present</em>"
"AnnotationUtils.java:238"$0$"	 * or <em>meta-present</em> on the method."
"AnnotationUtils.java:239"$1$"	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler."
"AnnotationUtils.java:240"$0$"	 * <p>Note that this method supports only a single level of meta-annotations."
"AnnotationUtils.java:241"$0$"	 * For support for arbitrary levels of meta-annotations, use"
"AnnotationUtils.java:242"$1$"	 * {@link #findAnnotation(Method, Class)} instead."
"AnnotationUtils.java:243"$0$"	 * @param method the method to look for annotations on"
"AnnotationUtils.java:244"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:245"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:246"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)"
"AnnotationUtils.java:247"$0$"	 * @see #getAnnotation(AnnotatedElement, Class)"
"AnnotationUtils.java:248"$0$"	 */"
"AnnotationUtils.java:249"$0$"	@Nullable"
"AnnotationUtils.java:250"$1$"	public static <A extends Annotation> A getAnnotation(Method method, Class<A> annotationType) {"
"AnnotationUtils.java:251"$1$"		Method resolvedMethod = BridgeMethodResolver.findBridgedMethod(method);"
"AnnotationUtils.java:252"$1$"		return getAnnotation((AnnotatedElement) resolvedMethod, annotationType);"
"AnnotationUtils.java:253"$1$"	}"
"AnnotationUtils.java:254"$0$""
"AnnotationUtils.java:255"$0$"	/**"
"AnnotationUtils.java:256"$1$"	 * Get all {@link Annotation Annotations} that are <em>present</em> on the"
"AnnotationUtils.java:257"$1$"	 * supplied {@link AnnotatedElement}."
"AnnotationUtils.java:258"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:259"$0$"	 * @param annotatedElement the Method, Constructor or Field to retrieve annotations from"
"AnnotationUtils.java:260"$1$"	 * @return the annotations found, an empty array, or {@code null} if not"
"AnnotationUtils.java:261"$0$"	 * resolvable (e.g. because nested Class values in annotation attributes"
"AnnotationUtils.java:262"$0$"	 * failed to resolve at runtime)"
"AnnotationUtils.java:263"$0$"	 * @since 4.0.8"
"AnnotationUtils.java:264"$0$"	 * @see AnnotatedElement#getAnnotations()"
"AnnotationUtils.java:265"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:266"$0$"	 */"
"AnnotationUtils.java:267"$0$"	@Deprecated"
"AnnotationUtils.java:268"$0$"	@Nullable"
"AnnotationUtils.java:269"$1$"	public static Annotation[] getAnnotations(AnnotatedElement annotatedElement) {"
"AnnotationUtils.java:270"$1$"		try {"
"AnnotationUtils.java:271"$1$"			return synthesizeAnnotationArray(annotatedElement.getAnnotations(), annotatedElement);"
"AnnotationUtils.java:272"$1$"		}"
"AnnotationUtils.java:273"$1$"		catch (Throwable ex) {"
"AnnotationUtils.java:274"$1$"			handleIntrospectionFailure(annotatedElement, ex);"
"AnnotationUtils.java:275"$1$"			return null;"
"AnnotationUtils.java:276"$1$"		}"
"AnnotationUtils.java:277"$0$"	}"
"AnnotationUtils.java:278"$0$""
"AnnotationUtils.java:279"$0$"	/**"
"AnnotationUtils.java:280"$1$"	 * Get all {@link Annotation Annotations} that are <em>present</em> on the"
"AnnotationUtils.java:281"$1$"	 * supplied {@link Method}."
"AnnotationUtils.java:282"$1$"	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler."
"AnnotationUtils.java:283"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:284"$0$"	 * @param method the Method to retrieve annotations from"
"AnnotationUtils.java:285"$1$"	 * @return the annotations found, an empty array, or {@code null} if not"
"AnnotationUtils.java:286"$0$"	 * resolvable (e.g. because nested Class values in annotation attributes"
"AnnotationUtils.java:287"$0$"	 * failed to resolve at runtime)"
"AnnotationUtils.java:288"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod(Method)"
"AnnotationUtils.java:289"$0$"	 * @see AnnotatedElement#getAnnotations()"
"AnnotationUtils.java:290"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:291"$0$"	 */"
"AnnotationUtils.java:292"$0$"	@Deprecated"
"AnnotationUtils.java:293"$0$"	@Nullable"
"AnnotationUtils.java:294"$1$"	public static Annotation[] getAnnotations(Method method) {"
"AnnotationUtils.java:295"$1$"		try {"
"AnnotationUtils.java:296"$1$"			return synthesizeAnnotationArray(BridgeMethodResolver.findBridgedMethod(method).getAnnotations(), method);"
"AnnotationUtils.java:297"$1$"		}"
"AnnotationUtils.java:298"$1$"		catch (Throwable ex) {"
"AnnotationUtils.java:299"$1$"			handleIntrospectionFailure(method, ex);"
"AnnotationUtils.java:300"$1$"			return null;"
"AnnotationUtils.java:301"$1$"		}"
"AnnotationUtils.java:302"$0$"	}"
"AnnotationUtils.java:303"$0$""
"AnnotationUtils.java:304"$0$"	/**"
"AnnotationUtils.java:305"$1$"	 * Get the <em>repeatable</em> {@linkplain Annotation annotations} of"
"AnnotationUtils.java:306"$1$"	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where"
"AnnotationUtils.java:307"$0$"	 * such annotations are either <em>present</em>, <em>indirectly present</em>,"
"AnnotationUtils.java:308"$0$"	 * or <em>meta-present</em> on the element."
"AnnotationUtils.java:309"$0$"	 * <p>This method mimics the functionality of Java 8's"
"AnnotationUtils.java:310"$1$"	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}"
"AnnotationUtils.java:311"$0$"	 * with support for automatic detection of a <em>container annotation</em>"
"AnnotationUtils.java:312"$1$"	 * declared via @{@link java.lang.annotation.Repeatable} (when running on"
"AnnotationUtils.java:313"$0$"	 * Java 8 or higher) and with additional support for meta-annotations."
"AnnotationUtils.java:314"$0$"	 * <p>Handles both single annotations and annotations nested within a"
"AnnotationUtils.java:315"$0$"	 * <em>container annotation</em>."
"AnnotationUtils.java:316"$0$"	 * <p>Correctly handles <em>bridge methods</em> generated by the"
"AnnotationUtils.java:317"$1$"	 * compiler if the supplied element is a {@link Method}."
"AnnotationUtils.java:318"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:319"$0$"	 * <em>present</em> on the supplied element."
"AnnotationUtils.java:320"$0$"	 * @param annotatedElement the element to look for annotations on"
"AnnotationUtils.java:321"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:322"$1$"	 * @return the annotations found or an empty set (never {@code null})"
"AnnotationUtils.java:323"$0$"	 * @since 4.2"
"AnnotationUtils.java:324"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:325"$0$"	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:326"$0$"	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:327"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod"
"AnnotationUtils.java:328"$0$"	 * @see java.lang.annotation.Repeatable"
"AnnotationUtils.java:329"$0$"	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType"
"AnnotationUtils.java:330"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:331"$0$"	 */"
"AnnotationUtils.java:332"$0$"	@Deprecated"
"AnnotationUtils.java:333"$0$"	public static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,"
"AnnotationUtils.java:334"$1$"			Class<A> annotationType) {"
"AnnotationUtils.java:335"$1$""
"AnnotationUtils.java:336"$1$"		return getRepeatableAnnotations(annotatedElement, annotationType, null);"
"AnnotationUtils.java:337"$1$"	}"
"AnnotationUtils.java:338"$0$""
"AnnotationUtils.java:339"$0$"	/**"
"AnnotationUtils.java:340"$1$"	 * Get the <em>repeatable</em> {@linkplain Annotation annotations} of"
"AnnotationUtils.java:341"$1$"	 * {@code annotationType} from the supplied {@link AnnotatedElement}, where"
"AnnotationUtils.java:342"$0$"	 * such annotations are either <em>present</em>, <em>indirectly present</em>,"
"AnnotationUtils.java:343"$0$"	 * or <em>meta-present</em> on the element."
"AnnotationUtils.java:344"$0$"	 * <p>This method mimics the functionality of Java 8's"
"AnnotationUtils.java:345"$1$"	 * {@link java.lang.reflect.AnnotatedElement#getAnnotationsByType(Class)}"
"AnnotationUtils.java:346"$0$"	 * with additional support for meta-annotations."
"AnnotationUtils.java:347"$0$"	 * <p>Handles both single annotations and annotations nested within a"
"AnnotationUtils.java:348"$0$"	 * <em>container annotation</em>."
"AnnotationUtils.java:349"$0$"	 * <p>Correctly handles <em>bridge methods</em> generated by the"
"AnnotationUtils.java:350"$1$"	 * compiler if the supplied element is a {@link Method}."
"AnnotationUtils.java:351"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:352"$0$"	 * <em>present</em> on the supplied element."
"AnnotationUtils.java:353"$0$"	 * @param annotatedElement the element to look for annotations on"
"AnnotationUtils.java:354"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:355"$0$"	 * @param containerAnnotationType the type of the container that holds"
"AnnotationUtils.java:356"$1$"	 * the annotations; may be {@code null} if a container is not supported"
"AnnotationUtils.java:357"$1$"	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}"
"AnnotationUtils.java:358"$0$"	 * when running on Java 8 or higher"
"AnnotationUtils.java:359"$1$"	 * @return the annotations found or an empty set (never {@code null})"
"AnnotationUtils.java:360"$0$"	 * @since 4.2"
"AnnotationUtils.java:361"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:362"$0$"	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:363"$0$"	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:364"$0$"	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:365"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod"
"AnnotationUtils.java:366"$0$"	 * @see java.lang.annotation.Repeatable"
"AnnotationUtils.java:367"$0$"	 * @see java.lang.reflect.AnnotatedElement#getAnnotationsByType"
"AnnotationUtils.java:368"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:369"$0$"	 */"
"AnnotationUtils.java:370"$0$"	@Deprecated"
"AnnotationUtils.java:371"$0$"	public static <A extends Annotation> Set<A> getRepeatableAnnotations(AnnotatedElement annotatedElement,"
"AnnotationUtils.java:372"$1$"			Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {"
"AnnotationUtils.java:373"$1$""
"AnnotationUtils.java:374"$1$"		RepeatableContainers repeatableContainers = (containerAnnotationType != null ?"
"AnnotationUtils.java:375"$1$"				RepeatableContainers.of(annotationType, containerAnnotationType) :"
"AnnotationUtils.java:376"$1$"				RepeatableContainers.standardRepeatables());"
"AnnotationUtils.java:377"$1$""
"AnnotationUtils.java:378"$1$"		return MergedAnnotations.from(annotatedElement, SearchStrategy.SUPERCLASS, repeatableContainers)"
"AnnotationUtils.java:379"$1$"				.stream(annotationType)"
"AnnotationUtils.java:380"$1$"				.filter(MergedAnnotationPredicates.firstRunOf(MergedAnnotation::getAggregateIndex))"
"AnnotationUtils.java:381"$1$"				.map(MergedAnnotation::withNonMergedAttributes)"
"AnnotationUtils.java:382"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotationUtils.java:383"$1$"	}"
"AnnotationUtils.java:384"$0$""
"AnnotationUtils.java:385"$0$"	/**"
"AnnotationUtils.java:386"$1$"	 * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}"
"AnnotationUtils.java:387"$1$"	 * of {@code annotationType} from the supplied {@link AnnotatedElement},"
"AnnotationUtils.java:388"$0$"	 * where such annotations are either <em>directly present</em>,"
"AnnotationUtils.java:389"$0$"	 * <em>indirectly present</em>, or <em>meta-present</em> on the element."
"AnnotationUtils.java:390"$0$"	 * <p>This method mimics the functionality of Java 8's"
"AnnotationUtils.java:391"$1$"	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}"
"AnnotationUtils.java:392"$0$"	 * with support for automatic detection of a <em>container annotation</em>"
"AnnotationUtils.java:393"$1$"	 * declared via @{@link java.lang.annotation.Repeatable} (when running on"
"AnnotationUtils.java:394"$0$"	 * Java 8 or higher) and with additional support for meta-annotations."
"AnnotationUtils.java:395"$0$"	 * <p>Handles both single annotations and annotations nested within a"
"AnnotationUtils.java:396"$0$"	 * <em>container annotation</em>."
"AnnotationUtils.java:397"$0$"	 * <p>Correctly handles <em>bridge methods</em> generated by the"
"AnnotationUtils.java:398"$1$"	 * compiler if the supplied element is a {@link Method}."
"AnnotationUtils.java:399"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:400"$0$"	 * <em>present</em> on the supplied element."
"AnnotationUtils.java:401"$0$"	 * @param annotatedElement the element to look for annotations on"
"AnnotationUtils.java:402"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:403"$1$"	 * @return the annotations found or an empty set (never {@code null})"
"AnnotationUtils.java:404"$0$"	 * @since 4.2"
"AnnotationUtils.java:405"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:406"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:407"$0$"	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:408"$0$"	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:409"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod"
"AnnotationUtils.java:410"$0$"	 * @see java.lang.annotation.Repeatable"
"AnnotationUtils.java:411"$0$"	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType"
"AnnotationUtils.java:412"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:413"$0$"	 */"
"AnnotationUtils.java:414"$0$"	@Deprecated"
"AnnotationUtils.java:415"$0$"	public static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,"
"AnnotationUtils.java:416"$1$"			Class<A> annotationType) {"
"AnnotationUtils.java:417"$1$""
"AnnotationUtils.java:418"$1$"		return getDeclaredRepeatableAnnotations(annotatedElement, annotationType, null);"
"AnnotationUtils.java:419"$1$"	}"
"AnnotationUtils.java:420"$0$""
"AnnotationUtils.java:421"$0$"	/**"
"AnnotationUtils.java:422"$1$"	 * Get the declared <em>repeatable</em> {@linkplain Annotation annotations}"
"AnnotationUtils.java:423"$1$"	 * of {@code annotationType} from the supplied {@link AnnotatedElement},"
"AnnotationUtils.java:424"$0$"	 * where such annotations are either <em>directly present</em>,"
"AnnotationUtils.java:425"$0$"	 * <em>indirectly present</em>, or <em>meta-present</em> on the element."
"AnnotationUtils.java:426"$0$"	 * <p>This method mimics the functionality of Java 8's"
"AnnotationUtils.java:427"$1$"	 * {@link java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType(Class)}"
"AnnotationUtils.java:428"$0$"	 * with additional support for meta-annotations."
"AnnotationUtils.java:429"$0$"	 * <p>Handles both single annotations and annotations nested within a"
"AnnotationUtils.java:430"$0$"	 * <em>container annotation</em>."
"AnnotationUtils.java:431"$0$"	 * <p>Correctly handles <em>bridge methods</em> generated by the"
"AnnotationUtils.java:432"$1$"	 * compiler if the supplied element is a {@link Method}."
"AnnotationUtils.java:433"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:434"$0$"	 * <em>present</em> on the supplied element."
"AnnotationUtils.java:435"$0$"	 * @param annotatedElement the element to look for annotations on"
"AnnotationUtils.java:436"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:437"$0$"	 * @param containerAnnotationType the type of the container that holds"
"AnnotationUtils.java:438"$1$"	 * the annotations; may be {@code null} if a container is not supported"
"AnnotationUtils.java:439"$1$"	 * or if it should be looked up via @{@link java.lang.annotation.Repeatable}"
"AnnotationUtils.java:440"$0$"	 * when running on Java 8 or higher"
"AnnotationUtils.java:441"$1$"	 * @return the annotations found or an empty set (never {@code null})"
"AnnotationUtils.java:442"$0$"	 * @since 4.2"
"AnnotationUtils.java:443"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:444"$0$"	 * @see #getRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:445"$0$"	 * @see #getDeclaredRepeatableAnnotations(AnnotatedElement, Class)"
"AnnotationUtils.java:446"$0$"	 * @see AnnotatedElementUtils#getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotationUtils.java:447"$0$"	 * @see org.springframework.core.BridgeMethodResolver#findBridgedMethod"
"AnnotationUtils.java:448"$0$"	 * @see java.lang.annotation.Repeatable"
"AnnotationUtils.java:449"$0$"	 * @see java.lang.reflect.AnnotatedElement#getDeclaredAnnotationsByType"
"AnnotationUtils.java:450"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:451"$0$"	 */"
"AnnotationUtils.java:452"$0$"	@Deprecated"
"AnnotationUtils.java:453"$0$"	public static <A extends Annotation> Set<A> getDeclaredRepeatableAnnotations(AnnotatedElement annotatedElement,"
"AnnotationUtils.java:454"$1$"			Class<A> annotationType, @Nullable Class<? extends Annotation> containerAnnotationType) {"
"AnnotationUtils.java:455"$1$""
"AnnotationUtils.java:456"$1$"		RepeatableContainers repeatableContainers = containerAnnotationType != null ?"
"AnnotationUtils.java:457"$1$"				RepeatableContainers.of(annotationType, containerAnnotationType) :"
"AnnotationUtils.java:458"$1$"				RepeatableContainers.standardRepeatables();"
"AnnotationUtils.java:459"$1$""
"AnnotationUtils.java:460"$1$"		return MergedAnnotations.from(annotatedElement, SearchStrategy.DIRECT, repeatableContainers)"
"AnnotationUtils.java:461"$1$"				.stream(annotationType)"
"AnnotationUtils.java:462"$1$"				.map(MergedAnnotation::withNonMergedAttributes)"
"AnnotationUtils.java:463"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotationUtils.java:464"$1$"	}"
"AnnotationUtils.java:465"$0$""
"AnnotationUtils.java:466"$0$"	/**"
"AnnotationUtils.java:467"$1$"	 * Find a single {@link Annotation} of {@code annotationType} on the"
"AnnotationUtils.java:468"$1$"	 * supplied {@link AnnotatedElement}."
"AnnotationUtils.java:469"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:470"$0$"	 * <em>directly present</em> on the supplied element."
"AnnotationUtils.java:471"$0$"	 * <p><strong>Warning</strong>: this method operates generically on"
"AnnotationUtils.java:472"$0$"	 * annotated elements. In other words, this method does not execute"
"AnnotationUtils.java:473"$0$"	 * specialized search algorithms for classes or methods. If you require"
"AnnotationUtils.java:474"$1$"	 * the more specific semantics of {@link #findAnnotation(Class, Class)}"
"AnnotationUtils.java:475"$1$"	 * or {@link #findAnnotation(Method, Class)}, invoke one of those methods"
"AnnotationUtils.java:476"$0$"	 * instead."
"AnnotationUtils.java:477"$1$"	 * @param annotatedElement the {@code AnnotatedElement} on which to find the annotation"
"AnnotationUtils.java:478"$0$"	 * @param annotationType the annotation type to look for, both locally and as a meta-annotation"
"AnnotationUtils.java:479"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:480"$0$"	 * @since 4.2"
"AnnotationUtils.java:481"$0$"	 */"
"AnnotationUtils.java:482"$0$"	@Nullable"
"AnnotationUtils.java:483"$0$"	public static <A extends Annotation> A findAnnotation("
"AnnotationUtils.java:484"$1$"			AnnotatedElement annotatedElement, @Nullable Class<A> annotationType) {"
"AnnotationUtils.java:485"$1$""
"AnnotationUtils.java:486"$1$"		if (annotationType == null) {"
"AnnotationUtils.java:487"$1$"			return null;"
"AnnotationUtils.java:488"$1$"		}"
"AnnotationUtils.java:489"$0$""
"AnnotationUtils.java:490"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:491"$0$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotationUtils.java:492"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {"
"AnnotationUtils.java:493"$1$"			return annotatedElement.getDeclaredAnnotation(annotationType);"
"AnnotationUtils.java:494"$1$"		}"
"AnnotationUtils.java:495"$0$""
"AnnotationUtils.java:496"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:497"$0$"		return MergedAnnotations.from(annotatedElement, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none())"
"AnnotationUtils.java:498"$0$"				.get(annotationType).withNonMergedAttributes()"
"AnnotationUtils.java:499"$0$"				.synthesize(MergedAnnotation::isPresent).orElse(null);"
"AnnotationUtils.java:500"$0$"	}"
"AnnotationUtils.java:501"$0$""
"AnnotationUtils.java:502"$0$"	/**"
"AnnotationUtils.java:503"$1$"	 * Find a single {@link Annotation} of {@code annotationType} on the supplied"
"AnnotationUtils.java:504"$1$"	 * {@link Method}, traversing its super methods (i.e. from superclasses and"
"AnnotationUtils.java:505"$0$"	 * interfaces) if the annotation is not <em>directly present</em> on the given"
"AnnotationUtils.java:506"$0$"	 * method itself."
"AnnotationUtils.java:507"$1$"	 * <p>Correctly handles bridge {@link Method Methods} generated by the compiler."
"AnnotationUtils.java:508"$0$"	 * <p>Meta-annotations will be searched if the annotation is not"
"AnnotationUtils.java:509"$0$"	 * <em>directly present</em> on the method."
"AnnotationUtils.java:510"$0$"	 * <p>Annotations on methods are not inherited by default, so we need to handle"
"AnnotationUtils.java:511"$0$"	 * this explicitly."
"AnnotationUtils.java:512"$0$"	 * @param method the method to look for annotations on"
"AnnotationUtils.java:513"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:514"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:515"$0$"	 * @see #getAnnotation(Method, Class)"
"AnnotationUtils.java:516"$0$"	 */"
"AnnotationUtils.java:517"$0$"	@Nullable"
"AnnotationUtils.java:518"$1$"	public static <A extends Annotation> A findAnnotation(Method method, @Nullable Class<A> annotationType) {"
"AnnotationUtils.java:519"$1$"		if (annotationType == null) {"
"AnnotationUtils.java:520"$1$"			return null;"
"AnnotationUtils.java:521"$1$"		}"
"AnnotationUtils.java:522"$0$""
"AnnotationUtils.java:523"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:524"$0$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotationUtils.java:525"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(method)) {"
"AnnotationUtils.java:526"$1$"			return method.getDeclaredAnnotation(annotationType);"
"AnnotationUtils.java:527"$1$"		}"
"AnnotationUtils.java:528"$0$""
"AnnotationUtils.java:529"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:530"$0$"		return MergedAnnotations.from(method, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())"
"AnnotationUtils.java:531"$0$"				.get(annotationType).withNonMergedAttributes()"
"AnnotationUtils.java:532"$0$"				.synthesize(MergedAnnotation::isPresent).orElse(null);"
"AnnotationUtils.java:533"$0$"	}"
"AnnotationUtils.java:534"$0$""
"AnnotationUtils.java:535"$0$"	/**"
"AnnotationUtils.java:536"$1$"	 * Find a single {@link Annotation} of {@code annotationType} on the"
"AnnotationUtils.java:537"$1$"	 * supplied {@link Class}, traversing its interfaces, annotations, and"
"AnnotationUtils.java:538"$0$"	 * superclasses if the annotation is not <em>directly present</em> on"
"AnnotationUtils.java:539"$0$"	 * the given class itself."
"AnnotationUtils.java:540"$0$"	 * <p>This method explicitly handles class-level annotations which are not"
"AnnotationUtils.java:541"$1$"	 * declared as {@link java.lang.annotation.Inherited inherited} <em>as well"
"AnnotationUtils.java:542"$0$"	 * as meta-annotations and annotations on interfaces</em>."
"AnnotationUtils.java:543"$0$"	 * <p>The algorithm operates as follows:"
"AnnotationUtils.java:544"$0$"	 * <ol>"
"AnnotationUtils.java:545"$0$"	 * <li>Search for the annotation on the given class and return it if found."
"AnnotationUtils.java:546"$0$"	 * <li>Recursively search through all annotations that the given class declares."
"AnnotationUtils.java:547"$0$"	 * <li>Recursively search through all interfaces that the given class declares."
"AnnotationUtils.java:548"$0$"	 * <li>Recursively search through the superclass hierarchy of the given class."
"AnnotationUtils.java:549"$0$"	 * </ol>"
"AnnotationUtils.java:550"$0$"	 * <p>Note: in this context, the term <em>recursively</em> means that the search"
"AnnotationUtils.java:551"$0$"	 * process continues by returning to step #1 with the current interface,"
"AnnotationUtils.java:552"$0$"	 * annotation, or superclass as the class to look for annotations on."
"AnnotationUtils.java:553"$0$"	 * @param clazz the class to look for annotations on"
"AnnotationUtils.java:554"$0$"	 * @param annotationType the type of annotation to look for"
"AnnotationUtils.java:555"$1$"	 * @return the first matching annotation, or {@code null} if not found"
"AnnotationUtils.java:556"$0$"	 */"
"AnnotationUtils.java:557"$0$"	@Nullable"
"AnnotationUtils.java:558"$1$"	public static <A extends Annotation> A findAnnotation(Class<?> clazz, @Nullable Class<A> annotationType) {"
"AnnotationUtils.java:559"$1$"		if (annotationType == null) {"
"AnnotationUtils.java:560"$1$"			return null;"
"AnnotationUtils.java:561"$1$"		}"
"AnnotationUtils.java:562"$0$""
"AnnotationUtils.java:563"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:564"$0$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotationUtils.java:565"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(clazz)) {"
"AnnotationUtils.java:566"$1$"			A annotation = clazz.getDeclaredAnnotation(annotationType);"
"AnnotationUtils.java:567"$1$"			if (annotation != null) {"
"AnnotationUtils.java:568"$1$"				return annotation;"
"AnnotationUtils.java:569"$1$"			}"
"AnnotationUtils.java:570"$0$"			// For backwards compatibility, perform a superclass search with plain annotations"
"AnnotationUtils.java:571"$0$"			// even if not marked as @Inherited: e.g. a findAnnotation search for @Deprecated"
"AnnotationUtils.java:572"$0$"			Class<?> superclass = clazz.getSuperclass();"
"AnnotationUtils.java:573"$1$"			if (superclass == null || superclass == Object.class) {"
"AnnotationUtils.java:574"$1$"				return null;"
"AnnotationUtils.java:575"$1$"			}"
"AnnotationUtils.java:576"$0$"			return findAnnotation(superclass, annotationType);"
"AnnotationUtils.java:577"$0$"		}"
"AnnotationUtils.java:578"$0$""
"AnnotationUtils.java:579"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:580"$0$"		return MergedAnnotations.from(clazz, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none())"
"AnnotationUtils.java:581"$0$"				.get(annotationType).withNonMergedAttributes()"
"AnnotationUtils.java:582"$0$"				.synthesize(MergedAnnotation::isPresent).orElse(null);"
"AnnotationUtils.java:583"$0$"	}"
"AnnotationUtils.java:584"$0$""
"AnnotationUtils.java:585"$0$"	/**"
"AnnotationUtils.java:586"$1$"	 * Find the first {@link Class} in the inheritance hierarchy of the"
"AnnotationUtils.java:587"$1$"	 * specified {@code clazz} (including the specified {@code clazz} itself)"
"AnnotationUtils.java:588"$1$"	 * on which an annotation of the specified {@code annotationType} is"
"AnnotationUtils.java:589"$0$"	 * <em>directly present</em>."
"AnnotationUtils.java:590"$1$"	 * <p>If the supplied {@code clazz} is an interface, only the interface"
"AnnotationUtils.java:591"$0$"	 * itself will be checked; the inheritance hierarchy for interfaces will"
"AnnotationUtils.java:592"$0$"	 * not be traversed."
"AnnotationUtils.java:593"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:594"$1$"	 * <p>The standard {@link Class} API does not provide a mechanism for"
"AnnotationUtils.java:595"$0$"	 * determining which class in an inheritance hierarchy actually declares"
"AnnotationUtils.java:596"$1$"	 * an {@link Annotation}, so we need to handle this explicitly."
"AnnotationUtils.java:597"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:598"$1$"	 * @param clazz the class to check for the annotation on (may be {@code null})"
"AnnotationUtils.java:599"$1$"	 * @return the first {@link Class} in the inheritance hierarchy that"
"AnnotationUtils.java:600"$1$"	 * declares an annotation of the specified {@code annotationType},"
"AnnotationUtils.java:601"$1$"	 * or {@code null} if not found"
"AnnotationUtils.java:602"$0$"	 * @see Class#isAnnotationPresent(Class)"
"AnnotationUtils.java:603"$0$"	 * @see Class#getDeclaredAnnotations()"
"AnnotationUtils.java:604"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:605"$0$"	 */"
"AnnotationUtils.java:606"$0$"	@Deprecated"
"AnnotationUtils.java:607"$0$"	@Nullable"
"AnnotationUtils.java:608"$0$"	public static Class<?> findAnnotationDeclaringClass("
"AnnotationUtils.java:609"$1$"			Class<? extends Annotation> annotationType, @Nullable Class<?> clazz) {"
"AnnotationUtils.java:610"$1$""
"AnnotationUtils.java:611"$1$"		if (clazz == null) {"
"AnnotationUtils.java:612"$1$"			return null;"
"AnnotationUtils.java:613"$1$"		}"
"AnnotationUtils.java:614"$0$""
"AnnotationUtils.java:615"$0$"		return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS)"
"AnnotationUtils.java:616"$0$"				.get(annotationType, MergedAnnotation::isDirectlyPresent)"
"AnnotationUtils.java:617"$0$"				.getSource();"
"AnnotationUtils.java:618"$0$"	}"
"AnnotationUtils.java:619"$0$""
"AnnotationUtils.java:620"$0$"	/**"
"AnnotationUtils.java:621"$1$"	 * Find the first {@link Class} in the inheritance hierarchy of the"
"AnnotationUtils.java:622"$1$"	 * specified {@code clazz} (including the specified {@code clazz} itself)"
"AnnotationUtils.java:623"$1$"	 * on which at least one of the specified {@code annotationTypes} is"
"AnnotationUtils.java:624"$0$"	 * <em>directly present</em>."
"AnnotationUtils.java:625"$1$"	 * <p>If the supplied {@code clazz} is an interface, only the interface"
"AnnotationUtils.java:626"$0$"	 * itself will be checked; the inheritance hierarchy for interfaces will"
"AnnotationUtils.java:627"$0$"	 * not be traversed."
"AnnotationUtils.java:628"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:629"$1$"	 * <p>The standard {@link Class} API does not provide a mechanism for"
"AnnotationUtils.java:630"$0$"	 * determining which class in an inheritance hierarchy actually declares"
"AnnotationUtils.java:631"$1$"	 * one of several candidate {@linkplain Annotation annotations}, so we"
"AnnotationUtils.java:632"$0$"	 * need to handle this explicitly."
"AnnotationUtils.java:633"$0$"	 * @param annotationTypes the annotation types to look for"
"AnnotationUtils.java:634"$1$"	 * @param clazz the class to check for the annotation on (may be {@code null})"
"AnnotationUtils.java:635"$1$"	 * @return the first {@link Class} in the inheritance hierarchy that"
"AnnotationUtils.java:636"$0$"	 * declares an annotation of at least one of the specified"
"AnnotationUtils.java:637"$1$"	 * {@code annotationTypes}, or {@code null} if not found"
"AnnotationUtils.java:638"$0$"	 * @since 3.2.2"
"AnnotationUtils.java:639"$0$"	 * @see Class#isAnnotationPresent(Class)"
"AnnotationUtils.java:640"$0$"	 * @see Class#getDeclaredAnnotations()"
"AnnotationUtils.java:641"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:642"$0$"	 */"
"AnnotationUtils.java:643"$0$"	@Deprecated"
"AnnotationUtils.java:644"$0$"	@Nullable"
"AnnotationUtils.java:645"$0$"	public static Class<?> findAnnotationDeclaringClassForTypes("
"AnnotationUtils.java:646"$1$"			List<Class<? extends Annotation>> annotationTypes, @Nullable Class<?> clazz) {"
"AnnotationUtils.java:647"$1$""
"AnnotationUtils.java:648"$1$"		if (clazz == null) {"
"AnnotationUtils.java:649"$1$"			return null;"
"AnnotationUtils.java:650"$1$"		}"
"AnnotationUtils.java:651"$0$""
"AnnotationUtils.java:652"$0$"		return (Class<?>) MergedAnnotations.from(clazz, SearchStrategy.SUPERCLASS)"
"AnnotationUtils.java:653"$0$"				.stream()"
"AnnotationUtils.java:654"$0$"				.filter(MergedAnnotationPredicates.typeIn(annotationTypes).and(MergedAnnotation::isDirectlyPresent))"
"AnnotationUtils.java:655"$0$"				.map(MergedAnnotation::getSource)"
"AnnotationUtils.java:656"$0$"				.findFirst().orElse(null);"
"AnnotationUtils.java:657"$0$"	}"
"AnnotationUtils.java:658"$0$""
"AnnotationUtils.java:659"$0$"	/**"
"AnnotationUtils.java:660"$1$"	 * Determine whether an annotation of the specified {@code annotationType}"
"AnnotationUtils.java:661"$0$"	 * is declared locally (i.e. <em>directly present</em>) on the supplied"
"AnnotationUtils.java:662"$1$"	 * {@code clazz}."
"AnnotationUtils.java:663"$1$"	 * <p>The supplied {@link Class} may represent any type."
"AnnotationUtils.java:664"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:665"$0$"	 * <p>Note: This method does <strong>not</strong> determine if the annotation"
"AnnotationUtils.java:666"$1$"	 * is {@linkplain java.lang.annotation.Inherited inherited}."
"AnnotationUtils.java:667"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:668"$0$"	 * @param clazz the class to check for the annotation on"
"AnnotationUtils.java:669"$1$"	 * @return {@code true} if an annotation of the specified {@code annotationType}"
"AnnotationUtils.java:670"$0$"	 * is <em>directly present</em>"
"AnnotationUtils.java:671"$0$"	 * @see java.lang.Class#getDeclaredAnnotations()"
"AnnotationUtils.java:672"$0$"	 * @see java.lang.Class#getDeclaredAnnotation(Class)"
"AnnotationUtils.java:673"$0$"	 */"
"AnnotationUtils.java:674"$1$"	public static boolean isAnnotationDeclaredLocally(Class<? extends Annotation> annotationType, Class<?> clazz) {"
"AnnotationUtils.java:675"$1$"		return MergedAnnotations.from(clazz).get(annotationType).isDirectlyPresent();"
"AnnotationUtils.java:676"$1$"	}"
"AnnotationUtils.java:677"$0$""
"AnnotationUtils.java:678"$0$"	/**"
"AnnotationUtils.java:679"$1$"	 * Determine whether an annotation of the specified {@code annotationType}"
"AnnotationUtils.java:680"$1$"	 * is <em>present</em> on the supplied {@code clazz} and is"
"AnnotationUtils.java:681"$1$"	 * {@linkplain java.lang.annotation.Inherited inherited}"
"AnnotationUtils.java:682"$0$"	 * (i.e. not <em>directly present</em>)."
"AnnotationUtils.java:683"$0$"	 * <p>Meta-annotations will <em>not</em> be searched."
"AnnotationUtils.java:684"$1$"	 * <p>If the supplied {@code clazz} is an interface, only the interface"
"AnnotationUtils.java:685"$0$"	 * itself will be checked. In accordance with standard meta-annotation"
"AnnotationUtils.java:686"$0$"	 * semantics in Java, the inheritance hierarchy for interfaces will not"
"AnnotationUtils.java:687"$1$"	 * be traversed. See the {@linkplain java.lang.annotation.Inherited javadoc}"
"AnnotationUtils.java:688"$1$"	 * for the {@code @Inherited} meta-annotation for further details regarding"
"AnnotationUtils.java:689"$0$"	 * annotation inheritance."
"AnnotationUtils.java:690"$0$"	 * @param annotationType the annotation type to look for"
"AnnotationUtils.java:691"$0$"	 * @param clazz the class to check for the annotation on"
"AnnotationUtils.java:692"$1$"	 * @return {@code true} if an annotation of the specified {@code annotationType}"
"AnnotationUtils.java:693"$0$"	 * is <em>present</em> and <em>inherited</em>"
"AnnotationUtils.java:694"$0$"	 * @see Class#isAnnotationPresent(Class)"
"AnnotationUtils.java:695"$0$"	 * @see #isAnnotationDeclaredLocally(Class, Class)"
"AnnotationUtils.java:696"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:697"$0$"	 */"
"AnnotationUtils.java:698"$0$"	@Deprecated"
"AnnotationUtils.java:699"$1$"	public static boolean isAnnotationInherited(Class<? extends Annotation> annotationType, Class<?> clazz) {"
"AnnotationUtils.java:700"$1$"		return MergedAnnotations.from(clazz, SearchStrategy.INHERITED_ANNOTATIONS)"
"AnnotationUtils.java:701"$1$"				.stream(annotationType)"
"AnnotationUtils.java:702"$1$"				.filter(MergedAnnotation::isDirectlyPresent)"
"AnnotationUtils.java:703"$1$"				.findFirst().orElseGet(MergedAnnotation::missing)"
"AnnotationUtils.java:704"$1$"				.getAggregateIndex() > 0;"
"AnnotationUtils.java:705"$1$"	}"
"AnnotationUtils.java:706"$0$""
"AnnotationUtils.java:707"$0$"	/**"
"AnnotationUtils.java:708"$1$"	 * Determine if an annotation of type {@code metaAnnotationType} is"
"AnnotationUtils.java:709"$1$"	 * <em>meta-present</em> on the supplied {@code annotationType}."
"AnnotationUtils.java:710"$0$"	 * @param annotationType the annotation type to search on"
"AnnotationUtils.java:711"$0$"	 * @param metaAnnotationType the type of meta-annotation to search for"
"AnnotationUtils.java:712"$1$"	 * @return {@code true} if such an annotation is meta-present"
"AnnotationUtils.java:713"$0$"	 * @since 4.2.1"
"AnnotationUtils.java:714"$1$"	 * @deprecated as of 5.2 since it is superseded by the {@link MergedAnnotations} API"
"AnnotationUtils.java:715"$0$"	 */"
"AnnotationUtils.java:716"$0$"	@Deprecated"
"AnnotationUtils.java:717"$0$"	public static boolean isAnnotationMetaPresent(Class<? extends Annotation> annotationType,"
"AnnotationUtils.java:718"$1$"			@Nullable Class<? extends Annotation> metaAnnotationType) {"
"AnnotationUtils.java:719"$1$""
"AnnotationUtils.java:720"$1$"		if (metaAnnotationType == null) {"
"AnnotationUtils.java:721"$1$"			return false;"
"AnnotationUtils.java:722"$1$"		}"
"AnnotationUtils.java:723"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotationUtils.java:724"$0$"		if (AnnotationFilter.PLAIN.matches(metaAnnotationType) ||"
"AnnotationUtils.java:725"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotationType)) {"
"AnnotationUtils.java:726"$1$"			return annotationType.isAnnotationPresent(metaAnnotationType);"
"AnnotationUtils.java:727"$1$"		}"
"AnnotationUtils.java:728"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotationUtils.java:729"$0$"		return MergedAnnotations.from(annotationType, SearchStrategy.INHERITED_ANNOTATIONS,"
"AnnotationUtils.java:730"$0$"				RepeatableContainers.none()).isPresent(metaAnnotationType);"
"AnnotationUtils.java:731"$0$"	}"
"AnnotationUtils.java:732"$0$""
"AnnotationUtils.java:733"$0$"	/**"
"AnnotationUtils.java:734"$1$"	 * Determine if the supplied {@link Annotation} is defined in the core JDK"
"AnnotationUtils.java:735"$1$"	 * {@code java.lang.annotation} package."
"AnnotationUtils.java:736"$0$"	 * @param annotation the annotation to check"
"AnnotationUtils.java:737"$1$"	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package"
"AnnotationUtils.java:738"$0$"	 */"
"AnnotationUtils.java:739"$1$"	public static boolean isInJavaLangAnnotationPackage(@Nullable Annotation annotation) {"
"AnnotationUtils.java:740"$1$"		return (annotation != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotation));"
"AnnotationUtils.java:741"$1$"	}"
"AnnotationUtils.java:742"$0$""
"AnnotationUtils.java:743"$0$"	/**"
"AnnotationUtils.java:744"$1$"	 * Determine if the {@link Annotation} with the supplied name is defined"
"AnnotationUtils.java:745"$1$"	 * in the core JDK {@code java.lang.annotation} package."
"AnnotationUtils.java:746"$0$"	 * @param annotationType the name of the annotation type to check"
"AnnotationUtils.java:747"$1$"	 * @return {@code true} if the annotation is in the {@code java.lang.annotation} package"
"AnnotationUtils.java:748"$0$"	 * @since 4.2"
"AnnotationUtils.java:749"$0$"	 */"
"AnnotationUtils.java:750"$1$"	public static boolean isInJavaLangAnnotationPackage(@Nullable String annotationType) {"
"AnnotationUtils.java:751"$1$"		return (annotationType != null && JAVA_LANG_ANNOTATION_FILTER.matches(annotationType));"
"AnnotationUtils.java:752"$1$"	}"
"AnnotationUtils.java:753"$0$""
"AnnotationUtils.java:754"$0$"	/**"
"AnnotationUtils.java:755"$0$"	 * Check the declared attributes of the given annotation, in particular covering"
"AnnotationUtils.java:756"$1$"	 * Google App Engine's late arrival of {@code TypeNotPresentExceptionProxy} for"
"AnnotationUtils.java:757"$1$"	 * {@code Class} values (instead of early {@code Class.getAnnotations() failure}."
"AnnotationUtils.java:758"$1$"	 * <p>This method not failing indicates that {@link #getAnnotationAttributes(Annotation)}"
"AnnotationUtils.java:759"$0$"	 * won't failure either (when attempted later on)."
"AnnotationUtils.java:760"$0$"	 * @param annotation the annotation to validate"
"AnnotationUtils.java:761"$1$"	 * @throws IllegalStateException if a declared {@code Class} attribute could not be read"
"AnnotationUtils.java:762"$0$"	 * @since 4.3.15"
"AnnotationUtils.java:763"$0$"	 * @see Class#getAnnotations()"
"AnnotationUtils.java:764"$0$"	 * @see #getAnnotationAttributes(Annotation)"
"AnnotationUtils.java:765"$0$"	 */"
"AnnotationUtils.java:766"$1$"	public static void validateAnnotation(Annotation annotation) {"
"AnnotationUtils.java:767"$1$"		AttributeMethods.forAnnotationType(annotation.annotationType()).validate(annotation);"
"AnnotationUtils.java:768"$1$"	}"
"AnnotationUtils.java:769"$0$""
"AnnotationUtils.java:770"$0$"	/**"
"AnnotationUtils.java:771"$1$"	 * Retrieve the given annotation's attributes as a {@link Map}, preserving all"
"AnnotationUtils.java:772"$0$"	 * attribute types."
"AnnotationUtils.java:773"$1$"	 * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}"
"AnnotationUtils.java:774"$1$"	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters"
"AnnotationUtils.java:775"$1$"	 * set to {@code false}."
"AnnotationUtils.java:776"$1$"	 * <p>Note: This method actually returns an {@link AnnotationAttributes} instance."
"AnnotationUtils.java:777"$1$"	 * However, the {@code Map} signature has been preserved for binary compatibility."
"AnnotationUtils.java:778"$0$"	 * @param annotation the annotation to retrieve the attributes for"
"AnnotationUtils.java:779"$0$"	 * @return the Map of annotation attributes, with attribute names as keys and"
"AnnotationUtils.java:780"$1$"	 * corresponding attribute values as values (never {@code null})"
"AnnotationUtils.java:781"$0$"	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)"
"AnnotationUtils.java:782"$0$"	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)"
"AnnotationUtils.java:783"$0$"	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)"
"AnnotationUtils.java:784"$0$"	 */"
"AnnotationUtils.java:785"$1$"	public static Map<String, Object> getAnnotationAttributes(Annotation annotation) {"
"AnnotationUtils.java:786"$1$"		return getAnnotationAttributes(null, annotation);"
"AnnotationUtils.java:787"$1$"	}"
"AnnotationUtils.java:788"$0$""
"AnnotationUtils.java:789"$0$"	/**"
"AnnotationUtils.java:790"$1$"	 * Retrieve the given annotation's attributes as a {@link Map}."
"AnnotationUtils.java:791"$1$"	 * <p>Equivalent to calling {@link #getAnnotationAttributes(Annotation, boolean, boolean)}"
"AnnotationUtils.java:792"$1$"	 * with the {@code nestedAnnotationsAsMap} parameter set to {@code false}."
"AnnotationUtils.java:793"$1$"	 * <p>Note: This method actually returns an {@link AnnotationAttributes} instance."
"AnnotationUtils.java:794"$1$"	 * However, the {@code Map} signature has been preserved for binary compatibility."
"AnnotationUtils.java:795"$0$"	 * @param annotation the annotation to retrieve the attributes for"
"AnnotationUtils.java:796"$0$"	 * @param classValuesAsString whether to convert Class references into Strings (for"
"AnnotationUtils.java:797"$1$"	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})"
"AnnotationUtils.java:798"$0$"	 * or to preserve them as Class references"
"AnnotationUtils.java:799"$0$"	 * @return the Map of annotation attributes, with attribute names as keys and"
"AnnotationUtils.java:800"$1$"	 * corresponding attribute values as values (never {@code null})"
"AnnotationUtils.java:801"$0$"	 * @see #getAnnotationAttributes(Annotation, boolean, boolean)"
"AnnotationUtils.java:802"$0$"	 */"
"AnnotationUtils.java:803"$0$"	public static Map<String, Object> getAnnotationAttributes("
"AnnotationUtils.java:804"$1$"			Annotation annotation, boolean classValuesAsString) {"
"AnnotationUtils.java:805"$1$""
"AnnotationUtils.java:806"$1$"		return getAnnotationAttributes(annotation, classValuesAsString, false);"
"AnnotationUtils.java:807"$1$"	}"
"AnnotationUtils.java:808"$0$""
"AnnotationUtils.java:809"$0$"	/**"
"AnnotationUtils.java:810"$1$"	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map."
"AnnotationUtils.java:811"$0$"	 * <p>This method provides fully recursive annotation reading capabilities on par with"
"AnnotationUtils.java:812"$1$"	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}."
"AnnotationUtils.java:813"$0$"	 * @param annotation the annotation to retrieve the attributes for"
"AnnotationUtils.java:814"$0$"	 * @param classValuesAsString whether to convert Class references into Strings (for"
"AnnotationUtils.java:815"$1$"	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})"
"AnnotationUtils.java:816"$0$"	 * or to preserve them as Class references"
"AnnotationUtils.java:817"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested annotations into"
"AnnotationUtils.java:818"$1$"	 * {@link AnnotationAttributes} maps (for compatibility with"
"AnnotationUtils.java:819"$1$"	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as"
"AnnotationUtils.java:820"$1$"	 * {@code Annotation} instances"
"AnnotationUtils.java:821"$0$"	 * @return the annotation attributes (a specialized Map) with attribute names as keys"
"AnnotationUtils.java:822"$1$"	 * and corresponding attribute values as values (never {@code null})"
"AnnotationUtils.java:823"$0$"	 * @since 3.1.1"
"AnnotationUtils.java:824"$0$"	 */"
"AnnotationUtils.java:825"$0$"	public static AnnotationAttributes getAnnotationAttributes("
"AnnotationUtils.java:826"$1$"			Annotation annotation, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotationUtils.java:827"$1$""
"AnnotationUtils.java:828"$1$"		return getAnnotationAttributes(null, annotation, classValuesAsString, nestedAnnotationsAsMap);"
"AnnotationUtils.java:829"$1$"	}"
"AnnotationUtils.java:830"$0$""
"AnnotationUtils.java:831"$0$"	/**"
"AnnotationUtils.java:832"$1$"	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map."
"AnnotationUtils.java:833"$1$"	 * <p>Equivalent to calling {@link #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)}"
"AnnotationUtils.java:834"$1$"	 * with the {@code classValuesAsString} and {@code nestedAnnotationsAsMap} parameters"
"AnnotationUtils.java:835"$1$"	 * set to {@code false}."
"AnnotationUtils.java:836"$0$"	 * @param annotatedElement the element that is annotated with the supplied annotation;"
"AnnotationUtils.java:837"$1$"	 * may be {@code null} if unknown"
"AnnotationUtils.java:838"$0$"	 * @param annotation the annotation to retrieve the attributes for"
"AnnotationUtils.java:839"$0$"	 * @return the annotation attributes (a specialized Map) with attribute names as keys"
"AnnotationUtils.java:840"$1$"	 * and corresponding attribute values as values (never {@code null})"
"AnnotationUtils.java:841"$0$"	 * @since 4.2"
"AnnotationUtils.java:842"$0$"	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)"
"AnnotationUtils.java:843"$0$"	 */"
"AnnotationUtils.java:844"$0$"	public static AnnotationAttributes getAnnotationAttributes("
"AnnotationUtils.java:845"$1$"			@Nullable AnnotatedElement annotatedElement, Annotation annotation) {"
"AnnotationUtils.java:846"$1$""
"AnnotationUtils.java:847"$1$"		return getAnnotationAttributes(annotatedElement, annotation, false, false);"
"AnnotationUtils.java:848"$1$"	}"
"AnnotationUtils.java:849"$0$""
"AnnotationUtils.java:850"$0$"	/**"
"AnnotationUtils.java:851"$1$"	 * Retrieve the given annotation's attributes as an {@link AnnotationAttributes} map."
"AnnotationUtils.java:852"$0$"	 * <p>This method provides fully recursive annotation reading capabilities on par with"
"AnnotationUtils.java:853"$1$"	 * the reflection-based {@link org.springframework.core.type.StandardAnnotationMetadata}."
"AnnotationUtils.java:854"$0$"	 * @param annotatedElement the element that is annotated with the supplied annotation;"
"AnnotationUtils.java:855"$1$"	 * may be {@code null} if unknown"
"AnnotationUtils.java:856"$0$"	 * @param annotation the annotation to retrieve the attributes for"
"AnnotationUtils.java:857"$0$"	 * @param classValuesAsString whether to convert Class references into Strings (for"
"AnnotationUtils.java:858"$1$"	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})"
"AnnotationUtils.java:859"$0$"	 * or to preserve them as Class references"
"AnnotationUtils.java:860"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested annotations into"
"AnnotationUtils.java:861"$1$"	 * {@link AnnotationAttributes} maps (for compatibility with"
"AnnotationUtils.java:862"$1$"	 * {@link org.springframework.core.type.AnnotationMetadata}) or to preserve them as"
"AnnotationUtils.java:863"$1$"	 * {@code Annotation} instances"
"AnnotationUtils.java:864"$0$"	 * @return the annotation attributes (a specialized Map) with attribute names as keys"
"AnnotationUtils.java:865"$1$"	 * and corresponding attribute values as values (never {@code null})"
"AnnotationUtils.java:866"$0$"	 * @since 4.2"
"AnnotationUtils.java:867"$0$"	 */"
"AnnotationUtils.java:868"$0$"	public static AnnotationAttributes getAnnotationAttributes("
"AnnotationUtils.java:869"$0$"			@Nullable AnnotatedElement annotatedElement, Annotation annotation,"
"AnnotationUtils.java:870"$1$"			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotationUtils.java:871"$1$""
"AnnotationUtils.java:872"$1$"		Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);"
"AnnotationUtils.java:873"$1$"		return MergedAnnotation.from(annotatedElement, annotation)"
"AnnotationUtils.java:874"$1$"				.withNonMergedAttributes()"
"AnnotationUtils.java:875"$1$"				.asMap(mergedAnnotation ->"
"AnnotationUtils.java:876"$1$"						new AnnotationAttributes(mergedAnnotation.getType(), true), adaptations);"
"AnnotationUtils.java:877"$1$"	}"
"AnnotationUtils.java:878"$0$""
"AnnotationUtils.java:879"$0$"	/**"
"AnnotationUtils.java:880"$0$"	 * Register the annotation-declared default values for the given attributes,"
"AnnotationUtils.java:881"$0$"	 * if available."
"AnnotationUtils.java:882"$0$"	 * @param attributes the annotation attributes to process"
"AnnotationUtils.java:883"$0$"	 * @since 4.3.2"
"AnnotationUtils.java:884"$0$"	 */"
"AnnotationUtils.java:885"$1$"	public static void registerDefaultValues(AnnotationAttributes attributes) {"
"AnnotationUtils.java:886"$1$"		Class<? extends Annotation> annotationType = attributes.annotationType();"
"AnnotationUtils.java:887"$1$"		if (annotationType != null && Modifier.isPublic(annotationType.getModifiers()) &&"
"AnnotationUtils.java:888"$1$"				!AnnotationFilter.PLAIN.matches(annotationType)) {"
"AnnotationUtils.java:889"$1$"			Map<String, DefaultValueHolder> defaultValues = getDefaultValues(annotationType);"
"AnnotationUtils.java:890"$1$"			defaultValues.forEach(attributes::putIfAbsent);"
"AnnotationUtils.java:891"$1$"		}"
"AnnotationUtils.java:892"$0$"	}"
"AnnotationUtils.java:893"$0$""
"AnnotationUtils.java:894"$0$"	private static Map<String, DefaultValueHolder> getDefaultValues("
"AnnotationUtils.java:895"$1$"			Class<? extends Annotation> annotationType) {"
"AnnotationUtils.java:896"$1$""
"AnnotationUtils.java:897"$1$"		return defaultValuesCache.computeIfAbsent(annotationType,"
"AnnotationUtils.java:898"$1$"				AnnotationUtils::computeDefaultValues);"
"AnnotationUtils.java:899"$1$"	}"
"AnnotationUtils.java:900"$0$""
"AnnotationUtils.java:901"$0$"	private static Map<String, DefaultValueHolder> computeDefaultValues("
"AnnotationUtils.java:902"$1$"			Class<? extends Annotation> annotationType) {"
"AnnotationUtils.java:903"$1$""
"AnnotationUtils.java:904"$1$"		AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);"
"AnnotationUtils.java:905"$1$"		if (!methods.hasDefaultValueMethod()) {"
"AnnotationUtils.java:906"$1$"			return Collections.emptyMap();"
"AnnotationUtils.java:907"$1$"		}"
"AnnotationUtils.java:908"$0$"		Map<String, DefaultValueHolder> result = new LinkedHashMap<>(methods.size());"
"AnnotationUtils.java:909"$1$"		if (!methods.hasNestedAnnotation()) {"
"AnnotationUtils.java:910"$0$"			// Use simpler method if there are no nested annotations"
"AnnotationUtils.java:911"$1$"			for (int i = 0; i < methods.size(); i++) {"
"AnnotationUtils.java:912"$1$"				Method method = methods.get(i);"
"AnnotationUtils.java:913"$1$"				Object defaultValue = method.getDefaultValue();"
"AnnotationUtils.java:914"$1$"				if (defaultValue != null) {"
"AnnotationUtils.java:915"$1$"					result.put(method.getName(), new DefaultValueHolder(defaultValue));"
"AnnotationUtils.java:916"$1$"				}"
"AnnotationUtils.java:917"$0$"			}"
"AnnotationUtils.java:918"$0$"		}"
"AnnotationUtils.java:919"$1$"		else {"
"AnnotationUtils.java:920"$0$"			// If we have nested annotations, we need them as nested maps"
"AnnotationUtils.java:921"$1$"			AnnotationAttributes attributes = MergedAnnotation.of(annotationType)"
"AnnotationUtils.java:922"$1$"					.asMap(annotation ->"
"AnnotationUtils.java:923"$1$"							new AnnotationAttributes(annotation.getType(), true), Adapt.ANNOTATION_TO_MAP);"
"AnnotationUtils.java:924"$1$"			for (Map.Entry<String, Object> element : attributes.entrySet()) {"
"AnnotationUtils.java:925"$1$"				result.put(element.getKey(), new DefaultValueHolder(element.getValue()));"
"AnnotationUtils.java:926"$1$"			}"
"AnnotationUtils.java:927"$0$"		}"
"AnnotationUtils.java:928"$0$"		return result;"
"AnnotationUtils.java:929"$0$"	}"
"AnnotationUtils.java:930"$0$""
"AnnotationUtils.java:931"$0$"	/**"
"AnnotationUtils.java:932"$1$"	 * Post-process the supplied {@link AnnotationAttributes}, preserving nested"
"AnnotationUtils.java:933"$1$"	 * annotations as {@code Annotation} instances."
"AnnotationUtils.java:934"$0$"	 * <p>Specifically, this method enforces <em>attribute alias</em> semantics"
"AnnotationUtils.java:935"$1$"	 * for annotation attributes that are annotated with {@link AliasFor @AliasFor}"
"AnnotationUtils.java:936"$0$"	 * and replaces default value placeholders with their original default values."
"AnnotationUtils.java:937"$0$"	 * @param annotatedElement the element that is annotated with an annotation or"
"AnnotationUtils.java:938"$0$"	 * annotation hierarchy from which the supplied attributes were created;"
"AnnotationUtils.java:939"$1$"	 * may be {@code null} if unknown"
"AnnotationUtils.java:940"$0$"	 * @param attributes the annotation attributes to post-process"
"AnnotationUtils.java:941"$0$"	 * @param classValuesAsString whether to convert Class references into Strings (for"
"AnnotationUtils.java:942"$1$"	 * compatibility with {@link org.springframework.core.type.AnnotationMetadata})"
"AnnotationUtils.java:943"$0$"	 * or to preserve them as Class references"
"AnnotationUtils.java:944"$0$"	 * @since 4.3.2"
"AnnotationUtils.java:945"$0$"	 * @see #getDefaultValue(Class, String)"
"AnnotationUtils.java:946"$0$"	 */"
"AnnotationUtils.java:947"$0$"	public static void postProcessAnnotationAttributes(@Nullable Object annotatedElement,"
"AnnotationUtils.java:948"$1$"			@Nullable AnnotationAttributes attributes, boolean classValuesAsString) {"
"AnnotationUtils.java:949"$1$""
"AnnotationUtils.java:950"$1$"		if (attributes == null) {"
"AnnotationUtils.java:951"$1$"			return;"
"AnnotationUtils.java:952"$1$"		}"
"AnnotationUtils.java:953"$1$"		if (!attributes.validated) {"
"AnnotationUtils.java:954"$1$"			Class<? extends Annotation> annotationType = attributes.annotationType();"
"AnnotationUtils.java:955"$1$"			if (annotationType == null) {"
"AnnotationUtils.java:956"$1$"				return;"
"AnnotationUtils.java:957"$1$"			}"
"AnnotationUtils.java:958"$0$"			AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);"
"AnnotationUtils.java:959"$1$"			for (int i = 0; i < mapping.getMirrorSets().size(); i++) {"
"AnnotationUtils.java:960"$1$"				MirrorSet mirrorSet = mapping.getMirrorSets().get(i);"
"AnnotationUtils.java:961"$1$"				int resolved = mirrorSet.resolve(attributes.displayName, attributes,"
"AnnotationUtils.java:962"$1$"						AnnotationUtils::getAttributeValueForMirrorResolution);"
"AnnotationUtils.java:963"$1$"				if (resolved != -1) {"
"AnnotationUtils.java:964"$1$"					Method attribute = mapping.getAttributes().get(resolved);"
"AnnotationUtils.java:965"$1$"					Object value = attributes.get(attribute.getName());"
"AnnotationUtils.java:966"$1$"					for (int j = 0; j < mirrorSet.size(); j++) {"
"AnnotationUtils.java:967"$1$"						Method mirror = mirrorSet.get(j);"
"AnnotationUtils.java:968"$1$"						if (mirror != attribute) {"
"AnnotationUtils.java:969"$1$"							attributes.put(mirror.getName(),"
"AnnotationUtils.java:970"$1$"									adaptValue(annotatedElement, value, classValuesAsString));"
"AnnotationUtils.java:971"$1$"						}"
"AnnotationUtils.java:972"$0$"					}"
"AnnotationUtils.java:973"$0$"				}"
"AnnotationUtils.java:974"$0$"			}"
"AnnotationUtils.java:975"$0$"		}"
"AnnotationUtils.java:976"$1$"		for (Map.Entry<String, Object> attributeEntry : attributes.entrySet()) {"
"AnnotationUtils.java:977"$1$"			String attributeName = attributeEntry.getKey();"
"AnnotationUtils.java:978"$1$"			Object value = attributeEntry.getValue();"
"AnnotationUtils.java:979"$1$"			if (value instanceof DefaultValueHolder) {"
"AnnotationUtils.java:980"$1$"				value = ((DefaultValueHolder) value).defaultValue;"
"AnnotationUtils.java:981"$1$"				attributes.put(attributeName,"
"AnnotationUtils.java:982"$1$"						adaptValue(annotatedElement, value, classValuesAsString));"
"AnnotationUtils.java:983"$1$"			}"
"AnnotationUtils.java:984"$0$"		}"
"AnnotationUtils.java:985"$0$"	}"
"AnnotationUtils.java:986"$0$""
"AnnotationUtils.java:987"$1$"	private static Object getAttributeValueForMirrorResolution(Method attribute, Object attributes) {"
"AnnotationUtils.java:988"$1$"		Object result = ((AnnotationAttributes) attributes).get(attribute.getName());"
"AnnotationUtils.java:989"$1$"		return (result instanceof DefaultValueHolder ? ((DefaultValueHolder) result).defaultValue : result);"
"AnnotationUtils.java:990"$1$"	}"
"AnnotationUtils.java:991"$0$""
"AnnotationUtils.java:992"$0$"	@Nullable"
"AnnotationUtils.java:993"$0$"	private static Object adaptValue("
"AnnotationUtils.java:994"$1$"			@Nullable Object annotatedElement, @Nullable Object value, boolean classValuesAsString) {"
"AnnotationUtils.java:995"$1$""
"AnnotationUtils.java:996"$1$"		if (classValuesAsString) {"
"AnnotationUtils.java:997"$1$"			if (value instanceof Class) {"
"AnnotationUtils.java:998"$1$"				return ((Class<?>) value).getName();"
"AnnotationUtils.java:999"$1$"			}"
"AnnotationUtils.java:1000"$1$"			if (value instanceof Class[]) {"
"AnnotationUtils.java:1001"$1$"				Class<?>[] classes = (Class<?>[]) value;"
"AnnotationUtils.java:1002"$1$"				String[] names = new String[classes.length];"
"AnnotationUtils.java:1003"$1$"				for (int i = 0; i < classes.length; i++) {"
"AnnotationUtils.java:1004"$1$"					names[i] = classes[i].getName();"
"AnnotationUtils.java:1005"$1$"				}"
"AnnotationUtils.java:1006"$0$"				return names;"
"AnnotationUtils.java:1007"$0$"			}"
"AnnotationUtils.java:1008"$0$"		}"
"AnnotationUtils.java:1009"$1$"		if (value instanceof Annotation) {"
"AnnotationUtils.java:1010"$1$"			Annotation annotation = (Annotation) value;"
"AnnotationUtils.java:1011"$1$"			return MergedAnnotation.from(annotatedElement, annotation).synthesize();"
"AnnotationUtils.java:1012"$1$"		}"
"AnnotationUtils.java:1013"$1$"		if (value instanceof Annotation[]) {"
"AnnotationUtils.java:1014"$1$"			Annotation[] annotations = (Annotation[]) value;"
"AnnotationUtils.java:1015"$1$"			Annotation[] synthesized = (Annotation[]) Array.newInstance("
"AnnotationUtils.java:1016"$1$"					annotations.getClass().getComponentType(), annotations.length);"
"AnnotationUtils.java:1017"$1$"			for (int i = 0; i < annotations.length; i++) {"
"AnnotationUtils.java:1018"$1$"				synthesized[i] = MergedAnnotation.from(annotatedElement, annotations[i]).synthesize();"
"AnnotationUtils.java:1019"$1$"			}"
"AnnotationUtils.java:1020"$0$"			return synthesized;"
"AnnotationUtils.java:1021"$0$"		}"
"AnnotationUtils.java:1022"$0$"		return value;"
"AnnotationUtils.java:1023"$0$"	}"
"AnnotationUtils.java:1024"$0$""
"AnnotationUtils.java:1025"$0$"	/**"
"AnnotationUtils.java:1026"$1$"	 * Retrieve the <em>value</em> of the {@code value} attribute of a"
"AnnotationUtils.java:1027"$0$"	 * single-element Annotation, given an annotation instance."
"AnnotationUtils.java:1028"$0$"	 * @param annotation the annotation instance from which to retrieve the value"
"AnnotationUtils.java:1029"$1$"	 * @return the attribute value, or {@code null} if not found unless the attribute"
"AnnotationUtils.java:1030"$1$"	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},"
"AnnotationUtils.java:1031"$0$"	 * in which case such an exception will be rethrown"
"AnnotationUtils.java:1032"$0$"	 * @see #getValue(Annotation, String)"
"AnnotationUtils.java:1033"$0$"	 */"
"AnnotationUtils.java:1034"$0$"	@Nullable"
"AnnotationUtils.java:1035"$1$"	public static Object getValue(Annotation annotation) {"
"AnnotationUtils.java:1036"$1$"		return getValue(annotation, VALUE);"
"AnnotationUtils.java:1037"$1$"	}"
"AnnotationUtils.java:1038"$0$""
"AnnotationUtils.java:1039"$0$"	/**"
"AnnotationUtils.java:1040"$0$"	 * Retrieve the <em>value</em> of a named attribute, given an annotation instance."
"AnnotationUtils.java:1041"$0$"	 * @param annotation the annotation instance from which to retrieve the value"
"AnnotationUtils.java:1042"$0$"	 * @param attributeName the name of the attribute value to retrieve"
"AnnotationUtils.java:1043"$1$"	 * @return the attribute value, or {@code null} if not found unless the attribute"
"AnnotationUtils.java:1044"$1$"	 * value cannot be retrieved due to an {@link AnnotationConfigurationException},"
"AnnotationUtils.java:1045"$0$"	 * in which case such an exception will be rethrown"
"AnnotationUtils.java:1046"$0$"	 * @see #getValue(Annotation)"
"AnnotationUtils.java:1047"$0$"	 */"
"AnnotationUtils.java:1048"$0$"	@Nullable"
"AnnotationUtils.java:1049"$1$"	public static Object getValue(@Nullable Annotation annotation, @Nullable String attributeName) {"
"AnnotationUtils.java:1050"$1$"		if (annotation == null || !StringUtils.hasText(attributeName)) {"
"AnnotationUtils.java:1051"$1$"			return null;"
"AnnotationUtils.java:1052"$1$"		}"
"AnnotationUtils.java:1053"$1$"		try {"
"AnnotationUtils.java:1054"$1$"			Method method = annotation.annotationType().getDeclaredMethod(attributeName);"
"AnnotationUtils.java:1055"$1$"			ReflectionUtils.makeAccessible(method);"
"AnnotationUtils.java:1056"$1$"			return method.invoke(annotation);"
"AnnotationUtils.java:1057"$1$"		}"
"AnnotationUtils.java:1058"$1$"		catch (NoSuchMethodException ex) {"
"AnnotationUtils.java:1059"$1$"			return null;"
"AnnotationUtils.java:1060"$1$"		}"
"AnnotationUtils.java:1061"$1$"		catch (InvocationTargetException ex) {"
"AnnotationUtils.java:1062"$1$"			rethrowAnnotationConfigurationException(ex.getTargetException());"
"AnnotationUtils.java:1063"$1$"			throw new IllegalStateException(""Could not obtain value for annotation attribute '"" +"
"AnnotationUtils.java:1064"$1$"					attributeName + ""' in "" + annotation, ex);"
"AnnotationUtils.java:1065"$1$"		}"
"AnnotationUtils.java:1066"$1$"		catch (Throwable ex) {"
"AnnotationUtils.java:1067"$1$"			handleIntrospectionFailure(annotation.getClass(), ex);"
"AnnotationUtils.java:1068"$1$"			return null;"
"AnnotationUtils.java:1069"$1$"		}"
"AnnotationUtils.java:1070"$0$"	}"
"AnnotationUtils.java:1071"$0$""
"AnnotationUtils.java:1072"$0$"	/**"
"AnnotationUtils.java:1073"$1$"	 * If the supplied throwable is an {@link AnnotationConfigurationException},"
"AnnotationUtils.java:1074"$1$"	 * it will be cast to an {@code AnnotationConfigurationException} and thrown,"
"AnnotationUtils.java:1075"$0$"	 * allowing it to propagate to the caller."
"AnnotationUtils.java:1076"$0$"	 * <p>Otherwise, this method does nothing."
"AnnotationUtils.java:1077"$0$"	 * @param ex the throwable to inspect"
"AnnotationUtils.java:1078"$0$"	 */"
"AnnotationUtils.java:1079"$1$"	static void rethrowAnnotationConfigurationException(Throwable ex) {"
"AnnotationUtils.java:1080"$1$"		if (ex instanceof AnnotationConfigurationException) {"
"AnnotationUtils.java:1081"$1$"			throw (AnnotationConfigurationException) ex;"
"AnnotationUtils.java:1082"$1$"		}"
"AnnotationUtils.java:1083"$0$"	}"
"AnnotationUtils.java:1084"$0$""
"AnnotationUtils.java:1085"$0$"	/**"
"AnnotationUtils.java:1086"$0$"	 * Handle the supplied annotation introspection exception."
"AnnotationUtils.java:1087"$1$"	 * <p>If the supplied exception is an {@link AnnotationConfigurationException},"
"AnnotationUtils.java:1088"$0$"	 * it will simply be thrown, allowing it to propagate to the caller, and"
"AnnotationUtils.java:1089"$0$"	 * nothing will be logged."
"AnnotationUtils.java:1090"$0$"	 * <p>Otherwise, this method logs an introspection failure (in particular for"
"AnnotationUtils.java:1091"$1$"	 * a {@link TypeNotPresentException}) before moving on, assuming nested"
"AnnotationUtils.java:1092"$1$"	 * {@code Class} values were not resolvable within annotation attributes and"
"AnnotationUtils.java:1093"$0$"	 * thereby effectively pretending there were no annotations on the specified"
"AnnotationUtils.java:1094"$0$"	 * element."
"AnnotationUtils.java:1095"$0$"	 * @param element the element that we tried to introspect annotations on"
"AnnotationUtils.java:1096"$0$"	 * @param ex the exception that we encountered"
"AnnotationUtils.java:1097"$0$"	 * @see #rethrowAnnotationConfigurationException"
"AnnotationUtils.java:1098"$0$"	 * @see IntrospectionFailureLogger"
"AnnotationUtils.java:1099"$0$"	 */"
"AnnotationUtils.java:1100"$1$"	static void handleIntrospectionFailure(@Nullable AnnotatedElement element, Throwable ex) {"
"AnnotationUtils.java:1101"$1$"		rethrowAnnotationConfigurationException(ex);"
"AnnotationUtils.java:1102"$1$"		IntrospectionFailureLogger logger = IntrospectionFailureLogger.INFO;"
"AnnotationUtils.java:1103"$1$"		boolean meta = false;"
"AnnotationUtils.java:1104"$1$"		if (element instanceof Class && Annotation.class.isAssignableFrom((Class<?>) element)) {"
"AnnotationUtils.java:1105"$0$"			// Meta-annotation or (default) value lookup on an annotation type"
"AnnotationUtils.java:1106"$1$"			logger = IntrospectionFailureLogger.DEBUG;"
"AnnotationUtils.java:1107"$1$"			meta = true;"
"AnnotationUtils.java:1108"$1$"		}"
"AnnotationUtils.java:1109"$1$"		if (logger.isEnabled()) {"
"AnnotationUtils.java:1110"$1$"			String message = meta ?"
"AnnotationUtils.java:1111"$1$"					""Failed to meta-introspect annotation "" :"
"AnnotationUtils.java:1112"$1$"					""Failed to introspect annotations on "";"
"AnnotationUtils.java:1113"$1$"			logger.log(message + element + "": "" + ex);"
"AnnotationUtils.java:1114"$1$"		}"
"AnnotationUtils.java:1115"$0$"	}"
"AnnotationUtils.java:1116"$0$""
"AnnotationUtils.java:1117"$0$"	/**"
"AnnotationUtils.java:1118"$1$"	 * Retrieve the <em>default value</em> of the {@code value} attribute"
"AnnotationUtils.java:1119"$0$"	 * of a single-element Annotation, given an annotation instance."
"AnnotationUtils.java:1120"$0$"	 * @param annotation the annotation instance from which to retrieve the default value"
"AnnotationUtils.java:1121"$1$"	 * @return the default value, or {@code null} if not found"
"AnnotationUtils.java:1122"$0$"	 * @see #getDefaultValue(Annotation, String)"
"AnnotationUtils.java:1123"$0$"	 */"
"AnnotationUtils.java:1124"$0$"	@Nullable"
"AnnotationUtils.java:1125"$1$"	public static Object getDefaultValue(Annotation annotation) {"
"AnnotationUtils.java:1126"$1$"		return getDefaultValue(annotation, VALUE);"
"AnnotationUtils.java:1127"$1$"	}"
"AnnotationUtils.java:1128"$0$""
"AnnotationUtils.java:1129"$0$"	/**"
"AnnotationUtils.java:1130"$0$"	 * Retrieve the <em>default value</em> of a named attribute, given an annotation instance."
"AnnotationUtils.java:1131"$0$"	 * @param annotation the annotation instance from which to retrieve the default value"
"AnnotationUtils.java:1132"$0$"	 * @param attributeName the name of the attribute value to retrieve"
"AnnotationUtils.java:1133"$1$"	 * @return the default value of the named attribute, or {@code null} if not found"
"AnnotationUtils.java:1134"$0$"	 * @see #getDefaultValue(Class, String)"
"AnnotationUtils.java:1135"$0$"	 */"
"AnnotationUtils.java:1136"$0$"	@Nullable"
"AnnotationUtils.java:1137"$1$"	public static Object getDefaultValue(@Nullable Annotation annotation, @Nullable String attributeName) {"
"AnnotationUtils.java:1138"$1$"		return (annotation != null ? getDefaultValue(annotation.annotationType(), attributeName) : null);"
"AnnotationUtils.java:1139"$1$"	}"
"AnnotationUtils.java:1140"$0$""
"AnnotationUtils.java:1141"$0$"	/**"
"AnnotationUtils.java:1142"$1$"	 * Retrieve the <em>default value</em> of the {@code value} attribute"
"AnnotationUtils.java:1143"$1$"	 * of a single-element Annotation, given the {@link Class annotation type}."
"AnnotationUtils.java:1144"$0$"	 * @param annotationType the <em>annotation type</em> for which the default value should be retrieved"
"AnnotationUtils.java:1145"$1$"	 * @return the default value, or {@code null} if not found"
"AnnotationUtils.java:1146"$0$"	 * @see #getDefaultValue(Class, String)"
"AnnotationUtils.java:1147"$0$"	 */"
"AnnotationUtils.java:1148"$0$"	@Nullable"
"AnnotationUtils.java:1149"$1$"	public static Object getDefaultValue(Class<? extends Annotation> annotationType) {"
"AnnotationUtils.java:1150"$1$"		return getDefaultValue(annotationType, VALUE);"
"AnnotationUtils.java:1151"$1$"	}"
"AnnotationUtils.java:1152"$0$""
"AnnotationUtils.java:1153"$0$"	/**"
"AnnotationUtils.java:1154"$0$"	 * Retrieve the <em>default value</em> of a named attribute, given the"
"AnnotationUtils.java:1155"$1$"	 * {@link Class annotation type}."
"AnnotationUtils.java:1156"$0$"	 * @param annotationType the <em>annotation type</em> for which the default value should be retrieved"
"AnnotationUtils.java:1157"$0$"	 * @param attributeName the name of the attribute value to retrieve."
"AnnotationUtils.java:1158"$1$"	 * @return the default value of the named attribute, or {@code null} if not found"
"AnnotationUtils.java:1159"$0$"	 * @see #getDefaultValue(Annotation, String)"
"AnnotationUtils.java:1160"$0$"	 */"
"AnnotationUtils.java:1161"$0$"	@Nullable"
"AnnotationUtils.java:1162"$0$"	public static Object getDefaultValue("
"AnnotationUtils.java:1163"$1$"			@Nullable Class<? extends Annotation> annotationType, @Nullable String attributeName) {"
"AnnotationUtils.java:1164"$1$""
"AnnotationUtils.java:1165"$1$"		if (annotationType == null || !StringUtils.hasText(attributeName)) {"
"AnnotationUtils.java:1166"$1$"			return null;"
"AnnotationUtils.java:1167"$1$"		}"
"AnnotationUtils.java:1168"$0$"		return MergedAnnotation.of(annotationType).getDefaultValue(attributeName).orElse(null);"
"AnnotationUtils.java:1169"$0$"	}"
"AnnotationUtils.java:1170"$0$""
"AnnotationUtils.java:1171"$0$"	/**"
"AnnotationUtils.java:1172"$1$"	 * <em>Synthesize</em> an annotation from the supplied {@code annotation}"
"AnnotationUtils.java:1173"$0$"	 * by wrapping it in a dynamic proxy that transparently enforces"
"AnnotationUtils.java:1174"$0$"	 * <em>attribute alias</em> semantics for annotation attributes that are"
"AnnotationUtils.java:1175"$1$"	 * annotated with {@link AliasFor @AliasFor}."
"AnnotationUtils.java:1176"$0$"	 * @param annotation the annotation to synthesize"
"AnnotationUtils.java:1177"$0$"	 * @param annotatedElement the element that is annotated with the supplied"
"AnnotationUtils.java:1178"$1$"	 * annotation; may be {@code null} if unknown"
"AnnotationUtils.java:1179"$0$"	 * @return the synthesized annotation if the supplied annotation is"
"AnnotationUtils.java:1180"$1$"	 * <em>synthesizable</em>; {@code null} if the supplied annotation is"
"AnnotationUtils.java:1181"$1$"	 * {@code null}; otherwise the supplied annotation unmodified"
"AnnotationUtils.java:1182"$0$"	 * @throws AnnotationConfigurationException if invalid configuration of"
"AnnotationUtils.java:1183"$1$"	 * {@code @AliasFor} is detected"
"AnnotationUtils.java:1184"$0$"	 * @since 4.2"
"AnnotationUtils.java:1185"$0$"	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)"
"AnnotationUtils.java:1186"$0$"	 * @see #synthesizeAnnotation(Class)"
"AnnotationUtils.java:1187"$0$"	 */"
"AnnotationUtils.java:1188"$0$"	public static <A extends Annotation> A synthesizeAnnotation("
"AnnotationUtils.java:1189"$1$"			A annotation, @Nullable AnnotatedElement annotatedElement) {"
"AnnotationUtils.java:1190"$1$""
"AnnotationUtils.java:1191"$1$"		if (annotation instanceof SynthesizedAnnotation || AnnotationFilter.PLAIN.matches(annotation)) {"
"AnnotationUtils.java:1192"$1$"			return annotation;"
"AnnotationUtils.java:1193"$1$"		}"
"AnnotationUtils.java:1194"$0$"		return MergedAnnotation.from(annotatedElement, annotation).synthesize();"
"AnnotationUtils.java:1195"$0$"	}"
"AnnotationUtils.java:1196"$0$""
"AnnotationUtils.java:1197"$0$"	/**"
"AnnotationUtils.java:1198"$0$"	 * <em>Synthesize</em> an annotation from its default attributes values."
"AnnotationUtils.java:1199"$0$"	 * <p>This method simply delegates to"
"AnnotationUtils.java:1200"$1$"	 * {@link #synthesizeAnnotation(Map, Class, AnnotatedElement)},"
"AnnotationUtils.java:1201"$1$"	 * supplying an empty map for the source attribute values and {@code null}"
"AnnotationUtils.java:1202"$1$"	 * for the {@link AnnotatedElement}."
"AnnotationUtils.java:1203"$0$"	 * @param annotationType the type of annotation to synthesize"
"AnnotationUtils.java:1204"$0$"	 * @return the synthesized annotation"
"AnnotationUtils.java:1205"$0$"	 * @throws IllegalArgumentException if a required attribute is missing"
"AnnotationUtils.java:1206"$0$"	 * @throws AnnotationConfigurationException if invalid configuration of"
"AnnotationUtils.java:1207"$1$"	 * {@code @AliasFor} is detected"
"AnnotationUtils.java:1208"$0$"	 * @since 4.2"
"AnnotationUtils.java:1209"$0$"	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)"
"AnnotationUtils.java:1210"$0$"	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)"
"AnnotationUtils.java:1211"$0$"	 */"
"AnnotationUtils.java:1212"$1$"	public static <A extends Annotation> A synthesizeAnnotation(Class<A> annotationType) {"
"AnnotationUtils.java:1213"$1$"		return synthesizeAnnotation(Collections.emptyMap(), annotationType, null);"
"AnnotationUtils.java:1214"$1$"	}"
"AnnotationUtils.java:1215"$0$""
"AnnotationUtils.java:1216"$0$"	/**"
"AnnotationUtils.java:1217"$0$"	 * <em>Synthesize</em> an annotation from the supplied map of annotation"
"AnnotationUtils.java:1218"$0$"	 * attributes by wrapping the map in a dynamic proxy that implements an"
"AnnotationUtils.java:1219"$1$"	 * annotation of the specified {@code annotationType} and transparently"
"AnnotationUtils.java:1220"$0$"	 * enforces <em>attribute alias</em> semantics for annotation attributes"
"AnnotationUtils.java:1221"$1$"	 * that are annotated with {@link AliasFor @AliasFor}."
"AnnotationUtils.java:1222"$0$"	 * <p>The supplied map must contain a key-value pair for every attribute"
"AnnotationUtils.java:1223"$1$"	 * defined in the supplied {@code annotationType} that is not aliased or"
"AnnotationUtils.java:1224"$0$"	 * does not have a default value. Nested maps and nested arrays of maps"
"AnnotationUtils.java:1225"$0$"	 * will be recursively synthesized into nested annotations or nested"
"AnnotationUtils.java:1226"$0$"	 * arrays of annotations, respectively."
"AnnotationUtils.java:1227"$1$"	 * <p>Note that {@link AnnotationAttributes} is a specialized type of"
"AnnotationUtils.java:1228"$1$"	 * {@link Map} that is an ideal candidate for this method's"
"AnnotationUtils.java:1229"$1$"	 * {@code attributes} argument."
"AnnotationUtils.java:1230"$0$"	 * @param attributes the map of annotation attributes to synthesize"
"AnnotationUtils.java:1231"$0$"	 * @param annotationType the type of annotation to synthesize"
"AnnotationUtils.java:1232"$0$"	 * @param annotatedElement the element that is annotated with the annotation"
"AnnotationUtils.java:1233"$1$"	 * corresponding to the supplied attributes; may be {@code null} if unknown"
"AnnotationUtils.java:1234"$0$"	 * @return the synthesized annotation"
"AnnotationUtils.java:1235"$0$"	 * @throws IllegalArgumentException if a required attribute is missing or if an"
"AnnotationUtils.java:1236"$0$"	 * attribute is not of the correct type"
"AnnotationUtils.java:1237"$0$"	 * @throws AnnotationConfigurationException if invalid configuration of"
"AnnotationUtils.java:1238"$1$"	 * {@code @AliasFor} is detected"
"AnnotationUtils.java:1239"$0$"	 * @since 4.2"
"AnnotationUtils.java:1240"$0$"	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)"
"AnnotationUtils.java:1241"$0$"	 * @see #synthesizeAnnotation(Class)"
"AnnotationUtils.java:1242"$0$"	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation)"
"AnnotationUtils.java:1243"$0$"	 * @see #getAnnotationAttributes(AnnotatedElement, Annotation, boolean, boolean)"
"AnnotationUtils.java:1244"$0$"	 */"
"AnnotationUtils.java:1245"$0$"	public static <A extends Annotation> A synthesizeAnnotation(Map<String, Object> attributes,"
"AnnotationUtils.java:1246"$1$"			Class<A> annotationType, @Nullable AnnotatedElement annotatedElement) {"
"AnnotationUtils.java:1247"$1$""
"AnnotationUtils.java:1248"$1$"		try {"
"AnnotationUtils.java:1249"$1$"			return MergedAnnotation.of(annotatedElement, annotationType, attributes).synthesize();"
"AnnotationUtils.java:1250"$1$"		}"
"AnnotationUtils.java:1251"$1$"		catch (NoSuchElementException | IllegalStateException ex) {"
"AnnotationUtils.java:1252"$1$"			throw new IllegalArgumentException(ex);"
"AnnotationUtils.java:1253"$1$"		}"
"AnnotationUtils.java:1254"$0$"	}"
"AnnotationUtils.java:1255"$0$""
"AnnotationUtils.java:1256"$0$"	/**"
"AnnotationUtils.java:1257"$0$"	 * <em>Synthesize</em> an array of annotations from the supplied array"
"AnnotationUtils.java:1258"$1$"	 * of {@code annotations} by creating a new array of the same size and"
"AnnotationUtils.java:1259"$1$"	 * type and populating it with {@linkplain #synthesizeAnnotation(Annotation,"
"AnnotationUtils.java:1260"$1$"	 * AnnotatedElement) synthesized} versions of the annotations from the input"
"AnnotationUtils.java:1261"$0$"	 * array."
"AnnotationUtils.java:1262"$0$"	 * @param annotations the array of annotations to synthesize"
"AnnotationUtils.java:1263"$0$"	 * @param annotatedElement the element that is annotated with the supplied"
"AnnotationUtils.java:1264"$1$"	 * array of annotations; may be {@code null} if unknown"
"AnnotationUtils.java:1265"$1$"	 * @return a new array of synthesized annotations, or {@code null} if"
"AnnotationUtils.java:1266"$1$"	 * the supplied array is {@code null}"
"AnnotationUtils.java:1267"$0$"	 * @throws AnnotationConfigurationException if invalid configuration of"
"AnnotationUtils.java:1268"$1$"	 * {@code @AliasFor} is detected"
"AnnotationUtils.java:1269"$0$"	 * @since 4.2"
"AnnotationUtils.java:1270"$0$"	 * @see #synthesizeAnnotation(Annotation, AnnotatedElement)"
"AnnotationUtils.java:1271"$0$"	 * @see #synthesizeAnnotation(Map, Class, AnnotatedElement)"
"AnnotationUtils.java:1272"$0$"	 */"
"AnnotationUtils.java:1273"$1$"	static Annotation[] synthesizeAnnotationArray(Annotation[] annotations, AnnotatedElement annotatedElement) {"
"AnnotationUtils.java:1274"$1$"		if (AnnotationsScanner.hasPlainJavaAnnotationsOnly(annotatedElement)) {"
"AnnotationUtils.java:1275"$1$"			return annotations;"
"AnnotationUtils.java:1276"$1$"		}"
"AnnotationUtils.java:1277"$0$"		Annotation[] synthesized = (Annotation[]) Array.newInstance("
"AnnotationUtils.java:1278"$0$"				annotations.getClass().getComponentType(), annotations.length);"
"AnnotationUtils.java:1279"$1$"		for (int i = 0; i < annotations.length; i++) {"
"AnnotationUtils.java:1280"$1$"			synthesized[i] = synthesizeAnnotation(annotations[i], annotatedElement);"
"AnnotationUtils.java:1281"$1$"		}"
"AnnotationUtils.java:1282"$0$"		return synthesized;"
"AnnotationUtils.java:1283"$0$"	}"
"AnnotationUtils.java:1284"$0$""
"AnnotationUtils.java:1285"$0$"	/**"
"AnnotationUtils.java:1286"$0$"	 * Clear the internal annotation metadata cache."
"AnnotationUtils.java:1287"$0$"	 * @since 4.3.15"
"AnnotationUtils.java:1288"$0$"	 */"
"AnnotationUtils.java:1289"$1$"	public static void clearCache() {"
"AnnotationUtils.java:1290"$1$"		AnnotationTypeMappings.clearCache();"
"AnnotationUtils.java:1291"$1$"		AnnotationsScanner.clearCache();"
"AnnotationUtils.java:1292"$1$"	}"
"AnnotationUtils.java:1293"$0$""
"AnnotationUtils.java:1294"$0$""
"AnnotationUtils.java:1295"$0$"	/**"
"AnnotationUtils.java:1296"$0$"	 * Internal holder used to wrap default values."
"AnnotationUtils.java:1297"$0$"	 */"
"AnnotationUtils.java:1298"$1$"	private static class DefaultValueHolder {"
"AnnotationUtils.java:1299"$1$""
"AnnotationUtils.java:1300"$1$"		final Object defaultValue;"
"AnnotationUtils.java:1301"$1$""
"AnnotationUtils.java:1302"$1$"		public DefaultValueHolder(Object defaultValue) {"
"AnnotationUtils.java:1303"$1$"			this.defaultValue = defaultValue;"
"AnnotationUtils.java:1304"$1$"		}"
"AnnotationUtils.java:1305"$0$""
"AnnotationUtils.java:1306"$0$"		@Override"
"AnnotationUtils.java:1307"$1$"		public String toString() {"
"AnnotationUtils.java:1308"$1$"			return ""*"" + this.defaultValue;"
"AnnotationUtils.java:1309"$1$"		}"
"AnnotationUtils.java:1310"$0$"	}"
"AnnotationUtils.java:1311"$0$""
"AnnotationUtils.java:1312"$0$"}"
"CompositeIterator.java:1"$0$"/*"
"CompositeIterator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"CompositeIterator.java:3"$0$" *"
"CompositeIterator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CompositeIterator.java:5"$0$" * you may not use this file except in compliance with the License."
"CompositeIterator.java:6"$0$" * You may obtain a copy of the License at"
"CompositeIterator.java:7"$0$" *"
"CompositeIterator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CompositeIterator.java:9"$0$" *"
"CompositeIterator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CompositeIterator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CompositeIterator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CompositeIterator.java:13"$0$" * See the License for the specific language governing permissions and"
"CompositeIterator.java:14"$0$" * limitations under the License."
"CompositeIterator.java:15"$0$" */"
"CompositeIterator.java:16"$0$""
"CompositeIterator.java:17"$0$"package org.springframework.util;"
"CompositeIterator.java:18"$0$""
"CompositeIterator.java:19"$0$"import java.util.Iterator;"
"CompositeIterator.java:20"$0$"import java.util.LinkedHashSet;"
"CompositeIterator.java:21"$0$"import java.util.NoSuchElementException;"
"CompositeIterator.java:22"$0$"import java.util.Set;"
"CompositeIterator.java:23"$0$""
"CompositeIterator.java:24"$0$"/**"
"CompositeIterator.java:25"$0$" * Composite iterator that combines multiple other iterators,"
"CompositeIterator.java:26"$1$" * as registered via {@link #add(Iterator)}."
"CompositeIterator.java:27"$0$" *"
"CompositeIterator.java:28"$0$" * <p>This implementation maintains a linked set of iterators"
"CompositeIterator.java:29"$0$" * which are invoked in sequence until all iterators are exhausted."
"CompositeIterator.java:30"$0$" *"
"CompositeIterator.java:31"$0$" * @author Erwin Vervaet"
"CompositeIterator.java:32"$0$" * @author Juergen Hoeller"
"CompositeIterator.java:33"$0$" * @since 3.0"
"CompositeIterator.java:34"$0$" * @param <E> the element type"
"CompositeIterator.java:35"$0$" */"
"CompositeIterator.java:36"$1$"public class CompositeIterator<E> implements Iterator<E> {"
"CompositeIterator.java:37"$1$""
"CompositeIterator.java:38"$1$"	private final Set<Iterator<E>> iterators = new LinkedHashSet<>();"
"CompositeIterator.java:39"$1$""
"CompositeIterator.java:40"$1$"	private boolean inUse = false;"
"CompositeIterator.java:41"$1$""
"CompositeIterator.java:42"$1$""
"CompositeIterator.java:43"$1$"	/**"
"CompositeIterator.java:44"$1$"	 * Add given iterator to this composite."
"CompositeIterator.java:45"$1$"	 */"
"CompositeIterator.java:46"$1$"	public void add(Iterator<E> iterator) {"
"CompositeIterator.java:47"$1$"		Assert.state(!this.inUse, ""You can no longer add iterators to a composite iterator that's already in use"");"
"CompositeIterator.java:48"$1$"		if (this.iterators.contains(iterator)) {"
"CompositeIterator.java:49"$1$"			throw new IllegalArgumentException(""You cannot add the same iterator twice"");"
"CompositeIterator.java:50"$1$"		}"
"CompositeIterator.java:51"$0$"		this.iterators.add(iterator);"
"CompositeIterator.java:52"$0$"	}"
"CompositeIterator.java:53"$0$""
"CompositeIterator.java:54"$0$"	@Override"
"CompositeIterator.java:55"$1$"	public boolean hasNext() {"
"CompositeIterator.java:56"$1$"		this.inUse = true;"
"CompositeIterator.java:57"$1$"		for (Iterator<E> iterator : this.iterators) {"
"CompositeIterator.java:58"$1$"			if (iterator.hasNext()) {"
"CompositeIterator.java:59"$1$"				return true;"
"CompositeIterator.java:60"$1$"			}"
"CompositeIterator.java:61"$0$"		}"
"CompositeIterator.java:62"$0$"		return false;"
"CompositeIterator.java:63"$0$"	}"
"CompositeIterator.java:64"$0$""
"CompositeIterator.java:65"$0$"	@Override"
"CompositeIterator.java:66"$1$"	public E next() {"
"CompositeIterator.java:67"$1$"		this.inUse = true;"
"CompositeIterator.java:68"$1$"		for (Iterator<E> iterator : this.iterators) {"
"CompositeIterator.java:69"$1$"			if (iterator.hasNext()) {"
"CompositeIterator.java:70"$1$"				return iterator.next();"
"CompositeIterator.java:71"$1$"			}"
"CompositeIterator.java:72"$0$"		}"
"CompositeIterator.java:73"$0$"		throw new NoSuchElementException(""All iterators exhausted"");"
"CompositeIterator.java:74"$0$"	}"
"CompositeIterator.java:75"$0$""
"CompositeIterator.java:76"$0$"	@Override"
"CompositeIterator.java:77"$1$"	public void remove() {"
"CompositeIterator.java:78"$1$"		throw new UnsupportedOperationException(""CompositeIterator does not support remove()"");"
"CompositeIterator.java:79"$1$"	}"
"CompositeIterator.java:80"$0$""
"CompositeIterator.java:81"$0$"}"
"Assert.java:1"$0$"/*"
"Assert.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"Assert.java:3"$0$" *"
"Assert.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Assert.java:5"$0$" * you may not use this file except in compliance with the License."
"Assert.java:6"$0$" * You may obtain a copy of the License at"
"Assert.java:7"$0$" *"
"Assert.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Assert.java:9"$0$" *"
"Assert.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Assert.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Assert.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Assert.java:13"$0$" * See the License for the specific language governing permissions and"
"Assert.java:14"$0$" * limitations under the License."
"Assert.java:15"$0$" */"
"Assert.java:16"$0$""
"Assert.java:17"$0$"package org.springframework.util;"
"Assert.java:18"$0$""
"Assert.java:19"$0$"import java.util.Collection;"
"Assert.java:20"$0$"import java.util.Map;"
"Assert.java:21"$0$"import java.util.function.Supplier;"
"Assert.java:22"$0$""
"Assert.java:23"$0$"import org.springframework.lang.Nullable;"
"Assert.java:24"$0$""
"Assert.java:25"$0$"/**"
"Assert.java:26"$0$" * Assertion utility class that assists in validating arguments."
"Assert.java:27"$0$" *"
"Assert.java:28"$0$" * <p>Useful for identifying programmer errors early and clearly at runtime."
"Assert.java:29"$0$" *"
"Assert.java:30"$0$" * <p>For example, if the contract of a public method states it does not"
"Assert.java:31"$1$" * allow {@code null} arguments, {@code Assert} can be used to validate that"
"Assert.java:32"$0$" * contract. Doing this clearly indicates a contract violation when it"
"Assert.java:33"$0$" * occurs and protects the class's invariants."
"Assert.java:34"$0$" *"
"Assert.java:35"$0$" * <p>Typically used to validate method arguments rather than configuration"
"Assert.java:36"$0$" * properties, to check for cases that are usually programmer errors rather"
"Assert.java:37"$0$" * than configuration errors. In contrast to configuration initialization"
"Assert.java:38"$0$" * code, there is usually no point in falling back to defaults in such methods."
"Assert.java:39"$0$" *"
"Assert.java:40"$0$" * <p>This class is similar to JUnit's assertion library. If an argument value is"
"Assert.java:41"$1$" * deemed invalid, an {@link IllegalArgumentException} is thrown (typically)."
"Assert.java:42"$0$" * For example:"
"Assert.java:43"$0$" *"
"Assert.java:44"$0$" * <pre class=""code"">"
"Assert.java:45"$0$" * Assert.notNull(clazz, ""The class must not be null"");"
"Assert.java:46"$0$" * Assert.isTrue(i > 0, ""The value must be greater than zero"");</pre>"
"Assert.java:47"$0$" *"
"Assert.java:48"$0$" * <p>Mainly for internal use within the framework; consider"
"Assert.java:49"$0$" * <a href=""https://commons.apache.org/proper/commons-lang/"">Apache's Commons Lang</a>"
"Assert.java:50"$1$" * for a more comprehensive suite of {@code String} utilities."
"Assert.java:51"$0$" *"
"Assert.java:52"$0$" * @author Keith Donald"
"Assert.java:53"$0$" * @author Juergen Hoeller"
"Assert.java:54"$0$" * @author Sam Brannen"
"Assert.java:55"$0$" * @author Colin Sampaleanu"
"Assert.java:56"$0$" * @author Rob Harrop"
"Assert.java:57"$0$" * @since 1.1.2"
"Assert.java:58"$0$" */"
"Assert.java:59"$1$"public abstract class Assert {"
"Assert.java:60"$1$""
"Assert.java:61"$1$"	/**"
"Assert.java:62"$1$"	 * Assert a boolean expression, throwing an {@code IllegalStateException}"
"Assert.java:63"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:64"$1$"	 * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}"
"Assert.java:65"$1$"	 * on an assertion failure."
"Assert.java:66"$1$"	 * <pre class=""code"">Assert.state(id == null, ""The id property must not already be initialized"");</pre>"
"Assert.java:67"$1$"	 * @param expression a boolean expression"
"Assert.java:68"$1$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:69"$1$"	 * @throws IllegalStateException if {@code expression} is {@code false}"
"Assert.java:70"$1$"	 */"
"Assert.java:71"$1$"	public static void state(boolean expression, String message) {"
"Assert.java:72"$1$"		if (!expression) {"
"Assert.java:73"$1$"			throw new IllegalStateException(message);"
"Assert.java:74"$1$"		}"
"Assert.java:75"$0$"	}"
"Assert.java:76"$0$""
"Assert.java:77"$0$"	/**"
"Assert.java:78"$1$"	 * Assert a boolean expression, throwing an {@code IllegalStateException}"
"Assert.java:79"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:80"$1$"	 * <p>Call {@link #isTrue} if you wish to throw an {@code IllegalArgumentException}"
"Assert.java:81"$0$"	 * on an assertion failure."
"Assert.java:82"$0$"	 * <pre class=""code"">"
"Assert.java:83"$0$"	 * Assert.state(id == null,"
"Assert.java:84"$0$"	 *     () -&gt; ""ID for "" + entity.getName() + "" must not already be initialized"");"
"Assert.java:85"$0$"	 * </pre>"
"Assert.java:86"$0$"	 * @param expression a boolean expression"
"Assert.java:87"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:88"$0$"	 * assertion fails"
"Assert.java:89"$1$"	 * @throws IllegalStateException if {@code expression} is {@code false}"
"Assert.java:90"$0$"	 * @since 5.0"
"Assert.java:91"$0$"	 */"
"Assert.java:92"$1$"	public static void state(boolean expression, Supplier<String> messageSupplier) {"
"Assert.java:93"$1$"		if (!expression) {"
"Assert.java:94"$1$"			throw new IllegalStateException(nullSafeGet(messageSupplier));"
"Assert.java:95"$1$"		}"
"Assert.java:96"$0$"	}"
"Assert.java:97"$0$""
"Assert.java:98"$0$"	/**"
"Assert.java:99"$1$"	 * Assert a boolean expression, throwing an {@code IllegalStateException}"
"Assert.java:100"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:101"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #state(boolean, String)}"
"Assert.java:102"$0$"	 */"
"Assert.java:103"$0$"	@Deprecated"
"Assert.java:104"$1$"	public static void state(boolean expression) {"
"Assert.java:105"$1$"		state(expression, ""[Assertion failed] - this state invariant must be true"");"
"Assert.java:106"$1$"	}"
"Assert.java:107"$0$""
"Assert.java:108"$0$"	/**"
"Assert.java:109"$1$"	 * Assert a boolean expression, throwing an {@code IllegalArgumentException}"
"Assert.java:110"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:111"$0$"	 * <pre class=""code"">Assert.isTrue(i &gt; 0, ""The value must be greater than zero"");</pre>"
"Assert.java:112"$0$"	 * @param expression a boolean expression"
"Assert.java:113"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:114"$1$"	 * @throws IllegalArgumentException if {@code expression} is {@code false}"
"Assert.java:115"$0$"	 */"
"Assert.java:116"$1$"	public static void isTrue(boolean expression, String message) {"
"Assert.java:117"$1$"		if (!expression) {"
"Assert.java:118"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:119"$1$"		}"
"Assert.java:120"$0$"	}"
"Assert.java:121"$0$""
"Assert.java:122"$0$"	/**"
"Assert.java:123"$1$"	 * Assert a boolean expression, throwing an {@code IllegalArgumentException}"
"Assert.java:124"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:125"$0$"	 * <pre class=""code"">"
"Assert.java:126"$0$"	 * Assert.isTrue(i &gt; 0, () -&gt; ""The value '"" + i + ""' must be greater than zero"");"
"Assert.java:127"$0$"	 * </pre>"
"Assert.java:128"$0$"	 * @param expression a boolean expression"
"Assert.java:129"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:130"$0$"	 * assertion fails"
"Assert.java:131"$1$"	 * @throws IllegalArgumentException if {@code expression} is {@code false}"
"Assert.java:132"$0$"	 * @since 5.0"
"Assert.java:133"$0$"	 */"
"Assert.java:134"$1$"	public static void isTrue(boolean expression, Supplier<String> messageSupplier) {"
"Assert.java:135"$1$"		if (!expression) {"
"Assert.java:136"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:137"$1$"		}"
"Assert.java:138"$0$"	}"
"Assert.java:139"$0$""
"Assert.java:140"$0$"	/**"
"Assert.java:141"$1$"	 * Assert a boolean expression, throwing an {@code IllegalArgumentException}"
"Assert.java:142"$1$"	 * if the expression evaluates to {@code false}."
"Assert.java:143"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #isTrue(boolean, String)}"
"Assert.java:144"$0$"	 */"
"Assert.java:145"$0$"	@Deprecated"
"Assert.java:146"$1$"	public static void isTrue(boolean expression) {"
"Assert.java:147"$1$"		isTrue(expression, ""[Assertion failed] - this expression must be true"");"
"Assert.java:148"$1$"	}"
"Assert.java:149"$0$""
"Assert.java:150"$0$"	/**"
"Assert.java:151"$1$"	 * Assert that an object is {@code null}."
"Assert.java:152"$0$"	 * <pre class=""code"">Assert.isNull(value, ""The value must be null"");</pre>"
"Assert.java:153"$0$"	 * @param object the object to check"
"Assert.java:154"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:155"$1$"	 * @throws IllegalArgumentException if the object is not {@code null}"
"Assert.java:156"$0$"	 */"
"Assert.java:157"$1$"	public static void isNull(@Nullable Object object, String message) {"
"Assert.java:158"$1$"		if (object != null) {"
"Assert.java:159"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:160"$1$"		}"
"Assert.java:161"$0$"	}"
"Assert.java:162"$0$""
"Assert.java:163"$0$"	/**"
"Assert.java:164"$1$"	 * Assert that an object is {@code null}."
"Assert.java:165"$0$"	 * <pre class=""code"">"
"Assert.java:166"$0$"	 * Assert.isNull(value, () -&gt; ""The value '"" + value + ""' must be null"");"
"Assert.java:167"$0$"	 * </pre>"
"Assert.java:168"$0$"	 * @param object the object to check"
"Assert.java:169"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:170"$0$"	 * assertion fails"
"Assert.java:171"$1$"	 * @throws IllegalArgumentException if the object is not {@code null}"
"Assert.java:172"$0$"	 * @since 5.0"
"Assert.java:173"$0$"	 */"
"Assert.java:174"$1$"	public static void isNull(@Nullable Object object, Supplier<String> messageSupplier) {"
"Assert.java:175"$1$"		if (object != null) {"
"Assert.java:176"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:177"$1$"		}"
"Assert.java:178"$0$"	}"
"Assert.java:179"$0$""
"Assert.java:180"$0$"	/**"
"Assert.java:181"$1$"	 * Assert that an object is {@code null}."
"Assert.java:182"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #isNull(Object, String)}"
"Assert.java:183"$0$"	 */"
"Assert.java:184"$0$"	@Deprecated"
"Assert.java:185"$1$"	public static void isNull(@Nullable Object object) {"
"Assert.java:186"$1$"		isNull(object, ""[Assertion failed] - the object argument must be null"");"
"Assert.java:187"$1$"	}"
"Assert.java:188"$0$""
"Assert.java:189"$0$"	/**"
"Assert.java:190"$1$"	 * Assert that an object is not {@code null}."
"Assert.java:191"$0$"	 * <pre class=""code"">Assert.notNull(clazz, ""The class must not be null"");</pre>"
"Assert.java:192"$0$"	 * @param object the object to check"
"Assert.java:193"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:194"$1$"	 * @throws IllegalArgumentException if the object is {@code null}"
"Assert.java:195"$0$"	 */"
"Assert.java:196"$1$"	public static void notNull(@Nullable Object object, String message) {"
"Assert.java:197"$1$"		if (object == null) {"
"Assert.java:198"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:199"$1$"		}"
"Assert.java:200"$0$"	}"
"Assert.java:201"$0$""
"Assert.java:202"$0$"	/**"
"Assert.java:203"$1$"	 * Assert that an object is not {@code null}."
"Assert.java:204"$0$"	 * <pre class=""code"">"
"Assert.java:205"$0$"	 * Assert.notNull(clazz, () -&gt; ""The class '"" + clazz.getName() + ""' must not be null"");"
"Assert.java:206"$0$"	 * </pre>"
"Assert.java:207"$0$"	 * @param object the object to check"
"Assert.java:208"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:209"$0$"	 * assertion fails"
"Assert.java:210"$1$"	 * @throws IllegalArgumentException if the object is {@code null}"
"Assert.java:211"$0$"	 * @since 5.0"
"Assert.java:212"$0$"	 */"
"Assert.java:213"$1$"	public static void notNull(@Nullable Object object, Supplier<String> messageSupplier) {"
"Assert.java:214"$1$"		if (object == null) {"
"Assert.java:215"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:216"$1$"		}"
"Assert.java:217"$0$"	}"
"Assert.java:218"$0$""
"Assert.java:219"$0$"	/**"
"Assert.java:220"$1$"	 * Assert that an object is not {@code null}."
"Assert.java:221"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #notNull(Object, String)}"
"Assert.java:222"$0$"	 */"
"Assert.java:223"$0$"	@Deprecated"
"Assert.java:224"$1$"	public static void notNull(@Nullable Object object) {"
"Assert.java:225"$1$"		notNull(object, ""[Assertion failed] - this argument is required; it must not be null"");"
"Assert.java:226"$1$"	}"
"Assert.java:227"$0$""
"Assert.java:228"$0$"	/**"
"Assert.java:229"$0$"	 * Assert that the given String is not empty; that is,"
"Assert.java:230"$1$"	 * it must not be {@code null} and not the empty String."
"Assert.java:231"$0$"	 * <pre class=""code"">Assert.hasLength(name, ""Name must not be empty"");</pre>"
"Assert.java:232"$0$"	 * @param text the String to check"
"Assert.java:233"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:234"$0$"	 * @throws IllegalArgumentException if the text is empty"
"Assert.java:235"$0$"	 * @see StringUtils#hasLength"
"Assert.java:236"$0$"	 */"
"Assert.java:237"$1$"	public static void hasLength(@Nullable String text, String message) {"
"Assert.java:238"$1$"		if (!StringUtils.hasLength(text)) {"
"Assert.java:239"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:240"$1$"		}"
"Assert.java:241"$0$"	}"
"Assert.java:242"$0$""
"Assert.java:243"$0$"	/**"
"Assert.java:244"$0$"	 * Assert that the given String is not empty; that is,"
"Assert.java:245"$1$"	 * it must not be {@code null} and not the empty String."
"Assert.java:246"$0$"	 * <pre class=""code"">"
"Assert.java:247"$0$"	 * Assert.hasLength(name, () -&gt; ""Name for account '"" + account.getId() + ""' must not be empty"");"
"Assert.java:248"$0$"	 * </pre>"
"Assert.java:249"$0$"	 * @param text the String to check"
"Assert.java:250"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:251"$0$"	 * assertion fails"
"Assert.java:252"$0$"	 * @throws IllegalArgumentException if the text is empty"
"Assert.java:253"$0$"	 * @since 5.0"
"Assert.java:254"$0$"	 * @see StringUtils#hasLength"
"Assert.java:255"$0$"	 */"
"Assert.java:256"$1$"	public static void hasLength(@Nullable String text, Supplier<String> messageSupplier) {"
"Assert.java:257"$1$"		if (!StringUtils.hasLength(text)) {"
"Assert.java:258"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:259"$1$"		}"
"Assert.java:260"$0$"	}"
"Assert.java:261"$0$""
"Assert.java:262"$0$"	/**"
"Assert.java:263"$0$"	 * Assert that the given String is not empty; that is,"
"Assert.java:264"$1$"	 * it must not be {@code null} and not the empty String."
"Assert.java:265"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #hasLength(String, String)}"
"Assert.java:266"$0$"	 */"
"Assert.java:267"$0$"	@Deprecated"
"Assert.java:268"$1$"	public static void hasLength(@Nullable String text) {"
"Assert.java:269"$1$"		hasLength(text,"
"Assert.java:270"$1$"				""[Assertion failed] - this String argument must have length; it must not be null or empty"");"
"Assert.java:271"$1$"	}"
"Assert.java:272"$0$""
"Assert.java:273"$0$"	/**"
"Assert.java:274"$0$"	 * Assert that the given String contains valid text content; that is, it must not"
"Assert.java:275"$1$"	 * be {@code null} and must contain at least one non-whitespace character."
"Assert.java:276"$0$"	 * <pre class=""code"">Assert.hasText(name, ""'name' must not be empty"");</pre>"
"Assert.java:277"$0$"	 * @param text the String to check"
"Assert.java:278"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:279"$0$"	 * @throws IllegalArgumentException if the text does not contain valid text content"
"Assert.java:280"$0$"	 * @see StringUtils#hasText"
"Assert.java:281"$0$"	 */"
"Assert.java:282"$1$"	public static void hasText(@Nullable String text, String message) {"
"Assert.java:283"$1$"		if (!StringUtils.hasText(text)) {"
"Assert.java:284"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:285"$1$"		}"
"Assert.java:286"$0$"	}"
"Assert.java:287"$0$""
"Assert.java:288"$0$"	/**"
"Assert.java:289"$0$"	 * Assert that the given String contains valid text content; that is, it must not"
"Assert.java:290"$1$"	 * be {@code null} and must contain at least one non-whitespace character."
"Assert.java:291"$0$"	 * <pre class=""code"">"
"Assert.java:292"$0$"	 * Assert.hasText(name, () -&gt; ""Name for account '"" + account.getId() + ""' must not be empty"");"
"Assert.java:293"$0$"	 * </pre>"
"Assert.java:294"$0$"	 * @param text the String to check"
"Assert.java:295"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:296"$0$"	 * assertion fails"
"Assert.java:297"$0$"	 * @throws IllegalArgumentException if the text does not contain valid text content"
"Assert.java:298"$0$"	 * @since 5.0"
"Assert.java:299"$0$"	 * @see StringUtils#hasText"
"Assert.java:300"$0$"	 */"
"Assert.java:301"$1$"	public static void hasText(@Nullable String text, Supplier<String> messageSupplier) {"
"Assert.java:302"$1$"		if (!StringUtils.hasText(text)) {"
"Assert.java:303"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:304"$1$"		}"
"Assert.java:305"$0$"	}"
"Assert.java:306"$0$""
"Assert.java:307"$0$"	/**"
"Assert.java:308"$0$"	 * Assert that the given String contains valid text content; that is, it must not"
"Assert.java:309"$1$"	 * be {@code null} and must contain at least one non-whitespace character."
"Assert.java:310"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #hasText(String, String)}"
"Assert.java:311"$0$"	 */"
"Assert.java:312"$0$"	@Deprecated"
"Assert.java:313"$1$"	public static void hasText(@Nullable String text) {"
"Assert.java:314"$1$"		hasText(text,"
"Assert.java:315"$1$"				""[Assertion failed] - this String argument must have text; it must not be null, empty, or blank"");"
"Assert.java:316"$1$"	}"
"Assert.java:317"$0$""
"Assert.java:318"$0$"	/**"
"Assert.java:319"$0$"	 * Assert that the given text does not contain the given substring."
"Assert.java:320"$0$"	 * <pre class=""code"">Assert.doesNotContain(name, ""rod"", ""Name must not contain 'rod'"");</pre>"
"Assert.java:321"$0$"	 * @param textToSearch the text to search"
"Assert.java:322"$0$"	 * @param substring the substring to find within the text"
"Assert.java:323"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:324"$0$"	 * @throws IllegalArgumentException if the text contains the substring"
"Assert.java:325"$0$"	 */"
"Assert.java:326"$1$"	public static void doesNotContain(@Nullable String textToSearch, String substring, String message) {"
"Assert.java:327"$1$"		if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&"
"Assert.java:328"$1$"				textToSearch.contains(substring)) {"
"Assert.java:329"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:330"$1$"		}"
"Assert.java:331"$0$"	}"
"Assert.java:332"$0$""
"Assert.java:333"$0$"	/**"
"Assert.java:334"$0$"	 * Assert that the given text does not contain the given substring."
"Assert.java:335"$0$"	 * <pre class=""code"">"
"Assert.java:336"$0$"	 * Assert.doesNotContain(name, forbidden, () -&gt; ""Name must not contain '"" + forbidden + ""'"");"
"Assert.java:337"$0$"	 * </pre>"
"Assert.java:338"$0$"	 * @param textToSearch the text to search"
"Assert.java:339"$0$"	 * @param substring the substring to find within the text"
"Assert.java:340"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:341"$0$"	 * assertion fails"
"Assert.java:342"$0$"	 * @throws IllegalArgumentException if the text contains the substring"
"Assert.java:343"$0$"	 * @since 5.0"
"Assert.java:344"$0$"	 */"
"Assert.java:345"$1$"	public static void doesNotContain(@Nullable String textToSearch, String substring, Supplier<String> messageSupplier) {"
"Assert.java:346"$1$"		if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring) &&"
"Assert.java:347"$1$"				textToSearch.contains(substring)) {"
"Assert.java:348"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:349"$1$"		}"
"Assert.java:350"$0$"	}"
"Assert.java:351"$0$""
"Assert.java:352"$0$"	/**"
"Assert.java:353"$0$"	 * Assert that the given text does not contain the given substring."
"Assert.java:354"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #doesNotContain(String, String, String)}"
"Assert.java:355"$0$"	 */"
"Assert.java:356"$0$"	@Deprecated"
"Assert.java:357"$1$"	public static void doesNotContain(@Nullable String textToSearch, String substring) {"
"Assert.java:358"$1$"		doesNotContain(textToSearch, substring,"
"Assert.java:359"$1$"				() -> ""[Assertion failed] - this String argument must not contain the substring ["" + substring + ""]"");"
"Assert.java:360"$1$"	}"
"Assert.java:361"$0$""
"Assert.java:362"$0$"	/**"
"Assert.java:363"$0$"	 * Assert that an array contains elements; that is, it must not be"
"Assert.java:364"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:365"$0$"	 * <pre class=""code"">Assert.notEmpty(array, ""The array must contain elements"");</pre>"
"Assert.java:366"$0$"	 * @param array the array to check"
"Assert.java:367"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:368"$1$"	 * @throws IllegalArgumentException if the object array is {@code null} or contains no elements"
"Assert.java:369"$0$"	 */"
"Assert.java:370"$1$"	public static void notEmpty(@Nullable Object[] array, String message) {"
"Assert.java:371"$1$"		if (ObjectUtils.isEmpty(array)) {"
"Assert.java:372"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:373"$1$"		}"
"Assert.java:374"$0$"	}"
"Assert.java:375"$0$""
"Assert.java:376"$0$"	/**"
"Assert.java:377"$0$"	 * Assert that an array contains elements; that is, it must not be"
"Assert.java:378"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:379"$0$"	 * <pre class=""code"">"
"Assert.java:380"$0$"	 * Assert.notEmpty(array, () -&gt; ""The "" + arrayType + "" array must contain elements"");"
"Assert.java:381"$0$"	 * </pre>"
"Assert.java:382"$0$"	 * @param array the array to check"
"Assert.java:383"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:384"$0$"	 * assertion fails"
"Assert.java:385"$1$"	 * @throws IllegalArgumentException if the object array is {@code null} or contains no elements"
"Assert.java:386"$0$"	 * @since 5.0"
"Assert.java:387"$0$"	 */"
"Assert.java:388"$1$"	public static void notEmpty(@Nullable Object[] array, Supplier<String> messageSupplier) {"
"Assert.java:389"$1$"		if (ObjectUtils.isEmpty(array)) {"
"Assert.java:390"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:391"$1$"		}"
"Assert.java:392"$0$"	}"
"Assert.java:393"$0$""
"Assert.java:394"$0$"	/**"
"Assert.java:395"$0$"	 * Assert that an array contains elements; that is, it must not be"
"Assert.java:396"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:397"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Object[], String)}"
"Assert.java:398"$0$"	 */"
"Assert.java:399"$0$"	@Deprecated"
"Assert.java:400"$1$"	public static void notEmpty(@Nullable Object[] array) {"
"Assert.java:401"$1$"		notEmpty(array, ""[Assertion failed] - this array must not be empty: it must contain at least 1 element"");"
"Assert.java:402"$1$"	}"
"Assert.java:403"$0$""
"Assert.java:404"$0$"	/**"
"Assert.java:405"$1$"	 * Assert that an array contains no {@code null} elements."
"Assert.java:406"$0$"	 * <p>Note: Does not complain if the array is empty!"
"Assert.java:407"$0$"	 * <pre class=""code"">Assert.noNullElements(array, ""The array must contain non-null elements"");</pre>"
"Assert.java:408"$0$"	 * @param array the array to check"
"Assert.java:409"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:410"$1$"	 * @throws IllegalArgumentException if the object array contains a {@code null} element"
"Assert.java:411"$0$"	 */"
"Assert.java:412"$1$"	public static void noNullElements(@Nullable Object[] array, String message) {"
"Assert.java:413"$1$"		if (array != null) {"
"Assert.java:414"$1$"			for (Object element : array) {"
"Assert.java:415"$1$"				if (element == null) {"
"Assert.java:416"$1$"					throw new IllegalArgumentException(message);"
"Assert.java:417"$1$"				}"
"Assert.java:418"$0$"			}"
"Assert.java:419"$0$"		}"
"Assert.java:420"$0$"	}"
"Assert.java:421"$0$""
"Assert.java:422"$0$"	/**"
"Assert.java:423"$1$"	 * Assert that an array contains no {@code null} elements."
"Assert.java:424"$0$"	 * <p>Note: Does not complain if the array is empty!"
"Assert.java:425"$0$"	 * <pre class=""code"">"
"Assert.java:426"$0$"	 * Assert.noNullElements(array, () -&gt; ""The "" + arrayType + "" array must contain non-null elements"");"
"Assert.java:427"$0$"	 * </pre>"
"Assert.java:428"$0$"	 * @param array the array to check"
"Assert.java:429"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:430"$0$"	 * assertion fails"
"Assert.java:431"$1$"	 * @throws IllegalArgumentException if the object array contains a {@code null} element"
"Assert.java:432"$0$"	 * @since 5.0"
"Assert.java:433"$0$"	 */"
"Assert.java:434"$1$"	public static void noNullElements(@Nullable Object[] array, Supplier<String> messageSupplier) {"
"Assert.java:435"$1$"		if (array != null) {"
"Assert.java:436"$1$"			for (Object element : array) {"
"Assert.java:437"$1$"				if (element == null) {"
"Assert.java:438"$1$"					throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:439"$1$"				}"
"Assert.java:440"$0$"			}"
"Assert.java:441"$0$"		}"
"Assert.java:442"$0$"	}"
"Assert.java:443"$0$""
"Assert.java:444"$0$"	/**"
"Assert.java:445"$1$"	 * Assert that an array contains no {@code null} elements."
"Assert.java:446"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #noNullElements(Object[], String)}"
"Assert.java:447"$0$"	 */"
"Assert.java:448"$0$"	@Deprecated"
"Assert.java:449"$1$"	public static void noNullElements(@Nullable Object[] array) {"
"Assert.java:450"$1$"		noNullElements(array, ""[Assertion failed] - this array must not contain any null elements"");"
"Assert.java:451"$1$"	}"
"Assert.java:452"$0$""
"Assert.java:453"$0$"	/**"
"Assert.java:454"$0$"	 * Assert that a collection contains elements; that is, it must not be"
"Assert.java:455"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:456"$0$"	 * <pre class=""code"">Assert.notEmpty(collection, ""Collection must contain elements"");</pre>"
"Assert.java:457"$0$"	 * @param collection the collection to check"
"Assert.java:458"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:459"$1$"	 * @throws IllegalArgumentException if the collection is {@code null} or"
"Assert.java:460"$0$"	 * contains no elements"
"Assert.java:461"$0$"	 */"
"Assert.java:462"$1$"	public static void notEmpty(@Nullable Collection<?> collection, String message) {"
"Assert.java:463"$1$"		if (CollectionUtils.isEmpty(collection)) {"
"Assert.java:464"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:465"$1$"		}"
"Assert.java:466"$0$"	}"
"Assert.java:467"$0$""
"Assert.java:468"$0$"	/**"
"Assert.java:469"$0$"	 * Assert that a collection contains elements; that is, it must not be"
"Assert.java:470"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:471"$0$"	 * <pre class=""code"">"
"Assert.java:472"$0$"	 * Assert.notEmpty(collection, () -&gt; ""The "" + collectionType + "" collection must contain elements"");"
"Assert.java:473"$0$"	 * </pre>"
"Assert.java:474"$0$"	 * @param collection the collection to check"
"Assert.java:475"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:476"$0$"	 * assertion fails"
"Assert.java:477"$1$"	 * @throws IllegalArgumentException if the collection is {@code null} or"
"Assert.java:478"$0$"	 * contains no elements"
"Assert.java:479"$0$"	 * @since 5.0"
"Assert.java:480"$0$"	 */"
"Assert.java:481"$1$"	public static void notEmpty(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {"
"Assert.java:482"$1$"		if (CollectionUtils.isEmpty(collection)) {"
"Assert.java:483"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:484"$1$"		}"
"Assert.java:485"$0$"	}"
"Assert.java:486"$0$""
"Assert.java:487"$0$"	/**"
"Assert.java:488"$0$"	 * Assert that a collection contains elements; that is, it must not be"
"Assert.java:489"$1$"	 * {@code null} and must contain at least one element."
"Assert.java:490"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Collection, String)}"
"Assert.java:491"$0$"	 */"
"Assert.java:492"$0$"	@Deprecated"
"Assert.java:493"$1$"	public static void notEmpty(@Nullable Collection<?> collection) {"
"Assert.java:494"$1$"		notEmpty(collection,"
"Assert.java:495"$1$"				""[Assertion failed] - this collection must not be empty: it must contain at least 1 element"");"
"Assert.java:496"$1$"	}"
"Assert.java:497"$0$""
"Assert.java:498"$0$"	/**"
"Assert.java:499"$1$"	 * Assert that a collection contains no {@code null} elements."
"Assert.java:500"$0$"	 * <p>Note: Does not complain if the collection is empty!"
"Assert.java:501"$0$"	 * <pre class=""code"">Assert.noNullElements(collection, ""Collection must contain non-null elements"");</pre>"
"Assert.java:502"$0$"	 * @param collection the collection to check"
"Assert.java:503"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:504"$1$"	 * @throws IllegalArgumentException if the collection contains a {@code null} element"
"Assert.java:505"$0$"	 * @since 5.2"
"Assert.java:506"$0$"	 */"
"Assert.java:507"$1$"	public static void noNullElements(@Nullable Collection<?> collection, String message) {"
"Assert.java:508"$1$"		if (collection != null) {"
"Assert.java:509"$1$"			for (Object element : collection) {"
"Assert.java:510"$1$"				if (element == null) {"
"Assert.java:511"$1$"					throw new IllegalArgumentException(message);"
"Assert.java:512"$1$"				}"
"Assert.java:513"$0$"			}"
"Assert.java:514"$0$"		}"
"Assert.java:515"$0$"	}"
"Assert.java:516"$0$""
"Assert.java:517"$0$"	/**"
"Assert.java:518"$1$"	 * Assert that a collection contains no {@code null} elements."
"Assert.java:519"$0$"	 * <p>Note: Does not complain if the collection is empty!"
"Assert.java:520"$0$"	 * <pre class=""code"">"
"Assert.java:521"$0$"	 * Assert.noNullElements(collection, () -&gt; ""Collection "" + collectionName + "" must contain non-null elements"");"
"Assert.java:522"$0$"	 * </pre>"
"Assert.java:523"$0$"	 * @param collection the collection to check"
"Assert.java:524"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:525"$0$"	 * assertion fails"
"Assert.java:526"$1$"	 * @throws IllegalArgumentException if the collection contains a {@code null} element"
"Assert.java:527"$0$"	 * @since 5.2"
"Assert.java:528"$0$"	 */"
"Assert.java:529"$1$"	public static void noNullElements(@Nullable Collection<?> collection, Supplier<String> messageSupplier) {"
"Assert.java:530"$1$"		if (collection != null) {"
"Assert.java:531"$1$"			for (Object element : collection) {"
"Assert.java:532"$1$"				if (element == null) {"
"Assert.java:533"$1$"					throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:534"$1$"				}"
"Assert.java:535"$0$"			}"
"Assert.java:536"$0$"		}"
"Assert.java:537"$0$"	}"
"Assert.java:538"$0$""
"Assert.java:539"$0$"	/**"
"Assert.java:540"$1$"	 * Assert that a Map contains entries; that is, it must not be {@code null}"
"Assert.java:541"$0$"	 * and must contain at least one entry."
"Assert.java:542"$0$"	 * <pre class=""code"">Assert.notEmpty(map, ""Map must contain entries"");</pre>"
"Assert.java:543"$0$"	 * @param map the map to check"
"Assert.java:544"$0$"	 * @param message the exception message to use if the assertion fails"
"Assert.java:545"$1$"	 * @throws IllegalArgumentException if the map is {@code null} or contains no entries"
"Assert.java:546"$0$"	 */"
"Assert.java:547"$1$"	public static void notEmpty(@Nullable Map<?, ?> map, String message) {"
"Assert.java:548"$1$"		if (CollectionUtils.isEmpty(map)) {"
"Assert.java:549"$1$"			throw new IllegalArgumentException(message);"
"Assert.java:550"$1$"		}"
"Assert.java:551"$0$"	}"
"Assert.java:552"$0$""
"Assert.java:553"$0$"	/**"
"Assert.java:554"$1$"	 * Assert that a Map contains entries; that is, it must not be {@code null}"
"Assert.java:555"$0$"	 * and must contain at least one entry."
"Assert.java:556"$0$"	 * <pre class=""code"">"
"Assert.java:557"$0$"	 * Assert.notEmpty(map, () -&gt; ""The "" + mapType + "" map must contain entries"");"
"Assert.java:558"$0$"	 * </pre>"
"Assert.java:559"$0$"	 * @param map the map to check"
"Assert.java:560"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:561"$0$"	 * assertion fails"
"Assert.java:562"$1$"	 * @throws IllegalArgumentException if the map is {@code null} or contains no entries"
"Assert.java:563"$0$"	 * @since 5.0"
"Assert.java:564"$0$"	 */"
"Assert.java:565"$1$"	public static void notEmpty(@Nullable Map<?, ?> map, Supplier<String> messageSupplier) {"
"Assert.java:566"$1$"		if (CollectionUtils.isEmpty(map)) {"
"Assert.java:567"$1$"			throw new IllegalArgumentException(nullSafeGet(messageSupplier));"
"Assert.java:568"$1$"		}"
"Assert.java:569"$0$"	}"
"Assert.java:570"$0$""
"Assert.java:571"$0$"	/**"
"Assert.java:572"$1$"	 * Assert that a Map contains entries; that is, it must not be {@code null}"
"Assert.java:573"$0$"	 * and must contain at least one entry."
"Assert.java:574"$1$"	 * @deprecated as of 4.3.7, in favor of {@link #notEmpty(Map, String)}"
"Assert.java:575"$0$"	 */"
"Assert.java:576"$0$"	@Deprecated"
"Assert.java:577"$1$"	public static void notEmpty(@Nullable Map<?, ?> map) {"
"Assert.java:578"$1$"		notEmpty(map, ""[Assertion failed] - this map must not be empty; it must contain at least one entry"");"
"Assert.java:579"$1$"	}"
"Assert.java:580"$0$""
"Assert.java:581"$0$"	/**"
"Assert.java:582"$0$"	 * Assert that the provided object is an instance of the provided class."
"Assert.java:583"$0$"	 * <pre class=""code"">Assert.instanceOf(Foo.class, foo, ""Foo expected"");</pre>"
"Assert.java:584"$0$"	 * @param type the type to check against"
"Assert.java:585"$0$"	 * @param obj the object to check"
"Assert.java:586"$0$"	 * @param message a message which will be prepended to provide further context."
"Assert.java:587"$0$"	 * If it is empty or ends in "":"" or "";"" or "","" or ""."", a full exception message"
"Assert.java:588"$0$"	 * will be appended. If it ends in a space, the name of the offending object's"
"Assert.java:589"$0$"	 * type will be appended. In any other case, a "":"" with a space and the name"
"Assert.java:590"$0$"	 * of the offending object's type will be appended."
"Assert.java:591"$0$"	 * @throws IllegalArgumentException if the object is not an instance of type"
"Assert.java:592"$0$"	 */"
"Assert.java:593"$1$"	public static void isInstanceOf(Class<?> type, @Nullable Object obj, String message) {"
"Assert.java:594"$1$"		notNull(type, ""Type to check against must not be null"");"
"Assert.java:595"$1$"		if (!type.isInstance(obj)) {"
"Assert.java:596"$1$"			instanceCheckFailed(type, obj, message);"
"Assert.java:597"$1$"		}"
"Assert.java:598"$0$"	}"
"Assert.java:599"$0$""
"Assert.java:600"$0$"	/**"
"Assert.java:601"$0$"	 * Assert that the provided object is an instance of the provided class."
"Assert.java:602"$0$"	 * <pre class=""code"">"
"Assert.java:603"$0$"	 * Assert.instanceOf(Foo.class, foo, () -&gt; ""Processing "" + Foo.class.getSimpleName() + "":"");"
"Assert.java:604"$0$"	 * </pre>"
"Assert.java:605"$0$"	 * @param type the type to check against"
"Assert.java:606"$0$"	 * @param obj the object to check"
"Assert.java:607"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:608"$1$"	 * assertion fails. See {@link #isInstanceOf(Class, Object, String)} for details."
"Assert.java:609"$0$"	 * @throws IllegalArgumentException if the object is not an instance of type"
"Assert.java:610"$0$"	 * @since 5.0"
"Assert.java:611"$0$"	 */"
"Assert.java:612"$1$"	public static void isInstanceOf(Class<?> type, @Nullable Object obj, Supplier<String> messageSupplier) {"
"Assert.java:613"$1$"		notNull(type, ""Type to check against must not be null"");"
"Assert.java:614"$1$"		if (!type.isInstance(obj)) {"
"Assert.java:615"$1$"			instanceCheckFailed(type, obj, nullSafeGet(messageSupplier));"
"Assert.java:616"$1$"		}"
"Assert.java:617"$0$"	}"
"Assert.java:618"$0$""
"Assert.java:619"$0$"	/**"
"Assert.java:620"$0$"	 * Assert that the provided object is an instance of the provided class."
"Assert.java:621"$0$"	 * <pre class=""code"">Assert.instanceOf(Foo.class, foo);</pre>"
"Assert.java:622"$0$"	 * @param type the type to check against"
"Assert.java:623"$0$"	 * @param obj the object to check"
"Assert.java:624"$0$"	 * @throws IllegalArgumentException if the object is not an instance of type"
"Assert.java:625"$0$"	 */"
"Assert.java:626"$1$"	public static void isInstanceOf(Class<?> type, @Nullable Object obj) {"
"Assert.java:627"$1$"		isInstanceOf(type, obj, """");"
"Assert.java:628"$1$"	}"
"Assert.java:629"$0$""
"Assert.java:630"$0$"	/**"
"Assert.java:631"$1$"	 * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}."
"Assert.java:632"$0$"	 * <pre class=""code"">Assert.isAssignable(Number.class, myClass, ""Number expected"");</pre>"
"Assert.java:633"$0$"	 * @param superType the super type to check against"
"Assert.java:634"$0$"	 * @param subType the sub type to check"
"Assert.java:635"$0$"	 * @param message a message which will be prepended to provide further context."
"Assert.java:636"$0$"	 * If it is empty or ends in "":"" or "";"" or "","" or ""."", a full exception message"
"Assert.java:637"$0$"	 * will be appended. If it ends in a space, the name of the offending sub type"
"Assert.java:638"$0$"	 * will be appended. In any other case, a "":"" with a space and the name of the"
"Assert.java:639"$0$"	 * offending sub type will be appended."
"Assert.java:640"$0$"	 * @throws IllegalArgumentException if the classes are not assignable"
"Assert.java:641"$0$"	 */"
"Assert.java:642"$1$"	public static void isAssignable(Class<?> superType, @Nullable Class<?> subType, String message) {"
"Assert.java:643"$1$"		notNull(superType, ""Super type to check against must not be null"");"
"Assert.java:644"$1$"		if (subType == null || !superType.isAssignableFrom(subType)) {"
"Assert.java:645"$1$"			assignableCheckFailed(superType, subType, message);"
"Assert.java:646"$1$"		}"
"Assert.java:647"$0$"	}"
"Assert.java:648"$0$""
"Assert.java:649"$0$"	/**"
"Assert.java:650"$1$"	 * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}."
"Assert.java:651"$0$"	 * <pre class=""code"">"
"Assert.java:652"$0$"	 * Assert.isAssignable(Number.class, myClass, () -&gt; ""Processing "" + myAttributeName + "":"");"
"Assert.java:653"$0$"	 * </pre>"
"Assert.java:654"$0$"	 * @param superType the super type to check against"
"Assert.java:655"$0$"	 * @param subType the sub type to check"
"Assert.java:656"$0$"	 * @param messageSupplier a supplier for the exception message to use if the"
"Assert.java:657"$1$"	 * assertion fails. See {@link #isAssignable(Class, Class, String)} for details."
"Assert.java:658"$0$"	 * @throws IllegalArgumentException if the classes are not assignable"
"Assert.java:659"$0$"	 * @since 5.0"
"Assert.java:660"$0$"	 */"
"Assert.java:661"$1$"	public static void isAssignable(Class<?> superType, @Nullable Class<?> subType, Supplier<String> messageSupplier) {"
"Assert.java:662"$1$"		notNull(superType, ""Super type to check against must not be null"");"
"Assert.java:663"$1$"		if (subType == null || !superType.isAssignableFrom(subType)) {"
"Assert.java:664"$1$"			assignableCheckFailed(superType, subType, nullSafeGet(messageSupplier));"
"Assert.java:665"$1$"		}"
"Assert.java:666"$0$"	}"
"Assert.java:667"$0$""
"Assert.java:668"$0$"	/**"
"Assert.java:669"$1$"	 * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}."
"Assert.java:670"$0$"	 * <pre class=""code"">Assert.isAssignable(Number.class, myClass);</pre>"
"Assert.java:671"$0$"	 * @param superType the super type to check"
"Assert.java:672"$0$"	 * @param subType the sub type to check"
"Assert.java:673"$0$"	 * @throws IllegalArgumentException if the classes are not assignable"
"Assert.java:674"$0$"	 */"
"Assert.java:675"$1$"	public static void isAssignable(Class<?> superType, Class<?> subType) {"
"Assert.java:676"$1$"		isAssignable(superType, subType, """");"
"Assert.java:677"$1$"	}"
"Assert.java:678"$0$""
"Assert.java:679"$0$""
"Assert.java:680"$1$"	private static void instanceCheckFailed(Class<?> type, @Nullable Object obj, @Nullable String msg) {"
"Assert.java:681"$1$"		String className = (obj != null ? obj.getClass().getName() : ""null"");"
"Assert.java:682"$1$"		String result = """";"
"Assert.java:683"$1$"		boolean defaultMessage = true;"
"Assert.java:684"$1$"		if (StringUtils.hasLength(msg)) {"
"Assert.java:685"$1$"			if (endsWithSeparator(msg)) {"
"Assert.java:686"$1$"				result = msg + "" "";"
"Assert.java:687"$1$"			}"
"Assert.java:688"$1$"			else {"
"Assert.java:689"$1$"				result = messageWithTypeName(msg, className);"
"Assert.java:690"$1$"				defaultMessage = false;"
"Assert.java:691"$1$"			}"
"Assert.java:692"$0$"		}"
"Assert.java:693"$1$"		if (defaultMessage) {"
"Assert.java:694"$1$"			result = result + (""Object of class ["" + className + ""] must be an instance of "" + type);"
"Assert.java:695"$1$"		}"
"Assert.java:696"$0$"		throw new IllegalArgumentException(result);"
"Assert.java:697"$0$"	}"
"Assert.java:698"$0$""
"Assert.java:699"$1$"	private static void assignableCheckFailed(Class<?> superType, @Nullable Class<?> subType, @Nullable String msg) {"
"Assert.java:700"$1$"		String result = """";"
"Assert.java:701"$1$"		boolean defaultMessage = true;"
"Assert.java:702"$1$"		if (StringUtils.hasLength(msg)) {"
"Assert.java:703"$1$"			if (endsWithSeparator(msg)) {"
"Assert.java:704"$1$"				result = msg + "" "";"
"Assert.java:705"$1$"			}"
"Assert.java:706"$1$"			else {"
"Assert.java:707"$1$"				result = messageWithTypeName(msg, subType);"
"Assert.java:708"$1$"				defaultMessage = false;"
"Assert.java:709"$1$"			}"
"Assert.java:710"$0$"		}"
"Assert.java:711"$1$"		if (defaultMessage) {"
"Assert.java:712"$1$"			result = result + (subType + "" is not assignable to "" + superType);"
"Assert.java:713"$1$"		}"
"Assert.java:714"$0$"		throw new IllegalArgumentException(result);"
"Assert.java:715"$0$"	}"
"Assert.java:716"$0$""
"Assert.java:717"$1$"	private static boolean endsWithSeparator(String msg) {"
"Assert.java:718"$1$"		return (msg.endsWith("":"") || msg.endsWith("";"") || msg.endsWith("","") || msg.endsWith("".""));"
"Assert.java:719"$1$"	}"
"Assert.java:720"$0$""
"Assert.java:721"$1$"	private static String messageWithTypeName(String msg, @Nullable Object typeName) {"
"Assert.java:722"$1$"		return msg + (msg.endsWith("" "") ? """" : "": "") + typeName;"
"Assert.java:723"$1$"	}"
"Assert.java:724"$0$""
"Assert.java:725"$0$"	@Nullable"
"Assert.java:726"$1$"	private static String nullSafeGet(@Nullable Supplier<String> messageSupplier) {"
"Assert.java:727"$1$"		return (messageSupplier != null ? messageSupplier.get() : null);"
"Assert.java:728"$1$"	}"
"Assert.java:729"$0$""
"Assert.java:730"$0$"}"
"CompoundComparator.java:1"$0$"/*"
"CompoundComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"CompoundComparator.java:3"$0$" *"
"CompoundComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CompoundComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"CompoundComparator.java:6"$0$" * You may obtain a copy of the License at"
"CompoundComparator.java:7"$0$" *"
"CompoundComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CompoundComparator.java:9"$0$" *"
"CompoundComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CompoundComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CompoundComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CompoundComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"CompoundComparator.java:14"$0$" * limitations under the License."
"CompoundComparator.java:15"$0$" */"
"CompoundComparator.java:16"$0$""
"CompoundComparator.java:17"$0$"package org.springframework.util.comparator;"
"CompoundComparator.java:18"$0$""
"CompoundComparator.java:19"$0$"import java.io.Serializable;"
"CompoundComparator.java:20"$0$"import java.util.ArrayList;"
"CompoundComparator.java:21"$0$"import java.util.Comparator;"
"CompoundComparator.java:22"$0$"import java.util.List;"
"CompoundComparator.java:23"$0$""
"CompoundComparator.java:24"$0$"import org.springframework.lang.Nullable;"
"CompoundComparator.java:25"$0$"import org.springframework.util.Assert;"
"CompoundComparator.java:26"$0$""
"CompoundComparator.java:27"$0$"/**"
"CompoundComparator.java:28"$0$" * A comparator that chains a sequence of one or more Comparators."
"CompoundComparator.java:29"$0$" *"
"CompoundComparator.java:30"$0$" * <p>A compound comparator calls each Comparator in sequence until a single"
"CompoundComparator.java:31"$0$" * Comparator returns a non-zero result, or the comparators are exhausted and"
"CompoundComparator.java:32"$0$" * zero is returned."
"CompoundComparator.java:33"$0$" *"
"CompoundComparator.java:34"$0$" * <p>This facilitates in-memory sorting similar to multi-column sorting in SQL."
"CompoundComparator.java:35"$0$" * The order of any single Comparator in the list can also be reversed."
"CompoundComparator.java:36"$0$" *"
"CompoundComparator.java:37"$0$" * @author Keith Donald"
"CompoundComparator.java:38"$0$" * @author Juergen Hoeller"
"CompoundComparator.java:39"$0$" * @since 1.2.2"
"CompoundComparator.java:40"$0$" * @param <T> the type of objects that may be compared by this comparator"
"CompoundComparator.java:41"$0$" * @deprecated as of Spring Framework 5.0, in favor of the standard JDK 8"
"CompoundComparator.java:42"$1$" * {@link Comparator#thenComparing(Comparator)}"
"CompoundComparator.java:43"$0$" */"
"CompoundComparator.java:44"$0$"Deprecated"
"CompoundComparator.java:45"$1$"SuppressWarnings({""serial"", ""rawtypes""})"
"CompoundComparator.java:46"$1$"public class CompoundComparator<T> implements Comparator<T>, Serializable {"
"CompoundComparator.java:47"$1$""
"CompoundComparator.java:48"$1$"	private final List<InvertibleComparator> comparators;"
"CompoundComparator.java:49"$1$""
"CompoundComparator.java:50"$1$""
"CompoundComparator.java:51"$1$"	/**"
"CompoundComparator.java:52"$1$"	 * Construct a CompoundComparator with initially no Comparators. Clients"
"CompoundComparator.java:53"$1$"	 * must add at least one Comparator before calling the compare method or an"
"CompoundComparator.java:54"$1$"	 * IllegalStateException is thrown."
"CompoundComparator.java:55"$1$"	 */"
"CompoundComparator.java:56"$1$"	public CompoundComparator() {"
"CompoundComparator.java:57"$1$"		this.comparators = new ArrayList<>();"
"CompoundComparator.java:58"$1$"	}"
"CompoundComparator.java:59"$0$""
"CompoundComparator.java:60"$0$"	/**"
"CompoundComparator.java:61"$0$"	 * Construct a CompoundComparator from the Comparators in the provided array."
"CompoundComparator.java:62"$0$"	 * <p>All Comparators will default to ascending sort order,"
"CompoundComparator.java:63"$0$"	 * unless they are InvertibleComparators."
"CompoundComparator.java:64"$0$"	 * @param comparators the comparators to build into a compound comparator"
"CompoundComparator.java:65"$0$"	 * @see InvertibleComparator"
"CompoundComparator.java:66"$0$"	 */"
"CompoundComparator.java:67"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:68"$1$"	public CompoundComparator(Comparator... comparators) {"
"CompoundComparator.java:69"$1$"		Assert.notNull(comparators, ""Comparators must not be null"");"
"CompoundComparator.java:70"$1$"		this.comparators = new ArrayList<>(comparators.length);"
"CompoundComparator.java:71"$1$"		for (Comparator comparator : comparators) {"
"CompoundComparator.java:72"$1$"			addComparator(comparator);"
"CompoundComparator.java:73"$1$"		}"
"CompoundComparator.java:74"$0$"	}"
"CompoundComparator.java:75"$0$""
"CompoundComparator.java:76"$0$""
"CompoundComparator.java:77"$0$"	/**"
"CompoundComparator.java:78"$0$"	 * Add a Comparator to the end of the chain."
"CompoundComparator.java:79"$0$"	 * <p>The Comparator will default to ascending sort order,"
"CompoundComparator.java:80"$0$"	 * unless it is a InvertibleComparator."
"CompoundComparator.java:81"$0$"	 * @param comparator the Comparator to add to the end of the chain"
"CompoundComparator.java:82"$0$"	 * @see InvertibleComparator"
"CompoundComparator.java:83"$0$"	 */"
"CompoundComparator.java:84"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:85"$1$"	public void addComparator(Comparator<? extends T> comparator) {"
"CompoundComparator.java:86"$1$"		if (comparator instanceof InvertibleComparator) {"
"CompoundComparator.java:87"$1$"			this.comparators.add((InvertibleComparator) comparator);"
"CompoundComparator.java:88"$1$"		}"
"CompoundComparator.java:89"$1$"		else {"
"CompoundComparator.java:90"$1$"			this.comparators.add(new InvertibleComparator(comparator));"
"CompoundComparator.java:91"$1$"		}"
"CompoundComparator.java:92"$0$"	}"
"CompoundComparator.java:93"$0$""
"CompoundComparator.java:94"$0$"	/**"
"CompoundComparator.java:95"$0$"	 * Add a Comparator to the end of the chain using the provided sort order."
"CompoundComparator.java:96"$0$"	 * @param comparator the Comparator to add to the end of the chain"
"CompoundComparator.java:97"$0$"	 * @param ascending the sort order: ascending (true) or descending (false)"
"CompoundComparator.java:98"$0$"	 */"
"CompoundComparator.java:99"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:100"$1$"	public void addComparator(Comparator<? extends T> comparator, boolean ascending) {"
"CompoundComparator.java:101"$1$"		this.comparators.add(new InvertibleComparator(comparator, ascending));"
"CompoundComparator.java:102"$1$"	}"
"CompoundComparator.java:103"$0$""
"CompoundComparator.java:104"$0$"	/**"
"CompoundComparator.java:105"$0$"	 * Replace the Comparator at the given index."
"CompoundComparator.java:106"$0$"	 * <p>The Comparator will default to ascending sort order,"
"CompoundComparator.java:107"$0$"	 * unless it is a InvertibleComparator."
"CompoundComparator.java:108"$0$"	 * @param index the index of the Comparator to replace"
"CompoundComparator.java:109"$0$"	 * @param comparator the Comparator to place at the given index"
"CompoundComparator.java:110"$0$"	 * @see InvertibleComparator"
"CompoundComparator.java:111"$0$"	 */"
"CompoundComparator.java:112"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:113"$1$"	public void setComparator(int index, Comparator<? extends T> comparator) {"
"CompoundComparator.java:114"$1$"		if (comparator instanceof InvertibleComparator) {"
"CompoundComparator.java:115"$1$"			this.comparators.set(index, (InvertibleComparator) comparator);"
"CompoundComparator.java:116"$1$"		}"
"CompoundComparator.java:117"$1$"		else {"
"CompoundComparator.java:118"$1$"			this.comparators.set(index, new InvertibleComparator(comparator));"
"CompoundComparator.java:119"$1$"		}"
"CompoundComparator.java:120"$0$"	}"
"CompoundComparator.java:121"$0$""
"CompoundComparator.java:122"$0$"	/**"
"CompoundComparator.java:123"$0$"	 * Replace the Comparator at the given index using the given sort order."
"CompoundComparator.java:124"$0$"	 * @param index the index of the Comparator to replace"
"CompoundComparator.java:125"$0$"	 * @param comparator the Comparator to place at the given index"
"CompoundComparator.java:126"$0$"	 * @param ascending the sort order: ascending (true) or descending (false)"
"CompoundComparator.java:127"$0$"	 */"
"CompoundComparator.java:128"$1$"	public void setComparator(int index, Comparator<T> comparator, boolean ascending) {"
"CompoundComparator.java:129"$1$"		this.comparators.set(index, new InvertibleComparator<>(comparator, ascending));"
"CompoundComparator.java:130"$1$"	}"
"CompoundComparator.java:131"$0$""
"CompoundComparator.java:132"$0$"	/**"
"CompoundComparator.java:133"$0$"	 * Invert the sort order of each sort definition contained by this compound"
"CompoundComparator.java:134"$0$"	 * comparator."
"CompoundComparator.java:135"$0$"	 */"
"CompoundComparator.java:136"$1$"	public void invertOrder() {"
"CompoundComparator.java:137"$1$"		for (InvertibleComparator comparator : this.comparators) {"
"CompoundComparator.java:138"$1$"			comparator.invertOrder();"
"CompoundComparator.java:139"$1$"		}"
"CompoundComparator.java:140"$0$"	}"
"CompoundComparator.java:141"$0$""
"CompoundComparator.java:142"$0$"	/**"
"CompoundComparator.java:143"$0$"	 * Invert the sort order of the sort definition at the specified index."
"CompoundComparator.java:144"$0$"	 * @param index the index of the comparator to invert"
"CompoundComparator.java:145"$0$"	 */"
"CompoundComparator.java:146"$1$"	public void invertOrder(int index) {"
"CompoundComparator.java:147"$1$"		this.comparators.get(index).invertOrder();"
"CompoundComparator.java:148"$1$"	}"
"CompoundComparator.java:149"$0$""
"CompoundComparator.java:150"$0$"	/**"
"CompoundComparator.java:151"$0$"	 * Change the sort order at the given index to ascending."
"CompoundComparator.java:152"$0$"	 * @param index the index of the comparator to change"
"CompoundComparator.java:153"$0$"	 */"
"CompoundComparator.java:154"$1$"	public void setAscendingOrder(int index) {"
"CompoundComparator.java:155"$1$"		this.comparators.get(index).setAscending(true);"
"CompoundComparator.java:156"$1$"	}"
"CompoundComparator.java:157"$0$""
"CompoundComparator.java:158"$0$"	/**"
"CompoundComparator.java:159"$0$"	 * Change the sort order at the given index to descending sort."
"CompoundComparator.java:160"$0$"	 * @param index the index of the comparator to change"
"CompoundComparator.java:161"$0$"	 */"
"CompoundComparator.java:162"$1$"	public void setDescendingOrder(int index) {"
"CompoundComparator.java:163"$1$"		this.comparators.get(index).setAscending(false);"
"CompoundComparator.java:164"$1$"	}"
"CompoundComparator.java:165"$0$""
"CompoundComparator.java:166"$0$"	/**"
"CompoundComparator.java:167"$0$"	 * Returns the number of aggregated comparators."
"CompoundComparator.java:168"$0$"	 */"
"CompoundComparator.java:169"$1$"	public int getComparatorCount() {"
"CompoundComparator.java:170"$1$"		return this.comparators.size();"
"CompoundComparator.java:171"$1$"	}"
"CompoundComparator.java:172"$0$""
"CompoundComparator.java:173"$0$""
"CompoundComparator.java:174"$0$"	@Override"
"CompoundComparator.java:175"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:176"$1$"	public int compare(T o1, T o2) {"
"CompoundComparator.java:177"$1$"		Assert.state(!this.comparators.isEmpty(),"
"CompoundComparator.java:178"$1$"				""No sort definitions have been added to this CompoundComparator to compare"");"
"CompoundComparator.java:179"$1$"		for (InvertibleComparator comparator : this.comparators) {"
"CompoundComparator.java:180"$1$"			int result = comparator.compare(o1, o2);"
"CompoundComparator.java:181"$1$"			if (result != 0) {"
"CompoundComparator.java:182"$1$"				return result;"
"CompoundComparator.java:183"$1$"			}"
"CompoundComparator.java:184"$0$"		}"
"CompoundComparator.java:185"$0$"		return 0;"
"CompoundComparator.java:186"$0$"	}"
"CompoundComparator.java:187"$0$""
"CompoundComparator.java:188"$0$""
"CompoundComparator.java:189"$0$"	@Override"
"CompoundComparator.java:190"$0$"	@SuppressWarnings(""unchecked"")"
"CompoundComparator.java:191"$1$"	public boolean equals(@Nullable Object other) {"
"CompoundComparator.java:192"$1$"		return (this == other || (other instanceof CompoundComparator &&"
"CompoundComparator.java:193"$1$"				this.comparators.equals(((CompoundComparator<T>) other).comparators)));"
"CompoundComparator.java:194"$1$"	}"
"CompoundComparator.java:195"$0$""
"CompoundComparator.java:196"$0$"	@Override"
"CompoundComparator.java:197"$1$"	public int hashCode() {"
"CompoundComparator.java:198"$1$"		return this.comparators.hashCode();"
"CompoundComparator.java:199"$1$"	}"
"CompoundComparator.java:200"$0$""
"CompoundComparator.java:201"$0$"	@Override"
"CompoundComparator.java:202"$1$"	public String toString() {"
"CompoundComparator.java:203"$1$"		return ""CompoundComparator: "" + this.comparators;"
"CompoundComparator.java:204"$1$"	}"
"CompoundComparator.java:205"$0$""
"CompoundComparator.java:206"$0$"}"
"GenericTypeResolver.java:1"$0$"/*"
"GenericTypeResolver.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"GenericTypeResolver.java:3"$0$" *"
"GenericTypeResolver.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"GenericTypeResolver.java:5"$0$" * you may not use this file except in compliance with the License."
"GenericTypeResolver.java:6"$0$" * You may obtain a copy of the License at"
"GenericTypeResolver.java:7"$0$" *"
"GenericTypeResolver.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"GenericTypeResolver.java:9"$0$" *"
"GenericTypeResolver.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"GenericTypeResolver.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"GenericTypeResolver.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"GenericTypeResolver.java:13"$0$" * See the License for the specific language governing permissions and"
"GenericTypeResolver.java:14"$0$" * limitations under the License."
"GenericTypeResolver.java:15"$0$" */"
"GenericTypeResolver.java:16"$0$""
"GenericTypeResolver.java:17"$0$"package org.springframework.core;"
"GenericTypeResolver.java:18"$0$""
"GenericTypeResolver.java:19"$0$"import java.lang.reflect.Method;"
"GenericTypeResolver.java:20"$0$"import java.lang.reflect.ParameterizedType;"
"GenericTypeResolver.java:21"$0$"import java.lang.reflect.Type;"
"GenericTypeResolver.java:22"$0$"import java.lang.reflect.TypeVariable;"
"GenericTypeResolver.java:23"$0$"import java.lang.reflect.WildcardType;"
"GenericTypeResolver.java:24"$0$"import java.util.Collections;"
"GenericTypeResolver.java:25"$0$"import java.util.HashMap;"
"GenericTypeResolver.java:26"$0$"import java.util.Map;"
"GenericTypeResolver.java:27"$0$""
"GenericTypeResolver.java:28"$0$"import org.springframework.lang.Nullable;"
"GenericTypeResolver.java:29"$0$"import org.springframework.util.Assert;"
"GenericTypeResolver.java:30"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"GenericTypeResolver.java:31"$0$""
"GenericTypeResolver.java:32"$0$"/**"
"GenericTypeResolver.java:33"$0$" * Helper class for resolving generic types against type variables."
"GenericTypeResolver.java:34"$0$" *"
"GenericTypeResolver.java:35"$0$" * <p>Mainly intended for usage within the framework, resolving method"
"GenericTypeResolver.java:36"$0$" * parameter types even when they are declared generically."
"GenericTypeResolver.java:37"$0$" *"
"GenericTypeResolver.java:38"$0$" * @author Juergen Hoeller"
"GenericTypeResolver.java:39"$0$" * @author Rob Harrop"
"GenericTypeResolver.java:40"$0$" * @author Sam Brannen"
"GenericTypeResolver.java:41"$0$" * @author Phillip Webb"
"GenericTypeResolver.java:42"$0$" * @since 2.5.2"
"GenericTypeResolver.java:43"$0$" */"
"GenericTypeResolver.java:44"$1$"public final class GenericTypeResolver {"
"GenericTypeResolver.java:45"$1$""
"GenericTypeResolver.java:46"$1$"	/** Cache from Class to TypeVariable Map. */"
"GenericTypeResolver.java:47"$1$"	@SuppressWarnings(""rawtypes"")"
"GenericTypeResolver.java:48"$1$"	private static final Map<Class<?>, Map<TypeVariable, Type>> typeVariableCache = new ConcurrentReferenceHashMap<>();"
"GenericTypeResolver.java:49"$1$""
"GenericTypeResolver.java:50"$1$""
"GenericTypeResolver.java:51"$1$"	private GenericTypeResolver() {"
"GenericTypeResolver.java:52"$1$"	}"
"GenericTypeResolver.java:53"$0$""
"GenericTypeResolver.java:54"$0$""
"GenericTypeResolver.java:55"$0$"	/**"
"GenericTypeResolver.java:56"$0$"	 * Determine the target type for the given generic parameter type."
"GenericTypeResolver.java:57"$0$"	 * @param methodParameter the method parameter specification"
"GenericTypeResolver.java:58"$0$"	 * @param implementationClass the class to resolve type variables against"
"GenericTypeResolver.java:59"$0$"	 * @return the corresponding generic parameter or return type"
"GenericTypeResolver.java:60"$1$"	 * @deprecated since 5.2 in favor of {@code methodParameter.withContainingClass(implementationClass).getParameterType()}"
"GenericTypeResolver.java:61"$0$"	 */"
"GenericTypeResolver.java:62"$0$"	@Deprecated"
"GenericTypeResolver.java:63"$1$"	public static Class<?> resolveParameterType(MethodParameter methodParameter, Class<?> implementationClass) {"
"GenericTypeResolver.java:64"$1$"		Assert.notNull(methodParameter, ""MethodParameter must not be null"");"
"GenericTypeResolver.java:65"$1$"		Assert.notNull(implementationClass, ""Class must not be null"");"
"GenericTypeResolver.java:66"$1$"		methodParameter.setContainingClass(implementationClass);"
"GenericTypeResolver.java:67"$1$"		return methodParameter.getParameterType();"
"GenericTypeResolver.java:68"$1$"	}"
"GenericTypeResolver.java:69"$0$""
"GenericTypeResolver.java:70"$0$"	/**"
"GenericTypeResolver.java:71"$0$"	 * Determine the target type for the generic return type of the given method,"
"GenericTypeResolver.java:72"$0$"	 * where formal type variables are declared on the given class."
"GenericTypeResolver.java:73"$0$"	 * @param method the method to introspect"
"GenericTypeResolver.java:74"$0$"	 * @param clazz the class to resolve type variables against"
"GenericTypeResolver.java:75"$0$"	 * @return the corresponding generic parameter or return type"
"GenericTypeResolver.java:76"$0$"	 */"
"GenericTypeResolver.java:77"$1$"	public static Class<?> resolveReturnType(Method method, Class<?> clazz) {"
"GenericTypeResolver.java:78"$1$"		Assert.notNull(method, ""Method must not be null"");"
"GenericTypeResolver.java:79"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"GenericTypeResolver.java:80"$1$"		return ResolvableType.forMethodReturnType(method, clazz).resolve(method.getReturnType());"
"GenericTypeResolver.java:81"$1$"	}"
"GenericTypeResolver.java:82"$0$""
"GenericTypeResolver.java:83"$0$"	/**"
"GenericTypeResolver.java:84"$0$"	 * Resolve the single type argument of the given generic interface against the given"
"GenericTypeResolver.java:85"$0$"	 * target method which is assumed to return the given interface or an implementation"
"GenericTypeResolver.java:86"$0$"	 * of it."
"GenericTypeResolver.java:87"$0$"	 * @param method the target method to check the return type of"
"GenericTypeResolver.java:88"$0$"	 * @param genericIfc the generic interface or superclass to resolve the type argument from"
"GenericTypeResolver.java:89"$1$"	 * @return the resolved parameter type of the method return type, or {@code null}"
"GenericTypeResolver.java:90"$1$"	 * if not resolvable or if the single argument is of type {@link WildcardType}."
"GenericTypeResolver.java:91"$0$"	 */"
"GenericTypeResolver.java:92"$0$"	@Nullable"
"GenericTypeResolver.java:93"$1$"	public static Class<?> resolveReturnTypeArgument(Method method, Class<?> genericIfc) {"
"GenericTypeResolver.java:94"$1$"		Assert.notNull(method, ""Method must not be null"");"
"GenericTypeResolver.java:95"$1$"		ResolvableType resolvableType = ResolvableType.forMethodReturnType(method).as(genericIfc);"
"GenericTypeResolver.java:96"$1$"		if (!resolvableType.hasGenerics() || resolvableType.getType() instanceof WildcardType) {"
"GenericTypeResolver.java:97"$1$"			return null;"
"GenericTypeResolver.java:98"$1$"		}"
"GenericTypeResolver.java:99"$0$"		return getSingleGeneric(resolvableType);"
"GenericTypeResolver.java:100"$0$"	}"
"GenericTypeResolver.java:101"$0$""
"GenericTypeResolver.java:102"$0$"	/**"
"GenericTypeResolver.java:103"$0$"	 * Resolve the single type argument of the given generic interface against"
"GenericTypeResolver.java:104"$0$"	 * the given target class which is assumed to implement the generic interface"
"GenericTypeResolver.java:105"$0$"	 * and possibly declare a concrete type for its type variable."
"GenericTypeResolver.java:106"$0$"	 * @param clazz the target class to check against"
"GenericTypeResolver.java:107"$0$"	 * @param genericIfc the generic interface or superclass to resolve the type argument from"
"GenericTypeResolver.java:108"$1$"	 * @return the resolved type of the argument, or {@code null} if not resolvable"
"GenericTypeResolver.java:109"$0$"	 */"
"GenericTypeResolver.java:110"$0$"	@Nullable"
"GenericTypeResolver.java:111"$1$"	public static Class<?> resolveTypeArgument(Class<?> clazz, Class<?> genericIfc) {"
"GenericTypeResolver.java:112"$1$"		ResolvableType resolvableType = ResolvableType.forClass(clazz).as(genericIfc);"
"GenericTypeResolver.java:113"$1$"		if (!resolvableType.hasGenerics()) {"
"GenericTypeResolver.java:114"$1$"			return null;"
"GenericTypeResolver.java:115"$1$"		}"
"GenericTypeResolver.java:116"$0$"		return getSingleGeneric(resolvableType);"
"GenericTypeResolver.java:117"$0$"	}"
"GenericTypeResolver.java:118"$0$""
"GenericTypeResolver.java:119"$0$"	@Nullable"
"GenericTypeResolver.java:120"$1$"	private static Class<?> getSingleGeneric(ResolvableType resolvableType) {"
"GenericTypeResolver.java:121"$1$"		Assert.isTrue(resolvableType.getGenerics().length == 1,"
"GenericTypeResolver.java:122"$1$"				() -> ""Expected 1 type argument on generic interface ["" + resolvableType +"
"GenericTypeResolver.java:123"$1$"				""] but found "" + resolvableType.getGenerics().length);"
"GenericTypeResolver.java:124"$1$"		return resolvableType.getGeneric().resolve();"
"GenericTypeResolver.java:125"$1$"	}"
"GenericTypeResolver.java:126"$0$""
"GenericTypeResolver.java:127"$0$""
"GenericTypeResolver.java:128"$0$"	/**"
"GenericTypeResolver.java:129"$0$"	 * Resolve the type arguments of the given generic interface against the given"
"GenericTypeResolver.java:130"$0$"	 * target class which is assumed to implement the generic interface and possibly"
"GenericTypeResolver.java:131"$0$"	 * declare concrete types for its type variables."
"GenericTypeResolver.java:132"$0$"	 * @param clazz the target class to check against"
"GenericTypeResolver.java:133"$0$"	 * @param genericIfc the generic interface or superclass to resolve the type argument from"
"GenericTypeResolver.java:134"$0$"	 * @return the resolved type of each argument, with the array size matching the"
"GenericTypeResolver.java:135"$1$"	 * number of actual type arguments, or {@code null} if not resolvable"
"GenericTypeResolver.java:136"$0$"	 */"
"GenericTypeResolver.java:137"$0$"	@Nullable"
"GenericTypeResolver.java:138"$1$"	public static Class<?>[] resolveTypeArguments(Class<?> clazz, Class<?> genericIfc) {"
"GenericTypeResolver.java:139"$1$"		ResolvableType type = ResolvableType.forClass(clazz).as(genericIfc);"
"GenericTypeResolver.java:140"$1$"		if (!type.hasGenerics() || type.isEntirelyUnresolvable()) {"
"GenericTypeResolver.java:141"$1$"			return null;"
"GenericTypeResolver.java:142"$1$"		}"
"GenericTypeResolver.java:143"$0$"		return type.resolveGenerics(Object.class);"
"GenericTypeResolver.java:144"$0$"	}"
"GenericTypeResolver.java:145"$0$""
"GenericTypeResolver.java:146"$0$"	/**"
"GenericTypeResolver.java:147"$0$"	 * Resolve the given generic type against the given context class,"
"GenericTypeResolver.java:148"$0$"	 * substituting type variables as far as possible."
"GenericTypeResolver.java:149"$0$"	 * @param genericType the (potentially) generic type"
"GenericTypeResolver.java:150"$0$"	 * @param contextClass a context class for the target type, for example a class"
"GenericTypeResolver.java:151"$1$"	 * in which the target type appears in a method signature (can be {@code null})"
"GenericTypeResolver.java:152"$0$"	 * @return the resolved type (possibly the given generic type as-is)"
"GenericTypeResolver.java:153"$0$"	 * @since 5.0"
"GenericTypeResolver.java:154"$0$"	 */"
"GenericTypeResolver.java:155"$1$"	public static Type resolveType(Type genericType, @Nullable Class<?> contextClass) {"
"GenericTypeResolver.java:156"$1$"		if (contextClass != null) {"
"GenericTypeResolver.java:157"$1$"			if (genericType instanceof TypeVariable) {"
"GenericTypeResolver.java:158"$1$"				ResolvableType resolvedTypeVariable = resolveVariable("
"GenericTypeResolver.java:159"$1$"						(TypeVariable<?>) genericType, ResolvableType.forClass(contextClass));"
"GenericTypeResolver.java:160"$1$"				if (resolvedTypeVariable != ResolvableType.NONE) {"
"GenericTypeResolver.java:161"$1$"					Class<?> resolved = resolvedTypeVariable.resolve();"
"GenericTypeResolver.java:162"$1$"					if (resolved != null) {"
"GenericTypeResolver.java:163"$1$"						return resolved;"
"GenericTypeResolver.java:164"$1$"					}"
"GenericTypeResolver.java:165"$0$"				}"
"GenericTypeResolver.java:166"$0$"			}"
"GenericTypeResolver.java:167"$1$"			else if (genericType instanceof ParameterizedType) {"
"GenericTypeResolver.java:168"$1$"				ResolvableType resolvedType = ResolvableType.forType(genericType);"
"GenericTypeResolver.java:169"$1$"				if (resolvedType.hasUnresolvableGenerics()) {"
"GenericTypeResolver.java:170"$1$"					ParameterizedType parameterizedType = (ParameterizedType) genericType;"
"GenericTypeResolver.java:171"$1$"					Class<?>[] generics = new Class<?>[parameterizedType.getActualTypeArguments().length];"
"GenericTypeResolver.java:172"$1$"					Type[] typeArguments = parameterizedType.getActualTypeArguments();"
"GenericTypeResolver.java:173"$1$"					ResolvableType contextType = ResolvableType.forClass(contextClass);"
"GenericTypeResolver.java:174"$1$"					for (int i = 0; i < typeArguments.length; i++) {"
"GenericTypeResolver.java:175"$1$"						Type typeArgument = typeArguments[i];"
"GenericTypeResolver.java:176"$1$"						if (typeArgument instanceof TypeVariable) {"
"GenericTypeResolver.java:177"$1$"							ResolvableType resolvedTypeArgument = resolveVariable("
"GenericTypeResolver.java:178"$1$"									(TypeVariable<?>) typeArgument, contextType);"
"GenericTypeResolver.java:179"$1$"							if (resolvedTypeArgument != ResolvableType.NONE) {"
"GenericTypeResolver.java:180"$1$"								generics[i] = resolvedTypeArgument.resolve();"
"GenericTypeResolver.java:181"$1$"							}"
"GenericTypeResolver.java:182"$1$"							else {"
"GenericTypeResolver.java:183"$1$"								generics[i] = ResolvableType.forType(typeArgument).resolve();"
"GenericTypeResolver.java:184"$1$"							}"
"GenericTypeResolver.java:185"$0$"						}"
"GenericTypeResolver.java:186"$1$"						else {"
"GenericTypeResolver.java:187"$1$"							generics[i] = ResolvableType.forType(typeArgument).resolve();"
"GenericTypeResolver.java:188"$1$"						}"
"GenericTypeResolver.java:189"$0$"					}"
"GenericTypeResolver.java:190"$0$"					Class<?> rawClass = resolvedType.getRawClass();"
"GenericTypeResolver.java:191"$1$"					if (rawClass != null) {"
"GenericTypeResolver.java:192"$1$"						return ResolvableType.forClassWithGenerics(rawClass, generics).getType();"
"GenericTypeResolver.java:193"$1$"					}"
"GenericTypeResolver.java:194"$0$"				}"
"GenericTypeResolver.java:195"$0$"			}"
"GenericTypeResolver.java:196"$0$"		}"
"GenericTypeResolver.java:197"$0$"		return genericType;"
"GenericTypeResolver.java:198"$0$"	}"
"GenericTypeResolver.java:199"$0$""
"GenericTypeResolver.java:200"$1$"	private static ResolvableType resolveVariable(TypeVariable<?> typeVariable, ResolvableType contextType) {"
"GenericTypeResolver.java:201"$1$"		ResolvableType resolvedType;"
"GenericTypeResolver.java:202"$1$"		if (contextType.hasGenerics()) {"
"GenericTypeResolver.java:203"$1$"			resolvedType = ResolvableType.forType(typeVariable, contextType);"
"GenericTypeResolver.java:204"$1$"			if (resolvedType.resolve() != null) {"
"GenericTypeResolver.java:205"$1$"				return resolvedType;"
"GenericTypeResolver.java:206"$1$"			}"
"GenericTypeResolver.java:207"$0$"		}"
"GenericTypeResolver.java:208"$0$""
"GenericTypeResolver.java:209"$0$"		ResolvableType superType = contextType.getSuperType();"
"GenericTypeResolver.java:210"$1$"		if (superType != ResolvableType.NONE) {"
"GenericTypeResolver.java:211"$1$"			resolvedType = resolveVariable(typeVariable, superType);"
"GenericTypeResolver.java:212"$1$"			if (resolvedType.resolve() != null) {"
"GenericTypeResolver.java:213"$1$"				return resolvedType;"
"GenericTypeResolver.java:214"$1$"			}"
"GenericTypeResolver.java:215"$0$"		}"
"GenericTypeResolver.java:216"$1$"		for (ResolvableType ifc : contextType.getInterfaces()) {"
"GenericTypeResolver.java:217"$1$"			resolvedType = resolveVariable(typeVariable, ifc);"
"GenericTypeResolver.java:218"$1$"			if (resolvedType.resolve() != null) {"
"GenericTypeResolver.java:219"$1$"				return resolvedType;"
"GenericTypeResolver.java:220"$1$"			}"
"GenericTypeResolver.java:221"$0$"		}"
"GenericTypeResolver.java:222"$0$"		return ResolvableType.NONE;"
"GenericTypeResolver.java:223"$0$"	}"
"GenericTypeResolver.java:224"$0$""
"GenericTypeResolver.java:225"$0$"	/**"
"GenericTypeResolver.java:226"$0$"	 * Resolve the specified generic type against the given TypeVariable map."
"GenericTypeResolver.java:227"$0$"	 * <p>Used by Spring Data."
"GenericTypeResolver.java:228"$0$"	 * @param genericType the generic type to resolve"
"GenericTypeResolver.java:229"$0$"	 * @param map the TypeVariable Map to resolved against"
"GenericTypeResolver.java:230"$1$"	 * @return the type if it resolves to a Class, or {@code Object.class} otherwise"
"GenericTypeResolver.java:231"$0$"	 */"
"GenericTypeResolver.java:232"$0$"	@SuppressWarnings(""rawtypes"")"
"GenericTypeResolver.java:233"$1$"	public static Class<?> resolveType(Type genericType, Map<TypeVariable, Type> map) {"
"GenericTypeResolver.java:234"$1$"		return ResolvableType.forType(genericType, new TypeVariableMapVariableResolver(map)).toClass();"
"GenericTypeResolver.java:235"$1$"	}"
"GenericTypeResolver.java:236"$0$""
"GenericTypeResolver.java:237"$0$"	/**"
"GenericTypeResolver.java:238"$1$"	 * Build a mapping of {@link TypeVariable#getName TypeVariable names} to"
"GenericTypeResolver.java:239"$1$"	 * {@link Class concrete classes} for the specified {@link Class}."
"GenericTypeResolver.java:240"$0$"	 * Searches all super types, enclosing types and interfaces."
"GenericTypeResolver.java:241"$0$"	 * @see #resolveType(Type, Map)"
"GenericTypeResolver.java:242"$0$"	 */"
"GenericTypeResolver.java:243"$0$"	@SuppressWarnings(""rawtypes"")"
"GenericTypeResolver.java:244"$1$"	public static Map<TypeVariable, Type> getTypeVariableMap(Class<?> clazz) {"
"GenericTypeResolver.java:245"$1$"		Map<TypeVariable, Type> typeVariableMap = typeVariableCache.get(clazz);"
"GenericTypeResolver.java:246"$1$"		if (typeVariableMap == null) {"
"GenericTypeResolver.java:247"$1$"			typeVariableMap = new HashMap<>();"
"GenericTypeResolver.java:248"$1$"			buildTypeVariableMap(ResolvableType.forClass(clazz), typeVariableMap);"
"GenericTypeResolver.java:249"$1$"			typeVariableCache.put(clazz, Collections.unmodifiableMap(typeVariableMap));"
"GenericTypeResolver.java:250"$1$"		}"
"GenericTypeResolver.java:251"$0$"		return typeVariableMap;"
"GenericTypeResolver.java:252"$0$"	}"
"GenericTypeResolver.java:253"$0$""
"GenericTypeResolver.java:254"$0$"	@SuppressWarnings(""rawtypes"")"
"GenericTypeResolver.java:255"$1$"	private static void buildTypeVariableMap(ResolvableType type, Map<TypeVariable, Type> typeVariableMap) {"
"GenericTypeResolver.java:256"$1$"		if (type != ResolvableType.NONE) {"
"GenericTypeResolver.java:257"$1$"			Class<?> resolved = type.resolve();"
"GenericTypeResolver.java:258"$1$"			if (resolved != null && type.getType() instanceof ParameterizedType) {"
"GenericTypeResolver.java:259"$1$"				TypeVariable<?>[] variables = resolved.getTypeParameters();"
"GenericTypeResolver.java:260"$1$"				for (int i = 0; i < variables.length; i++) {"
"GenericTypeResolver.java:261"$1$"					ResolvableType generic = type.getGeneric(i);"
"GenericTypeResolver.java:262"$1$"					while (generic.getType() instanceof TypeVariable<?>) {"
"GenericTypeResolver.java:263"$1$"						generic = generic.resolveType();"
"GenericTypeResolver.java:264"$1$"					}"
"GenericTypeResolver.java:265"$1$"					if (generic != ResolvableType.NONE) {"
"GenericTypeResolver.java:266"$1$"						typeVariableMap.put(variables[i], generic.getType());"
"GenericTypeResolver.java:267"$1$"					}"
"GenericTypeResolver.java:268"$0$"				}"
"GenericTypeResolver.java:269"$0$"			}"
"GenericTypeResolver.java:270"$0$"			buildTypeVariableMap(type.getSuperType(), typeVariableMap);"
"GenericTypeResolver.java:271"$1$"			for (ResolvableType interfaceType : type.getInterfaces()) {"
"GenericTypeResolver.java:272"$1$"				buildTypeVariableMap(interfaceType, typeVariableMap);"
"GenericTypeResolver.java:273"$1$"			}"
"GenericTypeResolver.java:274"$1$"			if (resolved != null && resolved.isMemberClass()) {"
"GenericTypeResolver.java:275"$1$"				buildTypeVariableMap(ResolvableType.forClass(resolved.getEnclosingClass()), typeVariableMap);"
"GenericTypeResolver.java:276"$1$"			}"
"GenericTypeResolver.java:277"$0$"		}"
"GenericTypeResolver.java:278"$0$"	}"
"GenericTypeResolver.java:279"$0$""
"GenericTypeResolver.java:280"$0$""
"GenericTypeResolver.java:281"$1$"	@SuppressWarnings({""serial"", ""rawtypes""})"
"GenericTypeResolver.java:282"$1$"	private static class TypeVariableMapVariableResolver implements ResolvableType.VariableResolver {"
"GenericTypeResolver.java:283"$1$""
"GenericTypeResolver.java:284"$1$"		private final Map<TypeVariable, Type> typeVariableMap;"
"GenericTypeResolver.java:285"$1$""
"GenericTypeResolver.java:286"$1$"		public TypeVariableMapVariableResolver(Map<TypeVariable, Type> typeVariableMap) {"
"GenericTypeResolver.java:287"$1$"			this.typeVariableMap = typeVariableMap;"
"GenericTypeResolver.java:288"$1$"		}"
"GenericTypeResolver.java:289"$0$""
"GenericTypeResolver.java:290"$0$"		@Override"
"GenericTypeResolver.java:291"$0$"		@Nullable"
"GenericTypeResolver.java:292"$1$"		public ResolvableType resolveVariable(TypeVariable<?> variable) {"
"GenericTypeResolver.java:293"$1$"			Type type = this.typeVariableMap.get(variable);"
"GenericTypeResolver.java:294"$1$"			return (type != null ? ResolvableType.forType(type) : null);"
"GenericTypeResolver.java:295"$1$"		}"
"GenericTypeResolver.java:296"$0$""
"GenericTypeResolver.java:297"$0$"		@Override"
"GenericTypeResolver.java:298"$1$"		public Object getSource() {"
"GenericTypeResolver.java:299"$1$"			return this.typeVariableMap;"
"GenericTypeResolver.java:300"$1$"		}"
"GenericTypeResolver.java:301"$0$"	}"
"GenericTypeResolver.java:302"$0$""
"GenericTypeResolver.java:303"$0$"}"
"AttributeAccessorSupport.java:1"$0$"/*"
"AttributeAccessorSupport.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"AttributeAccessorSupport.java:3"$0$" *"
"AttributeAccessorSupport.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AttributeAccessorSupport.java:5"$0$" * you may not use this file except in compliance with the License."
"AttributeAccessorSupport.java:6"$0$" * You may obtain a copy of the License at"
"AttributeAccessorSupport.java:7"$0$" *"
"AttributeAccessorSupport.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AttributeAccessorSupport.java:9"$0$" *"
"AttributeAccessorSupport.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AttributeAccessorSupport.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AttributeAccessorSupport.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AttributeAccessorSupport.java:13"$0$" * See the License for the specific language governing permissions and"
"AttributeAccessorSupport.java:14"$0$" * limitations under the License."
"AttributeAccessorSupport.java:15"$0$" */"
"AttributeAccessorSupport.java:16"$0$""
"AttributeAccessorSupport.java:17"$0$"package org.springframework.core;"
"AttributeAccessorSupport.java:18"$0$""
"AttributeAccessorSupport.java:19"$0$"import java.io.Serializable;"
"AttributeAccessorSupport.java:20"$0$"import java.util.LinkedHashMap;"
"AttributeAccessorSupport.java:21"$0$"import java.util.Map;"
"AttributeAccessorSupport.java:22"$0$""
"AttributeAccessorSupport.java:23"$0$"import org.springframework.lang.Nullable;"
"AttributeAccessorSupport.java:24"$0$"import org.springframework.util.Assert;"
"AttributeAccessorSupport.java:25"$0$"import org.springframework.util.StringUtils;"
"AttributeAccessorSupport.java:26"$0$""
"AttributeAccessorSupport.java:27"$0$"/**"
"AttributeAccessorSupport.java:28"$1$" * Support class for {@link AttributeAccessor AttributeAccessors}, providing"
"AttributeAccessorSupport.java:29"$0$" * a base implementation of all methods. To be extended by subclasses."
"AttributeAccessorSupport.java:30"$0$" *"
"AttributeAccessorSupport.java:31"$1$" * <p>{@link Serializable} if subclasses and all attribute values are {@link Serializable}."
"AttributeAccessorSupport.java:32"$0$" *"
"AttributeAccessorSupport.java:33"$0$" * @author Rob Harrop"
"AttributeAccessorSupport.java:34"$0$" * @author Juergen Hoeller"
"AttributeAccessorSupport.java:35"$0$" * @since 2.0"
"AttributeAccessorSupport.java:36"$0$" */"
"AttributeAccessorSupport.java:37"$0$"SuppressWarnings(""serial"")"
"AttributeAccessorSupport.java:38"$1$"public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable {"
"AttributeAccessorSupport.java:39"$1$""
"AttributeAccessorSupport.java:40"$1$"	/** Map with String keys and Object values. */"
"AttributeAccessorSupport.java:41"$1$"	private final Map<String, Object> attributes = new LinkedHashMap<>();"
"AttributeAccessorSupport.java:42"$1$""
"AttributeAccessorSupport.java:43"$1$""
"AttributeAccessorSupport.java:44"$1$"	@Override"
"AttributeAccessorSupport.java:45"$1$"	public void setAttribute(String name, @Nullable Object value) {"
"AttributeAccessorSupport.java:46"$1$"		Assert.notNull(name, ""Name must not be null"");"
"AttributeAccessorSupport.java:47"$1$"		if (value != null) {"
"AttributeAccessorSupport.java:48"$1$"			this.attributes.put(name, value);"
"AttributeAccessorSupport.java:49"$1$"		}"
"AttributeAccessorSupport.java:50"$1$"		else {"
"AttributeAccessorSupport.java:51"$1$"			removeAttribute(name);"
"AttributeAccessorSupport.java:52"$1$"		}"
"AttributeAccessorSupport.java:53"$0$"	}"
"AttributeAccessorSupport.java:54"$0$""
"AttributeAccessorSupport.java:55"$0$"	@Override"
"AttributeAccessorSupport.java:56"$0$"	@Nullable"
"AttributeAccessorSupport.java:57"$1$"	public Object getAttribute(String name) {"
"AttributeAccessorSupport.java:58"$1$"		Assert.notNull(name, ""Name must not be null"");"
"AttributeAccessorSupport.java:59"$1$"		return this.attributes.get(name);"
"AttributeAccessorSupport.java:60"$1$"	}"
"AttributeAccessorSupport.java:61"$0$""
"AttributeAccessorSupport.java:62"$0$"	@Override"
"AttributeAccessorSupport.java:63"$0$"	@Nullable"
"AttributeAccessorSupport.java:64"$1$"	public Object removeAttribute(String name) {"
"AttributeAccessorSupport.java:65"$1$"		Assert.notNull(name, ""Name must not be null"");"
"AttributeAccessorSupport.java:66"$1$"		return this.attributes.remove(name);"
"AttributeAccessorSupport.java:67"$1$"	}"
"AttributeAccessorSupport.java:68"$0$""
"AttributeAccessorSupport.java:69"$0$"	@Override"
"AttributeAccessorSupport.java:70"$1$"	public boolean hasAttribute(String name) {"
"AttributeAccessorSupport.java:71"$1$"		Assert.notNull(name, ""Name must not be null"");"
"AttributeAccessorSupport.java:72"$1$"		return this.attributes.containsKey(name);"
"AttributeAccessorSupport.java:73"$1$"	}"
"AttributeAccessorSupport.java:74"$0$""
"AttributeAccessorSupport.java:75"$0$"	@Override"
"AttributeAccessorSupport.java:76"$1$"	public String[] attributeNames() {"
"AttributeAccessorSupport.java:77"$1$"		return StringUtils.toStringArray(this.attributes.keySet());"
"AttributeAccessorSupport.java:78"$1$"	}"
"AttributeAccessorSupport.java:79"$0$""
"AttributeAccessorSupport.java:80"$0$""
"AttributeAccessorSupport.java:81"$0$"	/**"
"AttributeAccessorSupport.java:82"$0$"	 * Copy the attributes from the supplied AttributeAccessor to this accessor."
"AttributeAccessorSupport.java:83"$0$"	 * @param source the AttributeAccessor to copy from"
"AttributeAccessorSupport.java:84"$0$"	 */"
"AttributeAccessorSupport.java:85"$1$"	protected void copyAttributesFrom(AttributeAccessor source) {"
"AttributeAccessorSupport.java:86"$1$"		Assert.notNull(source, ""Source must not be null"");"
"AttributeAccessorSupport.java:87"$1$"		String[] attributeNames = source.attributeNames();"
"AttributeAccessorSupport.java:88"$1$"		for (String attributeName : attributeNames) {"
"AttributeAccessorSupport.java:89"$1$"			setAttribute(attributeName, source.getAttribute(attributeName));"
"AttributeAccessorSupport.java:90"$1$"		}"
"AttributeAccessorSupport.java:91"$0$"	}"
"AttributeAccessorSupport.java:92"$0$""
"AttributeAccessorSupport.java:93"$0$""
"AttributeAccessorSupport.java:94"$0$"	@Override"
"AttributeAccessorSupport.java:95"$1$"	public boolean equals(@Nullable Object other) {"
"AttributeAccessorSupport.java:96"$1$"		return (this == other || (other instanceof AttributeAccessorSupport &&"
"AttributeAccessorSupport.java:97"$1$"				this.attributes.equals(((AttributeAccessorSupport) other).attributes)));"
"AttributeAccessorSupport.java:98"$1$"	}"
"AttributeAccessorSupport.java:99"$0$""
"AttributeAccessorSupport.java:100"$0$"	@Override"
"AttributeAccessorSupport.java:101"$1$"	public int hashCode() {"
"AttributeAccessorSupport.java:102"$1$"		return this.attributes.hashCode();"
"AttributeAccessorSupport.java:103"$1$"	}"
"AttributeAccessorSupport.java:104"$0$""
"AttributeAccessorSupport.java:105"$0$"}"
"PathResource.java:1"$0$"/*"
"PathResource.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"PathResource.java:3"$0$" *"
"PathResource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PathResource.java:5"$0$" * you may not use this file except in compliance with the License."
"PathResource.java:6"$0$" * You may obtain a copy of the License at"
"PathResource.java:7"$0$" *"
"PathResource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PathResource.java:9"$0$" *"
"PathResource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PathResource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PathResource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PathResource.java:13"$0$" * See the License for the specific language governing permissions and"
"PathResource.java:14"$0$" * limitations under the License."
"PathResource.java:15"$0$" */"
"PathResource.java:16"$0$""
"PathResource.java:17"$0$"package org.springframework.core.io;"
"PathResource.java:18"$0$""
"PathResource.java:19"$0$"import java.io.File;"
"PathResource.java:20"$0$"import java.io.FileNotFoundException;"
"PathResource.java:21"$0$"import java.io.IOException;"
"PathResource.java:22"$0$"import java.io.InputStream;"
"PathResource.java:23"$0$"import java.io.OutputStream;"
"PathResource.java:24"$0$"import java.net.URI;"
"PathResource.java:25"$0$"import java.net.URL;"
"PathResource.java:26"$0$"import java.nio.channels.ReadableByteChannel;"
"PathResource.java:27"$0$"import java.nio.channels.WritableByteChannel;"
"PathResource.java:28"$0$"import java.nio.file.Files;"
"PathResource.java:29"$0$"import java.nio.file.NoSuchFileException;"
"PathResource.java:30"$0$"import java.nio.file.OpenOption;"
"PathResource.java:31"$0$"import java.nio.file.Path;"
"PathResource.java:32"$0$"import java.nio.file.Paths;"
"PathResource.java:33"$0$"import java.nio.file.StandardOpenOption;"
"PathResource.java:34"$0$""
"PathResource.java:35"$0$"import org.springframework.lang.Nullable;"
"PathResource.java:36"$0$"import org.springframework.util.Assert;"
"PathResource.java:37"$0$""
"PathResource.java:38"$0$"/**"
"PathResource.java:39"$1$" * {@link Resource} implementation for {@link java.nio.file.Path} handles,"
"PathResource.java:40"$1$" * performing all operations and transformations via the {@code Path} API."
"PathResource.java:41"$1$" * Supports resolution as a {@link File} and also as a {@link URL}."
"PathResource.java:42"$1$" * Implements the extended {@link WritableResource} interface."
"PathResource.java:43"$0$" *"
"PathResource.java:44"$1$" * <p>Note: As of 5.1, {@link java.nio.file.Path} support is also available"
"PathResource.java:45"$1$" * in {@link FileSystemResource#FileSystemResource(Path) FileSystemResource},"
"PathResource.java:46"$0$" * applying Spring's standard String-based path transformations but"
"PathResource.java:47"$1$" * performing all operations via the {@link java.nio.file.Files} API."
"PathResource.java:48"$1$" * This {@code PathResource} is effectively a pure {@code java.nio.path.Path}"
"PathResource.java:49"$1$" * based alternative with different {@code createRelative} behavior."
"PathResource.java:50"$0$" *"
"PathResource.java:51"$0$" * @author Philippe Marschall"
"PathResource.java:52"$0$" * @author Juergen Hoeller"
"PathResource.java:53"$0$" * @since 4.0"
"PathResource.java:54"$0$" * @see java.nio.file.Path"
"PathResource.java:55"$0$" * @see java.nio.file.Files"
"PathResource.java:56"$0$" * @see FileSystemResource"
"PathResource.java:57"$0$" */"
"PathResource.java:58"$1$"public class PathResource extends AbstractResource implements WritableResource {"
"PathResource.java:59"$1$""
"PathResource.java:60"$1$"	private final Path path;"
"PathResource.java:61"$1$""
"PathResource.java:62"$1$""
"PathResource.java:63"$1$"	/**"
"PathResource.java:64"$1$"	 * Create a new PathResource from a Path handle."
"PathResource.java:65"$1$"	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources"
"PathResource.java:66"$1$"	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>"
"PathResource.java:67"$1$"	 * the given root: e.g. Paths.get(""C:/dir1/""), relative path ""dir2"" -> ""C:/dir1/dir2""!"
"PathResource.java:68"$1$"	 * @param path a Path handle"
"PathResource.java:69"$1$"	 */"
"PathResource.java:70"$1$"	public PathResource(Path path) {"
"PathResource.java:71"$1$"		Assert.notNull(path, ""Path must not be null"");"
"PathResource.java:72"$1$"		this.path = path.normalize();"
"PathResource.java:73"$1$"	}"
"PathResource.java:74"$0$""
"PathResource.java:75"$0$"	/**"
"PathResource.java:76"$0$"	 * Create a new PathResource from a Path handle."
"PathResource.java:77"$1$"	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources"
"PathResource.java:78"$1$"	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>"
"PathResource.java:79"$0$"	 * the given root: e.g. Paths.get(""C:/dir1/""), relative path ""dir2"" -> ""C:/dir1/dir2""!"
"PathResource.java:80"$0$"	 * @param path a path"
"PathResource.java:81"$0$"	 * @see java.nio.file.Paths#get(String, String...)"
"PathResource.java:82"$0$"	 */"
"PathResource.java:83"$1$"	public PathResource(String path) {"
"PathResource.java:84"$1$"		Assert.notNull(path, ""Path must not be null"");"
"PathResource.java:85"$1$"		this.path = Paths.get(path).normalize();"
"PathResource.java:86"$1$"	}"
"PathResource.java:87"$0$""
"PathResource.java:88"$0$"	/**"
"PathResource.java:89"$0$"	 * Create a new PathResource from a Path handle."
"PathResource.java:90"$1$"	 * <p>Note: Unlike {@link FileSystemResource}, when building relative resources"
"PathResource.java:91"$1$"	 * via {@link #createRelative}, the relative path will be built <i>underneath</i>"
"PathResource.java:92"$0$"	 * the given root: e.g. Paths.get(""C:/dir1/""), relative path ""dir2"" -> ""C:/dir1/dir2""!"
"PathResource.java:93"$0$"	 * @param uri a path URI"
"PathResource.java:94"$0$"	 * @see java.nio.file.Paths#get(URI)"
"PathResource.java:95"$0$"	 */"
"PathResource.java:96"$1$"	public PathResource(URI uri) {"
"PathResource.java:97"$1$"		Assert.notNull(uri, ""URI must not be null"");"
"PathResource.java:98"$1$"		this.path = Paths.get(uri).normalize();"
"PathResource.java:99"$1$"	}"
"PathResource.java:100"$0$""
"PathResource.java:101"$0$""
"PathResource.java:102"$0$"	/**"
"PathResource.java:103"$0$"	 * Return the file path for this resource."
"PathResource.java:104"$0$"	 */"
"PathResource.java:105"$1$"	public final String getPath() {"
"PathResource.java:106"$1$"		return this.path.toString();"
"PathResource.java:107"$1$"	}"
"PathResource.java:108"$0$""
"PathResource.java:109"$0$"	/**"
"PathResource.java:110"$0$"	 * This implementation returns whether the underlying file exists."
"PathResource.java:111"$0$"	 * @see java.nio.file.Files#exists(Path, java.nio.file.LinkOption...)"
"PathResource.java:112"$0$"	 */"
"PathResource.java:113"$0$"	@Override"
"PathResource.java:114"$1$"	public boolean exists() {"
"PathResource.java:115"$1$"		return Files.exists(this.path);"
"PathResource.java:116"$1$"	}"
"PathResource.java:117"$0$""
"PathResource.java:118"$0$"	/**"
"PathResource.java:119"$0$"	 * This implementation checks whether the underlying file is marked as readable"
"PathResource.java:120"$0$"	 * (and corresponds to an actual file with content, not to a directory)."
"PathResource.java:121"$0$"	 * @see java.nio.file.Files#isReadable(Path)"
"PathResource.java:122"$0$"	 * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)"
"PathResource.java:123"$0$"	 */"
"PathResource.java:124"$0$"	@Override"
"PathResource.java:125"$1$"	public boolean isReadable() {"
"PathResource.java:126"$1$"		return (Files.isReadable(this.path) && !Files.isDirectory(this.path));"
"PathResource.java:127"$1$"	}"
"PathResource.java:128"$0$""
"PathResource.java:129"$0$"	/**"
"PathResource.java:130"$0$"	 * This implementation opens a InputStream for the underlying file."
"PathResource.java:131"$0$"	 * @see java.nio.file.spi.FileSystemProvider#newInputStream(Path, OpenOption...)"
"PathResource.java:132"$0$"	 */"
"PathResource.java:133"$0$"	@Override"
"PathResource.java:134"$1$"	public InputStream getInputStream() throws IOException {"
"PathResource.java:135"$1$"		if (!exists()) {"
"PathResource.java:136"$1$"			throw new FileNotFoundException(getPath() + "" (no such file or directory)"");"
"PathResource.java:137"$1$"		}"
"PathResource.java:138"$1$"		if (Files.isDirectory(this.path)) {"
"PathResource.java:139"$1$"			throw new FileNotFoundException(getPath() + "" (is a directory)"");"
"PathResource.java:140"$1$"		}"
"PathResource.java:141"$0$"		return Files.newInputStream(this.path);"
"PathResource.java:142"$0$"	}"
"PathResource.java:143"$0$""
"PathResource.java:144"$0$"	/**"
"PathResource.java:145"$0$"	 * This implementation checks whether the underlying file is marked as writable"
"PathResource.java:146"$0$"	 * (and corresponds to an actual file with content, not to a directory)."
"PathResource.java:147"$0$"	 * @see java.nio.file.Files#isWritable(Path)"
"PathResource.java:148"$0$"	 * @see java.nio.file.Files#isDirectory(Path, java.nio.file.LinkOption...)"
"PathResource.java:149"$0$"	 */"
"PathResource.java:150"$0$"	@Override"
"PathResource.java:151"$1$"	public boolean isWritable() {"
"PathResource.java:152"$1$"		return (Files.isWritable(this.path) && !Files.isDirectory(this.path));"
"PathResource.java:153"$1$"	}"
"PathResource.java:154"$0$""
"PathResource.java:155"$0$"	/**"
"PathResource.java:156"$0$"	 * This implementation opens a OutputStream for the underlying file."
"PathResource.java:157"$0$"	 * @see java.nio.file.spi.FileSystemProvider#newOutputStream(Path, OpenOption...)"
"PathResource.java:158"$0$"	 */"
"PathResource.java:159"$0$"	@Override"
"PathResource.java:160"$1$"	public OutputStream getOutputStream() throws IOException {"
"PathResource.java:161"$1$"		if (Files.isDirectory(this.path)) {"
"PathResource.java:162"$1$"			throw new FileNotFoundException(getPath() + "" (is a directory)"");"
"PathResource.java:163"$1$"		}"
"PathResource.java:164"$0$"		return Files.newOutputStream(this.path);"
"PathResource.java:165"$0$"	}"
"PathResource.java:166"$0$""
"PathResource.java:167"$0$"	/**"
"PathResource.java:168"$0$"	 * This implementation returns a URL for the underlying file."
"PathResource.java:169"$0$"	 * @see java.nio.file.Path#toUri()"
"PathResource.java:170"$0$"	 * @see java.net.URI#toURL()"
"PathResource.java:171"$0$"	 */"
"PathResource.java:172"$0$"	@Override"
"PathResource.java:173"$1$"	public URL getURL() throws IOException {"
"PathResource.java:174"$1$"		return this.path.toUri().toURL();"
"PathResource.java:175"$1$"	}"
"PathResource.java:176"$0$""
"PathResource.java:177"$0$"	/**"
"PathResource.java:178"$0$"	 * This implementation returns a URI for the underlying file."
"PathResource.java:179"$0$"	 * @see java.nio.file.Path#toUri()"
"PathResource.java:180"$0$"	 */"
"PathResource.java:181"$0$"	@Override"
"PathResource.java:182"$1$"	public URI getURI() throws IOException {"
"PathResource.java:183"$1$"		return this.path.toUri();"
"PathResource.java:184"$1$"	}"
"PathResource.java:185"$0$""
"PathResource.java:186"$0$"	/**"
"PathResource.java:187"$0$"	 * This implementation always indicates a file."
"PathResource.java:188"$0$"	 */"
"PathResource.java:189"$0$"	@Override"
"PathResource.java:190"$1$"	public boolean isFile() {"
"PathResource.java:191"$1$"		return true;"
"PathResource.java:192"$1$"	}"
"PathResource.java:193"$0$""
"PathResource.java:194"$0$"	/**"
"PathResource.java:195"$0$"	 * This implementation returns the underlying File reference."
"PathResource.java:196"$0$"	 */"
"PathResource.java:197"$0$"	@Override"
"PathResource.java:198"$1$"	public File getFile() throws IOException {"
"PathResource.java:199"$1$"		try {"
"PathResource.java:200"$1$"			return this.path.toFile();"
"PathResource.java:201"$1$"		}"
"PathResource.java:202"$1$"		catch (UnsupportedOperationException ex) {"
"PathResource.java:203"$0$"			// Only paths on the default file system can be converted to a File:"
"PathResource.java:204"$0$"			// Do exception translation for cases where conversion is not possible."
"PathResource.java:205"$1$"			throw new FileNotFoundException(this.path + "" cannot be resolved to absolute file path"");"
"PathResource.java:206"$1$"		}"
"PathResource.java:207"$0$"	}"
"PathResource.java:208"$0$""
"PathResource.java:209"$0$"	/**"
"PathResource.java:210"$0$"	 * This implementation opens a Channel for the underlying file."
"PathResource.java:211"$0$"	 * @see Files#newByteChannel(Path, OpenOption...)"
"PathResource.java:212"$0$"	 */"
"PathResource.java:213"$0$"	@Override"
"PathResource.java:214"$1$"	public ReadableByteChannel readableChannel() throws IOException {"
"PathResource.java:215"$1$"		try {"
"PathResource.java:216"$1$"			return Files.newByteChannel(this.path, StandardOpenOption.READ);"
"PathResource.java:217"$1$"		}"
"PathResource.java:218"$1$"		catch (NoSuchFileException ex) {"
"PathResource.java:219"$1$"			throw new FileNotFoundException(ex.getMessage());"
"PathResource.java:220"$1$"		}"
"PathResource.java:221"$0$"	}"
"PathResource.java:222"$0$""
"PathResource.java:223"$0$"	/**"
"PathResource.java:224"$0$"	 * This implementation opens a Channel for the underlying file."
"PathResource.java:225"$0$"	 * @see Files#newByteChannel(Path, OpenOption...)"
"PathResource.java:226"$0$"	 */"
"PathResource.java:227"$0$"	@Override"
"PathResource.java:228"$1$"	public WritableByteChannel writableChannel() throws IOException {"
"PathResource.java:229"$1$"		return Files.newByteChannel(this.path, StandardOpenOption.WRITE);"
"PathResource.java:230"$1$"	}"
"PathResource.java:231"$0$""
"PathResource.java:232"$0$"	/**"
"PathResource.java:233"$0$"	 * This implementation returns the underlying file's length."
"PathResource.java:234"$0$"	 */"
"PathResource.java:235"$0$"	@Override"
"PathResource.java:236"$1$"	public long contentLength() throws IOException {"
"PathResource.java:237"$1$"		return Files.size(this.path);"
"PathResource.java:238"$1$"	}"
"PathResource.java:239"$0$""
"PathResource.java:240"$0$"	/**"
"PathResource.java:241"$0$"	 * This implementation returns the underlying File's timestamp."
"PathResource.java:242"$0$"	 * @see java.nio.file.Files#getLastModifiedTime(Path, java.nio.file.LinkOption...)"
"PathResource.java:243"$0$"	 */"
"PathResource.java:244"$0$"	@Override"
"PathResource.java:245"$1$"	public long lastModified() throws IOException {"
"PathResource.java:246"$0$"		// We can not use the superclass method since it uses conversion to a File and"
"PathResource.java:247"$0$"		// only a Path on the default file system can be converted to a File..."
"PathResource.java:248"$1$"		return Files.getLastModifiedTime(this.path).toMillis();"
"PathResource.java:249"$1$"	}"
"PathResource.java:250"$0$""
"PathResource.java:251"$0$"	/**"
"PathResource.java:252"$0$"	 * This implementation creates a PathResource, applying the given path"
"PathResource.java:253"$0$"	 * relative to the path of the underlying file of this resource descriptor."
"PathResource.java:254"$0$"	 * @see java.nio.file.Path#resolve(String)"
"PathResource.java:255"$0$"	 */"
"PathResource.java:256"$0$"	@Override"
"PathResource.java:257"$1$"	public Resource createRelative(String relativePath) {"
"PathResource.java:258"$1$"		return new PathResource(this.path.resolve(relativePath));"
"PathResource.java:259"$1$"	}"
"PathResource.java:260"$0$""
"PathResource.java:261"$0$"	/**"
"PathResource.java:262"$0$"	 * This implementation returns the name of the file."
"PathResource.java:263"$0$"	 * @see java.nio.file.Path#getFileName()"
"PathResource.java:264"$0$"	 */"
"PathResource.java:265"$0$"	@Override"
"PathResource.java:266"$1$"	public String getFilename() {"
"PathResource.java:267"$1$"		return this.path.getFileName().toString();"
"PathResource.java:268"$1$"	}"
"PathResource.java:269"$0$""
"PathResource.java:270"$0$"	@Override"
"PathResource.java:271"$1$"	public String getDescription() {"
"PathResource.java:272"$1$"		return ""path ["" + this.path.toAbsolutePath() + ""]"";"
"PathResource.java:273"$1$"	}"
"PathResource.java:274"$0$""
"PathResource.java:275"$0$""
"PathResource.java:276"$0$"	/**"
"PathResource.java:277"$0$"	 * This implementation compares the underlying Path references."
"PathResource.java:278"$0$"	 */"
"PathResource.java:279"$0$"	@Override"
"PathResource.java:280"$1$"	public boolean equals(@Nullable Object other) {"
"PathResource.java:281"$1$"		return (this == other || (other instanceof PathResource &&"
"PathResource.java:282"$1$"				this.path.equals(((PathResource) other).path)));"
"PathResource.java:283"$1$"	}"
"PathResource.java:284"$0$""
"PathResource.java:285"$0$"	/**"
"PathResource.java:286"$0$"	 * This implementation returns the hash code of the underlying Path reference."
"PathResource.java:287"$0$"	 */"
"PathResource.java:288"$0$"	@Override"
"PathResource.java:289"$1$"	public int hashCode() {"
"PathResource.java:290"$1$"		return this.path.hashCode();"
"PathResource.java:291"$1$"	}"
"PathResource.java:292"$0$""
"PathResource.java:293"$0$"}"
"XMLEventStreamReader.java:1"$0$"/*"
"XMLEventStreamReader.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"XMLEventStreamReader.java:3"$0$" *"
"XMLEventStreamReader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"XMLEventStreamReader.java:5"$0$" * you may not use this file except in compliance with the License."
"XMLEventStreamReader.java:6"$0$" * You may obtain a copy of the License at"
"XMLEventStreamReader.java:7"$0$" *"
"XMLEventStreamReader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"XMLEventStreamReader.java:9"$0$" *"
"XMLEventStreamReader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"XMLEventStreamReader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"XMLEventStreamReader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"XMLEventStreamReader.java:13"$0$" * See the License for the specific language governing permissions and"
"XMLEventStreamReader.java:14"$0$" * limitations under the License."
"XMLEventStreamReader.java:15"$0$" */"
"XMLEventStreamReader.java:16"$0$""
"XMLEventStreamReader.java:17"$0$"package org.springframework.util.xml;"
"XMLEventStreamReader.java:18"$0$""
"XMLEventStreamReader.java:19"$0$"import java.util.Iterator;"
"XMLEventStreamReader.java:20"$0$""
"XMLEventStreamReader.java:21"$0$"import javax.xml.namespace.NamespaceContext;"
"XMLEventStreamReader.java:22"$0$"import javax.xml.namespace.QName;"
"XMLEventStreamReader.java:23"$0$"import javax.xml.stream.Location;"
"XMLEventStreamReader.java:24"$0$"import javax.xml.stream.XMLEventReader;"
"XMLEventStreamReader.java:25"$0$"import javax.xml.stream.XMLStreamException;"
"XMLEventStreamReader.java:26"$0$"import javax.xml.stream.events.Attribute;"
"XMLEventStreamReader.java:27"$0$"import javax.xml.stream.events.Comment;"
"XMLEventStreamReader.java:28"$0$"import javax.xml.stream.events.Namespace;"
"XMLEventStreamReader.java:29"$0$"import javax.xml.stream.events.ProcessingInstruction;"
"XMLEventStreamReader.java:30"$0$"import javax.xml.stream.events.StartDocument;"
"XMLEventStreamReader.java:31"$0$"import javax.xml.stream.events.XMLEvent;"
"XMLEventStreamReader.java:32"$0$""
"XMLEventStreamReader.java:33"$0$"import org.springframework.lang.Nullable;"
"XMLEventStreamReader.java:34"$0$""
"XMLEventStreamReader.java:35"$0$"/**"
"XMLEventStreamReader.java:36"$1$" * Implementation of the {@link javax.xml.stream.XMLStreamReader} interface that wraps a"
"XMLEventStreamReader.java:37"$1$" * {@link XMLEventReader}. Useful because the StAX {@link javax.xml.stream.XMLInputFactory}"
"XMLEventStreamReader.java:38"$0$" * allows one to create a event reader from a stream reader, but not vice-versa."
"XMLEventStreamReader.java:39"$0$" *"
"XMLEventStreamReader.java:40"$0$" * @author Arjen Poutsma"
"XMLEventStreamReader.java:41"$0$" * @since 3.0"
"XMLEventStreamReader.java:42"$0$" * @see StaxUtils#createEventStreamReader(javax.xml.stream.XMLEventReader)"
"XMLEventStreamReader.java:43"$0$" */"
"XMLEventStreamReader.java:44"$1$"class XMLEventStreamReader extends AbstractXMLStreamReader {"
"XMLEventStreamReader.java:45"$1$""
"XMLEventStreamReader.java:46"$1$"	private XMLEvent event;"
"XMLEventStreamReader.java:47"$1$""
"XMLEventStreamReader.java:48"$1$"	private final XMLEventReader eventReader;"
"XMLEventStreamReader.java:49"$1$""
"XMLEventStreamReader.java:50"$1$""
"XMLEventStreamReader.java:51"$1$"	public XMLEventStreamReader(XMLEventReader eventReader) throws XMLStreamException {"
"XMLEventStreamReader.java:52"$1$"		this.eventReader = eventReader;"
"XMLEventStreamReader.java:53"$1$"		this.event = eventReader.nextEvent();"
"XMLEventStreamReader.java:54"$1$"	}"
"XMLEventStreamReader.java:55"$0$""
"XMLEventStreamReader.java:56"$0$""
"XMLEventStreamReader.java:57"$0$"	@Override"
"XMLEventStreamReader.java:58"$1$"	public QName getName() {"
"XMLEventStreamReader.java:59"$1$"		if (this.event.isStartElement()) {"
"XMLEventStreamReader.java:60"$1$"			return this.event.asStartElement().getName();"
"XMLEventStreamReader.java:61"$1$"		}"
"XMLEventStreamReader.java:62"$1$"		else if (this.event.isEndElement()) {"
"XMLEventStreamReader.java:63"$1$"			return this.event.asEndElement().getName();"
"XMLEventStreamReader.java:64"$1$"		}"
"XMLEventStreamReader.java:65"$1$"		else {"
"XMLEventStreamReader.java:66"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:67"$1$"		}"
"XMLEventStreamReader.java:68"$0$"	}"
"XMLEventStreamReader.java:69"$0$""
"XMLEventStreamReader.java:70"$0$"	@Override"
"XMLEventStreamReader.java:71"$1$"	public Location getLocation() {"
"XMLEventStreamReader.java:72"$1$"		return this.event.getLocation();"
"XMLEventStreamReader.java:73"$1$"	}"
"XMLEventStreamReader.java:74"$0$""
"XMLEventStreamReader.java:75"$0$"	@Override"
"XMLEventStreamReader.java:76"$1$"	public int getEventType() {"
"XMLEventStreamReader.java:77"$1$"		return this.event.getEventType();"
"XMLEventStreamReader.java:78"$1$"	}"
"XMLEventStreamReader.java:79"$0$""
"XMLEventStreamReader.java:80"$0$"	@Override"
"XMLEventStreamReader.java:81"$0$"	@Nullable"
"XMLEventStreamReader.java:82"$1$"	public String getVersion() {"
"XMLEventStreamReader.java:83"$1$"		if (this.event.isStartDocument()) {"
"XMLEventStreamReader.java:84"$1$"			return ((StartDocument) this.event).getVersion();"
"XMLEventStreamReader.java:85"$1$"		}"
"XMLEventStreamReader.java:86"$1$"		else {"
"XMLEventStreamReader.java:87"$1$"			return null;"
"XMLEventStreamReader.java:88"$1$"		}"
"XMLEventStreamReader.java:89"$0$"	}"
"XMLEventStreamReader.java:90"$0$""
"XMLEventStreamReader.java:91"$0$"	@Override"
"XMLEventStreamReader.java:92"$1$"	public Object getProperty(String name) throws IllegalArgumentException {"
"XMLEventStreamReader.java:93"$1$"		return this.eventReader.getProperty(name);"
"XMLEventStreamReader.java:94"$1$"	}"
"XMLEventStreamReader.java:95"$0$""
"XMLEventStreamReader.java:96"$0$"	@Override"
"XMLEventStreamReader.java:97"$1$"	public boolean isStandalone() {"
"XMLEventStreamReader.java:98"$1$"		if (this.event.isStartDocument()) {"
"XMLEventStreamReader.java:99"$1$"			return ((StartDocument) this.event).isStandalone();"
"XMLEventStreamReader.java:100"$1$"		}"
"XMLEventStreamReader.java:101"$1$"		else {"
"XMLEventStreamReader.java:102"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:103"$1$"		}"
"XMLEventStreamReader.java:104"$0$"	}"
"XMLEventStreamReader.java:105"$0$""
"XMLEventStreamReader.java:106"$0$"	@Override"
"XMLEventStreamReader.java:107"$1$"	public boolean standaloneSet() {"
"XMLEventStreamReader.java:108"$1$"		if (this.event.isStartDocument()) {"
"XMLEventStreamReader.java:109"$1$"			return ((StartDocument) this.event).standaloneSet();"
"XMLEventStreamReader.java:110"$1$"		}"
"XMLEventStreamReader.java:111"$1$"		else {"
"XMLEventStreamReader.java:112"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:113"$1$"		}"
"XMLEventStreamReader.java:114"$0$"	}"
"XMLEventStreamReader.java:115"$0$""
"XMLEventStreamReader.java:116"$0$"	@Override"
"XMLEventStreamReader.java:117"$0$"	@Nullable"
"XMLEventStreamReader.java:118"$1$"	public String getEncoding() {"
"XMLEventStreamReader.java:119"$1$"		return null;"
"XMLEventStreamReader.java:120"$1$"	}"
"XMLEventStreamReader.java:121"$0$""
"XMLEventStreamReader.java:122"$0$"	@Override"
"XMLEventStreamReader.java:123"$0$"	@Nullable"
"XMLEventStreamReader.java:124"$1$"	public String getCharacterEncodingScheme() {"
"XMLEventStreamReader.java:125"$1$"		return null;"
"XMLEventStreamReader.java:126"$1$"	}"
"XMLEventStreamReader.java:127"$0$""
"XMLEventStreamReader.java:128"$0$"	@Override"
"XMLEventStreamReader.java:129"$1$"	public String getPITarget() {"
"XMLEventStreamReader.java:130"$1$"		if (this.event.isProcessingInstruction()) {"
"XMLEventStreamReader.java:131"$1$"			return ((ProcessingInstruction) this.event).getTarget();"
"XMLEventStreamReader.java:132"$1$"		}"
"XMLEventStreamReader.java:133"$1$"		else {"
"XMLEventStreamReader.java:134"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:135"$1$"		}"
"XMLEventStreamReader.java:136"$0$"	}"
"XMLEventStreamReader.java:137"$0$""
"XMLEventStreamReader.java:138"$0$"	@Override"
"XMLEventStreamReader.java:139"$1$"	public String getPIData() {"
"XMLEventStreamReader.java:140"$1$"		if (this.event.isProcessingInstruction()) {"
"XMLEventStreamReader.java:141"$1$"			return ((ProcessingInstruction) this.event).getData();"
"XMLEventStreamReader.java:142"$1$"		}"
"XMLEventStreamReader.java:143"$1$"		else {"
"XMLEventStreamReader.java:144"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:145"$1$"		}"
"XMLEventStreamReader.java:146"$0$"	}"
"XMLEventStreamReader.java:147"$0$""
"XMLEventStreamReader.java:148"$0$"	@Override"
"XMLEventStreamReader.java:149"$1$"	public int getTextStart() {"
"XMLEventStreamReader.java:150"$1$"		return 0;"
"XMLEventStreamReader.java:151"$1$"	}"
"XMLEventStreamReader.java:152"$0$""
"XMLEventStreamReader.java:153"$0$"	@Override"
"XMLEventStreamReader.java:154"$1$"	public String getText() {"
"XMLEventStreamReader.java:155"$1$"		if (this.event.isCharacters()) {"
"XMLEventStreamReader.java:156"$1$"			return this.event.asCharacters().getData();"
"XMLEventStreamReader.java:157"$1$"		}"
"XMLEventStreamReader.java:158"$1$"		else if (this.event.getEventType() == XMLEvent.COMMENT) {"
"XMLEventStreamReader.java:159"$1$"			return ((Comment) this.event).getText();"
"XMLEventStreamReader.java:160"$1$"		}"
"XMLEventStreamReader.java:161"$1$"		else {"
"XMLEventStreamReader.java:162"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:163"$1$"		}"
"XMLEventStreamReader.java:164"$0$"	}"
"XMLEventStreamReader.java:165"$0$""
"XMLEventStreamReader.java:166"$0$"	@Override"
"XMLEventStreamReader.java:167"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamReader.java:168"$1$"	public int getAttributeCount() {"
"XMLEventStreamReader.java:169"$1$"		if (!this.event.isStartElement()) {"
"XMLEventStreamReader.java:170"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:171"$1$"		}"
"XMLEventStreamReader.java:172"$0$"		Iterator attributes = this.event.asStartElement().getAttributes();"
"XMLEventStreamReader.java:173"$0$"		return countIterator(attributes);"
"XMLEventStreamReader.java:174"$0$"	}"
"XMLEventStreamReader.java:175"$0$""
"XMLEventStreamReader.java:176"$0$"	@Override"
"XMLEventStreamReader.java:177"$1$"	public boolean isAttributeSpecified(int index) {"
"XMLEventStreamReader.java:178"$1$"		return getAttribute(index).isSpecified();"
"XMLEventStreamReader.java:179"$1$"	}"
"XMLEventStreamReader.java:180"$0$""
"XMLEventStreamReader.java:181"$0$"	@Override"
"XMLEventStreamReader.java:182"$1$"	public QName getAttributeName(int index) {"
"XMLEventStreamReader.java:183"$1$"		return getAttribute(index).getName();"
"XMLEventStreamReader.java:184"$1$"	}"
"XMLEventStreamReader.java:185"$0$""
"XMLEventStreamReader.java:186"$0$"	@Override"
"XMLEventStreamReader.java:187"$1$"	public String getAttributeType(int index) {"
"XMLEventStreamReader.java:188"$1$"		return getAttribute(index).getDTDType();"
"XMLEventStreamReader.java:189"$1$"	}"
"XMLEventStreamReader.java:190"$0$""
"XMLEventStreamReader.java:191"$0$"	@Override"
"XMLEventStreamReader.java:192"$1$"	public String getAttributeValue(int index) {"
"XMLEventStreamReader.java:193"$1$"		return getAttribute(index).getValue();"
"XMLEventStreamReader.java:194"$1$"	}"
"XMLEventStreamReader.java:195"$0$""
"XMLEventStreamReader.java:196"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamReader.java:197"$1$"	private Attribute getAttribute(int index) {"
"XMLEventStreamReader.java:198"$1$"		if (!this.event.isStartElement()) {"
"XMLEventStreamReader.java:199"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:200"$1$"		}"
"XMLEventStreamReader.java:201"$0$"		int count = 0;"
"XMLEventStreamReader.java:202"$0$"		Iterator attributes = this.event.asStartElement().getAttributes();"
"XMLEventStreamReader.java:203"$1$"		while (attributes.hasNext()) {"
"XMLEventStreamReader.java:204"$1$"			Attribute attribute = (Attribute) attributes.next();"
"XMLEventStreamReader.java:205"$1$"			if (count == index) {"
"XMLEventStreamReader.java:206"$1$"				return attribute;"
"XMLEventStreamReader.java:207"$1$"			}"
"XMLEventStreamReader.java:208"$1$"			else {"
"XMLEventStreamReader.java:209"$1$"				count++;"
"XMLEventStreamReader.java:210"$1$"			}"
"XMLEventStreamReader.java:211"$0$"		}"
"XMLEventStreamReader.java:212"$0$"		throw new IllegalArgumentException();"
"XMLEventStreamReader.java:213"$0$"	}"
"XMLEventStreamReader.java:214"$0$""
"XMLEventStreamReader.java:215"$0$"	@Override"
"XMLEventStreamReader.java:216"$1$"	public NamespaceContext getNamespaceContext() {"
"XMLEventStreamReader.java:217"$1$"		if (this.event.isStartElement()) {"
"XMLEventStreamReader.java:218"$1$"			return this.event.asStartElement().getNamespaceContext();"
"XMLEventStreamReader.java:219"$1$"		}"
"XMLEventStreamReader.java:220"$1$"		else {"
"XMLEventStreamReader.java:221"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:222"$1$"		}"
"XMLEventStreamReader.java:223"$0$"	}"
"XMLEventStreamReader.java:224"$0$""
"XMLEventStreamReader.java:225"$0$"	@Override"
"XMLEventStreamReader.java:226"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamReader.java:227"$1$"	public int getNamespaceCount() {"
"XMLEventStreamReader.java:228"$1$"		Iterator namespaces;"
"XMLEventStreamReader.java:229"$1$"		if (this.event.isStartElement()) {"
"XMLEventStreamReader.java:230"$1$"			namespaces = this.event.asStartElement().getNamespaces();"
"XMLEventStreamReader.java:231"$1$"		}"
"XMLEventStreamReader.java:232"$1$"		else if (this.event.isEndElement()) {"
"XMLEventStreamReader.java:233"$1$"			namespaces = this.event.asEndElement().getNamespaces();"
"XMLEventStreamReader.java:234"$1$"		}"
"XMLEventStreamReader.java:235"$1$"		else {"
"XMLEventStreamReader.java:236"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:237"$1$"		}"
"XMLEventStreamReader.java:238"$0$"		return countIterator(namespaces);"
"XMLEventStreamReader.java:239"$0$"	}"
"XMLEventStreamReader.java:240"$0$""
"XMLEventStreamReader.java:241"$0$"	@Override"
"XMLEventStreamReader.java:242"$1$"	public String getNamespacePrefix(int index) {"
"XMLEventStreamReader.java:243"$1$"		return getNamespace(index).getPrefix();"
"XMLEventStreamReader.java:244"$1$"	}"
"XMLEventStreamReader.java:245"$0$""
"XMLEventStreamReader.java:246"$0$"	@Override"
"XMLEventStreamReader.java:247"$1$"	public String getNamespaceURI(int index) {"
"XMLEventStreamReader.java:248"$1$"		return getNamespace(index).getNamespaceURI();"
"XMLEventStreamReader.java:249"$1$"	}"
"XMLEventStreamReader.java:250"$0$""
"XMLEventStreamReader.java:251"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamReader.java:252"$1$"	private Namespace getNamespace(int index) {"
"XMLEventStreamReader.java:253"$1$"		Iterator namespaces;"
"XMLEventStreamReader.java:254"$1$"		if (this.event.isStartElement()) {"
"XMLEventStreamReader.java:255"$1$"			namespaces = this.event.asStartElement().getNamespaces();"
"XMLEventStreamReader.java:256"$1$"		}"
"XMLEventStreamReader.java:257"$1$"		else if (this.event.isEndElement()) {"
"XMLEventStreamReader.java:258"$1$"			namespaces = this.event.asEndElement().getNamespaces();"
"XMLEventStreamReader.java:259"$1$"		}"
"XMLEventStreamReader.java:260"$1$"		else {"
"XMLEventStreamReader.java:261"$1$"			throw new IllegalStateException();"
"XMLEventStreamReader.java:262"$1$"		}"
"XMLEventStreamReader.java:263"$0$"		int count = 0;"
"XMLEventStreamReader.java:264"$1$"		while (namespaces.hasNext()) {"
"XMLEventStreamReader.java:265"$1$"			Namespace namespace = (Namespace) namespaces.next();"
"XMLEventStreamReader.java:266"$1$"			if (count == index) {"
"XMLEventStreamReader.java:267"$1$"				return namespace;"
"XMLEventStreamReader.java:268"$1$"			}"
"XMLEventStreamReader.java:269"$1$"			else {"
"XMLEventStreamReader.java:270"$1$"				count++;"
"XMLEventStreamReader.java:271"$1$"			}"
"XMLEventStreamReader.java:272"$0$"		}"
"XMLEventStreamReader.java:273"$0$"		throw new IllegalArgumentException();"
"XMLEventStreamReader.java:274"$0$"	}"
"XMLEventStreamReader.java:275"$0$""
"XMLEventStreamReader.java:276"$0$"	@Override"
"XMLEventStreamReader.java:277"$1$"	public int next() throws XMLStreamException {"
"XMLEventStreamReader.java:278"$1$"		this.event = this.eventReader.nextEvent();"
"XMLEventStreamReader.java:279"$1$"		return this.event.getEventType();"
"XMLEventStreamReader.java:280"$1$"	}"
"XMLEventStreamReader.java:281"$0$""
"XMLEventStreamReader.java:282"$0$"	@Override"
"XMLEventStreamReader.java:283"$1$"	public void close() throws XMLStreamException {"
"XMLEventStreamReader.java:284"$1$"		this.eventReader.close();"
"XMLEventStreamReader.java:285"$1$"	}"
"XMLEventStreamReader.java:286"$0$""
"XMLEventStreamReader.java:287"$0$""
"XMLEventStreamReader.java:288"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamReader.java:289"$1$"	private static int countIterator(Iterator iterator) {"
"XMLEventStreamReader.java:290"$1$"		int count = 0;"
"XMLEventStreamReader.java:291"$1$"		while (iterator.hasNext()) {"
"XMLEventStreamReader.java:292"$1$"			iterator.next();"
"XMLEventStreamReader.java:293"$1$"			count++;"
"XMLEventStreamReader.java:294"$1$"		}"
"XMLEventStreamReader.java:295"$0$"		return count;"
"XMLEventStreamReader.java:296"$0$"	}"
"XMLEventStreamReader.java:297"$0$""
"XMLEventStreamReader.java:298"$0$"}"
"CompositePropertySource.java:1"$0$"/*"
"CompositePropertySource.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"CompositePropertySource.java:3"$0$" *"
"CompositePropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CompositePropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"CompositePropertySource.java:6"$0$" * You may obtain a copy of the License at"
"CompositePropertySource.java:7"$0$" *"
"CompositePropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CompositePropertySource.java:9"$0$" *"
"CompositePropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CompositePropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CompositePropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CompositePropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"CompositePropertySource.java:14"$0$" * limitations under the License."
"CompositePropertySource.java:15"$0$" */"
"CompositePropertySource.java:16"$0$""
"CompositePropertySource.java:17"$0$"package org.springframework.core.env;"
"CompositePropertySource.java:18"$0$""
"CompositePropertySource.java:19"$0$"import java.util.ArrayList;"
"CompositePropertySource.java:20"$0$"import java.util.Arrays;"
"CompositePropertySource.java:21"$0$"import java.util.Collection;"
"CompositePropertySource.java:22"$0$"import java.util.LinkedHashSet;"
"CompositePropertySource.java:23"$0$"import java.util.List;"
"CompositePropertySource.java:24"$0$"import java.util.Set;"
"CompositePropertySource.java:25"$0$""
"CompositePropertySource.java:26"$0$"import org.springframework.lang.Nullable;"
"CompositePropertySource.java:27"$0$"import org.springframework.util.StringUtils;"
"CompositePropertySource.java:28"$0$""
"CompositePropertySource.java:29"$0$"/**"
"CompositePropertySource.java:30"$1$" * Composite {@link PropertySource} implementation that iterates over a set of"
"CompositePropertySource.java:31"$1$" * {@link PropertySource} instances. Necessary in cases where multiple property sources"
"CompositePropertySource.java:32"$1$" * share the same name, e.g. when multiple values are supplied to {@code @PropertySource}."
"CompositePropertySource.java:33"$0$" *"
"CompositePropertySource.java:34"$1$" * <p>As of Spring 4.1.2, this class extends {@link EnumerablePropertySource} instead"
"CompositePropertySource.java:35"$1$" * of plain {@link PropertySource}, exposing {@link #getPropertyNames()} based on the"
"CompositePropertySource.java:36"$0$" * accumulated property names from all contained sources (as far as possible)."
"CompositePropertySource.java:37"$0$" *"
"CompositePropertySource.java:38"$0$" * @author Chris Beams"
"CompositePropertySource.java:39"$0$" * @author Juergen Hoeller"
"CompositePropertySource.java:40"$0$" * @author Phillip Webb"
"CompositePropertySource.java:41"$0$" * @since 3.1.1"
"CompositePropertySource.java:42"$0$" */"
"CompositePropertySource.java:43"$1$"public class CompositePropertySource extends EnumerablePropertySource<Object> {"
"CompositePropertySource.java:44"$1$""
"CompositePropertySource.java:45"$1$"	private final Set<PropertySource<?>> propertySources = new LinkedHashSet<>();"
"CompositePropertySource.java:46"$1$""
"CompositePropertySource.java:47"$1$""
"CompositePropertySource.java:48"$1$"	/**"
"CompositePropertySource.java:49"$1$"	 * Create a new {@code CompositePropertySource}."
"CompositePropertySource.java:50"$1$"	 * @param name the name of the property source"
"CompositePropertySource.java:51"$1$"	 */"
"CompositePropertySource.java:52"$1$"	public CompositePropertySource(String name) {"
"CompositePropertySource.java:53"$1$"		super(name);"
"CompositePropertySource.java:54"$1$"	}"
"CompositePropertySource.java:55"$0$""
"CompositePropertySource.java:56"$0$""
"CompositePropertySource.java:57"$0$"	@Override"
"CompositePropertySource.java:58"$0$"	@Nullable"
"CompositePropertySource.java:59"$1$"	public Object getProperty(String name) {"
"CompositePropertySource.java:60"$1$"		for (PropertySource<?> propertySource : this.propertySources) {"
"CompositePropertySource.java:61"$1$"			Object candidate = propertySource.getProperty(name);"
"CompositePropertySource.java:62"$1$"			if (candidate != null) {"
"CompositePropertySource.java:63"$1$"				return candidate;"
"CompositePropertySource.java:64"$1$"			}"
"CompositePropertySource.java:65"$0$"		}"
"CompositePropertySource.java:66"$0$"		return null;"
"CompositePropertySource.java:67"$0$"	}"
"CompositePropertySource.java:68"$0$""
"CompositePropertySource.java:69"$0$"	@Override"
"CompositePropertySource.java:70"$1$"	public boolean containsProperty(String name) {"
"CompositePropertySource.java:71"$1$"		for (PropertySource<?> propertySource : this.propertySources) {"
"CompositePropertySource.java:72"$1$"			if (propertySource.containsProperty(name)) {"
"CompositePropertySource.java:73"$1$"				return true;"
"CompositePropertySource.java:74"$1$"			}"
"CompositePropertySource.java:75"$0$"		}"
"CompositePropertySource.java:76"$0$"		return false;"
"CompositePropertySource.java:77"$0$"	}"
"CompositePropertySource.java:78"$0$""
"CompositePropertySource.java:79"$0$"	@Override"
"CompositePropertySource.java:80"$1$"	public String[] getPropertyNames() {"
"CompositePropertySource.java:81"$1$"		Set<String> names = new LinkedHashSet<>();"
"CompositePropertySource.java:82"$1$"		for (PropertySource<?> propertySource : this.propertySources) {"
"CompositePropertySource.java:83"$1$"			if (!(propertySource instanceof EnumerablePropertySource)) {"
"CompositePropertySource.java:84"$1$"				throw new IllegalStateException("
"CompositePropertySource.java:85"$1$"						""Failed to enumerate property names due to non-enumerable property source: "" + propertySource);"
"CompositePropertySource.java:86"$1$"			}"
"CompositePropertySource.java:87"$0$"			names.addAll(Arrays.asList(((EnumerablePropertySource<?>) propertySource).getPropertyNames()));"
"CompositePropertySource.java:88"$0$"		}"
"CompositePropertySource.java:89"$0$"		return StringUtils.toStringArray(names);"
"CompositePropertySource.java:90"$0$"	}"
"CompositePropertySource.java:91"$0$""
"CompositePropertySource.java:92"$0$""
"CompositePropertySource.java:93"$0$"	/**"
"CompositePropertySource.java:94"$1$"	 * Add the given {@link PropertySource} to the end of the chain."
"CompositePropertySource.java:95"$0$"	 * @param propertySource the PropertySource to add"
"CompositePropertySource.java:96"$0$"	 */"
"CompositePropertySource.java:97"$1$"	public void addPropertySource(PropertySource<?> propertySource) {"
"CompositePropertySource.java:98"$1$"		this.propertySources.add(propertySource);"
"CompositePropertySource.java:99"$1$"	}"
"CompositePropertySource.java:100"$0$""
"CompositePropertySource.java:101"$0$"	/**"
"CompositePropertySource.java:102"$1$"	 * Add the given {@link PropertySource} to the start of the chain."
"CompositePropertySource.java:103"$0$"	 * @param propertySource the PropertySource to add"
"CompositePropertySource.java:104"$0$"	 * @since 4.1"
"CompositePropertySource.java:105"$0$"	 */"
"CompositePropertySource.java:106"$1$"	public void addFirstPropertySource(PropertySource<?> propertySource) {"
"CompositePropertySource.java:107"$1$"		List<PropertySource<?>> existing = new ArrayList<>(this.propertySources);"
"CompositePropertySource.java:108"$1$"		this.propertySources.clear();"
"CompositePropertySource.java:109"$1$"		this.propertySources.add(propertySource);"
"CompositePropertySource.java:110"$1$"		this.propertySources.addAll(existing);"
"CompositePropertySource.java:111"$1$"	}"
"CompositePropertySource.java:112"$0$""
"CompositePropertySource.java:113"$0$"	/**"
"CompositePropertySource.java:114"$0$"	 * Return all property sources that this composite source holds."
"CompositePropertySource.java:115"$0$"	 * @since 4.1.1"
"CompositePropertySource.java:116"$0$"	 */"
"CompositePropertySource.java:117"$1$"	public Collection<PropertySource<?>> getPropertySources() {"
"CompositePropertySource.java:118"$1$"		return this.propertySources;"
"CompositePropertySource.java:119"$1$"	}"
"CompositePropertySource.java:120"$0$""
"CompositePropertySource.java:121"$0$""
"CompositePropertySource.java:122"$0$"	@Override"
"CompositePropertySource.java:123"$1$"	public String toString() {"
"CompositePropertySource.java:124"$1$"		return getClass().getSimpleName() + "" {name='"" + this.name + ""', propertySources="" + this.propertySources + ""}"";"
"CompositePropertySource.java:125"$1$"	}"
"CompositePropertySource.java:126"$0$""
"CompositePropertySource.java:127"$0$"}"
"SocketUtils.java:1"$0$"/*"
"SocketUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SocketUtils.java:3"$0$" *"
"SocketUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SocketUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"SocketUtils.java:6"$0$" * You may obtain a copy of the License at"
"SocketUtils.java:7"$0$" *"
"SocketUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SocketUtils.java:9"$0$" *"
"SocketUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SocketUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SocketUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SocketUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"SocketUtils.java:14"$0$" * limitations under the License."
"SocketUtils.java:15"$0$" */"
"SocketUtils.java:16"$0$""
"SocketUtils.java:17"$0$"package org.springframework.util;"
"SocketUtils.java:18"$0$""
"SocketUtils.java:19"$0$"import java.net.DatagramSocket;"
"SocketUtils.java:20"$0$"import java.net.InetAddress;"
"SocketUtils.java:21"$0$"import java.net.ServerSocket;"
"SocketUtils.java:22"$0$"import java.util.Random;"
"SocketUtils.java:23"$0$"import java.util.SortedSet;"
"SocketUtils.java:24"$0$"import java.util.TreeSet;"
"SocketUtils.java:25"$0$""
"SocketUtils.java:26"$0$"import javax.net.ServerSocketFactory;"
"SocketUtils.java:27"$0$""
"SocketUtils.java:28"$0$"/**"
"SocketUtils.java:29"$0$" * Simple utility methods for working with network sockets &mdash; for example,"
"SocketUtils.java:30"$1$" * for finding available ports on {@code localhost}."
"SocketUtils.java:31"$0$" *"
"SocketUtils.java:32"$1$" * <p>Within this class, a TCP port refers to a port for a {@link ServerSocket};"
"SocketUtils.java:33"$1$" * whereas, a UDP port refers to a port for a {@link DatagramSocket}."
"SocketUtils.java:34"$0$" *"
"SocketUtils.java:35"$0$" * @author Sam Brannen"
"SocketUtils.java:36"$0$" * @author Ben Hale"
"SocketUtils.java:37"$0$" * @author Arjen Poutsma"
"SocketUtils.java:38"$0$" * @author Gunnar Hillert"
"SocketUtils.java:39"$0$" * @author Gary Russell"
"SocketUtils.java:40"$0$" * @since 4.0"
"SocketUtils.java:41"$0$" */"
"SocketUtils.java:42"$1$"public class SocketUtils {"
"SocketUtils.java:43"$1$""
"SocketUtils.java:44"$1$"	/**"
"SocketUtils.java:45"$1$"	 * The default minimum value for port ranges used when finding an available"
"SocketUtils.java:46"$1$"	 * socket port."
"SocketUtils.java:47"$1$"	 */"
"SocketUtils.java:48"$1$"	public static final int PORT_RANGE_MIN = 1024;"
"SocketUtils.java:49"$1$""
"SocketUtils.java:50"$1$"	/**"
"SocketUtils.java:51"$1$"	 * The default maximum value for port ranges used when finding an available"
"SocketUtils.java:52"$1$"	 * socket port."
"SocketUtils.java:53"$1$"	 */"
"SocketUtils.java:54"$1$"	public static final int PORT_RANGE_MAX = 65535;"
"SocketUtils.java:55"$1$""
"SocketUtils.java:56"$1$""
"SocketUtils.java:57"$1$"	private static final Random random = new Random(System.currentTimeMillis());"
"SocketUtils.java:58"$1$""
"SocketUtils.java:59"$1$""
"SocketUtils.java:60"$1$"	/**"
"SocketUtils.java:61"$1$"	 * Although {@code SocketUtils} consists solely of static utility methods,"
"SocketUtils.java:62"$1$"	 * this constructor is intentionally {@code public}."
"SocketUtils.java:63"$1$"	 * <h4>Rationale</h4>"
"SocketUtils.java:64"$1$"	 * <p>Static methods from this class may be invoked from within XML"
"SocketUtils.java:65"$1$"	 * configuration files using the Spring Expression Language (SpEL) and the"
"SocketUtils.java:66"$1$"	 * following syntax."
"SocketUtils.java:67"$1$"	 * <pre><code>&lt;bean id=""bean1"" ... p:port=""#{T(org.springframework.util.SocketUtils).findAvailableTcpPort(12000)}"" /&gt;</code></pre>"
"SocketUtils.java:68"$1$"	 * If this constructor were {@code private}, you would be required to supply"
"SocketUtils.java:69"$1$"	 * the fully qualified class name to SpEL's {@code T()} function for each usage."
"SocketUtils.java:70"$1$"	 * Thus, the fact that this constructor is {@code public} allows you to reduce"
"SocketUtils.java:71"$1$"	 * boilerplate configuration with SpEL as can be seen in the following example."
"SocketUtils.java:72"$1$"	 * <pre><code>&lt;bean id=""socketUtils"" class=""org.springframework.util.SocketUtils"" /&gt;"
"SocketUtils.java:73"$1$"	 * &lt;bean id=""bean1"" ... p:port=""#{socketUtils.findAvailableTcpPort(12000)}"" /&gt;"
"SocketUtils.java:74"$1$"	 * &lt;bean id=""bean2"" ... p:port=""#{socketUtils.findAvailableTcpPort(30000)}"" /&gt;</code></pre>"
"SocketUtils.java:75"$1$"	 */"
"SocketUtils.java:76"$1$"	public SocketUtils() {"
"SocketUtils.java:77"$1$"	}"
"SocketUtils.java:78"$0$""
"SocketUtils.java:79"$0$""
"SocketUtils.java:80"$0$"	/**"
"SocketUtils.java:81"$0$"	 * Find an available TCP port randomly selected from the range"
"SocketUtils.java:82"$1$"	 * [{@value #PORT_RANGE_MIN}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:83"$0$"	 * @return an available TCP port number"
"SocketUtils.java:84"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:85"$0$"	 */"
"SocketUtils.java:86"$1$"	public static int findAvailableTcpPort() {"
"SocketUtils.java:87"$1$"		return findAvailableTcpPort(PORT_RANGE_MIN);"
"SocketUtils.java:88"$1$"	}"
"SocketUtils.java:89"$0$""
"SocketUtils.java:90"$0$"	/**"
"SocketUtils.java:91"$0$"	 * Find an available TCP port randomly selected from the range"
"SocketUtils.java:92"$1$"	 * [{@code minPort}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:93"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:94"$0$"	 * @return an available TCP port number"
"SocketUtils.java:95"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:96"$0$"	 */"
"SocketUtils.java:97"$1$"	public static int findAvailableTcpPort(int minPort) {"
"SocketUtils.java:98"$1$"		return findAvailableTcpPort(minPort, PORT_RANGE_MAX);"
"SocketUtils.java:99"$1$"	}"
"SocketUtils.java:100"$0$""
"SocketUtils.java:101"$0$"	/**"
"SocketUtils.java:102"$0$"	 * Find an available TCP port randomly selected from the range"
"SocketUtils.java:103"$1$"	 * [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:104"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:105"$0$"	 * @param maxPort the maximum port number"
"SocketUtils.java:106"$0$"	 * @return an available TCP port number"
"SocketUtils.java:107"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:108"$0$"	 */"
"SocketUtils.java:109"$1$"	public static int findAvailableTcpPort(int minPort, int maxPort) {"
"SocketUtils.java:110"$1$"		return SocketType.TCP.findAvailablePort(minPort, maxPort);"
"SocketUtils.java:111"$1$"	}"
"SocketUtils.java:112"$0$""
"SocketUtils.java:113"$0$"	/**"
"SocketUtils.java:114"$0$"	 * Find the requested number of available TCP ports, each randomly selected"
"SocketUtils.java:115"$1$"	 * from the range [{@value #PORT_RANGE_MIN}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:116"$0$"	 * @param numRequested the number of available ports to find"
"SocketUtils.java:117"$0$"	 * @return a sorted set of available TCP port numbers"
"SocketUtils.java:118"$0$"	 * @throws IllegalStateException if the requested number of available ports could not be found"
"SocketUtils.java:119"$0$"	 */"
"SocketUtils.java:120"$1$"	public static SortedSet<Integer> findAvailableTcpPorts(int numRequested) {"
"SocketUtils.java:121"$1$"		return findAvailableTcpPorts(numRequested, PORT_RANGE_MIN, PORT_RANGE_MAX);"
"SocketUtils.java:122"$1$"	}"
"SocketUtils.java:123"$0$""
"SocketUtils.java:124"$0$"	/**"
"SocketUtils.java:125"$0$"	 * Find the requested number of available TCP ports, each randomly selected"
"SocketUtils.java:126"$1$"	 * from the range [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:127"$0$"	 * @param numRequested the number of available ports to find"
"SocketUtils.java:128"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:129"$0$"	 * @param maxPort the maximum port number"
"SocketUtils.java:130"$0$"	 * @return a sorted set of available TCP port numbers"
"SocketUtils.java:131"$0$"	 * @throws IllegalStateException if the requested number of available ports could not be found"
"SocketUtils.java:132"$0$"	 */"
"SocketUtils.java:133"$1$"	public static SortedSet<Integer> findAvailableTcpPorts(int numRequested, int minPort, int maxPort) {"
"SocketUtils.java:134"$1$"		return SocketType.TCP.findAvailablePorts(numRequested, minPort, maxPort);"
"SocketUtils.java:135"$1$"	}"
"SocketUtils.java:136"$0$""
"SocketUtils.java:137"$0$"	/**"
"SocketUtils.java:138"$0$"	 * Find an available UDP port randomly selected from the range"
"SocketUtils.java:139"$1$"	 * [{@value #PORT_RANGE_MIN}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:140"$0$"	 * @return an available UDP port number"
"SocketUtils.java:141"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:142"$0$"	 */"
"SocketUtils.java:143"$1$"	public static int findAvailableUdpPort() {"
"SocketUtils.java:144"$1$"		return findAvailableUdpPort(PORT_RANGE_MIN);"
"SocketUtils.java:145"$1$"	}"
"SocketUtils.java:146"$0$""
"SocketUtils.java:147"$0$"	/**"
"SocketUtils.java:148"$0$"	 * Find an available UDP port randomly selected from the range"
"SocketUtils.java:149"$1$"	 * [{@code minPort}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:150"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:151"$0$"	 * @return an available UDP port number"
"SocketUtils.java:152"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:153"$0$"	 */"
"SocketUtils.java:154"$1$"	public static int findAvailableUdpPort(int minPort) {"
"SocketUtils.java:155"$1$"		return findAvailableUdpPort(minPort, PORT_RANGE_MAX);"
"SocketUtils.java:156"$1$"	}"
"SocketUtils.java:157"$0$""
"SocketUtils.java:158"$0$"	/**"
"SocketUtils.java:159"$0$"	 * Find an available UDP port randomly selected from the range"
"SocketUtils.java:160"$1$"	 * [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:161"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:162"$0$"	 * @param maxPort the maximum port number"
"SocketUtils.java:163"$0$"	 * @return an available UDP port number"
"SocketUtils.java:164"$0$"	 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:165"$0$"	 */"
"SocketUtils.java:166"$1$"	public static int findAvailableUdpPort(int minPort, int maxPort) {"
"SocketUtils.java:167"$1$"		return SocketType.UDP.findAvailablePort(minPort, maxPort);"
"SocketUtils.java:168"$1$"	}"
"SocketUtils.java:169"$0$""
"SocketUtils.java:170"$0$"	/**"
"SocketUtils.java:171"$0$"	 * Find the requested number of available UDP ports, each randomly selected"
"SocketUtils.java:172"$1$"	 * from the range [{@value #PORT_RANGE_MIN}, {@value #PORT_RANGE_MAX}]."
"SocketUtils.java:173"$0$"	 * @param numRequested the number of available ports to find"
"SocketUtils.java:174"$0$"	 * @return a sorted set of available UDP port numbers"
"SocketUtils.java:175"$0$"	 * @throws IllegalStateException if the requested number of available ports could not be found"
"SocketUtils.java:176"$0$"	 */"
"SocketUtils.java:177"$1$"	public static SortedSet<Integer> findAvailableUdpPorts(int numRequested) {"
"SocketUtils.java:178"$1$"		return findAvailableUdpPorts(numRequested, PORT_RANGE_MIN, PORT_RANGE_MAX);"
"SocketUtils.java:179"$1$"	}"
"SocketUtils.java:180"$0$""
"SocketUtils.java:181"$0$"	/**"
"SocketUtils.java:182"$0$"	 * Find the requested number of available UDP ports, each randomly selected"
"SocketUtils.java:183"$1$"	 * from the range [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:184"$0$"	 * @param numRequested the number of available ports to find"
"SocketUtils.java:185"$0$"	 * @param minPort the minimum port number"
"SocketUtils.java:186"$0$"	 * @param maxPort the maximum port number"
"SocketUtils.java:187"$0$"	 * @return a sorted set of available UDP port numbers"
"SocketUtils.java:188"$0$"	 * @throws IllegalStateException if the requested number of available ports could not be found"
"SocketUtils.java:189"$0$"	 */"
"SocketUtils.java:190"$1$"	public static SortedSet<Integer> findAvailableUdpPorts(int numRequested, int minPort, int maxPort) {"
"SocketUtils.java:191"$1$"		return SocketType.UDP.findAvailablePorts(numRequested, minPort, maxPort);"
"SocketUtils.java:192"$1$"	}"
"SocketUtils.java:193"$0$""
"SocketUtils.java:194"$0$""
"SocketUtils.java:195"$1$"	private enum SocketType {"
"SocketUtils.java:196"$1$""
"SocketUtils.java:197"$1$"		TCP {"
"SocketUtils.java:198"$1$"			@Override"
"SocketUtils.java:199"$1$"			protected boolean isPortAvailable(int port) {"
"SocketUtils.java:200"$1$"				try {"
"SocketUtils.java:201"$1$"					ServerSocket serverSocket = ServerSocketFactory.getDefault().createServerSocket("
"SocketUtils.java:202"$1$"							port, 1, InetAddress.getByName(""localhost""));"
"SocketUtils.java:203"$1$"					serverSocket.close();"
"SocketUtils.java:204"$1$"					return true;"
"SocketUtils.java:205"$1$"				}"
"SocketUtils.java:206"$1$"				catch (Exception ex) {"
"SocketUtils.java:207"$1$"					return false;"
"SocketUtils.java:208"$1$"				}"
"SocketUtils.java:209"$0$"			}"
"SocketUtils.java:210"$0$"		},"
"SocketUtils.java:211"$0$""
"SocketUtils.java:212"$1$"		UDP {"
"SocketUtils.java:213"$1$"			@Override"
"SocketUtils.java:214"$1$"			protected boolean isPortAvailable(int port) {"
"SocketUtils.java:215"$1$"				try {"
"SocketUtils.java:216"$1$"					DatagramSocket socket = new DatagramSocket(port, InetAddress.getByName(""localhost""));"
"SocketUtils.java:217"$1$"					socket.close();"
"SocketUtils.java:218"$1$"					return true;"
"SocketUtils.java:219"$1$"				}"
"SocketUtils.java:220"$1$"				catch (Exception ex) {"
"SocketUtils.java:221"$1$"					return false;"
"SocketUtils.java:222"$1$"				}"
"SocketUtils.java:223"$0$"			}"
"SocketUtils.java:224"$0$"		};"
"SocketUtils.java:225"$0$""
"SocketUtils.java:226"$0$"		/**"
"SocketUtils.java:227"$1$"		 * Determine if the specified port for this {@code SocketType} is"
"SocketUtils.java:228"$1$"		 * currently available on {@code localhost}."
"SocketUtils.java:229"$0$"		 */"
"SocketUtils.java:230"$0$"		protected abstract boolean isPortAvailable(int port);"
"SocketUtils.java:231"$0$""
"SocketUtils.java:232"$0$"		/**"
"SocketUtils.java:233"$0$"		 * Find a pseudo-random port number within the range"
"SocketUtils.java:234"$1$"		 * [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:235"$0$"		 * @param minPort the minimum port number"
"SocketUtils.java:236"$0$"		 * @param maxPort the maximum port number"
"SocketUtils.java:237"$0$"		 * @return a random port number within the specified range"
"SocketUtils.java:238"$0$"		 */"
"SocketUtils.java:239"$1$"		private int findRandomPort(int minPort, int maxPort) {"
"SocketUtils.java:240"$1$"			int portRange = maxPort - minPort;"
"SocketUtils.java:241"$1$"			return minPort + random.nextInt(portRange + 1);"
"SocketUtils.java:242"$1$"		}"
"SocketUtils.java:243"$0$""
"SocketUtils.java:244"$0$"		/**"
"SocketUtils.java:245"$1$"		 * Find an available port for this {@code SocketType}, randomly selected"
"SocketUtils.java:246"$1$"		 * from the range [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:247"$0$"		 * @param minPort the minimum port number"
"SocketUtils.java:248"$0$"		 * @param maxPort the maximum port number"
"SocketUtils.java:249"$0$"		 * @return an available port number for this socket type"
"SocketUtils.java:250"$0$"		 * @throws IllegalStateException if no available port could be found"
"SocketUtils.java:251"$0$"		 */"
"SocketUtils.java:252"$1$"		int findAvailablePort(int minPort, int maxPort) {"
"SocketUtils.java:253"$1$"			Assert.isTrue(minPort > 0, ""'minPort' must be greater than 0"");"
"SocketUtils.java:254"$1$"			Assert.isTrue(maxPort >= minPort, ""'maxPort' must be greater than or equal to 'minPort'"");"
"SocketUtils.java:255"$1$"			Assert.isTrue(maxPort <= PORT_RANGE_MAX, ""'maxPort' must be less than or equal to "" + PORT_RANGE_MAX);"
"SocketUtils.java:256"$1$""
"SocketUtils.java:257"$1$"			int portRange = maxPort - minPort;"
"SocketUtils.java:258"$1$"			int candidatePort;"
"SocketUtils.java:259"$1$"			int searchCounter = 0;"
"SocketUtils.java:260"$1$"			do {"
"SocketUtils.java:261"$1$"				if (searchCounter > portRange) {"
"SocketUtils.java:262"$1$"					throw new IllegalStateException(String.format("
"SocketUtils.java:263"$1$"							""Could not find an available %s port in the range [%d, %d] after %d attempts"","
"SocketUtils.java:264"$1$"							name(), minPort, maxPort, searchCounter));"
"SocketUtils.java:265"$1$"				}"
"SocketUtils.java:266"$0$"				candidatePort = findRandomPort(minPort, maxPort);"
"SocketUtils.java:267"$0$"				searchCounter++;"
"SocketUtils.java:268"$0$"			}"
"SocketUtils.java:269"$0$"			while (!isPortAvailable(candidatePort));"
"SocketUtils.java:270"$0$""
"SocketUtils.java:271"$0$"			return candidatePort;"
"SocketUtils.java:272"$0$"		}"
"SocketUtils.java:273"$0$""
"SocketUtils.java:274"$0$"		/**"
"SocketUtils.java:275"$1$"		 * Find the requested number of available ports for this {@code SocketType},"
"SocketUtils.java:276"$1$"		 * each randomly selected from the range [{@code minPort}, {@code maxPort}]."
"SocketUtils.java:277"$0$"		 * @param numRequested the number of available ports to find"
"SocketUtils.java:278"$0$"		 * @param minPort the minimum port number"
"SocketUtils.java:279"$0$"		 * @param maxPort the maximum port number"
"SocketUtils.java:280"$0$"		 * @return a sorted set of available port numbers for this socket type"
"SocketUtils.java:281"$0$"		 * @throws IllegalStateException if the requested number of available ports could not be found"
"SocketUtils.java:282"$0$"		 */"
"SocketUtils.java:283"$1$"		SortedSet<Integer> findAvailablePorts(int numRequested, int minPort, int maxPort) {"
"SocketUtils.java:284"$1$"			Assert.isTrue(minPort > 0, ""'minPort' must be greater than 0"");"
"SocketUtils.java:285"$1$"			Assert.isTrue(maxPort > minPort, ""'maxPort' must be greater than 'minPort'"");"
"SocketUtils.java:286"$1$"			Assert.isTrue(maxPort <= PORT_RANGE_MAX, ""'maxPort' must be less than or equal to "" + PORT_RANGE_MAX);"
"SocketUtils.java:287"$1$"			Assert.isTrue(numRequested > 0, ""'numRequested' must be greater than 0"");"
"SocketUtils.java:288"$1$"			Assert.isTrue((maxPort - minPort) >= numRequested,"
"SocketUtils.java:289"$1$"					""'numRequested' must not be greater than 'maxPort' - 'minPort'"");"
"SocketUtils.java:290"$1$""
"SocketUtils.java:291"$1$"			SortedSet<Integer> availablePorts = new TreeSet<>();"
"SocketUtils.java:292"$1$"			int attemptCount = 0;"
"SocketUtils.java:293"$1$"			while ((++attemptCount <= numRequested + 100) && availablePorts.size() < numRequested) {"
"SocketUtils.java:294"$1$"				availablePorts.add(findAvailablePort(minPort, maxPort));"
"SocketUtils.java:295"$1$"			}"
"SocketUtils.java:296"$0$""
"SocketUtils.java:297"$1$"			if (availablePorts.size() != numRequested) {"
"SocketUtils.java:298"$1$"				throw new IllegalStateException(String.format("
"SocketUtils.java:299"$1$"						""Could not find %d available %s ports in the range [%d, %d]"","
"SocketUtils.java:300"$1$"						numRequested, name(), minPort, maxPort));"
"SocketUtils.java:301"$1$"			}"
"SocketUtils.java:302"$0$""
"SocketUtils.java:303"$0$"			return availablePorts;"
"SocketUtils.java:304"$0$"		}"
"SocketUtils.java:305"$0$"	}"
"SocketUtils.java:306"$0$""
"SocketUtils.java:307"$0$"}"
"MapToMapConverter.java:1"$0$"/*"
"MapToMapConverter.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"MapToMapConverter.java:3"$0$" *"
"MapToMapConverter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MapToMapConverter.java:5"$0$" * you may not use this file except in compliance with the License."
"MapToMapConverter.java:6"$0$" * You may obtain a copy of the License at"
"MapToMapConverter.java:7"$0$" *"
"MapToMapConverter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MapToMapConverter.java:9"$0$" *"
"MapToMapConverter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MapToMapConverter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MapToMapConverter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MapToMapConverter.java:13"$0$" * See the License for the specific language governing permissions and"
"MapToMapConverter.java:14"$0$" * limitations under the License."
"MapToMapConverter.java:15"$0$" */"
"MapToMapConverter.java:16"$0$""
"MapToMapConverter.java:17"$0$"package org.springframework.core.convert.support;"
"MapToMapConverter.java:18"$0$""
"MapToMapConverter.java:19"$0$"import java.util.ArrayList;"
"MapToMapConverter.java:20"$0$"import java.util.Collections;"
"MapToMapConverter.java:21"$0$"import java.util.List;"
"MapToMapConverter.java:22"$0$"import java.util.Map;"
"MapToMapConverter.java:23"$0$"import java.util.Set;"
"MapToMapConverter.java:24"$0$""
"MapToMapConverter.java:25"$0$"import org.springframework.core.CollectionFactory;"
"MapToMapConverter.java:26"$0$"import org.springframework.core.convert.ConversionService;"
"MapToMapConverter.java:27"$0$"import org.springframework.core.convert.TypeDescriptor;"
"MapToMapConverter.java:28"$0$"import org.springframework.core.convert.converter.ConditionalGenericConverter;"
"MapToMapConverter.java:29"$0$"import org.springframework.lang.Nullable;"
"MapToMapConverter.java:30"$0$""
"MapToMapConverter.java:31"$0$"/**"
"MapToMapConverter.java:32"$0$" * Converts a Map to another Map."
"MapToMapConverter.java:33"$0$" *"
"MapToMapConverter.java:34"$0$" * <p>First, creates a new Map of the requested targetType with a size equal to the"
"MapToMapConverter.java:35"$0$" * size of the source Map. Then copies each element in the source map to the target map."
"MapToMapConverter.java:36"$0$" * Will perform a conversion from the source maps's parameterized K,V types to the target"
"MapToMapConverter.java:37"$0$" * map's parameterized types K,V if necessary."
"MapToMapConverter.java:38"$0$" *"
"MapToMapConverter.java:39"$0$" * @author Keith Donald"
"MapToMapConverter.java:40"$0$" * @author Juergen Hoeller"
"MapToMapConverter.java:41"$0$" * @since 3.0"
"MapToMapConverter.java:42"$0$" */"
"MapToMapConverter.java:43"$1$"final class MapToMapConverter implements ConditionalGenericConverter {"
"MapToMapConverter.java:44"$1$""
"MapToMapConverter.java:45"$1$"	private final ConversionService conversionService;"
"MapToMapConverter.java:46"$1$""
"MapToMapConverter.java:47"$1$""
"MapToMapConverter.java:48"$1$"	public MapToMapConverter(ConversionService conversionService) {"
"MapToMapConverter.java:49"$1$"		this.conversionService = conversionService;"
"MapToMapConverter.java:50"$1$"	}"
"MapToMapConverter.java:51"$0$""
"MapToMapConverter.java:52"$0$""
"MapToMapConverter.java:53"$0$"	@Override"
"MapToMapConverter.java:54"$1$"	public Set<ConvertiblePair> getConvertibleTypes() {"
"MapToMapConverter.java:55"$1$"		return Collections.singleton(new ConvertiblePair(Map.class, Map.class));"
"MapToMapConverter.java:56"$1$"	}"
"MapToMapConverter.java:57"$0$""
"MapToMapConverter.java:58"$0$"	@Override"
"MapToMapConverter.java:59"$1$"	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"MapToMapConverter.java:60"$1$"		return canConvertKey(sourceType, targetType) && canConvertValue(sourceType, targetType);"
"MapToMapConverter.java:61"$1$"	}"
"MapToMapConverter.java:62"$0$""
"MapToMapConverter.java:63"$0$"	@Override"
"MapToMapConverter.java:64"$0$"	@SuppressWarnings(""unchecked"")"
"MapToMapConverter.java:65"$0$"	@Nullable"
"MapToMapConverter.java:66"$1$"	public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"MapToMapConverter.java:67"$1$"		if (source == null) {"
"MapToMapConverter.java:68"$1$"			return null;"
"MapToMapConverter.java:69"$1$"		}"
"MapToMapConverter.java:70"$0$"		Map<Object, Object> sourceMap = (Map<Object, Object>) source;"
"MapToMapConverter.java:71"$0$""
"MapToMapConverter.java:72"$0$"		// Shortcut if possible..."
"MapToMapConverter.java:73"$0$"		boolean copyRequired = !targetType.getType().isInstance(source);"
"MapToMapConverter.java:74"$1$"		if (!copyRequired && sourceMap.isEmpty()) {"
"MapToMapConverter.java:75"$1$"			return sourceMap;"
"MapToMapConverter.java:76"$1$"		}"
"MapToMapConverter.java:77"$0$"		TypeDescriptor keyDesc = targetType.getMapKeyTypeDescriptor();"
"MapToMapConverter.java:78"$0$"		TypeDescriptor valueDesc = targetType.getMapValueTypeDescriptor();"
"MapToMapConverter.java:79"$0$""
"MapToMapConverter.java:80"$0$"		List<MapEntry> targetEntries = new ArrayList<>(sourceMap.size());"
"MapToMapConverter.java:81"$1$"		for (Map.Entry<Object, Object> entry : sourceMap.entrySet()) {"
"MapToMapConverter.java:82"$1$"			Object sourceKey = entry.getKey();"
"MapToMapConverter.java:83"$1$"			Object sourceValue = entry.getValue();"
"MapToMapConverter.java:84"$1$"			Object targetKey = convertKey(sourceKey, sourceType, keyDesc);"
"MapToMapConverter.java:85"$1$"			Object targetValue = convertValue(sourceValue, sourceType, valueDesc);"
"MapToMapConverter.java:86"$1$"			targetEntries.add(new MapEntry(targetKey, targetValue));"
"MapToMapConverter.java:87"$1$"			if (sourceKey != targetKey || sourceValue != targetValue) {"
"MapToMapConverter.java:88"$1$"				copyRequired = true;"
"MapToMapConverter.java:89"$1$"			}"
"MapToMapConverter.java:90"$0$"		}"
"MapToMapConverter.java:91"$1$"		if (!copyRequired) {"
"MapToMapConverter.java:92"$1$"			return sourceMap;"
"MapToMapConverter.java:93"$1$"		}"
"MapToMapConverter.java:94"$0$""
"MapToMapConverter.java:95"$0$"		Map<Object, Object> targetMap = CollectionFactory.createMap(targetType.getType(),"
"MapToMapConverter.java:96"$0$"				(keyDesc != null ? keyDesc.getType() : null), sourceMap.size());"
"MapToMapConverter.java:97"$0$""
"MapToMapConverter.java:98"$1$"		for (MapEntry entry : targetEntries) {"
"MapToMapConverter.java:99"$1$"			entry.addToMap(targetMap);"
"MapToMapConverter.java:100"$1$"		}"
"MapToMapConverter.java:101"$0$"		return targetMap;"
"MapToMapConverter.java:102"$0$"	}"
"MapToMapConverter.java:103"$0$""
"MapToMapConverter.java:104"$0$""
"MapToMapConverter.java:105"$0$"	// internal helpers"
"MapToMapConverter.java:106"$0$""
"MapToMapConverter.java:107"$1$"	private boolean canConvertKey(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"MapToMapConverter.java:108"$1$"		return ConversionUtils.canConvertElements(sourceType.getMapKeyTypeDescriptor(),"
"MapToMapConverter.java:109"$1$"				targetType.getMapKeyTypeDescriptor(), this.conversionService);"
"MapToMapConverter.java:110"$1$"	}"
"MapToMapConverter.java:111"$0$""
"MapToMapConverter.java:112"$1$"	private boolean canConvertValue(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"MapToMapConverter.java:113"$1$"		return ConversionUtils.canConvertElements(sourceType.getMapValueTypeDescriptor(),"
"MapToMapConverter.java:114"$1$"				targetType.getMapValueTypeDescriptor(), this.conversionService);"
"MapToMapConverter.java:115"$1$"	}"
"MapToMapConverter.java:116"$0$""
"MapToMapConverter.java:117"$0$"	@Nullable"
"MapToMapConverter.java:118"$1$"	private Object convertKey(Object sourceKey, TypeDescriptor sourceType, @Nullable TypeDescriptor targetType) {"
"MapToMapConverter.java:119"$1$"		if (targetType == null) {"
"MapToMapConverter.java:120"$1$"			return sourceKey;"
"MapToMapConverter.java:121"$1$"		}"
"MapToMapConverter.java:122"$0$"		return this.conversionService.convert(sourceKey, sourceType.getMapKeyTypeDescriptor(sourceKey), targetType);"
"MapToMapConverter.java:123"$0$"	}"
"MapToMapConverter.java:124"$0$""
"MapToMapConverter.java:125"$0$"	@Nullable"
"MapToMapConverter.java:126"$1$"	private Object convertValue(Object sourceValue, TypeDescriptor sourceType, @Nullable TypeDescriptor targetType) {"
"MapToMapConverter.java:127"$1$"		if (targetType == null) {"
"MapToMapConverter.java:128"$1$"			return sourceValue;"
"MapToMapConverter.java:129"$1$"		}"
"MapToMapConverter.java:130"$0$"		return this.conversionService.convert(sourceValue, sourceType.getMapValueTypeDescriptor(sourceValue), targetType);"
"MapToMapConverter.java:131"$0$"	}"
"MapToMapConverter.java:132"$0$""
"MapToMapConverter.java:133"$0$""
"MapToMapConverter.java:134"$1$"	private static class MapEntry {"
"MapToMapConverter.java:135"$1$""
"MapToMapConverter.java:136"$1$"		@Nullable"
"MapToMapConverter.java:137"$1$"		private final Object key;"
"MapToMapConverter.java:138"$1$""
"MapToMapConverter.java:139"$1$"		@Nullable"
"MapToMapConverter.java:140"$1$"		private final Object value;"
"MapToMapConverter.java:141"$1$""
"MapToMapConverter.java:142"$1$"		public MapEntry(@Nullable Object key, @Nullable Object value) {"
"MapToMapConverter.java:143"$1$"			this.key = key;"
"MapToMapConverter.java:144"$1$"			this.value = value;"
"MapToMapConverter.java:145"$1$"		}"
"MapToMapConverter.java:146"$0$""
"MapToMapConverter.java:147"$1$"		public void addToMap(Map<Object, Object> map) {"
"MapToMapConverter.java:148"$1$"			map.put(this.key, this.value);"
"MapToMapConverter.java:149"$1$"		}"
"MapToMapConverter.java:150"$0$"	}"
"MapToMapConverter.java:151"$0$""
"MapToMapConverter.java:152"$0$"}"
"FileSystemUtils.java:1"$0$"/*"
"FileSystemUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"FileSystemUtils.java:3"$0$" *"
"FileSystemUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"FileSystemUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"FileSystemUtils.java:6"$0$" * You may obtain a copy of the License at"
"FileSystemUtils.java:7"$0$" *"
"FileSystemUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"FileSystemUtils.java:9"$0$" *"
"FileSystemUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"FileSystemUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"FileSystemUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"FileSystemUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"FileSystemUtils.java:14"$0$" * limitations under the License."
"FileSystemUtils.java:15"$0$" */"
"FileSystemUtils.java:16"$0$""
"FileSystemUtils.java:17"$0$"package org.springframework.util;"
"FileSystemUtils.java:18"$0$""
"FileSystemUtils.java:19"$0$"import java.io.File;"
"FileSystemUtils.java:20"$0$"import java.io.IOException;"
"FileSystemUtils.java:21"$0$"import java.nio.file.FileVisitResult;"
"FileSystemUtils.java:22"$0$"import java.nio.file.Files;"
"FileSystemUtils.java:23"$0$"import java.nio.file.Path;"
"FileSystemUtils.java:24"$0$"import java.nio.file.SimpleFileVisitor;"
"FileSystemUtils.java:25"$0$"import java.nio.file.StandardCopyOption;"
"FileSystemUtils.java:26"$0$"import java.nio.file.attribute.BasicFileAttributes;"
"FileSystemUtils.java:27"$0$"import java.util.EnumSet;"
"FileSystemUtils.java:28"$0$""
"FileSystemUtils.java:29"$0$"import org.springframework.lang.Nullable;"
"FileSystemUtils.java:30"$0$""
"FileSystemUtils.java:31"$0$"import static java.nio.file.FileVisitOption.FOLLOW_LINKS;"
"FileSystemUtils.java:32"$0$""
"FileSystemUtils.java:33"$0$"/**"
"FileSystemUtils.java:34"$0$" * Utility methods for working with the file system."
"FileSystemUtils.java:35"$0$" *"
"FileSystemUtils.java:36"$0$" * @author Rob Harrop"
"FileSystemUtils.java:37"$0$" * @author Juergen Hoeller"
"FileSystemUtils.java:38"$0$" * @since 2.5.3"
"FileSystemUtils.java:39"$0$" * @see java.io.File"
"FileSystemUtils.java:40"$0$" * @see java.nio.file.Path"
"FileSystemUtils.java:41"$0$" * @see java.nio.file.Files"
"FileSystemUtils.java:42"$0$" */"
"FileSystemUtils.java:43"$1$"public abstract class FileSystemUtils {"
"FileSystemUtils.java:44"$1$""
"FileSystemUtils.java:45"$1$"	/**"
"FileSystemUtils.java:46"$1$"	 * Delete the supplied {@link File} - for directories,"
"FileSystemUtils.java:47"$1$"	 * recursively delete any nested directories or files as well."
"FileSystemUtils.java:48"$1$"	 * <p>Note: Like {@link File#delete()}, this method does not throw any"
"FileSystemUtils.java:49"$1$"	 * exception but rather silently returns {@code false} in case of I/O"
"FileSystemUtils.java:50"$1$"	 * errors. Consider using {@link #deleteRecursively(Path)} for NIO-style"
"FileSystemUtils.java:51"$1$"	 * handling of I/O errors, clearly differentiating between non-existence"
"FileSystemUtils.java:52"$1$"	 * and failure to delete an existing file."
"FileSystemUtils.java:53"$1$"	 * @param root the root {@code File} to delete"
"FileSystemUtils.java:54"$1$"	 * @return {@code true} if the {@code File} was successfully deleted,"
"FileSystemUtils.java:55"$1$"	 * otherwise {@code false}"
"FileSystemUtils.java:56"$1$"	 */"
"FileSystemUtils.java:57"$1$"	public static boolean deleteRecursively(@Nullable File root) {"
"FileSystemUtils.java:58"$1$"		if (root == null) {"
"FileSystemUtils.java:59"$1$"			return false;"
"FileSystemUtils.java:60"$1$"		}"
"FileSystemUtils.java:61"$0$""
"FileSystemUtils.java:62"$1$"		try {"
"FileSystemUtils.java:63"$1$"			return deleteRecursively(root.toPath());"
"FileSystemUtils.java:64"$1$"		}"
"FileSystemUtils.java:65"$1$"		catch (IOException ex) {"
"FileSystemUtils.java:66"$1$"			return false;"
"FileSystemUtils.java:67"$1$"		}"
"FileSystemUtils.java:68"$0$"	}"
"FileSystemUtils.java:69"$0$""
"FileSystemUtils.java:70"$0$"	/**"
"FileSystemUtils.java:71"$1$"	 * Delete the supplied {@link File} &mdash; for directories,"
"FileSystemUtils.java:72"$0$"	 * recursively delete any nested directories or files as well."
"FileSystemUtils.java:73"$1$"	 * @param root the root {@code File} to delete"
"FileSystemUtils.java:74"$1$"	 * @return {@code true} if the {@code File} existed and was deleted,"
"FileSystemUtils.java:75"$1$"	 * or {@code false} if it did not exist"
"FileSystemUtils.java:76"$0$"	 * @throws IOException in the case of I/O errors"
"FileSystemUtils.java:77"$0$"	 * @since 5.0"
"FileSystemUtils.java:78"$0$"	 */"
"FileSystemUtils.java:79"$1$"	public static boolean deleteRecursively(@Nullable Path root) throws IOException {"
"FileSystemUtils.java:80"$1$"		if (root == null) {"
"FileSystemUtils.java:81"$1$"			return false;"
"FileSystemUtils.java:82"$1$"		}"
"FileSystemUtils.java:83"$1$"		if (!Files.exists(root)) {"
"FileSystemUtils.java:84"$1$"			return false;"
"FileSystemUtils.java:85"$1$"		}"
"FileSystemUtils.java:86"$0$""
"FileSystemUtils.java:87"$1$"		Files.walkFileTree(root, new SimpleFileVisitor<Path>() {"
"FileSystemUtils.java:88"$1$"			@Override"
"FileSystemUtils.java:89"$1$"			public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {"
"FileSystemUtils.java:90"$1$"				Files.delete(file);"
"FileSystemUtils.java:91"$1$"				return FileVisitResult.CONTINUE;"
"FileSystemUtils.java:92"$1$"			}"
"FileSystemUtils.java:93"$0$"			@Override"
"FileSystemUtils.java:94"$1$"			public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {"
"FileSystemUtils.java:95"$1$"				Files.delete(dir);"
"FileSystemUtils.java:96"$1$"				return FileVisitResult.CONTINUE;"
"FileSystemUtils.java:97"$1$"			}"
"FileSystemUtils.java:98"$0$"		});"
"FileSystemUtils.java:99"$0$"		return true;"
"FileSystemUtils.java:100"$0$"	}"
"FileSystemUtils.java:101"$0$""
"FileSystemUtils.java:102"$0$"	/**"
"FileSystemUtils.java:103"$1$"	 * Recursively copy the contents of the {@code src} file/directory"
"FileSystemUtils.java:104"$1$"	 * to the {@code dest} file/directory."
"FileSystemUtils.java:105"$0$"	 * @param src the source directory"
"FileSystemUtils.java:106"$0$"	 * @param dest the destination directory"
"FileSystemUtils.java:107"$0$"	 * @throws IOException in the case of I/O errors"
"FileSystemUtils.java:108"$0$"	 */"
"FileSystemUtils.java:109"$1$"	public static void copyRecursively(File src, File dest) throws IOException {"
"FileSystemUtils.java:110"$1$"		Assert.notNull(src, ""Source File must not be null"");"
"FileSystemUtils.java:111"$1$"		Assert.notNull(dest, ""Destination File must not be null"");"
"FileSystemUtils.java:112"$1$"		copyRecursively(src.toPath(), dest.toPath());"
"FileSystemUtils.java:113"$1$"	}"
"FileSystemUtils.java:114"$0$""
"FileSystemUtils.java:115"$0$"	/**"
"FileSystemUtils.java:116"$1$"	 * Recursively copy the contents of the {@code src} file/directory"
"FileSystemUtils.java:117"$1$"	 * to the {@code dest} file/directory."
"FileSystemUtils.java:118"$0$"	 * @param src the source directory"
"FileSystemUtils.java:119"$0$"	 * @param dest the destination directory"
"FileSystemUtils.java:120"$0$"	 * @throws IOException in the case of I/O errors"
"FileSystemUtils.java:121"$0$"	 * @since 5.0"
"FileSystemUtils.java:122"$0$"	 */"
"FileSystemUtils.java:123"$1$"	public static void copyRecursively(Path src, Path dest) throws IOException {"
"FileSystemUtils.java:124"$1$"		Assert.notNull(src, ""Source Path must not be null"");"
"FileSystemUtils.java:125"$1$"		Assert.notNull(dest, ""Destination Path must not be null"");"
"FileSystemUtils.java:126"$1$"		BasicFileAttributes srcAttr = Files.readAttributes(src, BasicFileAttributes.class);"
"FileSystemUtils.java:127"$1$""
"FileSystemUtils.java:128"$1$"		if (srcAttr.isDirectory()) {"
"FileSystemUtils.java:129"$1$"			Files.walkFileTree(src, EnumSet.of(FOLLOW_LINKS), Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {"
"FileSystemUtils.java:130"$1$"				@Override"
"FileSystemUtils.java:131"$1$"				public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {"
"FileSystemUtils.java:132"$1$"					Files.createDirectories(dest.resolve(src.relativize(dir)));"
"FileSystemUtils.java:133"$1$"					return FileVisitResult.CONTINUE;"
"FileSystemUtils.java:134"$1$"				}"
"FileSystemUtils.java:135"$0$"				@Override"
"FileSystemUtils.java:136"$1$"				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {"
"FileSystemUtils.java:137"$1$"					Files.copy(file, dest.resolve(src.relativize(file)), StandardCopyOption.REPLACE_EXISTING);"
"FileSystemUtils.java:138"$1$"					return FileVisitResult.CONTINUE;"
"FileSystemUtils.java:139"$1$"				}"
"FileSystemUtils.java:140"$0$"			});"
"FileSystemUtils.java:141"$0$"		}"
"FileSystemUtils.java:142"$1$"		else if (srcAttr.isRegularFile()) {"
"FileSystemUtils.java:143"$1$"			Files.copy(src, dest);"
"FileSystemUtils.java:144"$1$"		}"
"FileSystemUtils.java:145"$1$"		else {"
"FileSystemUtils.java:146"$1$"			throw new IllegalArgumentException(""Source File must denote a directory or file"");"
"FileSystemUtils.java:147"$1$"		}"
"FileSystemUtils.java:148"$0$"	}"
"FileSystemUtils.java:149"$0$""
"FileSystemUtils.java:150"$0$"}"
"AnnotationTypeMappings.java:1"$0$"/*"
"AnnotationTypeMappings.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"AnnotationTypeMappings.java:3"$0$" *"
"AnnotationTypeMappings.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationTypeMappings.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationTypeMappings.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationTypeMappings.java:7"$0$" *"
"AnnotationTypeMappings.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationTypeMappings.java:9"$0$" *"
"AnnotationTypeMappings.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationTypeMappings.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationTypeMappings.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationTypeMappings.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationTypeMappings.java:14"$0$" * limitations under the License."
"AnnotationTypeMappings.java:15"$0$" */"
"AnnotationTypeMappings.java:16"$0$""
"AnnotationTypeMappings.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationTypeMappings.java:18"$0$""
"AnnotationTypeMappings.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotationTypeMappings.java:20"$0$"import java.util.ArrayDeque;"
"AnnotationTypeMappings.java:21"$0$"import java.util.ArrayList;"
"AnnotationTypeMappings.java:22"$0$"import java.util.Deque;"
"AnnotationTypeMappings.java:23"$0$"import java.util.List;"
"AnnotationTypeMappings.java:24"$0$"import java.util.Map;"
"AnnotationTypeMappings.java:25"$0$""
"AnnotationTypeMappings.java:26"$0$"import org.springframework.lang.Nullable;"
"AnnotationTypeMappings.java:27"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"AnnotationTypeMappings.java:28"$0$""
"AnnotationTypeMappings.java:29"$0$"/**"
"AnnotationTypeMappings.java:30"$1$" * Provides {@link AnnotationTypeMapping} information for a single source"
"AnnotationTypeMappings.java:31"$0$" * annotation type. Performs a recursive breadth first crawl of all"
"AnnotationTypeMappings.java:32"$0$" * meta-annotations to ultimately provide a quick way to map the attributes of"
"AnnotationTypeMappings.java:33"$1$" * root {@link Annotation}."
"AnnotationTypeMappings.java:34"$0$" *"
"AnnotationTypeMappings.java:35"$0$" * <p>Supports convention based merging of meta-annotations as well as implicit"
"AnnotationTypeMappings.java:36"$1$" * and explicit {@link AliasFor @AliasFor} aliases. Also provides information"
"AnnotationTypeMappings.java:37"$0$" * about mirrored attributes."
"AnnotationTypeMappings.java:38"$0$" *"
"AnnotationTypeMappings.java:39"$0$" * <p>This class is designed to be cached so that meta-annotations only need to"
"AnnotationTypeMappings.java:40"$0$" * be searched once, regardless of how many times they are actually used."
"AnnotationTypeMappings.java:41"$0$" *"
"AnnotationTypeMappings.java:42"$0$" * @author Phillip Webb"
"AnnotationTypeMappings.java:43"$0$" * @since 5.2"
"AnnotationTypeMappings.java:44"$0$" * @see AnnotationTypeMapping"
"AnnotationTypeMappings.java:45"$0$" */"
"AnnotationTypeMappings.java:46"$1$"final class AnnotationTypeMappings {"
"AnnotationTypeMappings.java:47"$1$""
"AnnotationTypeMappings.java:48"$1$"	private static final IntrospectionFailureLogger failureLogger = IntrospectionFailureLogger.DEBUG;"
"AnnotationTypeMappings.java:49"$1$""
"AnnotationTypeMappings.java:50"$1$"	private static final Map<AnnotationFilter, Cache> standardRepeatablesCache = new ConcurrentReferenceHashMap<>();"
"AnnotationTypeMappings.java:51"$1$""
"AnnotationTypeMappings.java:52"$1$"	private static final Map<AnnotationFilter, Cache> noRepeatablesCache = new ConcurrentReferenceHashMap<>();"
"AnnotationTypeMappings.java:53"$1$""
"AnnotationTypeMappings.java:54"$1$""
"AnnotationTypeMappings.java:55"$1$"	private final RepeatableContainers repeatableContainers;"
"AnnotationTypeMappings.java:56"$1$""
"AnnotationTypeMappings.java:57"$1$"	private final AnnotationFilter filter;"
"AnnotationTypeMappings.java:58"$1$""
"AnnotationTypeMappings.java:59"$1$"	private final List<AnnotationTypeMapping> mappings;"
"AnnotationTypeMappings.java:60"$1$""
"AnnotationTypeMappings.java:61"$1$""
"AnnotationTypeMappings.java:62"$1$"	private AnnotationTypeMappings(RepeatableContainers repeatableContainers,"
"AnnotationTypeMappings.java:63"$1$"			AnnotationFilter filter, Class<? extends Annotation> annotationType) {"
"AnnotationTypeMappings.java:64"$1$""
"AnnotationTypeMappings.java:65"$1$"		this.repeatableContainers = repeatableContainers;"
"AnnotationTypeMappings.java:66"$1$"		this.filter = filter;"
"AnnotationTypeMappings.java:67"$1$"		this.mappings = new ArrayList<>();"
"AnnotationTypeMappings.java:68"$1$"		addAllMappings(annotationType);"
"AnnotationTypeMappings.java:69"$1$"		this.mappings.forEach(AnnotationTypeMapping::afterAllMappingsSet);"
"AnnotationTypeMappings.java:70"$1$"	}"
"AnnotationTypeMappings.java:71"$0$""
"AnnotationTypeMappings.java:72"$0$""
"AnnotationTypeMappings.java:73"$1$"	private void addAllMappings(Class<? extends Annotation> annotationType) {"
"AnnotationTypeMappings.java:74"$1$"		Deque<AnnotationTypeMapping> queue = new ArrayDeque<>();"
"AnnotationTypeMappings.java:75"$1$"		addIfPossible(queue, null, annotationType, null);"
"AnnotationTypeMappings.java:76"$1$"		while (!queue.isEmpty()) {"
"AnnotationTypeMappings.java:77"$1$"			AnnotationTypeMapping mapping = queue.removeFirst();"
"AnnotationTypeMappings.java:78"$1$"			this.mappings.add(mapping);"
"AnnotationTypeMappings.java:79"$1$"			addMetaAnnotationsToQueue(queue, mapping);"
"AnnotationTypeMappings.java:80"$1$"		}"
"AnnotationTypeMappings.java:81"$0$"	}"
"AnnotationTypeMappings.java:82"$0$""
"AnnotationTypeMappings.java:83"$1$"	private void addMetaAnnotationsToQueue(Deque<AnnotationTypeMapping> queue, AnnotationTypeMapping source) {"
"AnnotationTypeMappings.java:84"$1$"		Annotation[] metaAnnotations ="
"AnnotationTypeMappings.java:85"$1$"				AnnotationsScanner.getDeclaredAnnotations(source.getAnnotationType(), false);"
"AnnotationTypeMappings.java:86"$1$"		for (Annotation metaAnnotation : metaAnnotations) {"
"AnnotationTypeMappings.java:87"$1$"			if (!isMappable(source, metaAnnotation)) {"
"AnnotationTypeMappings.java:88"$1$"				continue;"
"AnnotationTypeMappings.java:89"$1$"			}"
"AnnotationTypeMappings.java:90"$0$"			Annotation[] repeatedAnnotations = this.repeatableContainers"
"AnnotationTypeMappings.java:91"$0$"					.findRepeatedAnnotations(metaAnnotation);"
"AnnotationTypeMappings.java:92"$1$"			if (repeatedAnnotations != null) {"
"AnnotationTypeMappings.java:93"$1$"				for (Annotation repeatedAnnotation : repeatedAnnotations) {"
"AnnotationTypeMappings.java:94"$1$"					if (!isMappable(source, metaAnnotation)) {"
"AnnotationTypeMappings.java:95"$1$"						continue;"
"AnnotationTypeMappings.java:96"$1$"					}"
"AnnotationTypeMappings.java:97"$0$"					addIfPossible(queue, source, repeatedAnnotation);"
"AnnotationTypeMappings.java:98"$0$"				}"
"AnnotationTypeMappings.java:99"$0$"			}"
"AnnotationTypeMappings.java:100"$1$"			else {"
"AnnotationTypeMappings.java:101"$1$"				addIfPossible(queue, source, metaAnnotation);"
"AnnotationTypeMappings.java:102"$1$"			}"
"AnnotationTypeMappings.java:103"$0$"		}"
"AnnotationTypeMappings.java:104"$0$"	}"
"AnnotationTypeMappings.java:105"$0$""
"AnnotationTypeMappings.java:106"$0$"	private void addIfPossible(Deque<AnnotationTypeMapping> queue,"
"AnnotationTypeMappings.java:107"$1$"			AnnotationTypeMapping source, Annotation ann) {"
"AnnotationTypeMappings.java:108"$1$""
"AnnotationTypeMappings.java:109"$1$"		addIfPossible(queue, source, ann.annotationType(), ann);"
"AnnotationTypeMappings.java:110"$1$"	}"
"AnnotationTypeMappings.java:111"$0$""
"AnnotationTypeMappings.java:112"$0$"	private void addIfPossible(Deque<AnnotationTypeMapping> queue, @Nullable AnnotationTypeMapping source,"
"AnnotationTypeMappings.java:113"$1$"			Class<? extends Annotation> annotationType, @Nullable Annotation ann) {"
"AnnotationTypeMappings.java:114"$1$""
"AnnotationTypeMappings.java:115"$1$"		try {"
"AnnotationTypeMappings.java:116"$1$"			queue.addLast(new AnnotationTypeMapping(source, annotationType, ann));"
"AnnotationTypeMappings.java:117"$1$"		}"
"AnnotationTypeMappings.java:118"$1$"		catch (Exception ex) {"
"AnnotationTypeMappings.java:119"$1$"			AnnotationUtils.rethrowAnnotationConfigurationException(ex);"
"AnnotationTypeMappings.java:120"$1$"			if (failureLogger.isEnabled()) {"
"AnnotationTypeMappings.java:121"$1$"				failureLogger.log(""Failed to introspect meta-annotation "" + annotationType.getName(),"
"AnnotationTypeMappings.java:122"$1$"						(source != null ? source.getAnnotationType() : null), ex);"
"AnnotationTypeMappings.java:123"$1$"			}"
"AnnotationTypeMappings.java:124"$0$"		}"
"AnnotationTypeMappings.java:125"$0$"	}"
"AnnotationTypeMappings.java:126"$0$""
"AnnotationTypeMappings.java:127"$1$"	private boolean isMappable(AnnotationTypeMapping source, @Nullable Annotation metaAnnotation) {"
"AnnotationTypeMappings.java:128"$1$"		return (metaAnnotation != null && !this.filter.matches(metaAnnotation) &&"
"AnnotationTypeMappings.java:129"$1$"				!AnnotationFilter.PLAIN.matches(source.getAnnotationType()) &&"
"AnnotationTypeMappings.java:130"$1$"				!isAlreadyMapped(source, metaAnnotation));"
"AnnotationTypeMappings.java:131"$1$"	}"
"AnnotationTypeMappings.java:132"$0$""
"AnnotationTypeMappings.java:133"$1$"	private boolean isAlreadyMapped(AnnotationTypeMapping source, Annotation metaAnnotation) {"
"AnnotationTypeMappings.java:134"$1$"		Class<? extends Annotation> annotationType = metaAnnotation.annotationType();"
"AnnotationTypeMappings.java:135"$1$"		AnnotationTypeMapping mapping = source;"
"AnnotationTypeMappings.java:136"$1$"		while (mapping != null) {"
"AnnotationTypeMappings.java:137"$1$"			if (mapping.getAnnotationType() == annotationType) {"
"AnnotationTypeMappings.java:138"$1$"				return true;"
"AnnotationTypeMappings.java:139"$1$"			}"
"AnnotationTypeMappings.java:140"$0$"			mapping = mapping.getSource();"
"AnnotationTypeMappings.java:141"$0$"		}"
"AnnotationTypeMappings.java:142"$0$"		return false;"
"AnnotationTypeMappings.java:143"$0$"	}"
"AnnotationTypeMappings.java:144"$0$""
"AnnotationTypeMappings.java:145"$0$"	/**"
"AnnotationTypeMappings.java:146"$0$"	 * Get the total number of contained mappings."
"AnnotationTypeMappings.java:147"$0$"	 * @return the total number of mappings"
"AnnotationTypeMappings.java:148"$0$"	 */"
"AnnotationTypeMappings.java:149"$1$"	int size() {"
"AnnotationTypeMappings.java:150"$1$"		return this.mappings.size();"
"AnnotationTypeMappings.java:151"$1$"	}"
"AnnotationTypeMappings.java:152"$0$""
"AnnotationTypeMappings.java:153"$0$"	/**"
"AnnotationTypeMappings.java:154"$0$"	 * Get an individual mapping from this instance."
"AnnotationTypeMappings.java:155"$1$"	 * <p>Index {@code 0} will always return the root mapping; higher indexes"
"AnnotationTypeMappings.java:156"$0$"	 * will return meta-annotation mappings."
"AnnotationTypeMappings.java:157"$0$"	 * @param index the index to return"
"AnnotationTypeMappings.java:158"$1$"	 * @return the {@link AnnotationTypeMapping}"
"AnnotationTypeMappings.java:159"$0$"	 * @throws IndexOutOfBoundsException if the index is out of range"
"AnnotationTypeMappings.java:160"$0$"	 * (<tt>index &lt; 0 || index &gt;= size()</tt>)"
"AnnotationTypeMappings.java:161"$0$"	 */"
"AnnotationTypeMappings.java:162"$1$"	AnnotationTypeMapping get(int index) {"
"AnnotationTypeMappings.java:163"$1$"		return this.mappings.get(index);"
"AnnotationTypeMappings.java:164"$1$"	}"
"AnnotationTypeMappings.java:165"$0$""
"AnnotationTypeMappings.java:166"$0$""
"AnnotationTypeMappings.java:167"$0$"	/**"
"AnnotationTypeMappings.java:168"$1$"	 * Create {@link AnnotationTypeMappings} for the specified annotation type."
"AnnotationTypeMappings.java:169"$0$"	 * @param annotationType the source annotation type"
"AnnotationTypeMappings.java:170"$0$"	 * @return type mappings for the annotation type"
"AnnotationTypeMappings.java:171"$0$"	 */"
"AnnotationTypeMappings.java:172"$1$"	static AnnotationTypeMappings forAnnotationType(Class<? extends Annotation> annotationType) {"
"AnnotationTypeMappings.java:173"$1$"		return forAnnotationType(annotationType, AnnotationFilter.PLAIN);"
"AnnotationTypeMappings.java:174"$1$"	}"
"AnnotationTypeMappings.java:175"$0$""
"AnnotationTypeMappings.java:176"$0$"	/**"
"AnnotationTypeMappings.java:177"$1$"	 * Create {@link AnnotationTypeMappings} for the specified annotation type."
"AnnotationTypeMappings.java:178"$0$"	 * @param annotationType the source annotation type"
"AnnotationTypeMappings.java:179"$0$"	 * @param annotationFilter the annotation filter used to limit which"
"AnnotationTypeMappings.java:180"$0$"	 * annotations are considered"
"AnnotationTypeMappings.java:181"$0$"	 * @return type mappings for the annotation type"
"AnnotationTypeMappings.java:182"$0$"	 */"
"AnnotationTypeMappings.java:183"$0$"	static AnnotationTypeMappings forAnnotationType("
"AnnotationTypeMappings.java:184"$1$"			Class<? extends Annotation> annotationType, AnnotationFilter annotationFilter) {"
"AnnotationTypeMappings.java:185"$1$""
"AnnotationTypeMappings.java:186"$1$"		return forAnnotationType(annotationType,"
"AnnotationTypeMappings.java:187"$1$"				RepeatableContainers.standardRepeatables(), annotationFilter);"
"AnnotationTypeMappings.java:188"$1$"	}"
"AnnotationTypeMappings.java:189"$0$""
"AnnotationTypeMappings.java:190"$0$"	/**"
"AnnotationTypeMappings.java:191"$1$"	 * Create {@link AnnotationTypeMappings} for the specified annotation type."
"AnnotationTypeMappings.java:192"$0$"	 * @param annotationType the source annotation type"
"AnnotationTypeMappings.java:193"$0$"	 * @param annotationFilter the annotation filter used to limit which"
"AnnotationTypeMappings.java:194"$0$"	 * annotations are considered"
"AnnotationTypeMappings.java:195"$0$"	 * @return type mappings for the annotation type"
"AnnotationTypeMappings.java:196"$0$"	 */"
"AnnotationTypeMappings.java:197"$0$"	static AnnotationTypeMappings forAnnotationType("
"AnnotationTypeMappings.java:198"$0$"			Class<? extends Annotation> annotationType,"
"AnnotationTypeMappings.java:199"$0$"			RepeatableContainers repeatableContainers,"
"AnnotationTypeMappings.java:200"$1$"			AnnotationFilter annotationFilter) {"
"AnnotationTypeMappings.java:201"$1$""
"AnnotationTypeMappings.java:202"$1$"		if (repeatableContainers == RepeatableContainers.standardRepeatables()) {"
"AnnotationTypeMappings.java:203"$1$"			return standardRepeatablesCache.computeIfAbsent(annotationFilter,"
"AnnotationTypeMappings.java:204"$1$"					key -> new Cache(repeatableContainers, key)).get(annotationType);"
"AnnotationTypeMappings.java:205"$1$"		}"
"AnnotationTypeMappings.java:206"$1$"		if (repeatableContainers == RepeatableContainers.none()) {"
"AnnotationTypeMappings.java:207"$1$"			return noRepeatablesCache.computeIfAbsent(annotationFilter,"
"AnnotationTypeMappings.java:208"$1$"					key -> new Cache(repeatableContainers, key)).get(annotationType);"
"AnnotationTypeMappings.java:209"$1$"		}"
"AnnotationTypeMappings.java:210"$0$"		return new AnnotationTypeMappings(repeatableContainers, annotationFilter,"
"AnnotationTypeMappings.java:211"$0$"				annotationType);"
"AnnotationTypeMappings.java:212"$0$"	}"
"AnnotationTypeMappings.java:213"$0$""
"AnnotationTypeMappings.java:214"$1$"	static void clearCache() {"
"AnnotationTypeMappings.java:215"$1$"		standardRepeatablesCache.clear();"
"AnnotationTypeMappings.java:216"$1$"		noRepeatablesCache.clear();"
"AnnotationTypeMappings.java:217"$1$"	}"
"AnnotationTypeMappings.java:218"$0$""
"AnnotationTypeMappings.java:219"$0$""
"AnnotationTypeMappings.java:220"$0$"	/**"
"AnnotationTypeMappings.java:221"$1$"	 * Cache created per {@link AnnotationFilter}."
"AnnotationTypeMappings.java:222"$0$"	 */"
"AnnotationTypeMappings.java:223"$1$"	private static class Cache {"
"AnnotationTypeMappings.java:224"$1$""
"AnnotationTypeMappings.java:225"$1$"		private final RepeatableContainers repeatableContainers;"
"AnnotationTypeMappings.java:226"$1$""
"AnnotationTypeMappings.java:227"$1$"		private final AnnotationFilter filter;"
"AnnotationTypeMappings.java:228"$1$""
"AnnotationTypeMappings.java:229"$1$"		private final Map<Class<? extends Annotation>, AnnotationTypeMappings> mappings;"
"AnnotationTypeMappings.java:230"$1$""
"AnnotationTypeMappings.java:231"$1$"		/**"
"AnnotationTypeMappings.java:232"$1$"		 * Create a cache instance with the specified filter."
"AnnotationTypeMappings.java:233"$1$"		 * @param filter the annotation filter"
"AnnotationTypeMappings.java:234"$1$"		 */"
"AnnotationTypeMappings.java:235"$1$"		Cache(RepeatableContainers repeatableContainers, AnnotationFilter filter) {"
"AnnotationTypeMappings.java:236"$1$"			this.repeatableContainers = repeatableContainers;"
"AnnotationTypeMappings.java:237"$1$"			this.filter = filter;"
"AnnotationTypeMappings.java:238"$1$"			this.mappings = new ConcurrentReferenceHashMap<>();"
"AnnotationTypeMappings.java:239"$1$"		}"
"AnnotationTypeMappings.java:240"$0$""
"AnnotationTypeMappings.java:241"$0$"		/**"
"AnnotationTypeMappings.java:242"$1$"		 * Get or create {@link AnnotationTypeMappings} for the specified annotation type."
"AnnotationTypeMappings.java:243"$0$"		 * @param annotationType the annotation type"
"AnnotationTypeMappings.java:244"$1$"		 * @return a new or existing {@link AnnotationTypeMappings} instance"
"AnnotationTypeMappings.java:245"$0$"		 */"
"AnnotationTypeMappings.java:246"$1$"		AnnotationTypeMappings get(Class<? extends Annotation> annotationType) {"
"AnnotationTypeMappings.java:247"$1$"			return this.mappings.computeIfAbsent(annotationType, this::createMappings);"
"AnnotationTypeMappings.java:248"$1$"		}"
"AnnotationTypeMappings.java:249"$0$""
"AnnotationTypeMappings.java:250"$1$"		AnnotationTypeMappings createMappings(Class<? extends Annotation> annotationType) {"
"AnnotationTypeMappings.java:251"$1$"			return new AnnotationTypeMappings(this.repeatableContainers, this.filter, annotationType);"
"AnnotationTypeMappings.java:252"$1$"		}"
"AnnotationTypeMappings.java:253"$0$"	}"
"AnnotationTypeMappings.java:254"$0$""
"AnnotationTypeMappings.java:255"$0$"}"
"ReflectionUtils.java:1"$0$"/*"
"ReflectionUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ReflectionUtils.java:3"$0$" *"
"ReflectionUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ReflectionUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"ReflectionUtils.java:6"$0$" * You may obtain a copy of the License at"
"ReflectionUtils.java:7"$0$" *"
"ReflectionUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ReflectionUtils.java:9"$0$" *"
"ReflectionUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ReflectionUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ReflectionUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ReflectionUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"ReflectionUtils.java:14"$0$" * limitations under the License."
"ReflectionUtils.java:15"$0$" */"
"ReflectionUtils.java:16"$0$""
"ReflectionUtils.java:17"$0$"package org.springframework.util;"
"ReflectionUtils.java:18"$0$""
"ReflectionUtils.java:19"$0$"import java.lang.reflect.Constructor;"
"ReflectionUtils.java:20"$0$"import java.lang.reflect.Field;"
"ReflectionUtils.java:21"$0$"import java.lang.reflect.InvocationTargetException;"
"ReflectionUtils.java:22"$0$"import java.lang.reflect.Method;"
"ReflectionUtils.java:23"$0$"import java.lang.reflect.Modifier;"
"ReflectionUtils.java:24"$0$"import java.lang.reflect.UndeclaredThrowableException;"
"ReflectionUtils.java:25"$0$"import java.util.ArrayList;"
"ReflectionUtils.java:26"$0$"import java.util.Arrays;"
"ReflectionUtils.java:27"$0$"import java.util.List;"
"ReflectionUtils.java:28"$0$"import java.util.Map;"
"ReflectionUtils.java:29"$0$""
"ReflectionUtils.java:30"$0$"import org.springframework.lang.Nullable;"
"ReflectionUtils.java:31"$0$""
"ReflectionUtils.java:32"$0$"/**"
"ReflectionUtils.java:33"$0$" * Simple utility class for working with the reflection API and handling"
"ReflectionUtils.java:34"$0$" * reflection exceptions."
"ReflectionUtils.java:35"$0$" *"
"ReflectionUtils.java:36"$0$" * <p>Only intended for internal use."
"ReflectionUtils.java:37"$0$" *"
"ReflectionUtils.java:38"$0$" * @author Juergen Hoeller"
"ReflectionUtils.java:39"$0$" * @author Rob Harrop"
"ReflectionUtils.java:40"$0$" * @author Rod Johnson"
"ReflectionUtils.java:41"$0$" * @author Costin Leau"
"ReflectionUtils.java:42"$0$" * @author Sam Brannen"
"ReflectionUtils.java:43"$0$" * @author Chris Beams"
"ReflectionUtils.java:44"$0$" * @since 1.2.2"
"ReflectionUtils.java:45"$0$" */"
"ReflectionUtils.java:46"$1$"public abstract class ReflectionUtils {"
"ReflectionUtils.java:47"$1$""
"ReflectionUtils.java:48"$1$"	/**"
"ReflectionUtils.java:49"$1$"	 * Pre-built MethodFilter that matches all non-bridge non-synthetic methods"
"ReflectionUtils.java:50"$1$"	 * which are not declared on {@code java.lang.Object}."
"ReflectionUtils.java:51"$1$"	 * @since 3.0.5"
"ReflectionUtils.java:52"$1$"	 */"
"ReflectionUtils.java:53"$1$"	public static final MethodFilter USER_DECLARED_METHODS ="
"ReflectionUtils.java:54"$1$"			(method -> !method.isBridge() && !method.isSynthetic());"
"ReflectionUtils.java:55"$1$""
"ReflectionUtils.java:56"$1$"	/**"
"ReflectionUtils.java:57"$1$"	 * Pre-built FieldFilter that matches all non-static, non-final fields."
"ReflectionUtils.java:58"$1$"	 */"
"ReflectionUtils.java:59"$1$"	public static final FieldFilter COPYABLE_FIELDS ="
"ReflectionUtils.java:60"$1$"			(field -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers())));"
"ReflectionUtils.java:61"$1$""
"ReflectionUtils.java:62"$1$""
"ReflectionUtils.java:63"$1$"	/**"
"ReflectionUtils.java:64"$1$"	 * Naming prefix for CGLIB-renamed methods."
"ReflectionUtils.java:65"$1$"	 * @see #isCglibRenamedMethod"
"ReflectionUtils.java:66"$1$"	 */"
"ReflectionUtils.java:67"$1$"	private static final String CGLIB_RENAMED_METHOD_PREFIX = ""CGLIB$"";"
"ReflectionUtils.java:68"$1$""
"ReflectionUtils.java:69"$1$"	private static final Class<?>[] EMPTY_CLASS_ARRAY = new Class<?>[0];"
"ReflectionUtils.java:70"$1$""
"ReflectionUtils.java:71"$1$"	private static final Method[] EMPTY_METHOD_ARRAY = new Method[0];"
"ReflectionUtils.java:72"$1$""
"ReflectionUtils.java:73"$1$"	private static final Field[] EMPTY_FIELD_ARRAY = new Field[0];"
"ReflectionUtils.java:74"$1$""
"ReflectionUtils.java:75"$1$"	private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];"
"ReflectionUtils.java:76"$1$""
"ReflectionUtils.java:77"$1$""
"ReflectionUtils.java:78"$1$"	/**"
"ReflectionUtils.java:79"$1$"	 * Cache for {@link Class#getDeclaredMethods()} plus equivalent default methods"
"ReflectionUtils.java:80"$1$"	 * from Java 8 based interfaces, allowing for fast iteration."
"ReflectionUtils.java:81"$1$"	 */"
"ReflectionUtils.java:82"$1$"	private static final Map<Class<?>, Method[]> declaredMethodsCache = new ConcurrentReferenceHashMap<>(256);"
"ReflectionUtils.java:83"$1$""
"ReflectionUtils.java:84"$1$"	/**"
"ReflectionUtils.java:85"$1$"	 * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration."
"ReflectionUtils.java:86"$1$"	 */"
"ReflectionUtils.java:87"$1$"	private static final Map<Class<?>, Field[]> declaredFieldsCache = new ConcurrentReferenceHashMap<>(256);"
"ReflectionUtils.java:88"$1$""
"ReflectionUtils.java:89"$1$""
"ReflectionUtils.java:90"$0$"	// Exception handling"
"ReflectionUtils.java:91"$1$""
"ReflectionUtils.java:92"$1$"	/**"
"ReflectionUtils.java:93"$1$"	 * Handle the given reflection exception."
"ReflectionUtils.java:94"$1$"	 * <p>Should only be called if no checked exception is expected to be thrown"
"ReflectionUtils.java:95"$1$"	 * by a target method, or if an error occurs while accessing a method or field."
"ReflectionUtils.java:96"$1$"	 * <p>Throws the underlying RuntimeException or Error in case of an"
"ReflectionUtils.java:97"$1$"	 * InvocationTargetException with such a root cause. Throws an"
"ReflectionUtils.java:98"$1$"	 * IllegalStateException with an appropriate message or"
"ReflectionUtils.java:99"$1$"	 * UndeclaredThrowableException otherwise."
"ReflectionUtils.java:100"$1$"	 * @param ex the reflection exception to handle"
"ReflectionUtils.java:101"$1$"	 */"
"ReflectionUtils.java:102"$1$"	public static void handleReflectionException(Exception ex) {"
"ReflectionUtils.java:103"$1$"		if (ex instanceof NoSuchMethodException) {"
"ReflectionUtils.java:104"$1$"			throw new IllegalStateException(""Method not found: "" + ex.getMessage());"
"ReflectionUtils.java:105"$1$"		}"
"ReflectionUtils.java:106"$1$"		if (ex instanceof IllegalAccessException) {"
"ReflectionUtils.java:107"$1$"			throw new IllegalStateException(""Could not access method or field: "" + ex.getMessage());"
"ReflectionUtils.java:108"$1$"		}"
"ReflectionUtils.java:109"$1$"		if (ex instanceof InvocationTargetException) {"
"ReflectionUtils.java:110"$1$"			handleInvocationTargetException((InvocationTargetException) ex);"
"ReflectionUtils.java:111"$1$"		}"
"ReflectionUtils.java:112"$1$"		if (ex instanceof RuntimeException) {"
"ReflectionUtils.java:113"$1$"			throw (RuntimeException) ex;"
"ReflectionUtils.java:114"$1$"		}"
"ReflectionUtils.java:115"$0$"		throw new UndeclaredThrowableException(ex);"
"ReflectionUtils.java:116"$0$"	}"
"ReflectionUtils.java:117"$0$""
"ReflectionUtils.java:118"$0$"	/**"
"ReflectionUtils.java:119"$0$"	 * Handle the given invocation target exception. Should only be called if no"
"ReflectionUtils.java:120"$0$"	 * checked exception is expected to be thrown by the target method."
"ReflectionUtils.java:121"$0$"	 * <p>Throws the underlying RuntimeException or Error in case of such a root"
"ReflectionUtils.java:122"$0$"	 * cause. Throws an UndeclaredThrowableException otherwise."
"ReflectionUtils.java:123"$0$"	 * @param ex the invocation target exception to handle"
"ReflectionUtils.java:124"$0$"	 */"
"ReflectionUtils.java:125"$1$"	public static void handleInvocationTargetException(InvocationTargetException ex) {"
"ReflectionUtils.java:126"$1$"		rethrowRuntimeException(ex.getTargetException());"
"ReflectionUtils.java:127"$1$"	}"
"ReflectionUtils.java:128"$0$""
"ReflectionUtils.java:129"$0$"	/**"
"ReflectionUtils.java:130"$1$"	 * Rethrow the given {@link Throwable exception}, which is presumably the"
"ReflectionUtils.java:131"$1$"	 * <em>target exception</em> of an {@link InvocationTargetException}."
"ReflectionUtils.java:132"$0$"	 * Should only be called if no checked exception is expected to be thrown"
"ReflectionUtils.java:133"$0$"	 * by the target method."
"ReflectionUtils.java:134"$1$"	 * <p>Rethrows the underlying exception cast to a {@link RuntimeException} or"
"ReflectionUtils.java:135"$1$"	 * {@link Error} if appropriate; otherwise, throws an"
"ReflectionUtils.java:136"$1$"	 * {@link UndeclaredThrowableException}."
"ReflectionUtils.java:137"$0$"	 * @param ex the exception to rethrow"
"ReflectionUtils.java:138"$0$"	 * @throws RuntimeException the rethrown exception"
"ReflectionUtils.java:139"$0$"	 */"
"ReflectionUtils.java:140"$1$"	public static void rethrowRuntimeException(Throwable ex) {"
"ReflectionUtils.java:141"$1$"		if (ex instanceof RuntimeException) {"
"ReflectionUtils.java:142"$1$"			throw (RuntimeException) ex;"
"ReflectionUtils.java:143"$1$"		}"
"ReflectionUtils.java:144"$1$"		if (ex instanceof Error) {"
"ReflectionUtils.java:145"$1$"			throw (Error) ex;"
"ReflectionUtils.java:146"$1$"		}"
"ReflectionUtils.java:147"$0$"		throw new UndeclaredThrowableException(ex);"
"ReflectionUtils.java:148"$0$"	}"
"ReflectionUtils.java:149"$0$""
"ReflectionUtils.java:150"$0$"	/**"
"ReflectionUtils.java:151"$1$"	 * Rethrow the given {@link Throwable exception}, which is presumably the"
"ReflectionUtils.java:152"$1$"	 * <em>target exception</em> of an {@link InvocationTargetException}."
"ReflectionUtils.java:153"$0$"	 * Should only be called if no checked exception is expected to be thrown"
"ReflectionUtils.java:154"$0$"	 * by the target method."
"ReflectionUtils.java:155"$1$"	 * <p>Rethrows the underlying exception cast to an {@link Exception} or"
"ReflectionUtils.java:156"$1$"	 * {@link Error} if appropriate; otherwise, throws an"
"ReflectionUtils.java:157"$1$"	 * {@link UndeclaredThrowableException}."
"ReflectionUtils.java:158"$0$"	 * @param ex the exception to rethrow"
"ReflectionUtils.java:159"$0$"	 * @throws Exception the rethrown exception (in case of a checked exception)"
"ReflectionUtils.java:160"$0$"	 */"
"ReflectionUtils.java:161"$1$"	public static void rethrowException(Throwable ex) throws Exception {"
"ReflectionUtils.java:162"$1$"		if (ex instanceof Exception) {"
"ReflectionUtils.java:163"$1$"			throw (Exception) ex;"
"ReflectionUtils.java:164"$1$"		}"
"ReflectionUtils.java:165"$1$"		if (ex instanceof Error) {"
"ReflectionUtils.java:166"$1$"			throw (Error) ex;"
"ReflectionUtils.java:167"$1$"		}"
"ReflectionUtils.java:168"$0$"		throw new UndeclaredThrowableException(ex);"
"ReflectionUtils.java:169"$0$"	}"
"ReflectionUtils.java:170"$0$""
"ReflectionUtils.java:171"$0$""
"ReflectionUtils.java:172"$0$"	// Constructor handling"
"ReflectionUtils.java:173"$0$""
"ReflectionUtils.java:174"$0$"	/**"
"ReflectionUtils.java:175"$0$"	 * Obtain an accessible constructor for the given class and parameters."
"ReflectionUtils.java:176"$0$"	 * @param clazz the clazz to check"
"ReflectionUtils.java:177"$0$"	 * @param parameterTypes the parameter types of the desired constructor"
"ReflectionUtils.java:178"$0$"	 * @return the constructor reference"
"ReflectionUtils.java:179"$0$"	 * @throws NoSuchMethodException if no such constructor exists"
"ReflectionUtils.java:180"$0$"	 * @since 5.0"
"ReflectionUtils.java:181"$0$"	 */"
"ReflectionUtils.java:182"$0$"	public static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)"
"ReflectionUtils.java:183"$1$"			throws NoSuchMethodException {"
"ReflectionUtils.java:184"$1$""
"ReflectionUtils.java:185"$1$"		Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);"
"ReflectionUtils.java:186"$1$"		makeAccessible(ctor);"
"ReflectionUtils.java:187"$1$"		return ctor;"
"ReflectionUtils.java:188"$1$"	}"
"ReflectionUtils.java:189"$0$""
"ReflectionUtils.java:190"$0$"	/**"
"ReflectionUtils.java:191"$0$"	 * Make the given constructor accessible, explicitly setting it accessible"
"ReflectionUtils.java:192"$1$"	 * if necessary. The {@code setAccessible(true)} method is only called"
"ReflectionUtils.java:193"$0$"	 * when actually necessary, to avoid unnecessary conflicts with a JVM"
"ReflectionUtils.java:194"$0$"	 * SecurityManager (if active)."
"ReflectionUtils.java:195"$0$"	 * @param ctor the constructor to make accessible"
"ReflectionUtils.java:196"$0$"	 * @see java.lang.reflect.Constructor#setAccessible"
"ReflectionUtils.java:197"$0$"	 */"
"ReflectionUtils.java:198"$0$"	@SuppressWarnings(""deprecation"")  // on JDK 9"
"ReflectionUtils.java:199"$1$"	public static void makeAccessible(Constructor<?> ctor) {"
"ReflectionUtils.java:200"$1$"		if ((!Modifier.isPublic(ctor.getModifiers()) ||"
"ReflectionUtils.java:201"$1$"				!Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {"
"ReflectionUtils.java:202"$1$"			ctor.setAccessible(true);"
"ReflectionUtils.java:203"$1$"		}"
"ReflectionUtils.java:204"$0$"	}"
"ReflectionUtils.java:205"$0$""
"ReflectionUtils.java:206"$0$""
"ReflectionUtils.java:207"$0$"	// Method handling"
"ReflectionUtils.java:208"$0$""
"ReflectionUtils.java:209"$0$"	/**"
"ReflectionUtils.java:210"$1$"	 * Attempt to find a {@link Method} on the supplied class with the supplied name"
"ReflectionUtils.java:211"$1$"	 * and no parameters. Searches all superclasses up to {@code Object}."
"ReflectionUtils.java:212"$1$"	 * <p>Returns {@code null} if no {@link Method} can be found."
"ReflectionUtils.java:213"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:214"$0$"	 * @param name the name of the method"
"ReflectionUtils.java:215"$1$"	 * @return the Method object, or {@code null} if none found"
"ReflectionUtils.java:216"$0$"	 */"
"ReflectionUtils.java:217"$0$"	@Nullable"
"ReflectionUtils.java:218"$1$"	public static Method findMethod(Class<?> clazz, String name) {"
"ReflectionUtils.java:219"$1$"		return findMethod(clazz, name, EMPTY_CLASS_ARRAY);"
"ReflectionUtils.java:220"$1$"	}"
"ReflectionUtils.java:221"$0$""
"ReflectionUtils.java:222"$0$"	/**"
"ReflectionUtils.java:223"$1$"	 * Attempt to find a {@link Method} on the supplied class with the supplied name"
"ReflectionUtils.java:224"$1$"	 * and parameter types. Searches all superclasses up to {@code Object}."
"ReflectionUtils.java:225"$1$"	 * <p>Returns {@code null} if no {@link Method} can be found."
"ReflectionUtils.java:226"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:227"$0$"	 * @param name the name of the method"
"ReflectionUtils.java:228"$0$"	 * @param paramTypes the parameter types of the method"
"ReflectionUtils.java:229"$1$"	 * (may be {@code null} to indicate any signature)"
"ReflectionUtils.java:230"$1$"	 * @return the Method object, or {@code null} if none found"
"ReflectionUtils.java:231"$0$"	 */"
"ReflectionUtils.java:232"$0$"	@Nullable"
"ReflectionUtils.java:233"$1$"	public static Method findMethod(Class<?> clazz, String name, @Nullable Class<?>... paramTypes) {"
"ReflectionUtils.java:234"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ReflectionUtils.java:235"$1$"		Assert.notNull(name, ""Method name must not be null"");"
"ReflectionUtils.java:236"$1$"		Class<?> searchType = clazz;"
"ReflectionUtils.java:237"$1$"		while (searchType != null) {"
"ReflectionUtils.java:238"$1$"			Method[] methods = (searchType.isInterface() ? searchType.getMethods() :"
"ReflectionUtils.java:239"$1$"					getDeclaredMethods(searchType, false));"
"ReflectionUtils.java:240"$1$"			for (Method method : methods) {"
"ReflectionUtils.java:241"$1$"				if (name.equals(method.getName()) && (paramTypes == null || hasSameParams(method, paramTypes))) {"
"ReflectionUtils.java:242"$1$"					return method;"
"ReflectionUtils.java:243"$1$"				}"
"ReflectionUtils.java:244"$0$"			}"
"ReflectionUtils.java:245"$0$"			searchType = searchType.getSuperclass();"
"ReflectionUtils.java:246"$0$"		}"
"ReflectionUtils.java:247"$0$"		return null;"
"ReflectionUtils.java:248"$0$"	}"
"ReflectionUtils.java:249"$0$""
"ReflectionUtils.java:250"$1$"	private static boolean hasSameParams(Method method, Class<?>[] paramTypes) {"
"ReflectionUtils.java:251"$1$"		return (paramTypes.length == method.getParameterCount() &&"
"ReflectionUtils.java:252"$1$"				Arrays.equals(paramTypes, method.getParameterTypes()));"
"ReflectionUtils.java:253"$1$"	}"
"ReflectionUtils.java:254"$0$""
"ReflectionUtils.java:255"$0$"	/**"
"ReflectionUtils.java:256"$1$"	 * Invoke the specified {@link Method} against the supplied target object with no arguments."
"ReflectionUtils.java:257"$1$"	 * The target object can be {@code null} when invoking a static {@link Method}."
"ReflectionUtils.java:258"$1$"	 * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}."
"ReflectionUtils.java:259"$0$"	 * @param method the method to invoke"
"ReflectionUtils.java:260"$0$"	 * @param target the target object to invoke the method on"
"ReflectionUtils.java:261"$0$"	 * @return the invocation result, if any"
"ReflectionUtils.java:262"$0$"	 * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])"
"ReflectionUtils.java:263"$0$"	 */"
"ReflectionUtils.java:264"$0$"	@Nullable"
"ReflectionUtils.java:265"$1$"	public static Object invokeMethod(Method method, @Nullable Object target) {"
"ReflectionUtils.java:266"$1$"		return invokeMethod(method, target, EMPTY_OBJECT_ARRAY);"
"ReflectionUtils.java:267"$1$"	}"
"ReflectionUtils.java:268"$0$""
"ReflectionUtils.java:269"$0$"	/**"
"ReflectionUtils.java:270"$1$"	 * Invoke the specified {@link Method} against the supplied target object with the"
"ReflectionUtils.java:271"$1$"	 * supplied arguments. The target object can be {@code null} when invoking a"
"ReflectionUtils.java:272"$1$"	 * static {@link Method}."
"ReflectionUtils.java:273"$1$"	 * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException}."
"ReflectionUtils.java:274"$0$"	 * @param method the method to invoke"
"ReflectionUtils.java:275"$0$"	 * @param target the target object to invoke the method on"
"ReflectionUtils.java:276"$1$"	 * @param args the invocation arguments (may be {@code null})"
"ReflectionUtils.java:277"$0$"	 * @return the invocation result, if any"
"ReflectionUtils.java:278"$0$"	 */"
"ReflectionUtils.java:279"$0$"	@Nullable"
"ReflectionUtils.java:280"$1$"	public static Object invokeMethod(Method method, @Nullable Object target, @Nullable Object... args) {"
"ReflectionUtils.java:281"$1$"		try {"
"ReflectionUtils.java:282"$1$"			return method.invoke(target, args);"
"ReflectionUtils.java:283"$1$"		}"
"ReflectionUtils.java:284"$1$"		catch (Exception ex) {"
"ReflectionUtils.java:285"$1$"			handleReflectionException(ex);"
"ReflectionUtils.java:286"$1$"		}"
"ReflectionUtils.java:287"$0$"		throw new IllegalStateException(""Should never get here"");"
"ReflectionUtils.java:288"$0$"	}"
"ReflectionUtils.java:289"$0$""
"ReflectionUtils.java:290"$0$"	/**"
"ReflectionUtils.java:291"$0$"	 * Determine whether the given method explicitly declares the given"
"ReflectionUtils.java:292"$0$"	 * exception or one of its superclasses, which means that an exception"
"ReflectionUtils.java:293"$0$"	 * of that type can be propagated as-is within a reflective invocation."
"ReflectionUtils.java:294"$0$"	 * @param method the declaring method"
"ReflectionUtils.java:295"$0$"	 * @param exceptionType the exception to throw"
"ReflectionUtils.java:296"$1$"	 * @return {@code true} if the exception can be thrown as-is;"
"ReflectionUtils.java:297"$1$"	 * {@code false} if it needs to be wrapped"
"ReflectionUtils.java:298"$0$"	 */"
"ReflectionUtils.java:299"$1$"	public static boolean declaresException(Method method, Class<?> exceptionType) {"
"ReflectionUtils.java:300"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ReflectionUtils.java:301"$1$"		Class<?>[] declaredExceptions = method.getExceptionTypes();"
"ReflectionUtils.java:302"$1$"		for (Class<?> declaredException : declaredExceptions) {"
"ReflectionUtils.java:303"$1$"			if (declaredException.isAssignableFrom(exceptionType)) {"
"ReflectionUtils.java:304"$1$"				return true;"
"ReflectionUtils.java:305"$1$"			}"
"ReflectionUtils.java:306"$0$"		}"
"ReflectionUtils.java:307"$0$"		return false;"
"ReflectionUtils.java:308"$0$"	}"
"ReflectionUtils.java:309"$0$""
"ReflectionUtils.java:310"$0$"	/**"
"ReflectionUtils.java:311"$0$"	 * Perform the given callback operation on all matching methods of the given"
"ReflectionUtils.java:312"$0$"	 * class, as locally declared or equivalent thereof (such as default methods"
"ReflectionUtils.java:313"$0$"	 * on Java 8 based interfaces that the given class implements)."
"ReflectionUtils.java:314"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:315"$0$"	 * @param mc the callback to invoke for each method"
"ReflectionUtils.java:316"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:317"$0$"	 * @since 4.2"
"ReflectionUtils.java:318"$0$"	 * @see #doWithMethods"
"ReflectionUtils.java:319"$0$"	 */"
"ReflectionUtils.java:320"$1$"	public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {"
"ReflectionUtils.java:321"$1$"		Method[] methods = getDeclaredMethods(clazz, false);"
"ReflectionUtils.java:322"$1$"		for (Method method : methods) {"
"ReflectionUtils.java:323"$1$"			try {"
"ReflectionUtils.java:324"$1$"				mc.doWith(method);"
"ReflectionUtils.java:325"$1$"			}"
"ReflectionUtils.java:326"$1$"			catch (IllegalAccessException ex) {"
"ReflectionUtils.java:327"$1$"				throw new IllegalStateException(""Not allowed to access method '"" + method.getName() + ""': "" + ex);"
"ReflectionUtils.java:328"$1$"			}"
"ReflectionUtils.java:329"$0$"		}"
"ReflectionUtils.java:330"$0$"	}"
"ReflectionUtils.java:331"$0$""
"ReflectionUtils.java:332"$0$"	/**"
"ReflectionUtils.java:333"$0$"	 * Perform the given callback operation on all matching methods of the given"
"ReflectionUtils.java:334"$0$"	 * class and superclasses."
"ReflectionUtils.java:335"$0$"	 * <p>The same named method occurring on subclass and superclass will appear"
"ReflectionUtils.java:336"$1$"	 * twice, unless excluded by a {@link MethodFilter}."
"ReflectionUtils.java:337"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:338"$0$"	 * @param mc the callback to invoke for each method"
"ReflectionUtils.java:339"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:340"$0$"	 * @see #doWithMethods(Class, MethodCallback, MethodFilter)"
"ReflectionUtils.java:341"$0$"	 */"
"ReflectionUtils.java:342"$1$"	public static void doWithMethods(Class<?> clazz, MethodCallback mc) {"
"ReflectionUtils.java:343"$1$"		doWithMethods(clazz, mc, null);"
"ReflectionUtils.java:344"$1$"	}"
"ReflectionUtils.java:345"$0$""
"ReflectionUtils.java:346"$0$"	/**"
"ReflectionUtils.java:347"$0$"	 * Perform the given callback operation on all matching methods of the given"
"ReflectionUtils.java:348"$0$"	 * class and superclasses (or given interface and super-interfaces)."
"ReflectionUtils.java:349"$0$"	 * <p>The same named method occurring on subclass and superclass will appear"
"ReflectionUtils.java:350"$1$"	 * twice, unless excluded by the specified {@link MethodFilter}."
"ReflectionUtils.java:351"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:352"$0$"	 * @param mc the callback to invoke for each method"
"ReflectionUtils.java:353"$0$"	 * @param mf the filter that determines the methods to apply the callback to"
"ReflectionUtils.java:354"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:355"$0$"	 */"
"ReflectionUtils.java:356"$1$"	public static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {"
"ReflectionUtils.java:357"$0$"		// Keep backing up the inheritance hierarchy."
"ReflectionUtils.java:358"$1$"		Method[] methods = getDeclaredMethods(clazz, false);"
"ReflectionUtils.java:359"$1$"		for (Method method : methods) {"
"ReflectionUtils.java:360"$1$"			if (mf != null && !mf.matches(method)) {"
"ReflectionUtils.java:361"$1$"				continue;"
"ReflectionUtils.java:362"$1$"			}"
"ReflectionUtils.java:363"$1$"			try {"
"ReflectionUtils.java:364"$1$"				mc.doWith(method);"
"ReflectionUtils.java:365"$1$"			}"
"ReflectionUtils.java:366"$1$"			catch (IllegalAccessException ex) {"
"ReflectionUtils.java:367"$1$"				throw new IllegalStateException(""Not allowed to access method '"" + method.getName() + ""': "" + ex);"
"ReflectionUtils.java:368"$1$"			}"
"ReflectionUtils.java:369"$0$"		}"
"ReflectionUtils.java:370"$1$"		if (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {"
"ReflectionUtils.java:371"$1$"			doWithMethods(clazz.getSuperclass(), mc, mf);"
"ReflectionUtils.java:372"$1$"		}"
"ReflectionUtils.java:373"$1$"		else if (clazz.isInterface()) {"
"ReflectionUtils.java:374"$1$"			for (Class<?> superIfc : clazz.getInterfaces()) {"
"ReflectionUtils.java:375"$1$"				doWithMethods(superIfc, mc, mf);"
"ReflectionUtils.java:376"$1$"			}"
"ReflectionUtils.java:377"$0$"		}"
"ReflectionUtils.java:378"$0$"	}"
"ReflectionUtils.java:379"$0$""
"ReflectionUtils.java:380"$0$"	/**"
"ReflectionUtils.java:381"$0$"	 * Get all declared methods on the leaf class and all superclasses."
"ReflectionUtils.java:382"$0$"	 * Leaf class methods are included first."
"ReflectionUtils.java:383"$0$"	 * @param leafClass the class to introspect"
"ReflectionUtils.java:384"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:385"$0$"	 */"
"ReflectionUtils.java:386"$1$"	public static Method[] getAllDeclaredMethods(Class<?> leafClass) {"
"ReflectionUtils.java:387"$1$"		final List<Method> methods = new ArrayList<>(32);"
"ReflectionUtils.java:388"$1$"		doWithMethods(leafClass, methods::add);"
"ReflectionUtils.java:389"$1$"		return methods.toArray(EMPTY_METHOD_ARRAY);"
"ReflectionUtils.java:390"$1$"	}"
"ReflectionUtils.java:391"$0$""
"ReflectionUtils.java:392"$0$"	/**"
"ReflectionUtils.java:393"$0$"	 * Get the unique set of declared methods on the leaf class and all superclasses."
"ReflectionUtils.java:394"$0$"	 * Leaf class methods are included first and while traversing the superclass hierarchy"
"ReflectionUtils.java:395"$0$"	 * any methods found with signatures matching a method already included are filtered out."
"ReflectionUtils.java:396"$0$"	 * @param leafClass the class to introspect"
"ReflectionUtils.java:397"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:398"$0$"	 */"
"ReflectionUtils.java:399"$1$"	public static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {"
"ReflectionUtils.java:400"$1$"		return getUniqueDeclaredMethods(leafClass, null);"
"ReflectionUtils.java:401"$1$"	}"
"ReflectionUtils.java:402"$0$""
"ReflectionUtils.java:403"$0$"	/**"
"ReflectionUtils.java:404"$0$"	 * Get the unique set of declared methods on the leaf class and all superclasses."
"ReflectionUtils.java:405"$0$"	 * Leaf class methods are included first and while traversing the superclass hierarchy"
"ReflectionUtils.java:406"$0$"	 * any methods found with signatures matching a method already included are filtered out."
"ReflectionUtils.java:407"$0$"	 * @param leafClass the class to introspect"
"ReflectionUtils.java:408"$0$"	 * @param mf the filter that determines the methods to take into account"
"ReflectionUtils.java:409"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:410"$0$"	 * @since 5.2"
"ReflectionUtils.java:411"$0$"	 */"
"ReflectionUtils.java:412"$1$"	public static Method[] getUniqueDeclaredMethods(Class<?> leafClass, @Nullable MethodFilter mf) {"
"ReflectionUtils.java:413"$1$"		final List<Method> methods = new ArrayList<>(32);"
"ReflectionUtils.java:414"$1$"		doWithMethods(leafClass, method -> {"
"ReflectionUtils.java:415"$1$"			boolean knownSignature = false;"
"ReflectionUtils.java:416"$1$"			Method methodBeingOverriddenWithCovariantReturnType = null;"
"ReflectionUtils.java:417"$1$"			for (Method existingMethod : methods) {"
"ReflectionUtils.java:418"$1$"				if (method.getName().equals(existingMethod.getName()) &&"
"ReflectionUtils.java:419"$1$"						method.getParameterCount() == existingMethod.getParameterCount() &&"
"ReflectionUtils.java:420"$1$"						Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {"
"ReflectionUtils.java:421"$0$"					// Is this a covariant return type situation?"
"ReflectionUtils.java:422"$1$"					if (existingMethod.getReturnType() != method.getReturnType() &&"
"ReflectionUtils.java:423"$1$"							existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {"
"ReflectionUtils.java:424"$1$"						methodBeingOverriddenWithCovariantReturnType = existingMethod;"
"ReflectionUtils.java:425"$1$"					}"
"ReflectionUtils.java:426"$1$"					else {"
"ReflectionUtils.java:427"$1$"						knownSignature = true;"
"ReflectionUtils.java:428"$1$"					}"
"ReflectionUtils.java:429"$0$"					break;"
"ReflectionUtils.java:430"$0$"				}"
"ReflectionUtils.java:431"$0$"			}"
"ReflectionUtils.java:432"$1$"			if (methodBeingOverriddenWithCovariantReturnType != null) {"
"ReflectionUtils.java:433"$1$"				methods.remove(methodBeingOverriddenWithCovariantReturnType);"
"ReflectionUtils.java:434"$1$"			}"
"ReflectionUtils.java:435"$1$"			if (!knownSignature && !isCglibRenamedMethod(method)) {"
"ReflectionUtils.java:436"$1$"				methods.add(method);"
"ReflectionUtils.java:437"$1$"			}"
"ReflectionUtils.java:438"$0$"		}, mf);"
"ReflectionUtils.java:439"$0$"		return methods.toArray(EMPTY_METHOD_ARRAY);"
"ReflectionUtils.java:440"$0$"	}"
"ReflectionUtils.java:441"$0$""
"ReflectionUtils.java:442"$0$"	/**"
"ReflectionUtils.java:443"$1$"	 * Variant of {@link Class#getDeclaredMethods()} that uses a local cache in"
"ReflectionUtils.java:444"$0$"	 * order to avoid the JVM's SecurityManager check and new Method instances."
"ReflectionUtils.java:445"$0$"	 * In addition, it also includes Java 8 default methods from locally"
"ReflectionUtils.java:446"$0$"	 * implemented interfaces, since those are effectively to be treated just"
"ReflectionUtils.java:447"$0$"	 * like declared methods."
"ReflectionUtils.java:448"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:449"$0$"	 * @return the cached array of methods"
"ReflectionUtils.java:450"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:451"$0$"	 * @since 5.2"
"ReflectionUtils.java:452"$0$"	 * @see Class#getDeclaredMethods()"
"ReflectionUtils.java:453"$0$"	 */"
"ReflectionUtils.java:454"$1$"	public static Method[] getDeclaredMethods(Class<?> clazz) {"
"ReflectionUtils.java:455"$1$"		return getDeclaredMethods(clazz, true);"
"ReflectionUtils.java:456"$1$"	}"
"ReflectionUtils.java:457"$0$""
"ReflectionUtils.java:458"$1$"	private static Method[] getDeclaredMethods(Class<?> clazz, boolean defensive) {"
"ReflectionUtils.java:459"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ReflectionUtils.java:460"$1$"		Method[] result = declaredMethodsCache.get(clazz);"
"ReflectionUtils.java:461"$1$"		if (result == null) {"
"ReflectionUtils.java:462"$1$"			try {"
"ReflectionUtils.java:463"$1$"				Method[] declaredMethods = clazz.getDeclaredMethods();"
"ReflectionUtils.java:464"$1$"				List<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);"
"ReflectionUtils.java:465"$1$"				if (defaultMethods != null) {"
"ReflectionUtils.java:466"$1$"					result = new Method[declaredMethods.length + defaultMethods.size()];"
"ReflectionUtils.java:467"$1$"					System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);"
"ReflectionUtils.java:468"$1$"					int index = declaredMethods.length;"
"ReflectionUtils.java:469"$1$"					for (Method defaultMethod : defaultMethods) {"
"ReflectionUtils.java:470"$1$"						result[index] = defaultMethod;"
"ReflectionUtils.java:471"$1$"						index++;"
"ReflectionUtils.java:472"$1$"					}"
"ReflectionUtils.java:473"$0$"				}"
"ReflectionUtils.java:474"$1$"				else {"
"ReflectionUtils.java:475"$1$"					result = declaredMethods;"
"ReflectionUtils.java:476"$1$"				}"
"ReflectionUtils.java:477"$0$"				declaredMethodsCache.put(clazz, (result.length == 0 ? EMPTY_METHOD_ARRAY : result));"
"ReflectionUtils.java:478"$0$"			}"
"ReflectionUtils.java:479"$1$"			catch (Throwable ex) {"
"ReflectionUtils.java:480"$1$"				throw new IllegalStateException(""Failed to introspect Class ["" + clazz.getName() +"
"ReflectionUtils.java:481"$1$"						""] from ClassLoader ["" + clazz.getClassLoader() + ""]"", ex);"
"ReflectionUtils.java:482"$1$"			}"
"ReflectionUtils.java:483"$0$"		}"
"ReflectionUtils.java:484"$0$"		return (result.length == 0 || !defensive) ? result : result.clone();"
"ReflectionUtils.java:485"$0$"	}"
"ReflectionUtils.java:486"$0$""
"ReflectionUtils.java:487"$0$"	@Nullable"
"ReflectionUtils.java:488"$1$"	private static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {"
"ReflectionUtils.java:489"$1$"		List<Method> result = null;"
"ReflectionUtils.java:490"$1$"		for (Class<?> ifc : clazz.getInterfaces()) {"
"ReflectionUtils.java:491"$1$"			for (Method ifcMethod : ifc.getMethods()) {"
"ReflectionUtils.java:492"$1$"				if (!Modifier.isAbstract(ifcMethod.getModifiers())) {"
"ReflectionUtils.java:493"$1$"					if (result == null) {"
"ReflectionUtils.java:494"$1$"						result = new ArrayList<>();"
"ReflectionUtils.java:495"$1$"					}"
"ReflectionUtils.java:496"$0$"					result.add(ifcMethod);"
"ReflectionUtils.java:497"$0$"				}"
"ReflectionUtils.java:498"$0$"			}"
"ReflectionUtils.java:499"$0$"		}"
"ReflectionUtils.java:500"$0$"		return result;"
"ReflectionUtils.java:501"$0$"	}"
"ReflectionUtils.java:502"$0$""
"ReflectionUtils.java:503"$0$"	/**"
"ReflectionUtils.java:504"$0$"	 * Determine whether the given method is an ""equals"" method."
"ReflectionUtils.java:505"$0$"	 * @see java.lang.Object#equals(Object)"
"ReflectionUtils.java:506"$0$"	 */"
"ReflectionUtils.java:507"$1$"	public static boolean isEqualsMethod(@Nullable Method method) {"
"ReflectionUtils.java:508"$1$"		if (method == null || !method.getName().equals(""equals"")) {"
"ReflectionUtils.java:509"$1$"			return false;"
"ReflectionUtils.java:510"$1$"		}"
"ReflectionUtils.java:511"$1$"		if (method.getParameterCount() != 1) {"
"ReflectionUtils.java:512"$1$"			return false;"
"ReflectionUtils.java:513"$1$"		}"
"ReflectionUtils.java:514"$0$"		return method.getParameterTypes()[0] == Object.class;"
"ReflectionUtils.java:515"$0$"	}"
"ReflectionUtils.java:516"$0$""
"ReflectionUtils.java:517"$0$"	/**"
"ReflectionUtils.java:518"$0$"	 * Determine whether the given method is a ""hashCode"" method."
"ReflectionUtils.java:519"$0$"	 * @see java.lang.Object#hashCode()"
"ReflectionUtils.java:520"$0$"	 */"
"ReflectionUtils.java:521"$1$"	public static boolean isHashCodeMethod(@Nullable Method method) {"
"ReflectionUtils.java:522"$1$"		return (method != null && method.getName().equals(""hashCode"") && method.getParameterCount() == 0);"
"ReflectionUtils.java:523"$1$"	}"
"ReflectionUtils.java:524"$0$""
"ReflectionUtils.java:525"$0$"	/**"
"ReflectionUtils.java:526"$0$"	 * Determine whether the given method is a ""toString"" method."
"ReflectionUtils.java:527"$0$"	 * @see java.lang.Object#toString()"
"ReflectionUtils.java:528"$0$"	 */"
"ReflectionUtils.java:529"$1$"	public static boolean isToStringMethod(@Nullable Method method) {"
"ReflectionUtils.java:530"$1$"		return (method != null && method.getName().equals(""toString"") && method.getParameterCount() == 0);"
"ReflectionUtils.java:531"$1$"	}"
"ReflectionUtils.java:532"$0$""
"ReflectionUtils.java:533"$0$"	/**"
"ReflectionUtils.java:534"$1$"	 * Determine whether the given method is originally declared by {@link java.lang.Object}."
"ReflectionUtils.java:535"$0$"	 */"
"ReflectionUtils.java:536"$1$"	public static boolean isObjectMethod(@Nullable Method method) {"
"ReflectionUtils.java:537"$1$"		return (method != null && (method.getDeclaringClass() == Object.class ||"
"ReflectionUtils.java:538"$1$"				isEqualsMethod(method) || isHashCodeMethod(method) || isToStringMethod(method)));"
"ReflectionUtils.java:539"$1$"	}"
"ReflectionUtils.java:540"$0$""
"ReflectionUtils.java:541"$0$"	/**"
"ReflectionUtils.java:542"$0$"	 * Determine whether the given method is a CGLIB 'renamed' method,"
"ReflectionUtils.java:543"$0$"	 * following the pattern ""CGLIB$methodName$0""."
"ReflectionUtils.java:544"$0$"	 * @param renamedMethod the method to check"
"ReflectionUtils.java:545"$0$"	 */"
"ReflectionUtils.java:546"$1$"	public static boolean isCglibRenamedMethod(Method renamedMethod) {"
"ReflectionUtils.java:547"$1$"		String name = renamedMethod.getName();"
"ReflectionUtils.java:548"$1$"		if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {"
"ReflectionUtils.java:549"$1$"			int i = name.length() - 1;"
"ReflectionUtils.java:550"$1$"			while (i >= 0 && Character.isDigit(name.charAt(i))) {"
"ReflectionUtils.java:551"$1$"				i--;"
"ReflectionUtils.java:552"$1$"			}"
"ReflectionUtils.java:553"$0$"			return (i > CGLIB_RENAMED_METHOD_PREFIX.length() && (i < name.length() - 1) && name.charAt(i) == '$');"
"ReflectionUtils.java:554"$0$"		}"
"ReflectionUtils.java:555"$0$"		return false;"
"ReflectionUtils.java:556"$0$"	}"
"ReflectionUtils.java:557"$0$""
"ReflectionUtils.java:558"$0$"	/**"
"ReflectionUtils.java:559"$0$"	 * Make the given method accessible, explicitly setting it accessible if"
"ReflectionUtils.java:560"$1$"	 * necessary. The {@code setAccessible(true)} method is only called"
"ReflectionUtils.java:561"$0$"	 * when actually necessary, to avoid unnecessary conflicts with a JVM"
"ReflectionUtils.java:562"$0$"	 * SecurityManager (if active)."
"ReflectionUtils.java:563"$0$"	 * @param method the method to make accessible"
"ReflectionUtils.java:564"$0$"	 * @see java.lang.reflect.Method#setAccessible"
"ReflectionUtils.java:565"$0$"	 */"
"ReflectionUtils.java:566"$0$"	@SuppressWarnings(""deprecation"")  // on JDK 9"
"ReflectionUtils.java:567"$1$"	public static void makeAccessible(Method method) {"
"ReflectionUtils.java:568"$1$"		if ((!Modifier.isPublic(method.getModifiers()) ||"
"ReflectionUtils.java:569"$1$"				!Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {"
"ReflectionUtils.java:570"$1$"			method.setAccessible(true);"
"ReflectionUtils.java:571"$1$"		}"
"ReflectionUtils.java:572"$0$"	}"
"ReflectionUtils.java:573"$0$""
"ReflectionUtils.java:574"$0$""
"ReflectionUtils.java:575"$0$"	// Field handling"
"ReflectionUtils.java:576"$0$""
"ReflectionUtils.java:577"$0$"	/**"
"ReflectionUtils.java:578"$1$"	 * Attempt to find a {@link Field field} on the supplied {@link Class} with the"
"ReflectionUtils.java:579"$1$"	 * supplied {@code name}. Searches all superclasses up to {@link Object}."
"ReflectionUtils.java:580"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:581"$0$"	 * @param name the name of the field"
"ReflectionUtils.java:582"$1$"	 * @return the corresponding Field object, or {@code null} if not found"
"ReflectionUtils.java:583"$0$"	 */"
"ReflectionUtils.java:584"$0$"	@Nullable"
"ReflectionUtils.java:585"$1$"	public static Field findField(Class<?> clazz, String name) {"
"ReflectionUtils.java:586"$1$"		return findField(clazz, name, null);"
"ReflectionUtils.java:587"$1$"	}"
"ReflectionUtils.java:588"$0$""
"ReflectionUtils.java:589"$0$"	/**"
"ReflectionUtils.java:590"$1$"	 * Attempt to find a {@link Field field} on the supplied {@link Class} with the"
"ReflectionUtils.java:591"$1$"	 * supplied {@code name} and/or {@link Class type}. Searches all superclasses"
"ReflectionUtils.java:592"$1$"	 * up to {@link Object}."
"ReflectionUtils.java:593"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:594"$1$"	 * @param name the name of the field (may be {@code null} if type is specified)"
"ReflectionUtils.java:595"$1$"	 * @param type the type of the field (may be {@code null} if name is specified)"
"ReflectionUtils.java:596"$1$"	 * @return the corresponding Field object, or {@code null} if not found"
"ReflectionUtils.java:597"$0$"	 */"
"ReflectionUtils.java:598"$0$"	@Nullable"
"ReflectionUtils.java:599"$1$"	public static Field findField(Class<?> clazz, @Nullable String name, @Nullable Class<?> type) {"
"ReflectionUtils.java:600"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ReflectionUtils.java:601"$1$"		Assert.isTrue(name != null || type != null, ""Either name or type of the field must be specified"");"
"ReflectionUtils.java:602"$1$"		Class<?> searchType = clazz;"
"ReflectionUtils.java:603"$1$"		while (Object.class != searchType && searchType != null) {"
"ReflectionUtils.java:604"$1$"			Field[] fields = getDeclaredFields(searchType);"
"ReflectionUtils.java:605"$1$"			for (Field field : fields) {"
"ReflectionUtils.java:606"$1$"				if ((name == null || name.equals(field.getName())) &&"
"ReflectionUtils.java:607"$1$"						(type == null || type.equals(field.getType()))) {"
"ReflectionUtils.java:608"$1$"					return field;"
"ReflectionUtils.java:609"$1$"				}"
"ReflectionUtils.java:610"$0$"			}"
"ReflectionUtils.java:611"$0$"			searchType = searchType.getSuperclass();"
"ReflectionUtils.java:612"$0$"		}"
"ReflectionUtils.java:613"$0$"		return null;"
"ReflectionUtils.java:614"$0$"	}"
"ReflectionUtils.java:615"$0$""
"ReflectionUtils.java:616"$0$"	/**"
"ReflectionUtils.java:617"$1$"	 * Set the field represented by the supplied {@linkplain Field field object} on"
"ReflectionUtils.java:618"$1$"	 * the specified {@linkplain Object target object} to the specified {@code value}."
"ReflectionUtils.java:619"$1$"	 * <p>In accordance with {@link Field#set(Object, Object)} semantics, the new value"
"ReflectionUtils.java:620"$0$"	 * is automatically unwrapped if the underlying field has a primitive type."
"ReflectionUtils.java:621"$1$"	 * <p>This method does not support setting {@code static final} fields."
"ReflectionUtils.java:622"$1$"	 * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}."
"ReflectionUtils.java:623"$0$"	 * @param field the field to set"
"ReflectionUtils.java:624"$0$"	 * @param target the target object on which to set the field"
"ReflectionUtils.java:625"$1$"	 * @param value the value to set (may be {@code null})"
"ReflectionUtils.java:626"$0$"	 */"
"ReflectionUtils.java:627"$1$"	public static void setField(Field field, @Nullable Object target, @Nullable Object value) {"
"ReflectionUtils.java:628"$1$"		try {"
"ReflectionUtils.java:629"$1$"			field.set(target, value);"
"ReflectionUtils.java:630"$1$"		}"
"ReflectionUtils.java:631"$1$"		catch (IllegalAccessException ex) {"
"ReflectionUtils.java:632"$1$"			handleReflectionException(ex);"
"ReflectionUtils.java:633"$1$"		}"
"ReflectionUtils.java:634"$0$"	}"
"ReflectionUtils.java:635"$0$""
"ReflectionUtils.java:636"$0$"	/**"
"ReflectionUtils.java:637"$1$"	 * Get the field represented by the supplied {@link Field field object} on the"
"ReflectionUtils.java:638"$1$"	 * specified {@link Object target object}. In accordance with {@link Field#get(Object)}"
"ReflectionUtils.java:639"$0$"	 * semantics, the returned value is automatically wrapped if the underlying field"
"ReflectionUtils.java:640"$0$"	 * has a primitive type."
"ReflectionUtils.java:641"$1$"	 * <p>Thrown exceptions are handled via a call to {@link #handleReflectionException(Exception)}."
"ReflectionUtils.java:642"$0$"	 * @param field the field to get"
"ReflectionUtils.java:643"$0$"	 * @param target the target object from which to get the field"
"ReflectionUtils.java:644"$0$"	 * @return the field's current value"
"ReflectionUtils.java:645"$0$"	 */"
"ReflectionUtils.java:646"$0$"	@Nullable"
"ReflectionUtils.java:647"$1$"	public static Object getField(Field field, @Nullable Object target) {"
"ReflectionUtils.java:648"$1$"		try {"
"ReflectionUtils.java:649"$1$"			return field.get(target);"
"ReflectionUtils.java:650"$1$"		}"
"ReflectionUtils.java:651"$1$"		catch (IllegalAccessException ex) {"
"ReflectionUtils.java:652"$1$"			handleReflectionException(ex);"
"ReflectionUtils.java:653"$1$"		}"
"ReflectionUtils.java:654"$0$"		throw new IllegalStateException(""Should never get here"");"
"ReflectionUtils.java:655"$0$"	}"
"ReflectionUtils.java:656"$0$""
"ReflectionUtils.java:657"$0$"	/**"
"ReflectionUtils.java:658"$0$"	 * Invoke the given callback on all locally declared fields in the given class."
"ReflectionUtils.java:659"$0$"	 * @param clazz the target class to analyze"
"ReflectionUtils.java:660"$0$"	 * @param fc the callback to invoke for each field"
"ReflectionUtils.java:661"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:662"$0$"	 * @since 4.2"
"ReflectionUtils.java:663"$0$"	 * @see #doWithFields"
"ReflectionUtils.java:664"$0$"	 */"
"ReflectionUtils.java:665"$1$"	public static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {"
"ReflectionUtils.java:666"$1$"		for (Field field : getDeclaredFields(clazz)) {"
"ReflectionUtils.java:667"$1$"			try {"
"ReflectionUtils.java:668"$1$"				fc.doWith(field);"
"ReflectionUtils.java:669"$1$"			}"
"ReflectionUtils.java:670"$1$"			catch (IllegalAccessException ex) {"
"ReflectionUtils.java:671"$1$"				throw new IllegalStateException(""Not allowed to access field '"" + field.getName() + ""': "" + ex);"
"ReflectionUtils.java:672"$1$"			}"
"ReflectionUtils.java:673"$0$"		}"
"ReflectionUtils.java:674"$0$"	}"
"ReflectionUtils.java:675"$0$""
"ReflectionUtils.java:676"$0$"	/**"
"ReflectionUtils.java:677"$0$"	 * Invoke the given callback on all fields in the target class, going up the"
"ReflectionUtils.java:678"$0$"	 * class hierarchy to get all declared fields."
"ReflectionUtils.java:679"$0$"	 * @param clazz the target class to analyze"
"ReflectionUtils.java:680"$0$"	 * @param fc the callback to invoke for each field"
"ReflectionUtils.java:681"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:682"$0$"	 */"
"ReflectionUtils.java:683"$1$"	public static void doWithFields(Class<?> clazz, FieldCallback fc) {"
"ReflectionUtils.java:684"$1$"		doWithFields(clazz, fc, null);"
"ReflectionUtils.java:685"$1$"	}"
"ReflectionUtils.java:686"$0$""
"ReflectionUtils.java:687"$0$"	/**"
"ReflectionUtils.java:688"$0$"	 * Invoke the given callback on all fields in the target class, going up the"
"ReflectionUtils.java:689"$0$"	 * class hierarchy to get all declared fields."
"ReflectionUtils.java:690"$0$"	 * @param clazz the target class to analyze"
"ReflectionUtils.java:691"$0$"	 * @param fc the callback to invoke for each field"
"ReflectionUtils.java:692"$0$"	 * @param ff the filter that determines the fields to apply the callback to"
"ReflectionUtils.java:693"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:694"$0$"	 */"
"ReflectionUtils.java:695"$1$"	public static void doWithFields(Class<?> clazz, FieldCallback fc, @Nullable FieldFilter ff) {"
"ReflectionUtils.java:696"$0$"		// Keep backing up the inheritance hierarchy."
"ReflectionUtils.java:697"$1$"		Class<?> targetClass = clazz;"
"ReflectionUtils.java:698"$1$"		do {"
"ReflectionUtils.java:699"$1$"			Field[] fields = getDeclaredFields(targetClass);"
"ReflectionUtils.java:700"$1$"			for (Field field : fields) {"
"ReflectionUtils.java:701"$1$"				if (ff != null && !ff.matches(field)) {"
"ReflectionUtils.java:702"$1$"					continue;"
"ReflectionUtils.java:703"$1$"				}"
"ReflectionUtils.java:704"$1$"				try {"
"ReflectionUtils.java:705"$1$"					fc.doWith(field);"
"ReflectionUtils.java:706"$1$"				}"
"ReflectionUtils.java:707"$1$"				catch (IllegalAccessException ex) {"
"ReflectionUtils.java:708"$1$"					throw new IllegalStateException(""Not allowed to access field '"" + field.getName() + ""': "" + ex);"
"ReflectionUtils.java:709"$1$"				}"
"ReflectionUtils.java:710"$0$"			}"
"ReflectionUtils.java:711"$0$"			targetClass = targetClass.getSuperclass();"
"ReflectionUtils.java:712"$0$"		}"
"ReflectionUtils.java:713"$0$"		while (targetClass != null && targetClass != Object.class);"
"ReflectionUtils.java:714"$0$"	}"
"ReflectionUtils.java:715"$0$""
"ReflectionUtils.java:716"$0$"	/**"
"ReflectionUtils.java:717"$1$"	 * This variant retrieves {@link Class#getDeclaredFields()} from a local cache"
"ReflectionUtils.java:718"$0$"	 * in order to avoid the JVM's SecurityManager check and defensive array copying."
"ReflectionUtils.java:719"$0$"	 * @param clazz the class to introspect"
"ReflectionUtils.java:720"$0$"	 * @return the cached array of fields"
"ReflectionUtils.java:721"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:722"$0$"	 * @see Class#getDeclaredFields()"
"ReflectionUtils.java:723"$0$"	 */"
"ReflectionUtils.java:724"$1$"	private static Field[] getDeclaredFields(Class<?> clazz) {"
"ReflectionUtils.java:725"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ReflectionUtils.java:726"$1$"		Field[] result = declaredFieldsCache.get(clazz);"
"ReflectionUtils.java:727"$1$"		if (result == null) {"
"ReflectionUtils.java:728"$1$"			try {"
"ReflectionUtils.java:729"$1$"				result = clazz.getDeclaredFields();"
"ReflectionUtils.java:730"$1$"				declaredFieldsCache.put(clazz, (result.length == 0 ? EMPTY_FIELD_ARRAY : result));"
"ReflectionUtils.java:731"$1$"			}"
"ReflectionUtils.java:732"$1$"			catch (Throwable ex) {"
"ReflectionUtils.java:733"$1$"				throw new IllegalStateException(""Failed to introspect Class ["" + clazz.getName() +"
"ReflectionUtils.java:734"$1$"						""] from ClassLoader ["" + clazz.getClassLoader() + ""]"", ex);"
"ReflectionUtils.java:735"$1$"			}"
"ReflectionUtils.java:736"$0$"		}"
"ReflectionUtils.java:737"$0$"		return result;"
"ReflectionUtils.java:738"$0$"	}"
"ReflectionUtils.java:739"$0$""
"ReflectionUtils.java:740"$0$"	/**"
"ReflectionUtils.java:741"$0$"	 * Given the source object and the destination, which must be the same class"
"ReflectionUtils.java:742"$0$"	 * or a subclass, copy all fields, including inherited fields. Designed to"
"ReflectionUtils.java:743"$0$"	 * work on objects with public no-arg constructors."
"ReflectionUtils.java:744"$0$"	 * @throws IllegalStateException if introspection fails"
"ReflectionUtils.java:745"$0$"	 */"
"ReflectionUtils.java:746"$1$"	public static void shallowCopyFieldState(final Object src, final Object dest) {"
"ReflectionUtils.java:747"$1$"		Assert.notNull(src, ""Source for field copy cannot be null"");"
"ReflectionUtils.java:748"$1$"		Assert.notNull(dest, ""Destination for field copy cannot be null"");"
"ReflectionUtils.java:749"$1$"		if (!src.getClass().isAssignableFrom(dest.getClass())) {"
"ReflectionUtils.java:750"$1$"			throw new IllegalArgumentException(""Destination class ["" + dest.getClass().getName() +"
"ReflectionUtils.java:751"$1$"					""] must be same or subclass as source class ["" + src.getClass().getName() + ""]"");"
"ReflectionUtils.java:752"$1$"		}"
"ReflectionUtils.java:753"$1$"		doWithFields(src.getClass(), field -> {"
"ReflectionUtils.java:754"$1$"			makeAccessible(field);"
"ReflectionUtils.java:755"$1$"			Object srcValue = field.get(src);"
"ReflectionUtils.java:756"$1$"			field.set(dest, srcValue);"
"ReflectionUtils.java:757"$1$"		}, COPYABLE_FIELDS);"
"ReflectionUtils.java:758"$0$"	}"
"ReflectionUtils.java:759"$0$""
"ReflectionUtils.java:760"$0$"	/**"
"ReflectionUtils.java:761"$0$"	 * Determine whether the given field is a ""public static final"" constant."
"ReflectionUtils.java:762"$0$"	 * @param field the field to check"
"ReflectionUtils.java:763"$0$"	 */"
"ReflectionUtils.java:764"$1$"	public static boolean isPublicStaticFinal(Field field) {"
"ReflectionUtils.java:765"$1$"		int modifiers = field.getModifiers();"
"ReflectionUtils.java:766"$1$"		return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));"
"ReflectionUtils.java:767"$1$"	}"
"ReflectionUtils.java:768"$0$""
"ReflectionUtils.java:769"$0$"	/**"
"ReflectionUtils.java:770"$0$"	 * Make the given field accessible, explicitly setting it accessible if"
"ReflectionUtils.java:771"$1$"	 * necessary. The {@code setAccessible(true)} method is only called"
"ReflectionUtils.java:772"$0$"	 * when actually necessary, to avoid unnecessary conflicts with a JVM"
"ReflectionUtils.java:773"$0$"	 * SecurityManager (if active)."
"ReflectionUtils.java:774"$0$"	 * @param field the field to make accessible"
"ReflectionUtils.java:775"$0$"	 * @see java.lang.reflect.Field#setAccessible"
"ReflectionUtils.java:776"$0$"	 */"
"ReflectionUtils.java:777"$0$"	@SuppressWarnings(""deprecation"")  // on JDK 9"
"ReflectionUtils.java:778"$1$"	public static void makeAccessible(Field field) {"
"ReflectionUtils.java:779"$1$"		if ((!Modifier.isPublic(field.getModifiers()) ||"
"ReflectionUtils.java:780"$1$"				!Modifier.isPublic(field.getDeclaringClass().getModifiers()) ||"
"ReflectionUtils.java:781"$1$"				Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {"
"ReflectionUtils.java:782"$1$"			field.setAccessible(true);"
"ReflectionUtils.java:783"$1$"		}"
"ReflectionUtils.java:784"$0$"	}"
"ReflectionUtils.java:785"$0$""
"ReflectionUtils.java:786"$0$""
"ReflectionUtils.java:787"$0$"	// Cache handling"
"ReflectionUtils.java:788"$0$""
"ReflectionUtils.java:789"$0$"	/**"
"ReflectionUtils.java:790"$0$"	 * Clear the internal method/field cache."
"ReflectionUtils.java:791"$0$"	 * @since 4.2.4"
"ReflectionUtils.java:792"$0$"	 */"
"ReflectionUtils.java:793"$1$"	public static void clearCache() {"
"ReflectionUtils.java:794"$1$"		declaredMethodsCache.clear();"
"ReflectionUtils.java:795"$1$"		declaredFieldsCache.clear();"
"ReflectionUtils.java:796"$1$"	}"
"ReflectionUtils.java:797"$0$""
"ReflectionUtils.java:798"$0$""
"ReflectionUtils.java:799"$0$"	/**"
"ReflectionUtils.java:800"$0$"	 * Action to take on each method."
"ReflectionUtils.java:801"$0$"	 */"
"ReflectionUtils.java:802"$0$"	@FunctionalInterface"
"ReflectionUtils.java:803"$1$"	public interface MethodCallback {"
"ReflectionUtils.java:804"$1$""
"ReflectionUtils.java:805"$1$"		/**"
"ReflectionUtils.java:806"$1$"		 * Perform an operation using the given method."
"ReflectionUtils.java:807"$1$"		 * @param method the method to operate on"
"ReflectionUtils.java:808"$1$"		 */"
"ReflectionUtils.java:809"$1$"		void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;"
"ReflectionUtils.java:810"$1$"	}"
"ReflectionUtils.java:811"$0$""
"ReflectionUtils.java:812"$0$""
"ReflectionUtils.java:813"$0$"	/**"
"ReflectionUtils.java:814"$0$"	 * Callback optionally used to filter methods to be operated on by a method callback."
"ReflectionUtils.java:815"$0$"	 */"
"ReflectionUtils.java:816"$0$"	@FunctionalInterface"
"ReflectionUtils.java:817"$1$"	public interface MethodFilter {"
"ReflectionUtils.java:818"$1$""
"ReflectionUtils.java:819"$1$"		/**"
"ReflectionUtils.java:820"$1$"		 * Determine whether the given method matches."
"ReflectionUtils.java:821"$1$"		 * @param method the method to check"
"ReflectionUtils.java:822"$1$"		 */"
"ReflectionUtils.java:823"$1$"		boolean matches(Method method);"
"ReflectionUtils.java:824"$1$"	}"
"ReflectionUtils.java:825"$0$""
"ReflectionUtils.java:826"$0$""
"ReflectionUtils.java:827"$0$"	/**"
"ReflectionUtils.java:828"$0$"	 * Callback interface invoked on each field in the hierarchy."
"ReflectionUtils.java:829"$0$"	 */"
"ReflectionUtils.java:830"$0$"	@FunctionalInterface"
"ReflectionUtils.java:831"$1$"	public interface FieldCallback {"
"ReflectionUtils.java:832"$1$""
"ReflectionUtils.java:833"$1$"		/**"
"ReflectionUtils.java:834"$1$"		 * Perform an operation using the given field."
"ReflectionUtils.java:835"$1$"		 * @param field the field to operate on"
"ReflectionUtils.java:836"$1$"		 */"
"ReflectionUtils.java:837"$1$"		void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;"
"ReflectionUtils.java:838"$1$"	}"
"ReflectionUtils.java:839"$0$""
"ReflectionUtils.java:840"$0$""
"ReflectionUtils.java:841"$0$"	/**"
"ReflectionUtils.java:842"$0$"	 * Callback optionally used to filter fields to be operated on by a field callback."
"ReflectionUtils.java:843"$0$"	 */"
"ReflectionUtils.java:844"$0$"	@FunctionalInterface"
"ReflectionUtils.java:845"$1$"	public interface FieldFilter {"
"ReflectionUtils.java:846"$1$""
"ReflectionUtils.java:847"$1$"		/**"
"ReflectionUtils.java:848"$1$"		 * Determine whether the given field matches."
"ReflectionUtils.java:849"$1$"		 * @param field the field to check"
"ReflectionUtils.java:850"$1$"		 */"
"ReflectionUtils.java:851"$1$"		boolean matches(Field field);"
"ReflectionUtils.java:852"$1$"	}"
"ReflectionUtils.java:853"$0$""
"ReflectionUtils.java:854"$0$"}"
"MutablePropertySources.java:1"$0$"/*"
"MutablePropertySources.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"MutablePropertySources.java:3"$0$" *"
"MutablePropertySources.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MutablePropertySources.java:5"$0$" * you may not use this file except in compliance with the License."
"MutablePropertySources.java:6"$0$" * You may obtain a copy of the License at"
"MutablePropertySources.java:7"$0$" *"
"MutablePropertySources.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MutablePropertySources.java:9"$0$" *"
"MutablePropertySources.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MutablePropertySources.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MutablePropertySources.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MutablePropertySources.java:13"$0$" * See the License for the specific language governing permissions and"
"MutablePropertySources.java:14"$0$" * limitations under the License."
"MutablePropertySources.java:15"$0$" */"
"MutablePropertySources.java:16"$0$""
"MutablePropertySources.java:17"$0$"package org.springframework.core.env;"
"MutablePropertySources.java:18"$0$""
"MutablePropertySources.java:19"$0$"import java.util.Iterator;"
"MutablePropertySources.java:20"$0$"import java.util.List;"
"MutablePropertySources.java:21"$0$"import java.util.Spliterator;"
"MutablePropertySources.java:22"$0$"import java.util.Spliterators;"
"MutablePropertySources.java:23"$0$"import java.util.concurrent.CopyOnWriteArrayList;"
"MutablePropertySources.java:24"$0$"import java.util.stream.Stream;"
"MutablePropertySources.java:25"$0$""
"MutablePropertySources.java:26"$0$"import org.springframework.lang.Nullable;"
"MutablePropertySources.java:27"$0$""
"MutablePropertySources.java:28"$0$"/**"
"MutablePropertySources.java:29"$1$" * The default implementation of the {@link PropertySources} interface."
"MutablePropertySources.java:30"$0$" * Allows manipulation of contained property sources and provides a constructor"
"MutablePropertySources.java:31"$1$" * for copying an existing {@code PropertySources} instance."
"MutablePropertySources.java:32"$0$" *"
"MutablePropertySources.java:33"$1$" * <p>Where <em>precedence</em> is mentioned in methods such as {@link #addFirst}"
"MutablePropertySources.java:34"$1$" * and {@link #addLast}, this is with regard to the order in which property sources"
"MutablePropertySources.java:35"$1$" * will be searched when resolving a given property with a {@link PropertyResolver}."
"MutablePropertySources.java:36"$0$" *"
"MutablePropertySources.java:37"$0$" * @author Chris Beams"
"MutablePropertySources.java:38"$0$" * @author Juergen Hoeller"
"MutablePropertySources.java:39"$0$" * @since 3.1"
"MutablePropertySources.java:40"$0$" * @see PropertySourcesPropertyResolver"
"MutablePropertySources.java:41"$0$" */"
"MutablePropertySources.java:42"$1$"public class MutablePropertySources implements PropertySources {"
"MutablePropertySources.java:43"$1$""
"MutablePropertySources.java:44"$1$"	private final List<PropertySource<?>> propertySourceList = new CopyOnWriteArrayList<>();"
"MutablePropertySources.java:45"$1$""
"MutablePropertySources.java:46"$1$""
"MutablePropertySources.java:47"$1$"	/**"
"MutablePropertySources.java:48"$1$"	 * Create a new {@link MutablePropertySources} object."
"MutablePropertySources.java:49"$1$"	 */"
"MutablePropertySources.java:50"$1$"	public MutablePropertySources() {"
"MutablePropertySources.java:51"$1$"	}"
"MutablePropertySources.java:52"$0$""
"MutablePropertySources.java:53"$0$"	/**"
"MutablePropertySources.java:54"$1$"	 * Create a new {@code MutablePropertySources} from the given propertySources"
"MutablePropertySources.java:55"$1$"	 * object, preserving the original order of contained {@code PropertySource} objects."
"MutablePropertySources.java:56"$0$"	 */"
"MutablePropertySources.java:57"$1$"	public MutablePropertySources(PropertySources propertySources) {"
"MutablePropertySources.java:58"$1$"		this();"
"MutablePropertySources.java:59"$1$"		for (PropertySource<?> propertySource : propertySources) {"
"MutablePropertySources.java:60"$1$"			addLast(propertySource);"
"MutablePropertySources.java:61"$1$"		}"
"MutablePropertySources.java:62"$0$"	}"
"MutablePropertySources.java:63"$0$""
"MutablePropertySources.java:64"$0$""
"MutablePropertySources.java:65"$0$"	@Override"
"MutablePropertySources.java:66"$1$"	public Iterator<PropertySource<?>> iterator() {"
"MutablePropertySources.java:67"$1$"		return this.propertySourceList.iterator();"
"MutablePropertySources.java:68"$1$"	}"
"MutablePropertySources.java:69"$0$""
"MutablePropertySources.java:70"$0$"	@Override"
"MutablePropertySources.java:71"$1$"	public Spliterator<PropertySource<?>> spliterator() {"
"MutablePropertySources.java:72"$1$"		return Spliterators.spliterator(this.propertySourceList, 0);"
"MutablePropertySources.java:73"$1$"	}"
"MutablePropertySources.java:74"$0$""
"MutablePropertySources.java:75"$0$"	@Override"
"MutablePropertySources.java:76"$1$"	public Stream<PropertySource<?>> stream() {"
"MutablePropertySources.java:77"$1$"		return this.propertySourceList.stream();"
"MutablePropertySources.java:78"$1$"	}"
"MutablePropertySources.java:79"$0$""
"MutablePropertySources.java:80"$0$"	@Override"
"MutablePropertySources.java:81"$1$"	public boolean contains(String name) {"
"MutablePropertySources.java:82"$1$"		return this.propertySourceList.contains(PropertySource.named(name));"
"MutablePropertySources.java:83"$1$"	}"
"MutablePropertySources.java:84"$0$""
"MutablePropertySources.java:85"$0$"	@Override"
"MutablePropertySources.java:86"$0$"	@Nullable"
"MutablePropertySources.java:87"$1$"	public PropertySource<?> get(String name) {"
"MutablePropertySources.java:88"$1$"		int index = this.propertySourceList.indexOf(PropertySource.named(name));"
"MutablePropertySources.java:89"$1$"		return (index != -1 ? this.propertySourceList.get(index) : null);"
"MutablePropertySources.java:90"$1$"	}"
"MutablePropertySources.java:91"$0$""
"MutablePropertySources.java:92"$0$""
"MutablePropertySources.java:93"$0$"	/**"
"MutablePropertySources.java:94"$0$"	 * Add the given property source object with highest precedence."
"MutablePropertySources.java:95"$0$"	 */"
"MutablePropertySources.java:96"$1$"	public void addFirst(PropertySource<?> propertySource) {"
"MutablePropertySources.java:97"$1$"		removeIfPresent(propertySource);"
"MutablePropertySources.java:98"$1$"		this.propertySourceList.add(0, propertySource);"
"MutablePropertySources.java:99"$1$"	}"
"MutablePropertySources.java:100"$0$""
"MutablePropertySources.java:101"$0$"	/**"
"MutablePropertySources.java:102"$0$"	 * Add the given property source object with lowest precedence."
"MutablePropertySources.java:103"$0$"	 */"
"MutablePropertySources.java:104"$1$"	public void addLast(PropertySource<?> propertySource) {"
"MutablePropertySources.java:105"$1$"		removeIfPresent(propertySource);"
"MutablePropertySources.java:106"$1$"		this.propertySourceList.add(propertySource);"
"MutablePropertySources.java:107"$1$"	}"
"MutablePropertySources.java:108"$0$""
"MutablePropertySources.java:109"$0$"	/**"
"MutablePropertySources.java:110"$0$"	 * Add the given property source object with precedence immediately higher"
"MutablePropertySources.java:111"$0$"	 * than the named relative property source."
"MutablePropertySources.java:112"$0$"	 */"
"MutablePropertySources.java:113"$1$"	public void addBefore(String relativePropertySourceName, PropertySource<?> propertySource) {"
"MutablePropertySources.java:114"$1$"		assertLegalRelativeAddition(relativePropertySourceName, propertySource);"
"MutablePropertySources.java:115"$1$"		removeIfPresent(propertySource);"
"MutablePropertySources.java:116"$1$"		int index = assertPresentAndGetIndex(relativePropertySourceName);"
"MutablePropertySources.java:117"$1$"		addAtIndex(index, propertySource);"
"MutablePropertySources.java:118"$1$"	}"
"MutablePropertySources.java:119"$0$""
"MutablePropertySources.java:120"$0$"	/**"
"MutablePropertySources.java:121"$0$"	 * Add the given property source object with precedence immediately lower"
"MutablePropertySources.java:122"$0$"	 * than the named relative property source."
"MutablePropertySources.java:123"$0$"	 */"
"MutablePropertySources.java:124"$1$"	public void addAfter(String relativePropertySourceName, PropertySource<?> propertySource) {"
"MutablePropertySources.java:125"$1$"		assertLegalRelativeAddition(relativePropertySourceName, propertySource);"
"MutablePropertySources.java:126"$1$"		removeIfPresent(propertySource);"
"MutablePropertySources.java:127"$1$"		int index = assertPresentAndGetIndex(relativePropertySourceName);"
"MutablePropertySources.java:128"$1$"		addAtIndex(index + 1, propertySource);"
"MutablePropertySources.java:129"$1$"	}"
"MutablePropertySources.java:130"$0$""
"MutablePropertySources.java:131"$0$"	/**"
"MutablePropertySources.java:132"$1$"	 * Return the precedence of the given property source, {@code -1} if not found."
"MutablePropertySources.java:133"$0$"	 */"
"MutablePropertySources.java:134"$1$"	public int precedenceOf(PropertySource<?> propertySource) {"
"MutablePropertySources.java:135"$1$"		return this.propertySourceList.indexOf(propertySource);"
"MutablePropertySources.java:136"$1$"	}"
"MutablePropertySources.java:137"$0$""
"MutablePropertySources.java:138"$0$"	/**"
"MutablePropertySources.java:139"$1$"	 * Remove and return the property source with the given name, {@code null} if not found."
"MutablePropertySources.java:140"$0$"	 * @param name the name of the property source to find and remove"
"MutablePropertySources.java:141"$0$"	 */"
"MutablePropertySources.java:142"$0$"	@Nullable"
"MutablePropertySources.java:143"$1$"	public PropertySource<?> remove(String name) {"
"MutablePropertySources.java:144"$1$"		int index = this.propertySourceList.indexOf(PropertySource.named(name));"
"MutablePropertySources.java:145"$1$"		return (index != -1 ? this.propertySourceList.remove(index) : null);"
"MutablePropertySources.java:146"$1$"	}"
"MutablePropertySources.java:147"$0$""
"MutablePropertySources.java:148"$0$"	/**"
"MutablePropertySources.java:149"$0$"	 * Replace the property source with the given name with the given property source object."
"MutablePropertySources.java:150"$0$"	 * @param name the name of the property source to find and replace"
"MutablePropertySources.java:151"$0$"	 * @param propertySource the replacement property source"
"MutablePropertySources.java:152"$0$"	 * @throws IllegalArgumentException if no property source with the given name is present"
"MutablePropertySources.java:153"$0$"	 * @see #contains"
"MutablePropertySources.java:154"$0$"	 */"
"MutablePropertySources.java:155"$1$"	public void replace(String name, PropertySource<?> propertySource) {"
"MutablePropertySources.java:156"$1$"		int index = assertPresentAndGetIndex(name);"
"MutablePropertySources.java:157"$1$"		this.propertySourceList.set(index, propertySource);"
"MutablePropertySources.java:158"$1$"	}"
"MutablePropertySources.java:159"$0$""
"MutablePropertySources.java:160"$0$"	/**"
"MutablePropertySources.java:161"$1$"	 * Return the number of {@link PropertySource} objects contained."
"MutablePropertySources.java:162"$0$"	 */"
"MutablePropertySources.java:163"$1$"	public int size() {"
"MutablePropertySources.java:164"$1$"		return this.propertySourceList.size();"
"MutablePropertySources.java:165"$1$"	}"
"MutablePropertySources.java:166"$0$""
"MutablePropertySources.java:167"$0$"	@Override"
"MutablePropertySources.java:168"$1$"	public String toString() {"
"MutablePropertySources.java:169"$1$"		return this.propertySourceList.toString();"
"MutablePropertySources.java:170"$1$"	}"
"MutablePropertySources.java:171"$0$""
"MutablePropertySources.java:172"$0$"	/**"
"MutablePropertySources.java:173"$0$"	 * Ensure that the given property source is not being added relative to itself."
"MutablePropertySources.java:174"$0$"	 */"
"MutablePropertySources.java:175"$1$"	protected void assertLegalRelativeAddition(String relativePropertySourceName, PropertySource<?> propertySource) {"
"MutablePropertySources.java:176"$1$"		String newPropertySourceName = propertySource.getName();"
"MutablePropertySources.java:177"$1$"		if (relativePropertySourceName.equals(newPropertySourceName)) {"
"MutablePropertySources.java:178"$1$"			throw new IllegalArgumentException("
"MutablePropertySources.java:179"$1$"					""PropertySource named '"" + newPropertySourceName + ""' cannot be added relative to itself"");"
"MutablePropertySources.java:180"$1$"		}"
"MutablePropertySources.java:181"$0$"	}"
"MutablePropertySources.java:182"$0$""
"MutablePropertySources.java:183"$0$"	/**"
"MutablePropertySources.java:184"$0$"	 * Remove the given property source if it is present."
"MutablePropertySources.java:185"$0$"	 */"
"MutablePropertySources.java:186"$1$"	protected void removeIfPresent(PropertySource<?> propertySource) {"
"MutablePropertySources.java:187"$1$"		this.propertySourceList.remove(propertySource);"
"MutablePropertySources.java:188"$1$"	}"
"MutablePropertySources.java:189"$0$""
"MutablePropertySources.java:190"$0$"	/**"
"MutablePropertySources.java:191"$0$"	 * Add the given property source at a particular index in the list."
"MutablePropertySources.java:192"$0$"	 */"
"MutablePropertySources.java:193"$1$"	private void addAtIndex(int index, PropertySource<?> propertySource) {"
"MutablePropertySources.java:194"$1$"		removeIfPresent(propertySource);"
"MutablePropertySources.java:195"$1$"		this.propertySourceList.add(index, propertySource);"
"MutablePropertySources.java:196"$1$"	}"
"MutablePropertySources.java:197"$0$""
"MutablePropertySources.java:198"$0$"	/**"
"MutablePropertySources.java:199"$0$"	 * Assert that the named property source is present and return its index."
"MutablePropertySources.java:200"$1$"	 * @param name {@linkplain PropertySource#getName() name of the property source} to find"
"MutablePropertySources.java:201"$0$"	 * @throws IllegalArgumentException if the named property source is not present"
"MutablePropertySources.java:202"$0$"	 */"
"MutablePropertySources.java:203"$1$"	private int assertPresentAndGetIndex(String name) {"
"MutablePropertySources.java:204"$1$"		int index = this.propertySourceList.indexOf(PropertySource.named(name));"
"MutablePropertySources.java:205"$1$"		if (index == -1) {"
"MutablePropertySources.java:206"$1$"			throw new IllegalArgumentException(""PropertySource named '"" + name + ""' does not exist"");"
"MutablePropertySources.java:207"$1$"		}"
"MutablePropertySources.java:208"$0$"		return index;"
"MutablePropertySources.java:209"$0$"	}"
"MutablePropertySources.java:210"$0$""
"MutablePropertySources.java:211"$0$"}"
"ExceptionDepthComparator.java:1"$0$"/*"
"ExceptionDepthComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ExceptionDepthComparator.java:3"$0$" *"
"ExceptionDepthComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ExceptionDepthComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"ExceptionDepthComparator.java:6"$0$" * You may obtain a copy of the License at"
"ExceptionDepthComparator.java:7"$0$" *"
"ExceptionDepthComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ExceptionDepthComparator.java:9"$0$" *"
"ExceptionDepthComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ExceptionDepthComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ExceptionDepthComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ExceptionDepthComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"ExceptionDepthComparator.java:14"$0$" * limitations under the License."
"ExceptionDepthComparator.java:15"$0$" */"
"ExceptionDepthComparator.java:16"$0$""
"ExceptionDepthComparator.java:17"$0$"package org.springframework.core;"
"ExceptionDepthComparator.java:18"$0$""
"ExceptionDepthComparator.java:19"$0$"import java.util.ArrayList;"
"ExceptionDepthComparator.java:20"$0$"import java.util.Collection;"
"ExceptionDepthComparator.java:21"$0$"import java.util.Comparator;"
"ExceptionDepthComparator.java:22"$0$"import java.util.List;"
"ExceptionDepthComparator.java:23"$0$""
"ExceptionDepthComparator.java:24"$0$"import org.springframework.util.Assert;"
"ExceptionDepthComparator.java:25"$0$""
"ExceptionDepthComparator.java:26"$0$"/**"
"ExceptionDepthComparator.java:27"$0$" * Comparator capable of sorting exceptions based on their depth from the thrown exception type."
"ExceptionDepthComparator.java:28"$0$" *"
"ExceptionDepthComparator.java:29"$0$" * @author Juergen Hoeller"
"ExceptionDepthComparator.java:30"$0$" * @author Arjen Poutsma"
"ExceptionDepthComparator.java:31"$0$" * @since 3.0.3"
"ExceptionDepthComparator.java:32"$0$" */"
"ExceptionDepthComparator.java:33"$1$"public class ExceptionDepthComparator implements Comparator<Class<? extends Throwable>> {"
"ExceptionDepthComparator.java:34"$1$""
"ExceptionDepthComparator.java:35"$1$"	private final Class<? extends Throwable> targetException;"
"ExceptionDepthComparator.java:36"$1$""
"ExceptionDepthComparator.java:37"$1$""
"ExceptionDepthComparator.java:38"$1$"	/**"
"ExceptionDepthComparator.java:39"$1$"	 * Create a new ExceptionDepthComparator for the given exception."
"ExceptionDepthComparator.java:40"$1$"	 * @param exception the target exception to compare to when sorting by depth"
"ExceptionDepthComparator.java:41"$1$"	 */"
"ExceptionDepthComparator.java:42"$1$"	public ExceptionDepthComparator(Throwable exception) {"
"ExceptionDepthComparator.java:43"$1$"		Assert.notNull(exception, ""Target exception must not be null"");"
"ExceptionDepthComparator.java:44"$1$"		this.targetException = exception.getClass();"
"ExceptionDepthComparator.java:45"$1$"	}"
"ExceptionDepthComparator.java:46"$0$""
"ExceptionDepthComparator.java:47"$0$"	/**"
"ExceptionDepthComparator.java:48"$0$"	 * Create a new ExceptionDepthComparator for the given exception type."
"ExceptionDepthComparator.java:49"$0$"	 * @param exceptionType the target exception type to compare to when sorting by depth"
"ExceptionDepthComparator.java:50"$0$"	 */"
"ExceptionDepthComparator.java:51"$1$"	public ExceptionDepthComparator(Class<? extends Throwable> exceptionType) {"
"ExceptionDepthComparator.java:52"$1$"		Assert.notNull(exceptionType, ""Target exception type must not be null"");"
"ExceptionDepthComparator.java:53"$1$"		this.targetException = exceptionType;"
"ExceptionDepthComparator.java:54"$1$"	}"
"ExceptionDepthComparator.java:55"$0$""
"ExceptionDepthComparator.java:56"$0$""
"ExceptionDepthComparator.java:57"$0$"	@Override"
"ExceptionDepthComparator.java:58"$1$"	public int compare(Class<? extends Throwable> o1, Class<? extends Throwable> o2) {"
"ExceptionDepthComparator.java:59"$1$"		int depth1 = getDepth(o1, this.targetException, 0);"
"ExceptionDepthComparator.java:60"$1$"		int depth2 = getDepth(o2, this.targetException, 0);"
"ExceptionDepthComparator.java:61"$1$"		return (depth1 - depth2);"
"ExceptionDepthComparator.java:62"$1$"	}"
"ExceptionDepthComparator.java:63"$0$""
"ExceptionDepthComparator.java:64"$1$"	private int getDepth(Class<?> declaredException, Class<?> exceptionToMatch, int depth) {"
"ExceptionDepthComparator.java:65"$1$"		if (exceptionToMatch.equals(declaredException)) {"
"ExceptionDepthComparator.java:66"$0$"			// Found it!"
"ExceptionDepthComparator.java:67"$1$"			return depth;"
"ExceptionDepthComparator.java:68"$1$"		}"
"ExceptionDepthComparator.java:69"$0$"		// If we've gone as far as we can go and haven't found it..."
"ExceptionDepthComparator.java:70"$1$"		if (exceptionToMatch == Throwable.class) {"
"ExceptionDepthComparator.java:71"$1$"			return Integer.MAX_VALUE;"
"ExceptionDepthComparator.java:72"$1$"		}"
"ExceptionDepthComparator.java:73"$0$"		return getDepth(declaredException, exceptionToMatch.getSuperclass(), depth + 1);"
"ExceptionDepthComparator.java:74"$0$"	}"
"ExceptionDepthComparator.java:75"$0$""
"ExceptionDepthComparator.java:76"$0$""
"ExceptionDepthComparator.java:77"$0$"	/**"
"ExceptionDepthComparator.java:78"$0$"	 * Obtain the closest match from the given exception types for the given target exception."
"ExceptionDepthComparator.java:79"$0$"	 * @param exceptionTypes the collection of exception types"
"ExceptionDepthComparator.java:80"$0$"	 * @param targetException the target exception to find a match for"
"ExceptionDepthComparator.java:81"$0$"	 * @return the closest matching exception type from the given collection"
"ExceptionDepthComparator.java:82"$0$"	 */"
"ExceptionDepthComparator.java:83"$0$"	public static Class<? extends Throwable> findClosestMatch("
"ExceptionDepthComparator.java:84"$1$"			Collection<Class<? extends Throwable>> exceptionTypes, Throwable targetException) {"
"ExceptionDepthComparator.java:85"$1$""
"ExceptionDepthComparator.java:86"$1$"		Assert.notEmpty(exceptionTypes, ""Exception types must not be empty"");"
"ExceptionDepthComparator.java:87"$1$"		if (exceptionTypes.size() == 1) {"
"ExceptionDepthComparator.java:88"$1$"			return exceptionTypes.iterator().next();"
"ExceptionDepthComparator.java:89"$1$"		}"
"ExceptionDepthComparator.java:90"$0$"		List<Class<? extends Throwable>> handledExceptions = new ArrayList<>(exceptionTypes);"
"ExceptionDepthComparator.java:91"$0$"		handledExceptions.sort(new ExceptionDepthComparator(targetException));"
"ExceptionDepthComparator.java:92"$0$"		return handledExceptions.get(0);"
"ExceptionDepthComparator.java:93"$0$"	}"
"ExceptionDepthComparator.java:94"$0$""
"ExceptionDepthComparator.java:95"$0$"}"
"XmlValidationModeDetector.java:1"$0$"/*"
"XmlValidationModeDetector.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"XmlValidationModeDetector.java:3"$0$" *"
"XmlValidationModeDetector.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"XmlValidationModeDetector.java:5"$0$" * you may not use this file except in compliance with the License."
"XmlValidationModeDetector.java:6"$0$" * You may obtain a copy of the License at"
"XmlValidationModeDetector.java:7"$0$" *"
"XmlValidationModeDetector.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"XmlValidationModeDetector.java:9"$0$" *"
"XmlValidationModeDetector.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"XmlValidationModeDetector.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"XmlValidationModeDetector.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"XmlValidationModeDetector.java:13"$0$" * See the License for the specific language governing permissions and"
"XmlValidationModeDetector.java:14"$0$" * limitations under the License."
"XmlValidationModeDetector.java:15"$0$" */"
"XmlValidationModeDetector.java:16"$0$""
"XmlValidationModeDetector.java:17"$0$"package org.springframework.util.xml;"
"XmlValidationModeDetector.java:18"$0$""
"XmlValidationModeDetector.java:19"$0$"import java.io.BufferedReader;"
"XmlValidationModeDetector.java:20"$0$"import java.io.CharConversionException;"
"XmlValidationModeDetector.java:21"$0$"import java.io.IOException;"
"XmlValidationModeDetector.java:22"$0$"import java.io.InputStream;"
"XmlValidationModeDetector.java:23"$0$"import java.io.InputStreamReader;"
"XmlValidationModeDetector.java:24"$0$""
"XmlValidationModeDetector.java:25"$0$"import org.springframework.lang.Nullable;"
"XmlValidationModeDetector.java:26"$0$"import org.springframework.util.StringUtils;"
"XmlValidationModeDetector.java:27"$0$""
"XmlValidationModeDetector.java:28"$0$"/**"
"XmlValidationModeDetector.java:29"$0$" * Detects whether an XML stream is using DTD- or XSD-based validation."
"XmlValidationModeDetector.java:30"$0$" *"
"XmlValidationModeDetector.java:31"$0$" * @author Rob Harrop"
"XmlValidationModeDetector.java:32"$0$" * @author Juergen Hoeller"
"XmlValidationModeDetector.java:33"$0$" * @author Sam Brannen"
"XmlValidationModeDetector.java:34"$0$" * @since 2.0"
"XmlValidationModeDetector.java:35"$0$" */"
"XmlValidationModeDetector.java:36"$1$"public class XmlValidationModeDetector {"
"XmlValidationModeDetector.java:37"$1$""
"XmlValidationModeDetector.java:38"$1$"	/**"
"XmlValidationModeDetector.java:39"$1$"	 * Indicates that the validation should be disabled."
"XmlValidationModeDetector.java:40"$1$"	 */"
"XmlValidationModeDetector.java:41"$1$"	public static final int VALIDATION_NONE = 0;"
"XmlValidationModeDetector.java:42"$1$""
"XmlValidationModeDetector.java:43"$1$"	/**"
"XmlValidationModeDetector.java:44"$1$"	 * Indicates that the validation mode should be auto-guessed, since we cannot find"
"XmlValidationModeDetector.java:45"$1$"	 * a clear indication (probably choked on some special characters, or the like)."
"XmlValidationModeDetector.java:46"$1$"	 */"
"XmlValidationModeDetector.java:47"$1$"	public static final int VALIDATION_AUTO = 1;"
"XmlValidationModeDetector.java:48"$1$""
"XmlValidationModeDetector.java:49"$1$"	/**"
"XmlValidationModeDetector.java:50"$1$"	 * Indicates that DTD validation should be used (we found a ""DOCTYPE"" declaration)."
"XmlValidationModeDetector.java:51"$1$"	 */"
"XmlValidationModeDetector.java:52"$1$"	public static final int VALIDATION_DTD = 2;"
"XmlValidationModeDetector.java:53"$1$""
"XmlValidationModeDetector.java:54"$1$"	/**"
"XmlValidationModeDetector.java:55"$1$"	 * Indicates that XSD validation should be used (found no ""DOCTYPE"" declaration)."
"XmlValidationModeDetector.java:56"$1$"	 */"
"XmlValidationModeDetector.java:57"$1$"	public static final int VALIDATION_XSD = 3;"
"XmlValidationModeDetector.java:58"$1$""
"XmlValidationModeDetector.java:59"$1$""
"XmlValidationModeDetector.java:60"$1$"	/**"
"XmlValidationModeDetector.java:61"$1$"	 * The token in a XML document that declares the DTD to use for validation"
"XmlValidationModeDetector.java:62"$1$"	 * and thus that DTD validation is being used."
"XmlValidationModeDetector.java:63"$1$"	 */"
"XmlValidationModeDetector.java:64"$1$"	private static final String DOCTYPE = ""DOCTYPE"";"
"XmlValidationModeDetector.java:65"$1$""
"XmlValidationModeDetector.java:66"$1$"	/**"
"XmlValidationModeDetector.java:67"$1$"	 * The token that indicates the start of an XML comment."
"XmlValidationModeDetector.java:68"$1$"	 */"
"XmlValidationModeDetector.java:69"$1$"	private static final String START_COMMENT = ""<!--"";"
"XmlValidationModeDetector.java:70"$1$""
"XmlValidationModeDetector.java:71"$1$"	/**"
"XmlValidationModeDetector.java:72"$1$"	 * The token that indicates the end of an XML comment."
"XmlValidationModeDetector.java:73"$1$"	 */"
"XmlValidationModeDetector.java:74"$1$"	private static final String END_COMMENT = ""-->"";"
"XmlValidationModeDetector.java:75"$1$""
"XmlValidationModeDetector.java:76"$1$""
"XmlValidationModeDetector.java:77"$1$"	/**"
"XmlValidationModeDetector.java:78"$1$"	 * Indicates whether or not the current parse position is inside an XML comment."
"XmlValidationModeDetector.java:79"$1$"	 */"
"XmlValidationModeDetector.java:80"$1$"	private boolean inComment;"
"XmlValidationModeDetector.java:81"$1$""
"XmlValidationModeDetector.java:82"$1$""
"XmlValidationModeDetector.java:83"$1$"	/**"
"XmlValidationModeDetector.java:84"$1$"	 * Detect the validation mode for the XML document in the supplied {@link InputStream}."
"XmlValidationModeDetector.java:85"$1$"	 * Note that the supplied {@link InputStream} is closed by this method before returning."
"XmlValidationModeDetector.java:86"$1$"	 * @param inputStream the InputStream to parse"
"XmlValidationModeDetector.java:87"$1$"	 * @throws IOException in case of I/O failure"
"XmlValidationModeDetector.java:88"$1$"	 * @see #VALIDATION_DTD"
"XmlValidationModeDetector.java:89"$1$"	 * @see #VALIDATION_XSD"
"XmlValidationModeDetector.java:90"$1$"	 */"
"XmlValidationModeDetector.java:91"$1$"	public int detectValidationMode(InputStream inputStream) throws IOException {"
"XmlValidationModeDetector.java:92"$0$"		// Peek into the file to look for DOCTYPE."
"XmlValidationModeDetector.java:93"$1$"		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));"
"XmlValidationModeDetector.java:94"$1$"		try {"
"XmlValidationModeDetector.java:95"$1$"			boolean isDtdValidated = false;"
"XmlValidationModeDetector.java:96"$1$"			String content;"
"XmlValidationModeDetector.java:97"$1$"			while ((content = reader.readLine()) != null) {"
"XmlValidationModeDetector.java:98"$1$"				content = consumeCommentTokens(content);"
"XmlValidationModeDetector.java:99"$1$"				if (this.inComment || !StringUtils.hasText(content)) {"
"XmlValidationModeDetector.java:100"$1$"					continue;"
"XmlValidationModeDetector.java:101"$1$"				}"
"XmlValidationModeDetector.java:102"$1$"				if (hasDoctype(content)) {"
"XmlValidationModeDetector.java:103"$1$"					isDtdValidated = true;"
"XmlValidationModeDetector.java:104"$1$"					break;"
"XmlValidationModeDetector.java:105"$1$"				}"
"XmlValidationModeDetector.java:106"$1$"				if (hasOpeningTag(content)) {"
"XmlValidationModeDetector.java:107"$0$"					// End of meaningful data..."
"XmlValidationModeDetector.java:108"$1$"					break;"
"XmlValidationModeDetector.java:109"$1$"				}"
"XmlValidationModeDetector.java:110"$0$"			}"
"XmlValidationModeDetector.java:111"$0$"			return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);"
"XmlValidationModeDetector.java:112"$0$"		}"
"XmlValidationModeDetector.java:113"$1$"		catch (CharConversionException ex) {"
"XmlValidationModeDetector.java:114"$0$"			// Choked on some character encoding..."
"XmlValidationModeDetector.java:115"$0$"			// Leave the decision up to the caller."
"XmlValidationModeDetector.java:116"$1$"			return VALIDATION_AUTO;"
"XmlValidationModeDetector.java:117"$1$"		}"
"XmlValidationModeDetector.java:118"$1$"		finally {"
"XmlValidationModeDetector.java:119"$1$"			reader.close();"
"XmlValidationModeDetector.java:120"$1$"		}"
"XmlValidationModeDetector.java:121"$0$"	}"
"XmlValidationModeDetector.java:122"$0$""
"XmlValidationModeDetector.java:123"$0$""
"XmlValidationModeDetector.java:124"$0$"	/**"
"XmlValidationModeDetector.java:125"$0$"	 * Does the content contain the DTD DOCTYPE declaration?"
"XmlValidationModeDetector.java:126"$0$"	 */"
"XmlValidationModeDetector.java:127"$1$"	private boolean hasDoctype(String content) {"
"XmlValidationModeDetector.java:128"$1$"		return content.contains(DOCTYPE);"
"XmlValidationModeDetector.java:129"$1$"	}"
"XmlValidationModeDetector.java:130"$0$""
"XmlValidationModeDetector.java:131"$0$"	/**"
"XmlValidationModeDetector.java:132"$0$"	 * Does the supplied content contain an XML opening tag. If the parse state is currently"
"XmlValidationModeDetector.java:133"$0$"	 * in an XML comment then this method always returns false. It is expected that all comment"
"XmlValidationModeDetector.java:134"$0$"	 * tokens will have consumed for the supplied content before passing the remainder to this method."
"XmlValidationModeDetector.java:135"$0$"	 */"
"XmlValidationModeDetector.java:136"$1$"	private boolean hasOpeningTag(String content) {"
"XmlValidationModeDetector.java:137"$1$"		if (this.inComment) {"
"XmlValidationModeDetector.java:138"$1$"			return false;"
"XmlValidationModeDetector.java:139"$1$"		}"
"XmlValidationModeDetector.java:140"$0$"		int openTagIndex = content.indexOf('<');"
"XmlValidationModeDetector.java:141"$0$"		return (openTagIndex > -1 && (content.length() > openTagIndex + 1) &&"
"XmlValidationModeDetector.java:142"$0$"				Character.isLetter(content.charAt(openTagIndex + 1)));"
"XmlValidationModeDetector.java:143"$0$"	}"
"XmlValidationModeDetector.java:144"$0$""
"XmlValidationModeDetector.java:145"$0$"	/**"
"XmlValidationModeDetector.java:146"$0$"	 * Consume all leading and trailing comments in the given String and return"
"XmlValidationModeDetector.java:147"$0$"	 * the remaining content, which may be empty since the supplied content might"
"XmlValidationModeDetector.java:148"$0$"	 * be all comment data."
"XmlValidationModeDetector.java:149"$0$"	 */"
"XmlValidationModeDetector.java:150"$0$"	@Nullable"
"XmlValidationModeDetector.java:151"$1$"	private String consumeCommentTokens(String line) {"
"XmlValidationModeDetector.java:152"$1$"		int indexOfStartComment = line.indexOf(START_COMMENT);"
"XmlValidationModeDetector.java:153"$1$"		if (indexOfStartComment == -1 && !line.contains(END_COMMENT)) {"
"XmlValidationModeDetector.java:154"$1$"			return line;"
"XmlValidationModeDetector.java:155"$1$"		}"
"XmlValidationModeDetector.java:156"$0$""
"XmlValidationModeDetector.java:157"$0$"		String result = """";"
"XmlValidationModeDetector.java:158"$0$"		String currLine = line;"
"XmlValidationModeDetector.java:159"$1$"		if (indexOfStartComment >= 0) {"
"XmlValidationModeDetector.java:160"$1$"			result = line.substring(0, indexOfStartComment);"
"XmlValidationModeDetector.java:161"$1$"			currLine = line.substring(indexOfStartComment);"
"XmlValidationModeDetector.java:162"$1$"		}"
"XmlValidationModeDetector.java:163"$0$""
"XmlValidationModeDetector.java:164"$1$"		while ((currLine = consume(currLine)) != null) {"
"XmlValidationModeDetector.java:165"$1$"			if (!this.inComment && !currLine.trim().startsWith(START_COMMENT)) {"
"XmlValidationModeDetector.java:166"$1$"				return result + currLine;"
"XmlValidationModeDetector.java:167"$1$"			}"
"XmlValidationModeDetector.java:168"$0$"		}"
"XmlValidationModeDetector.java:169"$0$"		return null;"
"XmlValidationModeDetector.java:170"$0$"	}"
"XmlValidationModeDetector.java:171"$0$""
"XmlValidationModeDetector.java:172"$0$"	/**"
"XmlValidationModeDetector.java:173"$0$"	 * Consume the next comment token, update the ""inComment"" flag"
"XmlValidationModeDetector.java:174"$0$"	 * and return the remaining content."
"XmlValidationModeDetector.java:175"$0$"	 */"
"XmlValidationModeDetector.java:176"$0$"	@Nullable"
"XmlValidationModeDetector.java:177"$1$"	private String consume(String line) {"
"XmlValidationModeDetector.java:178"$1$"		int index = (this.inComment ? endComment(line) : startComment(line));"
"XmlValidationModeDetector.java:179"$1$"		return (index == -1 ? null : line.substring(index));"
"XmlValidationModeDetector.java:180"$1$"	}"
"XmlValidationModeDetector.java:181"$0$""
"XmlValidationModeDetector.java:182"$0$"	/**"
"XmlValidationModeDetector.java:183"$1$"	 * Try to consume the {@link #START_COMMENT} token."
"XmlValidationModeDetector.java:184"$0$"	 * @see #commentToken(String, String, boolean)"
"XmlValidationModeDetector.java:185"$0$"	 */"
"XmlValidationModeDetector.java:186"$1$"	private int startComment(String line) {"
"XmlValidationModeDetector.java:187"$1$"		return commentToken(line, START_COMMENT, true);"
"XmlValidationModeDetector.java:188"$1$"	}"
"XmlValidationModeDetector.java:189"$0$""
"XmlValidationModeDetector.java:190"$1$"	private int endComment(String line) {"
"XmlValidationModeDetector.java:191"$1$"		return commentToken(line, END_COMMENT, false);"
"XmlValidationModeDetector.java:192"$1$"	}"
"XmlValidationModeDetector.java:193"$0$""
"XmlValidationModeDetector.java:194"$0$"	/**"
"XmlValidationModeDetector.java:195"$0$"	 * Try to consume the supplied token against the supplied content and update the"
"XmlValidationModeDetector.java:196"$0$"	 * in comment parse state to the supplied value. Returns the index into the content"
"XmlValidationModeDetector.java:197"$0$"	 * which is after the token or -1 if the token is not found."
"XmlValidationModeDetector.java:198"$0$"	 */"
"XmlValidationModeDetector.java:199"$1$"	private int commentToken(String line, String token, boolean inCommentIfPresent) {"
"XmlValidationModeDetector.java:200"$1$"		int index = line.indexOf(token);"
"XmlValidationModeDetector.java:201"$1$"		if (index > - 1) {"
"XmlValidationModeDetector.java:202"$1$"			this.inComment = inCommentIfPresent;"
"XmlValidationModeDetector.java:203"$1$"		}"
"XmlValidationModeDetector.java:204"$0$"		return (index == -1 ? index : index + token.length());"
"XmlValidationModeDetector.java:205"$0$"	}"
"XmlValidationModeDetector.java:206"$0$""
"XmlValidationModeDetector.java:207"$0$"}"
"LimitedDataBufferList.java:1"$0$"/*"
"LimitedDataBufferList.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"LimitedDataBufferList.java:3"$0$" *"
"LimitedDataBufferList.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"LimitedDataBufferList.java:5"$0$" * you may not use this file except in compliance with the License."
"LimitedDataBufferList.java:6"$0$" * You may obtain a copy of the License at"
"LimitedDataBufferList.java:7"$0$" *"
"LimitedDataBufferList.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"LimitedDataBufferList.java:9"$0$" *"
"LimitedDataBufferList.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"LimitedDataBufferList.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"LimitedDataBufferList.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"LimitedDataBufferList.java:13"$0$" * See the License for the specific language governing permissions and"
"LimitedDataBufferList.java:14"$0$" * limitations under the License."
"LimitedDataBufferList.java:15"$0$" */"
"LimitedDataBufferList.java:16"$0$"package org.springframework.core.io.buffer;"
"LimitedDataBufferList.java:17"$0$""
"LimitedDataBufferList.java:18"$0$"import java.util.ArrayList;"
"LimitedDataBufferList.java:19"$0$"import java.util.Collection;"
"LimitedDataBufferList.java:20"$0$"import java.util.List;"
"LimitedDataBufferList.java:21"$0$"import java.util.function.Predicate;"
"LimitedDataBufferList.java:22"$0$""
"LimitedDataBufferList.java:23"$0$"import reactor.core.publisher.Flux;"
"LimitedDataBufferList.java:24"$0$""
"LimitedDataBufferList.java:25"$0$"/**"
"LimitedDataBufferList.java:26"$1$" * Custom {@link List} to collect data buffers with and enforce a"
"LimitedDataBufferList.java:27"$0$" * limit on the total number of bytes buffered. For use with ""collect"" or"
"LimitedDataBufferList.java:28"$1$" * other buffering operators in declarative APIs, e.g. {@link Flux}."
"LimitedDataBufferList.java:29"$0$" *"
"LimitedDataBufferList.java:30"$0$" * <p>Adding elements increases the byte count and if the limit is exceeded,"
"LimitedDataBufferList.java:31"$1$" * {@link DataBufferLimitException} is raised.  {@link #clear()} resets the"
"LimitedDataBufferList.java:32"$0$" * count. Remove and set are not supported."
"LimitedDataBufferList.java:33"$0$" *"
"LimitedDataBufferList.java:34"$0$" * <p><strong>Note:</strong> This class does not automatically release the"
"LimitedDataBufferList.java:35"$0$" * buffers it contains. It is usually preferable to use hooks such as"
"LimitedDataBufferList.java:36"$1$" * {@link Flux#doOnDiscard} that also take care of cancel and error signals,"
"LimitedDataBufferList.java:37"$1$" * or otherwise {@link #releaseAndClear()} can be used."
"LimitedDataBufferList.java:38"$0$" *"
"LimitedDataBufferList.java:39"$0$" * @author Rossen Stoyanchev"
"LimitedDataBufferList.java:40"$0$" * @since 5.1.11"
"LimitedDataBufferList.java:41"$0$" */"
"LimitedDataBufferList.java:42"$0$"SuppressWarnings(""serial"")"
"LimitedDataBufferList.java:43"$1$"public class LimitedDataBufferList extends ArrayList<DataBuffer> {"
"LimitedDataBufferList.java:44"$1$""
"LimitedDataBufferList.java:45"$1$"	private final int maxByteCount;"
"LimitedDataBufferList.java:46"$1$""
"LimitedDataBufferList.java:47"$1$"	private int byteCount;"
"LimitedDataBufferList.java:48"$1$""
"LimitedDataBufferList.java:49"$1$""
"LimitedDataBufferList.java:50"$1$"	public LimitedDataBufferList(int maxByteCount) {"
"LimitedDataBufferList.java:51"$1$"		this.maxByteCount = maxByteCount;"
"LimitedDataBufferList.java:52"$1$"	}"
"LimitedDataBufferList.java:53"$0$""
"LimitedDataBufferList.java:54"$0$""
"LimitedDataBufferList.java:55"$0$"	@Override"
"LimitedDataBufferList.java:56"$1$"	public boolean add(DataBuffer buffer) {"
"LimitedDataBufferList.java:57"$1$"		boolean result = super.add(buffer);"
"LimitedDataBufferList.java:58"$1$"		if (result) {"
"LimitedDataBufferList.java:59"$1$"			updateCount(buffer.readableByteCount());"
"LimitedDataBufferList.java:60"$1$"		}"
"LimitedDataBufferList.java:61"$0$"		return result;"
"LimitedDataBufferList.java:62"$0$"	}"
"LimitedDataBufferList.java:63"$0$""
"LimitedDataBufferList.java:64"$0$"	@Override"
"LimitedDataBufferList.java:65"$1$"	public void add(int index, DataBuffer buffer) {"
"LimitedDataBufferList.java:66"$1$"		super.add(index, buffer);"
"LimitedDataBufferList.java:67"$1$"		updateCount(buffer.readableByteCount());"
"LimitedDataBufferList.java:68"$1$"	}"
"LimitedDataBufferList.java:69"$0$""
"LimitedDataBufferList.java:70"$0$"	@Override"
"LimitedDataBufferList.java:71"$1$"	public boolean addAll(Collection<? extends DataBuffer> collection) {"
"LimitedDataBufferList.java:72"$1$"		boolean result = super.addAll(collection);"
"LimitedDataBufferList.java:73"$1$"		collection.forEach(buffer -> updateCount(buffer.readableByteCount()));"
"LimitedDataBufferList.java:74"$1$"		return result;"
"LimitedDataBufferList.java:75"$1$"	}"
"LimitedDataBufferList.java:76"$0$""
"LimitedDataBufferList.java:77"$0$"	@Override"
"LimitedDataBufferList.java:78"$1$"	public boolean addAll(int index, Collection<? extends DataBuffer> collection) {"
"LimitedDataBufferList.java:79"$1$"		boolean result = super.addAll(index, collection);"
"LimitedDataBufferList.java:80"$1$"		collection.forEach(buffer -> updateCount(buffer.readableByteCount()));"
"LimitedDataBufferList.java:81"$1$"		return result;"
"LimitedDataBufferList.java:82"$1$"	}"
"LimitedDataBufferList.java:83"$0$""
"LimitedDataBufferList.java:84"$1$"	private void updateCount(int bytesToAdd) {"
"LimitedDataBufferList.java:85"$1$"		if (this.maxByteCount < 0) {"
"LimitedDataBufferList.java:86"$1$"			return;"
"LimitedDataBufferList.java:87"$1$"		}"
"LimitedDataBufferList.java:88"$1$"		if (bytesToAdd > Integer.MAX_VALUE - this.byteCount) {"
"LimitedDataBufferList.java:89"$1$"			raiseLimitException();"
"LimitedDataBufferList.java:90"$1$"		}"
"LimitedDataBufferList.java:91"$1$"		else {"
"LimitedDataBufferList.java:92"$1$"			this.byteCount += bytesToAdd;"
"LimitedDataBufferList.java:93"$1$"			if (this.byteCount > this.maxByteCount) {"
"LimitedDataBufferList.java:94"$1$"				raiseLimitException();"
"LimitedDataBufferList.java:95"$1$"			}"
"LimitedDataBufferList.java:96"$0$"		}"
"LimitedDataBufferList.java:97"$0$"	}"
"LimitedDataBufferList.java:98"$0$""
"LimitedDataBufferList.java:99"$1$"	private void raiseLimitException() {"
"LimitedDataBufferList.java:100"$0$"		// Do not release here, it's likely down via doOnDiscard.."
"LimitedDataBufferList.java:101"$1$"		throw new DataBufferLimitException("
"LimitedDataBufferList.java:102"$1$"				""Exceeded limit on max bytes to buffer : "" + this.maxByteCount);"
"LimitedDataBufferList.java:103"$1$"	}"
"LimitedDataBufferList.java:104"$0$""
"LimitedDataBufferList.java:105"$0$"	@Override"
"LimitedDataBufferList.java:106"$1$"	public DataBuffer remove(int index) {"
"LimitedDataBufferList.java:107"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:108"$1$"	}"
"LimitedDataBufferList.java:109"$0$""
"LimitedDataBufferList.java:110"$0$"	@Override"
"LimitedDataBufferList.java:111"$1$"	public boolean remove(Object o) {"
"LimitedDataBufferList.java:112"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:113"$1$"	}"
"LimitedDataBufferList.java:114"$0$""
"LimitedDataBufferList.java:115"$0$"	@Override"
"LimitedDataBufferList.java:116"$1$"	protected void removeRange(int fromIndex, int toIndex) {"
"LimitedDataBufferList.java:117"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:118"$1$"	}"
"LimitedDataBufferList.java:119"$0$""
"LimitedDataBufferList.java:120"$0$"	@Override"
"LimitedDataBufferList.java:121"$1$"	public boolean removeAll(Collection<?> c) {"
"LimitedDataBufferList.java:122"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:123"$1$"	}"
"LimitedDataBufferList.java:124"$0$""
"LimitedDataBufferList.java:125"$0$"	@Override"
"LimitedDataBufferList.java:126"$1$"	public boolean removeIf(Predicate<? super DataBuffer> filter) {"
"LimitedDataBufferList.java:127"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:128"$1$"	}"
"LimitedDataBufferList.java:129"$0$""
"LimitedDataBufferList.java:130"$0$"	@Override"
"LimitedDataBufferList.java:131"$1$"	public DataBuffer set(int index, DataBuffer element) {"
"LimitedDataBufferList.java:132"$1$"		throw new UnsupportedOperationException();"
"LimitedDataBufferList.java:133"$1$"	}"
"LimitedDataBufferList.java:134"$0$""
"LimitedDataBufferList.java:135"$0$"	@Override"
"LimitedDataBufferList.java:136"$1$"	public void clear() {"
"LimitedDataBufferList.java:137"$1$"		this.byteCount = 0;"
"LimitedDataBufferList.java:138"$1$"		super.clear();"
"LimitedDataBufferList.java:139"$1$"	}"
"LimitedDataBufferList.java:140"$0$""
"LimitedDataBufferList.java:141"$0$"	/**"
"LimitedDataBufferList.java:142"$1$"	 * Shortcut to {@link DataBufferUtils#release release} all data buffers and"
"LimitedDataBufferList.java:143"$1$"	 * then {@link #clear()}."
"LimitedDataBufferList.java:144"$0$"	 */"
"LimitedDataBufferList.java:145"$1$"	public void releaseAndClear() {"
"LimitedDataBufferList.java:146"$1$"		forEach(buf -> {"
"LimitedDataBufferList.java:147"$1$"			try {"
"LimitedDataBufferList.java:148"$1$"				DataBufferUtils.release(buf);"
"LimitedDataBufferList.java:149"$1$"			}"
"LimitedDataBufferList.java:150"$1$"			catch (Throwable ex) {"
"LimitedDataBufferList.java:151"$0$"				// Keep going.."
"LimitedDataBufferList.java:152"$1$"			}"
"LimitedDataBufferList.java:153"$0$"		});"
"LimitedDataBufferList.java:154"$0$"		clear();"
"LimitedDataBufferList.java:155"$0$"	}"
"LimitedDataBufferList.java:156"$0$""
"LimitedDataBufferList.java:157"$0$"}"
"LinkedCaseInsensitiveMap.java:1"$0$"/*"
"LinkedCaseInsensitiveMap.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"LinkedCaseInsensitiveMap.java:3"$0$" *"
"LinkedCaseInsensitiveMap.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"LinkedCaseInsensitiveMap.java:5"$0$" * you may not use this file except in compliance with the License."
"LinkedCaseInsensitiveMap.java:6"$0$" * You may obtain a copy of the License at"
"LinkedCaseInsensitiveMap.java:7"$0$" *"
"LinkedCaseInsensitiveMap.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"LinkedCaseInsensitiveMap.java:9"$0$" *"
"LinkedCaseInsensitiveMap.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"LinkedCaseInsensitiveMap.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"LinkedCaseInsensitiveMap.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"LinkedCaseInsensitiveMap.java:13"$0$" * See the License for the specific language governing permissions and"
"LinkedCaseInsensitiveMap.java:14"$0$" * limitations under the License."
"LinkedCaseInsensitiveMap.java:15"$0$" */"
"LinkedCaseInsensitiveMap.java:16"$0$""
"LinkedCaseInsensitiveMap.java:17"$0$"package org.springframework.util;"
"LinkedCaseInsensitiveMap.java:18"$0$""
"LinkedCaseInsensitiveMap.java:19"$0$"import java.io.Serializable;"
"LinkedCaseInsensitiveMap.java:20"$0$"import java.util.AbstractCollection;"
"LinkedCaseInsensitiveMap.java:21"$0$"import java.util.AbstractSet;"
"LinkedCaseInsensitiveMap.java:22"$0$"import java.util.Collection;"
"LinkedCaseInsensitiveMap.java:23"$0$"import java.util.HashMap;"
"LinkedCaseInsensitiveMap.java:24"$0$"import java.util.Iterator;"
"LinkedCaseInsensitiveMap.java:25"$0$"import java.util.LinkedHashMap;"
"LinkedCaseInsensitiveMap.java:26"$0$"import java.util.Locale;"
"LinkedCaseInsensitiveMap.java:27"$0$"import java.util.Map;"
"LinkedCaseInsensitiveMap.java:28"$0$"import java.util.Set;"
"LinkedCaseInsensitiveMap.java:29"$0$"import java.util.Spliterator;"
"LinkedCaseInsensitiveMap.java:30"$0$"import java.util.function.Consumer;"
"LinkedCaseInsensitiveMap.java:31"$0$"import java.util.function.Function;"
"LinkedCaseInsensitiveMap.java:32"$0$""
"LinkedCaseInsensitiveMap.java:33"$0$"import org.springframework.lang.Nullable;"
"LinkedCaseInsensitiveMap.java:34"$0$""
"LinkedCaseInsensitiveMap.java:35"$0$"/**"
"LinkedCaseInsensitiveMap.java:36"$1$" * {@link LinkedHashMap} variant that stores String keys in a case-insensitive"
"LinkedCaseInsensitiveMap.java:37"$0$" * manner, for example for key-based access in a results table."
"LinkedCaseInsensitiveMap.java:38"$0$" *"
"LinkedCaseInsensitiveMap.java:39"$0$" * <p>Preserves the original order as well as the original casing of keys,"
"LinkedCaseInsensitiveMap.java:40"$0$" * while allowing for contains, get and remove calls with any case of key."
"LinkedCaseInsensitiveMap.java:41"$0$" *"
"LinkedCaseInsensitiveMap.java:42"$1$" * <p>Does <i>not</i> support {@code null} keys."
"LinkedCaseInsensitiveMap.java:43"$0$" *"
"LinkedCaseInsensitiveMap.java:44"$0$" * @author Juergen Hoeller"
"LinkedCaseInsensitiveMap.java:45"$0$" * @author Phillip Webb"
"LinkedCaseInsensitiveMap.java:46"$0$" * @since 3.0"
"LinkedCaseInsensitiveMap.java:47"$0$" * @param <V> the value type"
"LinkedCaseInsensitiveMap.java:48"$0$" */"
"LinkedCaseInsensitiveMap.java:49"$0$"SuppressWarnings(""serial"")"
"LinkedCaseInsensitiveMap.java:50"$1$"public class LinkedCaseInsensitiveMap<V> implements Map<String, V>, Serializable, Cloneable {"
"LinkedCaseInsensitiveMap.java:51"$1$""
"LinkedCaseInsensitiveMap.java:52"$1$"	private final LinkedHashMap<String, V> targetMap;"
"LinkedCaseInsensitiveMap.java:53"$1$""
"LinkedCaseInsensitiveMap.java:54"$1$"	private final HashMap<String, String> caseInsensitiveKeys;"
"LinkedCaseInsensitiveMap.java:55"$1$""
"LinkedCaseInsensitiveMap.java:56"$1$"	private final Locale locale;"
"LinkedCaseInsensitiveMap.java:57"$1$""
"LinkedCaseInsensitiveMap.java:58"$1$"	@Nullable"
"LinkedCaseInsensitiveMap.java:59"$1$"	private transient volatile Set<String> keySet;"
"LinkedCaseInsensitiveMap.java:60"$1$""
"LinkedCaseInsensitiveMap.java:61"$1$"	@Nullable"
"LinkedCaseInsensitiveMap.java:62"$1$"	private transient volatile Collection<V> values;"
"LinkedCaseInsensitiveMap.java:63"$1$""
"LinkedCaseInsensitiveMap.java:64"$1$"	@Nullable"
"LinkedCaseInsensitiveMap.java:65"$1$"	private transient volatile Set<Entry<String, V>> entrySet;"
"LinkedCaseInsensitiveMap.java:66"$1$""
"LinkedCaseInsensitiveMap.java:67"$1$""
"LinkedCaseInsensitiveMap.java:68"$1$"	/**"
"LinkedCaseInsensitiveMap.java:69"$1$"	 * Create a new LinkedCaseInsensitiveMap that stores case-insensitive keys"
"LinkedCaseInsensitiveMap.java:70"$1$"	 * according to the default Locale (by default in lower case)."
"LinkedCaseInsensitiveMap.java:71"$1$"	 * @see #convertKey(String)"
"LinkedCaseInsensitiveMap.java:72"$1$"	 */"
"LinkedCaseInsensitiveMap.java:73"$1$"	public LinkedCaseInsensitiveMap() {"
"LinkedCaseInsensitiveMap.java:74"$1$"		this((Locale) null);"
"LinkedCaseInsensitiveMap.java:75"$1$"	}"
"LinkedCaseInsensitiveMap.java:76"$0$""
"LinkedCaseInsensitiveMap.java:77"$0$"	/**"
"LinkedCaseInsensitiveMap.java:78"$0$"	 * Create a new LinkedCaseInsensitiveMap that stores case-insensitive keys"
"LinkedCaseInsensitiveMap.java:79"$0$"	 * according to the given Locale (by default in lower case)."
"LinkedCaseInsensitiveMap.java:80"$0$"	 * @param locale the Locale to use for case-insensitive key conversion"
"LinkedCaseInsensitiveMap.java:81"$0$"	 * @see #convertKey(String)"
"LinkedCaseInsensitiveMap.java:82"$0$"	 */"
"LinkedCaseInsensitiveMap.java:83"$1$"	public LinkedCaseInsensitiveMap(@Nullable Locale locale) {"
"LinkedCaseInsensitiveMap.java:84"$1$"		this(16, locale);"
"LinkedCaseInsensitiveMap.java:85"$1$"	}"
"LinkedCaseInsensitiveMap.java:86"$0$""
"LinkedCaseInsensitiveMap.java:87"$0$"	/**"
"LinkedCaseInsensitiveMap.java:88"$1$"	 * Create a new LinkedCaseInsensitiveMap that wraps a {@link LinkedHashMap}"
"LinkedCaseInsensitiveMap.java:89"$0$"	 * with the given initial capacity and stores case-insensitive keys"
"LinkedCaseInsensitiveMap.java:90"$0$"	 * according to the default Locale (by default in lower case)."
"LinkedCaseInsensitiveMap.java:91"$0$"	 * @param initialCapacity the initial capacity"
"LinkedCaseInsensitiveMap.java:92"$0$"	 * @see #convertKey(String)"
"LinkedCaseInsensitiveMap.java:93"$0$"	 */"
"LinkedCaseInsensitiveMap.java:94"$1$"	public LinkedCaseInsensitiveMap(int initialCapacity) {"
"LinkedCaseInsensitiveMap.java:95"$1$"		this(initialCapacity, null);"
"LinkedCaseInsensitiveMap.java:96"$1$"	}"
"LinkedCaseInsensitiveMap.java:97"$0$""
"LinkedCaseInsensitiveMap.java:98"$0$"	/**"
"LinkedCaseInsensitiveMap.java:99"$1$"	 * Create a new LinkedCaseInsensitiveMap that wraps a {@link LinkedHashMap}"
"LinkedCaseInsensitiveMap.java:100"$0$"	 * with the given initial capacity and stores case-insensitive keys"
"LinkedCaseInsensitiveMap.java:101"$0$"	 * according to the given Locale (by default in lower case)."
"LinkedCaseInsensitiveMap.java:102"$0$"	 * @param initialCapacity the initial capacity"
"LinkedCaseInsensitiveMap.java:103"$0$"	 * @param locale the Locale to use for case-insensitive key conversion"
"LinkedCaseInsensitiveMap.java:104"$0$"	 * @see #convertKey(String)"
"LinkedCaseInsensitiveMap.java:105"$0$"	 */"
"LinkedCaseInsensitiveMap.java:106"$1$"	public LinkedCaseInsensitiveMap(int initialCapacity, @Nullable Locale locale) {"
"LinkedCaseInsensitiveMap.java:107"$1$"		this.targetMap = new LinkedHashMap<String, V>(initialCapacity) {"
"LinkedCaseInsensitiveMap.java:108"$1$"			@Override"
"LinkedCaseInsensitiveMap.java:109"$1$"			public boolean containsKey(Object key) {"
"LinkedCaseInsensitiveMap.java:110"$1$"				return LinkedCaseInsensitiveMap.this.containsKey(key);"
"LinkedCaseInsensitiveMap.java:111"$1$"			}"
"LinkedCaseInsensitiveMap.java:112"$0$"			@Override"
"LinkedCaseInsensitiveMap.java:113"$1$"			protected boolean removeEldestEntry(Map.Entry<String, V> eldest) {"
"LinkedCaseInsensitiveMap.java:114"$1$"				boolean doRemove = LinkedCaseInsensitiveMap.this.removeEldestEntry(eldest);"
"LinkedCaseInsensitiveMap.java:115"$1$"				if (doRemove) {"
"LinkedCaseInsensitiveMap.java:116"$1$"					removeCaseInsensitiveKey(eldest.getKey());"
"LinkedCaseInsensitiveMap.java:117"$1$"				}"
"LinkedCaseInsensitiveMap.java:118"$0$"				return doRemove;"
"LinkedCaseInsensitiveMap.java:119"$0$"			}"
"LinkedCaseInsensitiveMap.java:120"$0$"		};"
"LinkedCaseInsensitiveMap.java:121"$0$"		this.caseInsensitiveKeys = new HashMap<>(initialCapacity);"
"LinkedCaseInsensitiveMap.java:122"$0$"		this.locale = (locale != null ? locale : Locale.getDefault());"
"LinkedCaseInsensitiveMap.java:123"$0$"	}"
"LinkedCaseInsensitiveMap.java:124"$0$""
"LinkedCaseInsensitiveMap.java:125"$0$"	/**"
"LinkedCaseInsensitiveMap.java:126"$0$"	 * Copy constructor."
"LinkedCaseInsensitiveMap.java:127"$0$"	 */"
"LinkedCaseInsensitiveMap.java:128"$0$"	@SuppressWarnings(""unchecked"")"
"LinkedCaseInsensitiveMap.java:129"$1$"	private LinkedCaseInsensitiveMap(LinkedCaseInsensitiveMap<V> other) {"
"LinkedCaseInsensitiveMap.java:130"$1$"		this.targetMap = (LinkedHashMap<String, V>) other.targetMap.clone();"
"LinkedCaseInsensitiveMap.java:131"$1$"		this.caseInsensitiveKeys = (HashMap<String, String>) other.caseInsensitiveKeys.clone();"
"LinkedCaseInsensitiveMap.java:132"$1$"		this.locale = other.locale;"
"LinkedCaseInsensitiveMap.java:133"$1$"	}"
"LinkedCaseInsensitiveMap.java:134"$0$""
"LinkedCaseInsensitiveMap.java:135"$0$""
"LinkedCaseInsensitiveMap.java:136"$0$"	// Implementation of java.util.Map"
"LinkedCaseInsensitiveMap.java:137"$0$""
"LinkedCaseInsensitiveMap.java:138"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:139"$1$"	public int size() {"
"LinkedCaseInsensitiveMap.java:140"$1$"		return this.targetMap.size();"
"LinkedCaseInsensitiveMap.java:141"$1$"	}"
"LinkedCaseInsensitiveMap.java:142"$0$""
"LinkedCaseInsensitiveMap.java:143"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:144"$1$"	public boolean isEmpty() {"
"LinkedCaseInsensitiveMap.java:145"$1$"		return this.targetMap.isEmpty();"
"LinkedCaseInsensitiveMap.java:146"$1$"	}"
"LinkedCaseInsensitiveMap.java:147"$0$""
"LinkedCaseInsensitiveMap.java:148"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:149"$1$"	public boolean containsKey(Object key) {"
"LinkedCaseInsensitiveMap.java:150"$1$"		return (key instanceof String && this.caseInsensitiveKeys.containsKey(convertKey((String) key)));"
"LinkedCaseInsensitiveMap.java:151"$1$"	}"
"LinkedCaseInsensitiveMap.java:152"$0$""
"LinkedCaseInsensitiveMap.java:153"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:154"$1$"	public boolean containsValue(Object value) {"
"LinkedCaseInsensitiveMap.java:155"$1$"		return this.targetMap.containsValue(value);"
"LinkedCaseInsensitiveMap.java:156"$1$"	}"
"LinkedCaseInsensitiveMap.java:157"$0$""
"LinkedCaseInsensitiveMap.java:158"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:159"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:160"$1$"	public V get(Object key) {"
"LinkedCaseInsensitiveMap.java:161"$1$"		if (key instanceof String) {"
"LinkedCaseInsensitiveMap.java:162"$1$"			String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey((String) key));"
"LinkedCaseInsensitiveMap.java:163"$1$"			if (caseInsensitiveKey != null) {"
"LinkedCaseInsensitiveMap.java:164"$1$"				return this.targetMap.get(caseInsensitiveKey);"
"LinkedCaseInsensitiveMap.java:165"$1$"			}"
"LinkedCaseInsensitiveMap.java:166"$0$"		}"
"LinkedCaseInsensitiveMap.java:167"$0$"		return null;"
"LinkedCaseInsensitiveMap.java:168"$0$"	}"
"LinkedCaseInsensitiveMap.java:169"$0$""
"LinkedCaseInsensitiveMap.java:170"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:171"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:172"$1$"	public V getOrDefault(Object key, V defaultValue) {"
"LinkedCaseInsensitiveMap.java:173"$1$"		if (key instanceof String) {"
"LinkedCaseInsensitiveMap.java:174"$1$"			String caseInsensitiveKey = this.caseInsensitiveKeys.get(convertKey((String) key));"
"LinkedCaseInsensitiveMap.java:175"$1$"			if (caseInsensitiveKey != null) {"
"LinkedCaseInsensitiveMap.java:176"$1$"				return this.targetMap.get(caseInsensitiveKey);"
"LinkedCaseInsensitiveMap.java:177"$1$"			}"
"LinkedCaseInsensitiveMap.java:178"$0$"		}"
"LinkedCaseInsensitiveMap.java:179"$0$"		return defaultValue;"
"LinkedCaseInsensitiveMap.java:180"$0$"	}"
"LinkedCaseInsensitiveMap.java:181"$0$""
"LinkedCaseInsensitiveMap.java:182"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:183"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:184"$1$"	public V put(String key, @Nullable V value) {"
"LinkedCaseInsensitiveMap.java:185"$1$"		String oldKey = this.caseInsensitiveKeys.put(convertKey(key), key);"
"LinkedCaseInsensitiveMap.java:186"$1$"		V oldKeyValue = null;"
"LinkedCaseInsensitiveMap.java:187"$1$"		if (oldKey != null && !oldKey.equals(key)) {"
"LinkedCaseInsensitiveMap.java:188"$1$"			oldKeyValue = this.targetMap.remove(oldKey);"
"LinkedCaseInsensitiveMap.java:189"$1$"		}"
"LinkedCaseInsensitiveMap.java:190"$0$"		V oldValue = this.targetMap.put(key, value);"
"LinkedCaseInsensitiveMap.java:191"$0$"		return (oldKeyValue != null ? oldKeyValue : oldValue);"
"LinkedCaseInsensitiveMap.java:192"$0$"	}"
"LinkedCaseInsensitiveMap.java:193"$0$""
"LinkedCaseInsensitiveMap.java:194"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:195"$1$"	public void putAll(Map<? extends String, ? extends V> map) {"
"LinkedCaseInsensitiveMap.java:196"$1$"		if (map.isEmpty()) {"
"LinkedCaseInsensitiveMap.java:197"$1$"			return;"
"LinkedCaseInsensitiveMap.java:198"$1$"		}"
"LinkedCaseInsensitiveMap.java:199"$0$"		map.forEach(this::put);"
"LinkedCaseInsensitiveMap.java:200"$0$"	}"
"LinkedCaseInsensitiveMap.java:201"$0$""
"LinkedCaseInsensitiveMap.java:202"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:203"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:204"$1$"	public V putIfAbsent(String key, @Nullable V value) {"
"LinkedCaseInsensitiveMap.java:205"$1$"		String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);"
"LinkedCaseInsensitiveMap.java:206"$1$"		if (oldKey != null) {"
"LinkedCaseInsensitiveMap.java:207"$1$"			return this.targetMap.get(oldKey);"
"LinkedCaseInsensitiveMap.java:208"$1$"		}"
"LinkedCaseInsensitiveMap.java:209"$0$"		return this.targetMap.putIfAbsent(key, value);"
"LinkedCaseInsensitiveMap.java:210"$0$"	}"
"LinkedCaseInsensitiveMap.java:211"$0$""
"LinkedCaseInsensitiveMap.java:212"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:213"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:214"$1$"	public V computeIfAbsent(String key, Function<? super String, ? extends V> mappingFunction) {"
"LinkedCaseInsensitiveMap.java:215"$1$"		String oldKey = this.caseInsensitiveKeys.putIfAbsent(convertKey(key), key);"
"LinkedCaseInsensitiveMap.java:216"$1$"		if (oldKey != null) {"
"LinkedCaseInsensitiveMap.java:217"$1$"			return this.targetMap.get(oldKey);"
"LinkedCaseInsensitiveMap.java:218"$1$"		}"
"LinkedCaseInsensitiveMap.java:219"$0$"		return this.targetMap.computeIfAbsent(key, mappingFunction);"
"LinkedCaseInsensitiveMap.java:220"$0$"	}"
"LinkedCaseInsensitiveMap.java:221"$0$""
"LinkedCaseInsensitiveMap.java:222"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:223"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:224"$1$"	public V remove(Object key) {"
"LinkedCaseInsensitiveMap.java:225"$1$"		if (key instanceof String) {"
"LinkedCaseInsensitiveMap.java:226"$1$"			String caseInsensitiveKey = removeCaseInsensitiveKey((String) key);"
"LinkedCaseInsensitiveMap.java:227"$1$"			if (caseInsensitiveKey != null) {"
"LinkedCaseInsensitiveMap.java:228"$1$"				return this.targetMap.remove(caseInsensitiveKey);"
"LinkedCaseInsensitiveMap.java:229"$1$"			}"
"LinkedCaseInsensitiveMap.java:230"$0$"		}"
"LinkedCaseInsensitiveMap.java:231"$0$"		return null;"
"LinkedCaseInsensitiveMap.java:232"$0$"	}"
"LinkedCaseInsensitiveMap.java:233"$0$""
"LinkedCaseInsensitiveMap.java:234"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:235"$1$"	public void clear() {"
"LinkedCaseInsensitiveMap.java:236"$1$"		this.caseInsensitiveKeys.clear();"
"LinkedCaseInsensitiveMap.java:237"$1$"		this.targetMap.clear();"
"LinkedCaseInsensitiveMap.java:238"$1$"	}"
"LinkedCaseInsensitiveMap.java:239"$0$""
"LinkedCaseInsensitiveMap.java:240"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:241"$1$"	public Set<String> keySet() {"
"LinkedCaseInsensitiveMap.java:242"$1$"		Set<String> keySet = this.keySet;"
"LinkedCaseInsensitiveMap.java:243"$1$"		if (keySet == null) {"
"LinkedCaseInsensitiveMap.java:244"$1$"			keySet = new KeySet(this.targetMap.keySet());"
"LinkedCaseInsensitiveMap.java:245"$1$"			this.keySet = keySet;"
"LinkedCaseInsensitiveMap.java:246"$1$"		}"
"LinkedCaseInsensitiveMap.java:247"$0$"		return keySet;"
"LinkedCaseInsensitiveMap.java:248"$0$"	}"
"LinkedCaseInsensitiveMap.java:249"$0$""
"LinkedCaseInsensitiveMap.java:250"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:251"$1$"	public Collection<V> values() {"
"LinkedCaseInsensitiveMap.java:252"$1$"		Collection<V> values = this.values;"
"LinkedCaseInsensitiveMap.java:253"$1$"		if (values == null) {"
"LinkedCaseInsensitiveMap.java:254"$1$"			values = new Values(this.targetMap.values());"
"LinkedCaseInsensitiveMap.java:255"$1$"			this.values = values;"
"LinkedCaseInsensitiveMap.java:256"$1$"		}"
"LinkedCaseInsensitiveMap.java:257"$0$"		return values;"
"LinkedCaseInsensitiveMap.java:258"$0$"	}"
"LinkedCaseInsensitiveMap.java:259"$0$""
"LinkedCaseInsensitiveMap.java:260"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:261"$1$"	public Set<Entry<String, V>> entrySet() {"
"LinkedCaseInsensitiveMap.java:262"$1$"		Set<Entry<String, V>> entrySet = this.entrySet;"
"LinkedCaseInsensitiveMap.java:263"$1$"		if (entrySet == null) {"
"LinkedCaseInsensitiveMap.java:264"$1$"			entrySet = new EntrySet(this.targetMap.entrySet());"
"LinkedCaseInsensitiveMap.java:265"$1$"			this.entrySet = entrySet;"
"LinkedCaseInsensitiveMap.java:266"$1$"		}"
"LinkedCaseInsensitiveMap.java:267"$0$"		return entrySet;"
"LinkedCaseInsensitiveMap.java:268"$0$"	}"
"LinkedCaseInsensitiveMap.java:269"$0$""
"LinkedCaseInsensitiveMap.java:270"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:271"$1$"	public LinkedCaseInsensitiveMap<V> clone() {"
"LinkedCaseInsensitiveMap.java:272"$1$"		return new LinkedCaseInsensitiveMap<>(this);"
"LinkedCaseInsensitiveMap.java:273"$1$"	}"
"LinkedCaseInsensitiveMap.java:274"$0$""
"LinkedCaseInsensitiveMap.java:275"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:276"$1$"	public boolean equals(@Nullable Object obj) {"
"LinkedCaseInsensitiveMap.java:277"$1$"		return this.targetMap.equals(obj);"
"LinkedCaseInsensitiveMap.java:278"$1$"	}"
"LinkedCaseInsensitiveMap.java:279"$0$""
"LinkedCaseInsensitiveMap.java:280"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:281"$1$"	public int hashCode() {"
"LinkedCaseInsensitiveMap.java:282"$1$"		return this.targetMap.hashCode();"
"LinkedCaseInsensitiveMap.java:283"$1$"	}"
"LinkedCaseInsensitiveMap.java:284"$0$""
"LinkedCaseInsensitiveMap.java:285"$0$"	@Override"
"LinkedCaseInsensitiveMap.java:286"$1$"	public String toString() {"
"LinkedCaseInsensitiveMap.java:287"$1$"		return this.targetMap.toString();"
"LinkedCaseInsensitiveMap.java:288"$1$"	}"
"LinkedCaseInsensitiveMap.java:289"$0$""
"LinkedCaseInsensitiveMap.java:290"$0$""
"LinkedCaseInsensitiveMap.java:291"$0$"	// Specific to LinkedCaseInsensitiveMap"
"LinkedCaseInsensitiveMap.java:292"$0$""
"LinkedCaseInsensitiveMap.java:293"$0$"	/**"
"LinkedCaseInsensitiveMap.java:294"$1$"	 * Return the locale used by this {@code LinkedCaseInsensitiveMap}."
"LinkedCaseInsensitiveMap.java:295"$0$"	 * Used for case-insensitive key conversion."
"LinkedCaseInsensitiveMap.java:296"$0$"	 * @since 4.3.10"
"LinkedCaseInsensitiveMap.java:297"$0$"	 * @see #LinkedCaseInsensitiveMap(Locale)"
"LinkedCaseInsensitiveMap.java:298"$0$"	 * @see #convertKey(String)"
"LinkedCaseInsensitiveMap.java:299"$0$"	 */"
"LinkedCaseInsensitiveMap.java:300"$1$"	public Locale getLocale() {"
"LinkedCaseInsensitiveMap.java:301"$1$"		return this.locale;"
"LinkedCaseInsensitiveMap.java:302"$1$"	}"
"LinkedCaseInsensitiveMap.java:303"$0$""
"LinkedCaseInsensitiveMap.java:304"$0$"	/**"
"LinkedCaseInsensitiveMap.java:305"$0$"	 * Convert the given key to a case-insensitive key."
"LinkedCaseInsensitiveMap.java:306"$0$"	 * <p>The default implementation converts the key"
"LinkedCaseInsensitiveMap.java:307"$0$"	 * to lower-case according to this Map's Locale."
"LinkedCaseInsensitiveMap.java:308"$0$"	 * @param key the user-specified key"
"LinkedCaseInsensitiveMap.java:309"$0$"	 * @return the key to use for storing"
"LinkedCaseInsensitiveMap.java:310"$0$"	 * @see String#toLowerCase(Locale)"
"LinkedCaseInsensitiveMap.java:311"$0$"	 */"
"LinkedCaseInsensitiveMap.java:312"$1$"	protected String convertKey(String key) {"
"LinkedCaseInsensitiveMap.java:313"$1$"		return key.toLowerCase(getLocale());"
"LinkedCaseInsensitiveMap.java:314"$1$"	}"
"LinkedCaseInsensitiveMap.java:315"$0$""
"LinkedCaseInsensitiveMap.java:316"$0$"	/**"
"LinkedCaseInsensitiveMap.java:317"$0$"	 * Determine whether this map should remove the given eldest entry."
"LinkedCaseInsensitiveMap.java:318"$0$"	 * @param eldest the candidate entry"
"LinkedCaseInsensitiveMap.java:319"$1$"	 * @return {@code true} for removing it, {@code false} for keeping it"
"LinkedCaseInsensitiveMap.java:320"$0$"	 * @see LinkedHashMap#removeEldestEntry"
"LinkedCaseInsensitiveMap.java:321"$0$"	 */"
"LinkedCaseInsensitiveMap.java:322"$1$"	protected boolean removeEldestEntry(Map.Entry<String, V> eldest) {"
"LinkedCaseInsensitiveMap.java:323"$1$"		return false;"
"LinkedCaseInsensitiveMap.java:324"$1$"	}"
"LinkedCaseInsensitiveMap.java:325"$0$""
"LinkedCaseInsensitiveMap.java:326"$0$"	@Nullable"
"LinkedCaseInsensitiveMap.java:327"$1$"	private String removeCaseInsensitiveKey(String key) {"
"LinkedCaseInsensitiveMap.java:328"$1$"		return this.caseInsensitiveKeys.remove(convertKey(key));"
"LinkedCaseInsensitiveMap.java:329"$1$"	}"
"LinkedCaseInsensitiveMap.java:330"$0$""
"LinkedCaseInsensitiveMap.java:331"$0$""
"LinkedCaseInsensitiveMap.java:332"$1$"	private class KeySet extends AbstractSet<String> {"
"LinkedCaseInsensitiveMap.java:333"$1$""
"LinkedCaseInsensitiveMap.java:334"$1$"		private final Set<String> delegate;"
"LinkedCaseInsensitiveMap.java:335"$1$""
"LinkedCaseInsensitiveMap.java:336"$1$"		KeySet(Set<String> delegate) {"
"LinkedCaseInsensitiveMap.java:337"$1$"			this.delegate = delegate;"
"LinkedCaseInsensitiveMap.java:338"$1$"		}"
"LinkedCaseInsensitiveMap.java:339"$0$""
"LinkedCaseInsensitiveMap.java:340"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:341"$1$"		public int size() {"
"LinkedCaseInsensitiveMap.java:342"$1$"			return this.delegate.size();"
"LinkedCaseInsensitiveMap.java:343"$1$"		}"
"LinkedCaseInsensitiveMap.java:344"$0$""
"LinkedCaseInsensitiveMap.java:345"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:346"$1$"		public boolean contains(Object o) {"
"LinkedCaseInsensitiveMap.java:347"$1$"			return this.delegate.contains(o);"
"LinkedCaseInsensitiveMap.java:348"$1$"		}"
"LinkedCaseInsensitiveMap.java:349"$0$""
"LinkedCaseInsensitiveMap.java:350"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:351"$1$"		public Iterator<String> iterator() {"
"LinkedCaseInsensitiveMap.java:352"$1$"			return new KeySetIterator();"
"LinkedCaseInsensitiveMap.java:353"$1$"		}"
"LinkedCaseInsensitiveMap.java:354"$0$""
"LinkedCaseInsensitiveMap.java:355"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:356"$1$"		public boolean remove(Object o) {"
"LinkedCaseInsensitiveMap.java:357"$1$"			return LinkedCaseInsensitiveMap.this.remove(o) != null;"
"LinkedCaseInsensitiveMap.java:358"$1$"		}"
"LinkedCaseInsensitiveMap.java:359"$0$""
"LinkedCaseInsensitiveMap.java:360"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:361"$1$"		public void clear() {"
"LinkedCaseInsensitiveMap.java:362"$1$"			LinkedCaseInsensitiveMap.this.clear();"
"LinkedCaseInsensitiveMap.java:363"$1$"		}"
"LinkedCaseInsensitiveMap.java:364"$0$""
"LinkedCaseInsensitiveMap.java:365"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:366"$1$"		public Spliterator<String> spliterator() {"
"LinkedCaseInsensitiveMap.java:367"$1$"			return this.delegate.spliterator();"
"LinkedCaseInsensitiveMap.java:368"$1$"		}"
"LinkedCaseInsensitiveMap.java:369"$0$""
"LinkedCaseInsensitiveMap.java:370"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:371"$1$"		public void forEach(Consumer<? super String> action) {"
"LinkedCaseInsensitiveMap.java:372"$1$"			this.delegate.forEach(action);"
"LinkedCaseInsensitiveMap.java:373"$1$"		}"
"LinkedCaseInsensitiveMap.java:374"$0$"	}"
"LinkedCaseInsensitiveMap.java:375"$0$""
"LinkedCaseInsensitiveMap.java:376"$0$""
"LinkedCaseInsensitiveMap.java:377"$1$"	private class Values extends AbstractCollection<V> {"
"LinkedCaseInsensitiveMap.java:378"$1$""
"LinkedCaseInsensitiveMap.java:379"$1$"		private final Collection<V> delegate;"
"LinkedCaseInsensitiveMap.java:380"$1$""
"LinkedCaseInsensitiveMap.java:381"$1$"		Values(Collection<V> delegate) {"
"LinkedCaseInsensitiveMap.java:382"$1$"			this.delegate = delegate;"
"LinkedCaseInsensitiveMap.java:383"$1$"		}"
"LinkedCaseInsensitiveMap.java:384"$0$""
"LinkedCaseInsensitiveMap.java:385"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:386"$1$"		public int size() {"
"LinkedCaseInsensitiveMap.java:387"$1$"			return this.delegate.size();"
"LinkedCaseInsensitiveMap.java:388"$1$"		}"
"LinkedCaseInsensitiveMap.java:389"$0$""
"LinkedCaseInsensitiveMap.java:390"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:391"$1$"		public boolean contains(Object o) {"
"LinkedCaseInsensitiveMap.java:392"$1$"			return this.delegate.contains(o);"
"LinkedCaseInsensitiveMap.java:393"$1$"		}"
"LinkedCaseInsensitiveMap.java:394"$0$""
"LinkedCaseInsensitiveMap.java:395"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:396"$1$"		public Iterator<V> iterator() {"
"LinkedCaseInsensitiveMap.java:397"$1$"			return new ValuesIterator();"
"LinkedCaseInsensitiveMap.java:398"$1$"		}"
"LinkedCaseInsensitiveMap.java:399"$0$""
"LinkedCaseInsensitiveMap.java:400"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:401"$1$"		public void clear() {"
"LinkedCaseInsensitiveMap.java:402"$1$"			LinkedCaseInsensitiveMap.this.clear();"
"LinkedCaseInsensitiveMap.java:403"$1$"		}"
"LinkedCaseInsensitiveMap.java:404"$0$""
"LinkedCaseInsensitiveMap.java:405"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:406"$1$"		public Spliterator<V> spliterator() {"
"LinkedCaseInsensitiveMap.java:407"$1$"			return this.delegate.spliterator();"
"LinkedCaseInsensitiveMap.java:408"$1$"		}"
"LinkedCaseInsensitiveMap.java:409"$0$""
"LinkedCaseInsensitiveMap.java:410"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:411"$1$"		public void forEach(Consumer<? super V> action) {"
"LinkedCaseInsensitiveMap.java:412"$1$"			this.delegate.forEach(action);"
"LinkedCaseInsensitiveMap.java:413"$1$"		}"
"LinkedCaseInsensitiveMap.java:414"$0$"	}"
"LinkedCaseInsensitiveMap.java:415"$0$""
"LinkedCaseInsensitiveMap.java:416"$0$""
"LinkedCaseInsensitiveMap.java:417"$1$"	private class EntrySet extends AbstractSet<Entry<String, V>> {"
"LinkedCaseInsensitiveMap.java:418"$1$""
"LinkedCaseInsensitiveMap.java:419"$1$"		private final Set<Entry<String, V>> delegate;"
"LinkedCaseInsensitiveMap.java:420"$1$""
"LinkedCaseInsensitiveMap.java:421"$1$"		public EntrySet(Set<Entry<String, V>> delegate) {"
"LinkedCaseInsensitiveMap.java:422"$1$"			this.delegate = delegate;"
"LinkedCaseInsensitiveMap.java:423"$1$"		}"
"LinkedCaseInsensitiveMap.java:424"$0$""
"LinkedCaseInsensitiveMap.java:425"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:426"$1$"		public int size() {"
"LinkedCaseInsensitiveMap.java:427"$1$"			return this.delegate.size();"
"LinkedCaseInsensitiveMap.java:428"$1$"		}"
"LinkedCaseInsensitiveMap.java:429"$0$""
"LinkedCaseInsensitiveMap.java:430"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:431"$1$"		public boolean contains(Object o) {"
"LinkedCaseInsensitiveMap.java:432"$1$"			return this.delegate.contains(o);"
"LinkedCaseInsensitiveMap.java:433"$1$"		}"
"LinkedCaseInsensitiveMap.java:434"$0$""
"LinkedCaseInsensitiveMap.java:435"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:436"$1$"		public Iterator<Entry<String, V>> iterator() {"
"LinkedCaseInsensitiveMap.java:437"$1$"			return new EntrySetIterator();"
"LinkedCaseInsensitiveMap.java:438"$1$"		}"
"LinkedCaseInsensitiveMap.java:439"$0$""
"LinkedCaseInsensitiveMap.java:440"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:441"$0$"		@SuppressWarnings(""unchecked"")"
"LinkedCaseInsensitiveMap.java:442"$1$"		public boolean remove(Object o) {"
"LinkedCaseInsensitiveMap.java:443"$1$"			if (this.delegate.remove(o)) {"
"LinkedCaseInsensitiveMap.java:444"$1$"				removeCaseInsensitiveKey(((Map.Entry<String, V>) o).getKey());"
"LinkedCaseInsensitiveMap.java:445"$1$"				return true;"
"LinkedCaseInsensitiveMap.java:446"$1$"			}"
"LinkedCaseInsensitiveMap.java:447"$0$"			return false;"
"LinkedCaseInsensitiveMap.java:448"$0$"		}"
"LinkedCaseInsensitiveMap.java:449"$0$""
"LinkedCaseInsensitiveMap.java:450"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:451"$1$"		public void clear() {"
"LinkedCaseInsensitiveMap.java:452"$1$"			this.delegate.clear();"
"LinkedCaseInsensitiveMap.java:453"$1$"			caseInsensitiveKeys.clear();"
"LinkedCaseInsensitiveMap.java:454"$1$"		}"
"LinkedCaseInsensitiveMap.java:455"$0$""
"LinkedCaseInsensitiveMap.java:456"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:457"$1$"		public Spliterator<Entry<String, V>> spliterator() {"
"LinkedCaseInsensitiveMap.java:458"$1$"			return this.delegate.spliterator();"
"LinkedCaseInsensitiveMap.java:459"$1$"		}"
"LinkedCaseInsensitiveMap.java:460"$0$""
"LinkedCaseInsensitiveMap.java:461"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:462"$1$"		public void forEach(Consumer<? super Entry<String, V>> action) {"
"LinkedCaseInsensitiveMap.java:463"$1$"			this.delegate.forEach(action);"
"LinkedCaseInsensitiveMap.java:464"$1$"		}"
"LinkedCaseInsensitiveMap.java:465"$0$"	}"
"LinkedCaseInsensitiveMap.java:466"$0$""
"LinkedCaseInsensitiveMap.java:467"$0$""
"LinkedCaseInsensitiveMap.java:468"$1$"	private abstract class EntryIterator<T> implements Iterator<T> {"
"LinkedCaseInsensitiveMap.java:469"$1$""
"LinkedCaseInsensitiveMap.java:470"$1$"		private final Iterator<Entry<String, V>> delegate;"
"LinkedCaseInsensitiveMap.java:471"$1$""
"LinkedCaseInsensitiveMap.java:472"$1$"		@Nullable"
"LinkedCaseInsensitiveMap.java:473"$1$"		private Entry<String, V> last;"
"LinkedCaseInsensitiveMap.java:474"$1$""
"LinkedCaseInsensitiveMap.java:475"$1$"		public EntryIterator() {"
"LinkedCaseInsensitiveMap.java:476"$1$"			this.delegate = targetMap.entrySet().iterator();"
"LinkedCaseInsensitiveMap.java:477"$1$"		}"
"LinkedCaseInsensitiveMap.java:478"$0$""
"LinkedCaseInsensitiveMap.java:479"$1$"		protected Entry<String, V> nextEntry() {"
"LinkedCaseInsensitiveMap.java:480"$1$"			Entry<String, V> entry = this.delegate.next();"
"LinkedCaseInsensitiveMap.java:481"$1$"			this.last = entry;"
"LinkedCaseInsensitiveMap.java:482"$1$"			return entry;"
"LinkedCaseInsensitiveMap.java:483"$1$"		}"
"LinkedCaseInsensitiveMap.java:484"$0$""
"LinkedCaseInsensitiveMap.java:485"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:486"$1$"		public boolean hasNext() {"
"LinkedCaseInsensitiveMap.java:487"$1$"			return this.delegate.hasNext();"
"LinkedCaseInsensitiveMap.java:488"$1$"		}"
"LinkedCaseInsensitiveMap.java:489"$0$""
"LinkedCaseInsensitiveMap.java:490"$0$"		@Override"
"LinkedCaseInsensitiveMap.java:491"$1$"		public void remove() {"
"LinkedCaseInsensitiveMap.java:492"$1$"			this.delegate.remove();"
"LinkedCaseInsensitiveMap.java:493"$1$"			if (this.last != null) {"
"LinkedCaseInsensitiveMap.java:494"$1$"				removeCaseInsensitiveKey(this.last.getKey());"
"LinkedCaseInsensitiveMap.java:495"$1$"				this.last = null;"
"LinkedCaseInsensitiveMap.java:496"$1$"			}"
"LinkedCaseInsensitiveMap.java:497"$0$"		}"
"LinkedCaseInsensitiveMap.java:498"$0$"	}"
"LinkedCaseInsensitiveMap.java:499"$0$""
"LinkedCaseInsensitiveMap.java:500"$0$""
"LinkedCaseInsensitiveMap.java:501"$1$"	private class KeySetIterator extends EntryIterator<String> {"
"LinkedCaseInsensitiveMap.java:502"$1$""
"LinkedCaseInsensitiveMap.java:503"$1$"		@Override"
"LinkedCaseInsensitiveMap.java:504"$1$"		public String next() {"
"LinkedCaseInsensitiveMap.java:505"$1$"			return nextEntry().getKey();"
"LinkedCaseInsensitiveMap.java:506"$1$"		}"
"LinkedCaseInsensitiveMap.java:507"$0$"	}"
"LinkedCaseInsensitiveMap.java:508"$0$""
"LinkedCaseInsensitiveMap.java:509"$0$""
"LinkedCaseInsensitiveMap.java:510"$1$"	private class ValuesIterator extends EntryIterator<V> {"
"LinkedCaseInsensitiveMap.java:511"$1$""
"LinkedCaseInsensitiveMap.java:512"$1$"		@Override"
"LinkedCaseInsensitiveMap.java:513"$1$"		public V next() {"
"LinkedCaseInsensitiveMap.java:514"$1$"			return nextEntry().getValue();"
"LinkedCaseInsensitiveMap.java:515"$1$"		}"
"LinkedCaseInsensitiveMap.java:516"$0$"	}"
"LinkedCaseInsensitiveMap.java:517"$0$""
"LinkedCaseInsensitiveMap.java:518"$0$""
"LinkedCaseInsensitiveMap.java:519"$1$"	private class EntrySetIterator extends EntryIterator<Entry<String, V>> {"
"LinkedCaseInsensitiveMap.java:520"$1$""
"LinkedCaseInsensitiveMap.java:521"$1$"		@Override"
"LinkedCaseInsensitiveMap.java:522"$1$"		public Entry<String, V> next() {"
"LinkedCaseInsensitiveMap.java:523"$1$"			return nextEntry();"
"LinkedCaseInsensitiveMap.java:524"$1$"		}"
"LinkedCaseInsensitiveMap.java:525"$0$"	}"
"LinkedCaseInsensitiveMap.java:526"$0$""
"LinkedCaseInsensitiveMap.java:527"$0$"}"
"StaxSource.java:1"$0$"/*"
"StaxSource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"StaxSource.java:3"$0$" *"
"StaxSource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxSource.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxSource.java:6"$0$" * You may obtain a copy of the License at"
"StaxSource.java:7"$0$" *"
"StaxSource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxSource.java:9"$0$" *"
"StaxSource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxSource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxSource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxSource.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxSource.java:14"$0$" * limitations under the License."
"StaxSource.java:15"$0$" */"
"StaxSource.java:16"$0$""
"StaxSource.java:17"$0$"package org.springframework.util.xml;"
"StaxSource.java:18"$0$""
"StaxSource.java:19"$0$"import javax.xml.stream.XMLEventReader;"
"StaxSource.java:20"$0$"import javax.xml.stream.XMLStreamReader;"
"StaxSource.java:21"$0$"import javax.xml.transform.sax.SAXSource;"
"StaxSource.java:22"$0$""
"StaxSource.java:23"$0$"import org.xml.sax.InputSource;"
"StaxSource.java:24"$0$"import org.xml.sax.XMLReader;"
"StaxSource.java:25"$0$""
"StaxSource.java:26"$0$"import org.springframework.lang.Nullable;"
"StaxSource.java:27"$0$""
"StaxSource.java:28"$0$"/**"
"StaxSource.java:29"$1$" * Implementation of the {@code Source} tagging interface for StAX readers. Can be constructed with"
"StaxSource.java:30"$1$" * an {@code XMLEventReader} or an {@code XMLStreamReader}."
"StaxSource.java:31"$0$" *"
"StaxSource.java:32"$1$" * <p>This class is necessary because there is no implementation of {@code Source} for StAX Readers"
"StaxSource.java:33"$1$" * in JAXP 1.3. There is a {@code StAXSource} in JAXP 1.4 (JDK 1.6), but this class is kept around"
"StaxSource.java:34"$0$" * for backwards compatibility reasons."
"StaxSource.java:35"$0$" *"
"StaxSource.java:36"$1$" * <p>Even though {@code StaxSource} extends from {@code SAXSource}, calling the methods of"
"StaxSource.java:37"$1$" * {@code SAXSource} is <strong>not supported</strong>. In general, the only supported operation"
"StaxSource.java:38"$1$" * on this class is to use the {@code XMLReader} obtained via {@link #getXMLReader()} to parse the"
"StaxSource.java:39"$1$" * input source obtained via {@link #getInputSource()}. Calling {@link #setXMLReader(XMLReader)}"
"StaxSource.java:40"$1$" * or {@link #setInputSource(InputSource)} will result in {@code UnsupportedOperationException #setInputSource(InputSource)} will result in {@code UnsupportedOperationExceptions}."
"StaxSource.java:41"$0$" *"
"StaxSource.java:42"$0$" * @author Arjen Poutsma"
"StaxSource.java:43"$0$" * @since 3.0"
"StaxSource.java:44"$0$" * @see XMLEventReader"
"StaxSource.java:45"$0$" * @see XMLStreamReader"
"StaxSource.java:46"$0$" * @see javax.xml.transform.Transformer"
"StaxSource.java:47"$0$" */"
"StaxSource.java:48"$1$"class StaxSource extends SAXSource {"
"StaxSource.java:49"$1$""
"StaxSource.java:50"$1$"	@Nullable"
"StaxSource.java:51"$1$"	private XMLEventReader eventReader;"
"StaxSource.java:52"$1$""
"StaxSource.java:53"$1$"	@Nullable"
"StaxSource.java:54"$1$"	private XMLStreamReader streamReader;"
"StaxSource.java:55"$1$""
"StaxSource.java:56"$1$""
"StaxSource.java:57"$1$"	/**"
"StaxSource.java:58"$1$"	 * Construct a new instance of the {@code StaxSource} with the specified {@code XMLEventReader}."
"StaxSource.java:59"$1$"	 * The supplied event reader must be in {@code XMLStreamConstants.START_DOCUMENT} or"
"StaxSource.java:60"$1$"	 * {@code XMLStreamConstants.START_ELEMENT} state."
"StaxSource.java:61"$1$"	 * @param eventReader the {@code XMLEventReader} to read from"
"StaxSource.java:62"$1$"	 * @throws IllegalStateException if the reader is not at the start of a document or element"
"StaxSource.java:63"$1$"	 */"
"StaxSource.java:64"$1$"	StaxSource(XMLEventReader eventReader) {"
"StaxSource.java:65"$1$"		super(new StaxEventXMLReader(eventReader), new InputSource());"
"StaxSource.java:66"$1$"		this.eventReader = eventReader;"
"StaxSource.java:67"$1$"	}"
"StaxSource.java:68"$0$""
"StaxSource.java:69"$0$"	/**"
"StaxSource.java:70"$1$"	 * Construct a new instance of the {@code StaxSource} with the specified {@code XMLStreamReader}."
"StaxSource.java:71"$1$"	 * The supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT} or"
"StaxSource.java:72"$1$"	 * {@code XMLStreamConstants.START_ELEMENT} state."
"StaxSource.java:73"$1$"	 * @param streamReader the {@code XMLStreamReader} to read from"
"StaxSource.java:74"$0$"	 * @throws IllegalStateException if the reader is not at the start of a document or element"
"StaxSource.java:75"$0$"	 */"
"StaxSource.java:76"$1$"	StaxSource(XMLStreamReader streamReader) {"
"StaxSource.java:77"$1$"		super(new StaxStreamXMLReader(streamReader), new InputSource());"
"StaxSource.java:78"$1$"		this.streamReader = streamReader;"
"StaxSource.java:79"$1$"	}"
"StaxSource.java:80"$0$""
"StaxSource.java:81"$0$""
"StaxSource.java:82"$0$"	/**"
"StaxSource.java:83"$1$"	 * Return the {@code XMLEventReader} used by this {@code StaxSource}."
"StaxSource.java:84"$1$"	 * <p>If this {@code StaxSource} was created with an {@code XMLStreamReader},"
"StaxSource.java:85"$1$"	 * the result will be {@code null}."
"StaxSource.java:86"$0$"	 * @return the StAX event reader used by this source"
"StaxSource.java:87"$0$"	 * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)"
"StaxSource.java:88"$0$"	 */"
"StaxSource.java:89"$0$"	@Nullable"
"StaxSource.java:90"$1$"	XMLEventReader getXMLEventReader() {"
"StaxSource.java:91"$1$"		return this.eventReader;"
"StaxSource.java:92"$1$"	}"
"StaxSource.java:93"$0$""
"StaxSource.java:94"$0$"	/**"
"StaxSource.java:95"$1$"	 * Return the {@code XMLStreamReader} used by this {@code StaxSource}."
"StaxSource.java:96"$1$"	 * <p>If this {@code StaxSource} was created with an {@code XMLEventReader},"
"StaxSource.java:97"$1$"	 * the result will be {@code null}."
"StaxSource.java:98"$0$"	 * @return the StAX event reader used by this source"
"StaxSource.java:99"$0$"	 * @see StaxSource#StaxSource(javax.xml.stream.XMLEventReader)"
"StaxSource.java:100"$0$"	 */"
"StaxSource.java:101"$0$"	@Nullable"
"StaxSource.java:102"$1$"	XMLStreamReader getXMLStreamReader() {"
"StaxSource.java:103"$1$"		return this.streamReader;"
"StaxSource.java:104"$1$"	}"
"StaxSource.java:105"$0$""
"StaxSource.java:106"$0$""
"StaxSource.java:107"$0$"	/**"
"StaxSource.java:108"$1$"	 * Throws an {@code UnsupportedOperationException}."
"StaxSource.java:109"$0$"	 * @throws UnsupportedOperationException always"
"StaxSource.java:110"$0$"	 */"
"StaxSource.java:111"$0$"	@Override"
"StaxSource.java:112"$1$"	public void setInputSource(InputSource inputSource) {"
"StaxSource.java:113"$1$"		throw new UnsupportedOperationException(""setInputSource is not supported"");"
"StaxSource.java:114"$1$"	}"
"StaxSource.java:115"$0$""
"StaxSource.java:116"$0$"	/**"
"StaxSource.java:117"$1$"	 * Throws an {@code UnsupportedOperationException}."
"StaxSource.java:118"$0$"	 * @throws UnsupportedOperationException always"
"StaxSource.java:119"$0$"	 */"
"StaxSource.java:120"$0$"	@Override"
"StaxSource.java:121"$1$"	public void setXMLReader(XMLReader reader) {"
"StaxSource.java:122"$1$"		throw new UnsupportedOperationException(""setXMLReader is not supported"");"
"StaxSource.java:123"$1$"	}"
"StaxSource.java:124"$0$""
"StaxSource.java:125"$0$"}"
"GenericConversionService.java:1"$0$"/*"
"GenericConversionService.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"GenericConversionService.java:3"$0$" *"
"GenericConversionService.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"GenericConversionService.java:5"$0$" * you may not use this file except in compliance with the License."
"GenericConversionService.java:6"$0$" * You may obtain a copy of the License at"
"GenericConversionService.java:7"$0$" *"
"GenericConversionService.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"GenericConversionService.java:9"$0$" *"
"GenericConversionService.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"GenericConversionService.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"GenericConversionService.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"GenericConversionService.java:13"$0$" * See the License for the specific language governing permissions and"
"GenericConversionService.java:14"$0$" * limitations under the License."
"GenericConversionService.java:15"$0$" */"
"GenericConversionService.java:16"$0$""
"GenericConversionService.java:17"$0$"package org.springframework.core.convert.support;"
"GenericConversionService.java:18"$0$""
"GenericConversionService.java:19"$0$"import java.lang.reflect.Array;"
"GenericConversionService.java:20"$0$"import java.util.ArrayList;"
"GenericConversionService.java:21"$0$"import java.util.Collections;"
"GenericConversionService.java:22"$0$"import java.util.HashSet;"
"GenericConversionService.java:23"$0$"import java.util.LinkedHashMap;"
"GenericConversionService.java:24"$0$"import java.util.LinkedHashSet;"
"GenericConversionService.java:25"$0$"import java.util.LinkedList;"
"GenericConversionService.java:26"$0$"import java.util.List;"
"GenericConversionService.java:27"$0$"import java.util.Map;"
"GenericConversionService.java:28"$0$"import java.util.Optional;"
"GenericConversionService.java:29"$0$"import java.util.Set;"
"GenericConversionService.java:30"$0$""
"GenericConversionService.java:31"$0$"import org.springframework.core.DecoratingProxy;"
"GenericConversionService.java:32"$0$"import org.springframework.core.ResolvableType;"
"GenericConversionService.java:33"$0$"import org.springframework.core.convert.ConversionException;"
"GenericConversionService.java:34"$0$"import org.springframework.core.convert.ConversionFailedException;"
"GenericConversionService.java:35"$0$"import org.springframework.core.convert.ConversionService;"
"GenericConversionService.java:36"$0$"import org.springframework.core.convert.ConverterNotFoundException;"
"GenericConversionService.java:37"$0$"import org.springframework.core.convert.TypeDescriptor;"
"GenericConversionService.java:38"$0$"import org.springframework.core.convert.converter.ConditionalConverter;"
"GenericConversionService.java:39"$0$"import org.springframework.core.convert.converter.ConditionalGenericConverter;"
"GenericConversionService.java:40"$0$"import org.springframework.core.convert.converter.Converter;"
"GenericConversionService.java:41"$0$"import org.springframework.core.convert.converter.ConverterFactory;"
"GenericConversionService.java:42"$0$"import org.springframework.core.convert.converter.ConverterRegistry;"
"GenericConversionService.java:43"$0$"import org.springframework.core.convert.converter.GenericConverter;"
"GenericConversionService.java:44"$0$"import org.springframework.core.convert.converter.GenericConverter.ConvertiblePair;"
"GenericConversionService.java:45"$0$"import org.springframework.lang.Nullable;"
"GenericConversionService.java:46"$0$"import org.springframework.util.Assert;"
"GenericConversionService.java:47"$0$"import org.springframework.util.ClassUtils;"
"GenericConversionService.java:48"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"GenericConversionService.java:49"$0$"import org.springframework.util.StringUtils;"
"GenericConversionService.java:50"$0$""
"GenericConversionService.java:51"$0$"/**"
"GenericConversionService.java:52"$1$" * Base {@link ConversionService} implementation suitable for use in most environments."
"GenericConversionService.java:53"$1$" * Indirectly implements {@link ConverterRegistry} as registration API through the"
"GenericConversionService.java:54"$1$" * {@link ConfigurableConversionService} interface."
"GenericConversionService.java:55"$0$" *"
"GenericConversionService.java:56"$0$" * @author Keith Donald"
"GenericConversionService.java:57"$0$" * @author Juergen Hoeller"
"GenericConversionService.java:58"$0$" * @author Chris Beams"
"GenericConversionService.java:59"$0$" * @author Phillip Webb"
"GenericConversionService.java:60"$0$" * @author David Haraburda"
"GenericConversionService.java:61"$0$" * @since 3.0"
"GenericConversionService.java:62"$0$" */"
"GenericConversionService.java:63"$1$"public class GenericConversionService implements ConfigurableConversionService {"
"GenericConversionService.java:64"$1$""
"GenericConversionService.java:65"$1$"	/**"
"GenericConversionService.java:66"$1$"	 * General NO-OP converter used when conversion is not required."
"GenericConversionService.java:67"$1$"	 */"
"GenericConversionService.java:68"$1$"	private static final GenericConverter NO_OP_CONVERTER = new NoOpConverter(""NO_OP"");"
"GenericConversionService.java:69"$1$""
"GenericConversionService.java:70"$1$"	/**"
"GenericConversionService.java:71"$1$"	 * Used as a cache entry when no converter is available."
"GenericConversionService.java:72"$1$"	 * This converter is never returned."
"GenericConversionService.java:73"$1$"	 */"
"GenericConversionService.java:74"$1$"	private static final GenericConverter NO_MATCH = new NoOpConverter(""NO_MATCH"");"
"GenericConversionService.java:75"$1$""
"GenericConversionService.java:76"$1$""
"GenericConversionService.java:77"$1$"	private final Converters converters = new Converters();"
"GenericConversionService.java:78"$1$""
"GenericConversionService.java:79"$1$"	private final Map<ConverterCacheKey, GenericConverter> converterCache = new ConcurrentReferenceHashMap<>(64);"
"GenericConversionService.java:80"$1$""
"GenericConversionService.java:81"$1$""
"GenericConversionService.java:82"$0$"	// ConverterRegistry implementation"
"GenericConversionService.java:83"$1$""
"GenericConversionService.java:84"$1$"	@Override"
"GenericConversionService.java:85"$1$"	public void addConverter(Converter<?, ?> converter) {"
"GenericConversionService.java:86"$1$"		ResolvableType[] typeInfo = getRequiredTypeInfo(converter.getClass(), Converter.class);"
"GenericConversionService.java:87"$1$"		if (typeInfo == null && converter instanceof DecoratingProxy) {"
"GenericConversionService.java:88"$1$"			typeInfo = getRequiredTypeInfo(((DecoratingProxy) converter).getDecoratedClass(), Converter.class);"
"GenericConversionService.java:89"$1$"		}"
"GenericConversionService.java:90"$1$"		if (typeInfo == null) {"
"GenericConversionService.java:91"$1$"			throw new IllegalArgumentException(""Unable to determine source type <S> and target type <T> for your "" +"
"GenericConversionService.java:92"$1$"					""Converter ["" + converter.getClass().getName() + ""]; does the class parameterize those types?"");"
"GenericConversionService.java:93"$1$"		}"
"GenericConversionService.java:94"$0$"		addConverter(new ConverterAdapter(converter, typeInfo[0], typeInfo[1]));"
"GenericConversionService.java:95"$0$"	}"
"GenericConversionService.java:96"$0$""
"GenericConversionService.java:97"$0$"	@Override"
"GenericConversionService.java:98"$1$"	public <S, T> void addConverter(Class<S> sourceType, Class<T> targetType, Converter<? super S, ? extends T> converter) {"
"GenericConversionService.java:99"$1$"		addConverter(new ConverterAdapter("
"GenericConversionService.java:100"$1$"				converter, ResolvableType.forClass(sourceType), ResolvableType.forClass(targetType)));"
"GenericConversionService.java:101"$1$"	}"
"GenericConversionService.java:102"$0$""
"GenericConversionService.java:103"$0$"	@Override"
"GenericConversionService.java:104"$1$"	public void addConverter(GenericConverter converter) {"
"GenericConversionService.java:105"$1$"		this.converters.add(converter);"
"GenericConversionService.java:106"$1$"		invalidateCache();"
"GenericConversionService.java:107"$1$"	}"
"GenericConversionService.java:108"$0$""
"GenericConversionService.java:109"$0$"	@Override"
"GenericConversionService.java:110"$1$"	public void addConverterFactory(ConverterFactory<?, ?> factory) {"
"GenericConversionService.java:111"$1$"		ResolvableType[] typeInfo = getRequiredTypeInfo(factory.getClass(), ConverterFactory.class);"
"GenericConversionService.java:112"$1$"		if (typeInfo == null && factory instanceof DecoratingProxy) {"
"GenericConversionService.java:113"$1$"			typeInfo = getRequiredTypeInfo(((DecoratingProxy) factory).getDecoratedClass(), ConverterFactory.class);"
"GenericConversionService.java:114"$1$"		}"
"GenericConversionService.java:115"$1$"		if (typeInfo == null) {"
"GenericConversionService.java:116"$1$"			throw new IllegalArgumentException(""Unable to determine source type <S> and target type <T> for your "" +"
"GenericConversionService.java:117"$1$"					""ConverterFactory ["" + factory.getClass().getName() + ""]; does the class parameterize those types?"");"
"GenericConversionService.java:118"$1$"		}"
"GenericConversionService.java:119"$0$"		addConverter(new ConverterFactoryAdapter(factory,"
"GenericConversionService.java:120"$0$"				new ConvertiblePair(typeInfo[0].toClass(), typeInfo[1].toClass())));"
"GenericConversionService.java:121"$0$"	}"
"GenericConversionService.java:122"$0$""
"GenericConversionService.java:123"$0$"	@Override"
"GenericConversionService.java:124"$1$"	public void removeConvertible(Class<?> sourceType, Class<?> targetType) {"
"GenericConversionService.java:125"$1$"		this.converters.remove(sourceType, targetType);"
"GenericConversionService.java:126"$1$"		invalidateCache();"
"GenericConversionService.java:127"$1$"	}"
"GenericConversionService.java:128"$0$""
"GenericConversionService.java:129"$0$""
"GenericConversionService.java:130"$0$"	// ConversionService implementation"
"GenericConversionService.java:131"$0$""
"GenericConversionService.java:132"$0$"	@Override"
"GenericConversionService.java:133"$1$"	public boolean canConvert(@Nullable Class<?> sourceType, Class<?> targetType) {"
"GenericConversionService.java:134"$1$"		Assert.notNull(targetType, ""Target type to convert to cannot be null"");"
"GenericConversionService.java:135"$1$"		return canConvert((sourceType != null ? TypeDescriptor.valueOf(sourceType) : null),"
"GenericConversionService.java:136"$1$"				TypeDescriptor.valueOf(targetType));"
"GenericConversionService.java:137"$1$"	}"
"GenericConversionService.java:138"$0$""
"GenericConversionService.java:139"$0$"	@Override"
"GenericConversionService.java:140"$1$"	public boolean canConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:141"$1$"		Assert.notNull(targetType, ""Target type to convert to cannot be null"");"
"GenericConversionService.java:142"$1$"		if (sourceType == null) {"
"GenericConversionService.java:143"$1$"			return true;"
"GenericConversionService.java:144"$1$"		}"
"GenericConversionService.java:145"$0$"		GenericConverter converter = getConverter(sourceType, targetType);"
"GenericConversionService.java:146"$0$"		return (converter != null);"
"GenericConversionService.java:147"$0$"	}"
"GenericConversionService.java:148"$0$""
"GenericConversionService.java:149"$0$"	/**"
"GenericConversionService.java:150"$0$"	 * Return whether conversion between the source type and the target type can be bypassed."
"GenericConversionService.java:151"$0$"	 * <p>More precisely, this method will return true if objects of sourceType can be"
"GenericConversionService.java:152"$0$"	 * converted to the target type by returning the source object unchanged."
"GenericConversionService.java:153"$0$"	 * @param sourceType context about the source type to convert from"
"GenericConversionService.java:154"$1$"	 * (may be {@code null} if source is {@code null})"
"GenericConversionService.java:155"$0$"	 * @param targetType context about the target type to convert to (required)"
"GenericConversionService.java:156"$1$"	 * @return {@code true} if conversion can be bypassed; {@code false} otherwise"
"GenericConversionService.java:157"$1$"	 * @throws IllegalArgumentException if targetType is {@code null}"
"GenericConversionService.java:158"$0$"	 * @since 3.2"
"GenericConversionService.java:159"$0$"	 */"
"GenericConversionService.java:160"$1$"	public boolean canBypassConvert(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:161"$1$"		Assert.notNull(targetType, ""Target type to convert to cannot be null"");"
"GenericConversionService.java:162"$1$"		if (sourceType == null) {"
"GenericConversionService.java:163"$1$"			return true;"
"GenericConversionService.java:164"$1$"		}"
"GenericConversionService.java:165"$0$"		GenericConverter converter = getConverter(sourceType, targetType);"
"GenericConversionService.java:166"$0$"		return (converter == NO_OP_CONVERTER);"
"GenericConversionService.java:167"$0$"	}"
"GenericConversionService.java:168"$0$""
"GenericConversionService.java:169"$0$"	@Override"
"GenericConversionService.java:170"$0$"	@SuppressWarnings(""unchecked"")"
"GenericConversionService.java:171"$0$"	@Nullable"
"GenericConversionService.java:172"$1$"	public <T> T convert(@Nullable Object source, Class<T> targetType) {"
"GenericConversionService.java:173"$1$"		Assert.notNull(targetType, ""Target type to convert to cannot be null"");"
"GenericConversionService.java:174"$1$"		return (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType));"
"GenericConversionService.java:175"$1$"	}"
"GenericConversionService.java:176"$0$""
"GenericConversionService.java:177"$0$"	@Override"
"GenericConversionService.java:178"$0$"	@Nullable"
"GenericConversionService.java:179"$1$"	public Object convert(@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:180"$1$"		Assert.notNull(targetType, ""Target type to convert to cannot be null"");"
"GenericConversionService.java:181"$1$"		if (sourceType == null) {"
"GenericConversionService.java:182"$1$"			Assert.isTrue(source == null, ""Source must be [null] if source type == [null]"");"
"GenericConversionService.java:183"$1$"			return handleResult(null, targetType, convertNullSource(null, targetType));"
"GenericConversionService.java:184"$1$"		}"
"GenericConversionService.java:185"$1$"		if (source != null && !sourceType.getObjectType().isInstance(source)) {"
"GenericConversionService.java:186"$1$"			throw new IllegalArgumentException(""Source to convert from must be an instance of ["" +"
"GenericConversionService.java:187"$1$"					sourceType + ""]; instead it was a ["" + source.getClass().getName() + ""]"");"
"GenericConversionService.java:188"$1$"		}"
"GenericConversionService.java:189"$0$"		GenericConverter converter = getConverter(sourceType, targetType);"
"GenericConversionService.java:190"$1$"		if (converter != null) {"
"GenericConversionService.java:191"$1$"			Object result = ConversionUtils.invokeConverter(converter, source, sourceType, targetType);"
"GenericConversionService.java:192"$1$"			return handleResult(sourceType, targetType, result);"
"GenericConversionService.java:193"$1$"		}"
"GenericConversionService.java:194"$0$"		return handleConverterNotFound(source, sourceType, targetType);"
"GenericConversionService.java:195"$0$"	}"
"GenericConversionService.java:196"$0$""
"GenericConversionService.java:197"$0$"	/**"
"GenericConversionService.java:198"$0$"	 * Convenience operation for converting a source object to the specified targetType,"
"GenericConversionService.java:199"$0$"	 * where the target type is a descriptor that provides additional conversion context."
"GenericConversionService.java:200"$1$"	 * Simply delegates to {@link #convert(Object, TypeDescriptor, TypeDescriptor)} and"
"GenericConversionService.java:201"$0$"	 * encapsulates the construction of the source type descriptor using"
"GenericConversionService.java:202"$1$"	 * {@link TypeDescriptor#forObject(Object)}."
"GenericConversionService.java:203"$0$"	 * @param source the source object"
"GenericConversionService.java:204"$0$"	 * @param targetType the target type"
"GenericConversionService.java:205"$0$"	 * @return the converted value"
"GenericConversionService.java:206"$0$"	 * @throws ConversionException if a conversion exception occurred"
"GenericConversionService.java:207"$1$"	 * @throws IllegalArgumentException if targetType is {@code null},"
"GenericConversionService.java:208"$1$"	 * or sourceType is {@code null} but source is not {@code null}"
"GenericConversionService.java:209"$0$"	 */"
"GenericConversionService.java:210"$0$"	@Nullable"
"GenericConversionService.java:211"$1$"	public Object convert(@Nullable Object source, TypeDescriptor targetType) {"
"GenericConversionService.java:212"$1$"		return convert(source, TypeDescriptor.forObject(source), targetType);"
"GenericConversionService.java:213"$1$"	}"
"GenericConversionService.java:214"$0$""
"GenericConversionService.java:215"$0$"	@Override"
"GenericConversionService.java:216"$1$"	public String toString() {"
"GenericConversionService.java:217"$1$"		return this.converters.toString();"
"GenericConversionService.java:218"$1$"	}"
"GenericConversionService.java:219"$0$""
"GenericConversionService.java:220"$0$""
"GenericConversionService.java:221"$0$"	// Protected template methods"
"GenericConversionService.java:222"$0$""
"GenericConversionService.java:223"$0$"	/**"
"GenericConversionService.java:224"$1$"	 * Template method to convert a {@code null} source."
"GenericConversionService.java:225"$1$"	 * <p>The default implementation returns {@code null} or the Java 8"
"GenericConversionService.java:226"$1$"	 * {@link java.util.Optional#empty()} instance if the target type is"
"GenericConversionService.java:227"$1$"	 * {@code java.util.Optional}. Subclasses may override this to return"
"GenericConversionService.java:228"$1$"	 * custom {@code null} objects for specific target types."
"GenericConversionService.java:229"$0$"	 * @param sourceType the source type to convert from"
"GenericConversionService.java:230"$0$"	 * @param targetType the target type to convert to"
"GenericConversionService.java:231"$0$"	 * @return the converted null object"
"GenericConversionService.java:232"$0$"	 */"
"GenericConversionService.java:233"$0$"	@Nullable"
"GenericConversionService.java:234"$1$"	protected Object convertNullSource(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:235"$1$"		if (targetType.getObjectType() == Optional.class) {"
"GenericConversionService.java:236"$1$"			return Optional.empty();"
"GenericConversionService.java:237"$1$"		}"
"GenericConversionService.java:238"$0$"		return null;"
"GenericConversionService.java:239"$0$"	}"
"GenericConversionService.java:240"$0$""
"GenericConversionService.java:241"$0$"	/**"
"GenericConversionService.java:242"$0$"	 * Hook method to lookup the converter for a given sourceType/targetType pair."
"GenericConversionService.java:243"$0$"	 * First queries this ConversionService's converter cache."
"GenericConversionService.java:244"$0$"	 * On a cache miss, then performs an exhaustive search for a matching converter."
"GenericConversionService.java:245"$0$"	 * If no converter matches, returns the default converter."
"GenericConversionService.java:246"$0$"	 * @param sourceType the source type to convert from"
"GenericConversionService.java:247"$0$"	 * @param targetType the target type to convert to"
"GenericConversionService.java:248"$0$"	 * @return the generic converter that will perform the conversion,"
"GenericConversionService.java:249"$1$"	 * or {@code null} if no suitable converter was found"
"GenericConversionService.java:250"$0$"	 * @see #getDefaultConverter(TypeDescriptor, TypeDescriptor)"
"GenericConversionService.java:251"$0$"	 */"
"GenericConversionService.java:252"$0$"	@Nullable"
"GenericConversionService.java:253"$1$"	protected GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:254"$1$"		ConverterCacheKey key = new ConverterCacheKey(sourceType, targetType);"
"GenericConversionService.java:255"$1$"		GenericConverter converter = this.converterCache.get(key);"
"GenericConversionService.java:256"$1$"		if (converter != null) {"
"GenericConversionService.java:257"$1$"			return (converter != NO_MATCH ? converter : null);"
"GenericConversionService.java:258"$1$"		}"
"GenericConversionService.java:259"$0$""
"GenericConversionService.java:260"$0$"		converter = this.converters.find(sourceType, targetType);"
"GenericConversionService.java:261"$1$"		if (converter == null) {"
"GenericConversionService.java:262"$1$"			converter = getDefaultConverter(sourceType, targetType);"
"GenericConversionService.java:263"$1$"		}"
"GenericConversionService.java:264"$0$""
"GenericConversionService.java:265"$1$"		if (converter != null) {"
"GenericConversionService.java:266"$1$"			this.converterCache.put(key, converter);"
"GenericConversionService.java:267"$1$"			return converter;"
"GenericConversionService.java:268"$1$"		}"
"GenericConversionService.java:269"$0$""
"GenericConversionService.java:270"$0$"		this.converterCache.put(key, NO_MATCH);"
"GenericConversionService.java:271"$0$"		return null;"
"GenericConversionService.java:272"$0$"	}"
"GenericConversionService.java:273"$0$""
"GenericConversionService.java:274"$0$"	/**"
"GenericConversionService.java:275"$0$"	 * Return the default converter if no converter is found for the given sourceType/targetType pair."
"GenericConversionService.java:276"$0$"	 * <p>Returns a NO_OP Converter if the source type is assignable to the target type."
"GenericConversionService.java:277"$1$"	 * Returns {@code null} otherwise, indicating no suitable converter could be found."
"GenericConversionService.java:278"$0$"	 * @param sourceType the source type to convert from"
"GenericConversionService.java:279"$0$"	 * @param targetType the target type to convert to"
"GenericConversionService.java:280"$0$"	 * @return the default generic converter that will perform the conversion"
"GenericConversionService.java:281"$0$"	 */"
"GenericConversionService.java:282"$0$"	@Nullable"
"GenericConversionService.java:283"$1$"	protected GenericConverter getDefaultConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:284"$1$"		return (sourceType.isAssignableTo(targetType) ? NO_OP_CONVERTER : null);"
"GenericConversionService.java:285"$1$"	}"
"GenericConversionService.java:286"$0$""
"GenericConversionService.java:287"$0$""
"GenericConversionService.java:288"$0$"	// Internal helpers"
"GenericConversionService.java:289"$0$""
"GenericConversionService.java:290"$0$"	@Nullable"
"GenericConversionService.java:291"$1$"	private ResolvableType[] getRequiredTypeInfo(Class<?> converterClass, Class<?> genericIfc) {"
"GenericConversionService.java:292"$1$"		ResolvableType resolvableType = ResolvableType.forClass(converterClass).as(genericIfc);"
"GenericConversionService.java:293"$1$"		ResolvableType[] generics = resolvableType.getGenerics();"
"GenericConversionService.java:294"$1$"		if (generics.length < 2) {"
"GenericConversionService.java:295"$1$"			return null;"
"GenericConversionService.java:296"$1$"		}"
"GenericConversionService.java:297"$0$"		Class<?> sourceType = generics[0].resolve();"
"GenericConversionService.java:298"$0$"		Class<?> targetType = generics[1].resolve();"
"GenericConversionService.java:299"$1$"		if (sourceType == null || targetType == null) {"
"GenericConversionService.java:300"$1$"			return null;"
"GenericConversionService.java:301"$1$"		}"
"GenericConversionService.java:302"$0$"		return generics;"
"GenericConversionService.java:303"$0$"	}"
"GenericConversionService.java:304"$0$""
"GenericConversionService.java:305"$1$"	private void invalidateCache() {"
"GenericConversionService.java:306"$1$"		this.converterCache.clear();"
"GenericConversionService.java:307"$1$"	}"
"GenericConversionService.java:308"$0$""
"GenericConversionService.java:309"$0$"	@Nullable"
"GenericConversionService.java:310"$0$"	private Object handleConverterNotFound("
"GenericConversionService.java:311"$1$"			@Nullable Object source, @Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:312"$1$""
"GenericConversionService.java:313"$1$"		if (source == null) {"
"GenericConversionService.java:314"$1$"			assertNotPrimitiveTargetType(sourceType, targetType);"
"GenericConversionService.java:315"$1$"			return null;"
"GenericConversionService.java:316"$1$"		}"
"GenericConversionService.java:317"$0$"		if ((sourceType == null || sourceType.isAssignableTo(targetType)) &&"
"GenericConversionService.java:318"$1$"				targetType.getObjectType().isInstance(source)) {"
"GenericConversionService.java:319"$1$"			return source;"
"GenericConversionService.java:320"$1$"		}"
"GenericConversionService.java:321"$0$"		throw new ConverterNotFoundException(sourceType, targetType);"
"GenericConversionService.java:322"$0$"	}"
"GenericConversionService.java:323"$0$""
"GenericConversionService.java:324"$0$"	@Nullable"
"GenericConversionService.java:325"$1$"	private Object handleResult(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType, @Nullable Object result) {"
"GenericConversionService.java:326"$1$"		if (result == null) {"
"GenericConversionService.java:327"$1$"			assertNotPrimitiveTargetType(sourceType, targetType);"
"GenericConversionService.java:328"$1$"		}"
"GenericConversionService.java:329"$0$"		return result;"
"GenericConversionService.java:330"$0$"	}"
"GenericConversionService.java:331"$0$""
"GenericConversionService.java:332"$1$"	private void assertNotPrimitiveTargetType(@Nullable TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:333"$1$"		if (targetType.isPrimitive()) {"
"GenericConversionService.java:334"$1$"			throw new ConversionFailedException(sourceType, targetType, null,"
"GenericConversionService.java:335"$1$"					new IllegalArgumentException(""A null value cannot be assigned to a primitive type""));"
"GenericConversionService.java:336"$1$"		}"
"GenericConversionService.java:337"$0$"	}"
"GenericConversionService.java:338"$0$""
"GenericConversionService.java:339"$0$""
"GenericConversionService.java:340"$0$"	/**"
"GenericConversionService.java:341"$1$"	 * Adapts a {@link Converter} to a {@link GenericConverter}."
"GenericConversionService.java:342"$0$"	 */"
"GenericConversionService.java:343"$0$"	@SuppressWarnings(""unchecked"")"
"GenericConversionService.java:344"$1$"	private final class ConverterAdapter implements ConditionalGenericConverter {"
"GenericConversionService.java:345"$1$""
"GenericConversionService.java:346"$1$"		private final Converter<Object, Object> converter;"
"GenericConversionService.java:347"$1$""
"GenericConversionService.java:348"$1$"		private final ConvertiblePair typeInfo;"
"GenericConversionService.java:349"$1$""
"GenericConversionService.java:350"$1$"		private final ResolvableType targetType;"
"GenericConversionService.java:351"$1$""
"GenericConversionService.java:352"$1$"		public ConverterAdapter(Converter<?, ?> converter, ResolvableType sourceType, ResolvableType targetType) {"
"GenericConversionService.java:353"$1$"			this.converter = (Converter<Object, Object>) converter;"
"GenericConversionService.java:354"$1$"			this.typeInfo = new ConvertiblePair(sourceType.toClass(), targetType.toClass());"
"GenericConversionService.java:355"$1$"			this.targetType = targetType;"
"GenericConversionService.java:356"$1$"		}"
"GenericConversionService.java:357"$0$""
"GenericConversionService.java:358"$0$"		@Override"
"GenericConversionService.java:359"$1$"		public Set<ConvertiblePair> getConvertibleTypes() {"
"GenericConversionService.java:360"$1$"			return Collections.singleton(this.typeInfo);"
"GenericConversionService.java:361"$1$"		}"
"GenericConversionService.java:362"$0$""
"GenericConversionService.java:363"$0$"		@Override"
"GenericConversionService.java:364"$1$"		public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:365"$0$"			// Check raw type first..."
"GenericConversionService.java:366"$1$"			if (this.typeInfo.getTargetType() != targetType.getObjectType()) {"
"GenericConversionService.java:367"$1$"				return false;"
"GenericConversionService.java:368"$1$"			}"
"GenericConversionService.java:369"$0$"			// Full check for complex generic type match required?"
"GenericConversionService.java:370"$0$"			ResolvableType rt = targetType.getResolvableType();"
"GenericConversionService.java:371"$0$"			if (!(rt.getType() instanceof Class) && !rt.isAssignableFrom(this.targetType) &&"
"GenericConversionService.java:372"$1$"					!this.targetType.hasUnresolvableGenerics()) {"
"GenericConversionService.java:373"$1$"				return false;"
"GenericConversionService.java:374"$1$"			}"
"GenericConversionService.java:375"$0$"			return !(this.converter instanceof ConditionalConverter) ||"
"GenericConversionService.java:376"$0$"					((ConditionalConverter) this.converter).matches(sourceType, targetType);"
"GenericConversionService.java:377"$0$"		}"
"GenericConversionService.java:378"$0$""
"GenericConversionService.java:379"$0$"		@Override"
"GenericConversionService.java:380"$0$"		@Nullable"
"GenericConversionService.java:381"$1$"		public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:382"$1$"			if (source == null) {"
"GenericConversionService.java:383"$1$"				return convertNullSource(sourceType, targetType);"
"GenericConversionService.java:384"$1$"			}"
"GenericConversionService.java:385"$0$"			return this.converter.convert(source);"
"GenericConversionService.java:386"$0$"		}"
"GenericConversionService.java:387"$0$""
"GenericConversionService.java:388"$0$"		@Override"
"GenericConversionService.java:389"$1$"		public String toString() {"
"GenericConversionService.java:390"$1$"			return (this.typeInfo + "" : "" + this.converter);"
"GenericConversionService.java:391"$1$"		}"
"GenericConversionService.java:392"$0$"	}"
"GenericConversionService.java:393"$0$""
"GenericConversionService.java:394"$0$""
"GenericConversionService.java:395"$0$"	/**"
"GenericConversionService.java:396"$1$"	 * Adapts a {@link ConverterFactory} to a {@link GenericConverter}."
"GenericConversionService.java:397"$0$"	 */"
"GenericConversionService.java:398"$0$"	@SuppressWarnings(""unchecked"")"
"GenericConversionService.java:399"$1$"	private final class ConverterFactoryAdapter implements ConditionalGenericConverter {"
"GenericConversionService.java:400"$1$""
"GenericConversionService.java:401"$1$"		private final ConverterFactory<Object, Object> converterFactory;"
"GenericConversionService.java:402"$1$""
"GenericConversionService.java:403"$1$"		private final ConvertiblePair typeInfo;"
"GenericConversionService.java:404"$1$""
"GenericConversionService.java:405"$1$"		public ConverterFactoryAdapter(ConverterFactory<?, ?> converterFactory, ConvertiblePair typeInfo) {"
"GenericConversionService.java:406"$1$"			this.converterFactory = (ConverterFactory<Object, Object>) converterFactory;"
"GenericConversionService.java:407"$1$"			this.typeInfo = typeInfo;"
"GenericConversionService.java:408"$1$"		}"
"GenericConversionService.java:409"$0$""
"GenericConversionService.java:410"$0$"		@Override"
"GenericConversionService.java:411"$1$"		public Set<ConvertiblePair> getConvertibleTypes() {"
"GenericConversionService.java:412"$1$"			return Collections.singleton(this.typeInfo);"
"GenericConversionService.java:413"$1$"		}"
"GenericConversionService.java:414"$0$""
"GenericConversionService.java:415"$0$"		@Override"
"GenericConversionService.java:416"$1$"		public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:417"$1$"			boolean matches = true;"
"GenericConversionService.java:418"$1$"			if (this.converterFactory instanceof ConditionalConverter) {"
"GenericConversionService.java:419"$1$"				matches = ((ConditionalConverter) this.converterFactory).matches(sourceType, targetType);"
"GenericConversionService.java:420"$1$"			}"
"GenericConversionService.java:421"$1$"			if (matches) {"
"GenericConversionService.java:422"$1$"				Converter<?, ?> converter = this.converterFactory.getConverter(targetType.getType());"
"GenericConversionService.java:423"$1$"				if (converter instanceof ConditionalConverter) {"
"GenericConversionService.java:424"$1$"					matches = ((ConditionalConverter) converter).matches(sourceType, targetType);"
"GenericConversionService.java:425"$1$"				}"
"GenericConversionService.java:426"$0$"			}"
"GenericConversionService.java:427"$0$"			return matches;"
"GenericConversionService.java:428"$0$"		}"
"GenericConversionService.java:429"$0$""
"GenericConversionService.java:430"$0$"		@Override"
"GenericConversionService.java:431"$0$"		@Nullable"
"GenericConversionService.java:432"$1$"		public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:433"$1$"			if (source == null) {"
"GenericConversionService.java:434"$1$"				return convertNullSource(sourceType, targetType);"
"GenericConversionService.java:435"$1$"			}"
"GenericConversionService.java:436"$0$"			return this.converterFactory.getConverter(targetType.getObjectType()).convert(source);"
"GenericConversionService.java:437"$0$"		}"
"GenericConversionService.java:438"$0$""
"GenericConversionService.java:439"$0$"		@Override"
"GenericConversionService.java:440"$1$"		public String toString() {"
"GenericConversionService.java:441"$1$"			return (this.typeInfo + "" : "" + this.converterFactory);"
"GenericConversionService.java:442"$1$"		}"
"GenericConversionService.java:443"$0$"	}"
"GenericConversionService.java:444"$0$""
"GenericConversionService.java:445"$0$""
"GenericConversionService.java:446"$0$"	/**"
"GenericConversionService.java:447"$0$"	 * Key for use with the converter cache."
"GenericConversionService.java:448"$0$"	 */"
"GenericConversionService.java:449"$1$"	private static final class ConverterCacheKey implements Comparable<ConverterCacheKey> {"
"GenericConversionService.java:450"$1$""
"GenericConversionService.java:451"$1$"		private final TypeDescriptor sourceType;"
"GenericConversionService.java:452"$1$""
"GenericConversionService.java:453"$1$"		private final TypeDescriptor targetType;"
"GenericConversionService.java:454"$1$""
"GenericConversionService.java:455"$1$"		public ConverterCacheKey(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:456"$1$"			this.sourceType = sourceType;"
"GenericConversionService.java:457"$1$"			this.targetType = targetType;"
"GenericConversionService.java:458"$1$"		}"
"GenericConversionService.java:459"$0$""
"GenericConversionService.java:460"$0$"		@Override"
"GenericConversionService.java:461"$1$"		public boolean equals(@Nullable Object other) {"
"GenericConversionService.java:462"$1$"			if (this == other) {"
"GenericConversionService.java:463"$1$"				return true;"
"GenericConversionService.java:464"$1$"			}"
"GenericConversionService.java:465"$1$"			if (!(other instanceof ConverterCacheKey)) {"
"GenericConversionService.java:466"$1$"				return false;"
"GenericConversionService.java:467"$1$"			}"
"GenericConversionService.java:468"$0$"			ConverterCacheKey otherKey = (ConverterCacheKey) other;"
"GenericConversionService.java:469"$0$"			return (this.sourceType.equals(otherKey.sourceType)) &&"
"GenericConversionService.java:470"$0$"					this.targetType.equals(otherKey.targetType);"
"GenericConversionService.java:471"$0$"		}"
"GenericConversionService.java:472"$0$""
"GenericConversionService.java:473"$0$"		@Override"
"GenericConversionService.java:474"$1$"		public int hashCode() {"
"GenericConversionService.java:475"$1$"			return (this.sourceType.hashCode() * 29 + this.targetType.hashCode());"
"GenericConversionService.java:476"$1$"		}"
"GenericConversionService.java:477"$0$""
"GenericConversionService.java:478"$0$"		@Override"
"GenericConversionService.java:479"$1$"		public String toString() {"
"GenericConversionService.java:480"$1$"			return (""ConverterCacheKey [sourceType = "" + this.sourceType +"
"GenericConversionService.java:481"$1$"					"", targetType = "" + this.targetType + ""]"");"
"GenericConversionService.java:482"$1$"		}"
"GenericConversionService.java:483"$0$""
"GenericConversionService.java:484"$0$"		@Override"
"GenericConversionService.java:485"$1$"		public int compareTo(ConverterCacheKey other) {"
"GenericConversionService.java:486"$1$"			int result = this.sourceType.getResolvableType().toString().compareTo("
"GenericConversionService.java:487"$1$"					other.sourceType.getResolvableType().toString());"
"GenericConversionService.java:488"$1$"			if (result == 0) {"
"GenericConversionService.java:489"$1$"				result = this.targetType.getResolvableType().toString().compareTo("
"GenericConversionService.java:490"$1$"						other.targetType.getResolvableType().toString());"
"GenericConversionService.java:491"$1$"			}"
"GenericConversionService.java:492"$0$"			return result;"
"GenericConversionService.java:493"$0$"		}"
"GenericConversionService.java:494"$0$"	}"
"GenericConversionService.java:495"$0$""
"GenericConversionService.java:496"$0$""
"GenericConversionService.java:497"$0$"	/**"
"GenericConversionService.java:498"$0$"	 * Manages all converters registered with the service."
"GenericConversionService.java:499"$0$"	 */"
"GenericConversionService.java:500"$1$"	private static class Converters {"
"GenericConversionService.java:501"$1$""
"GenericConversionService.java:502"$1$"		private final Set<GenericConverter> globalConverters = new LinkedHashSet<>();"
"GenericConversionService.java:503"$1$""
"GenericConversionService.java:504"$1$"		private final Map<ConvertiblePair, ConvertersForPair> converters = new LinkedHashMap<>(36);"
"GenericConversionService.java:505"$1$""
"GenericConversionService.java:506"$1$"		public void add(GenericConverter converter) {"
"GenericConversionService.java:507"$1$"			Set<ConvertiblePair> convertibleTypes = converter.getConvertibleTypes();"
"GenericConversionService.java:508"$1$"			if (convertibleTypes == null) {"
"GenericConversionService.java:509"$1$"				Assert.state(converter instanceof ConditionalConverter,"
"GenericConversionService.java:510"$1$"						""Only conditional converters may return null convertible types"");"
"GenericConversionService.java:511"$1$"				this.globalConverters.add(converter);"
"GenericConversionService.java:512"$1$"			}"
"GenericConversionService.java:513"$1$"			else {"
"GenericConversionService.java:514"$1$"				for (ConvertiblePair convertiblePair : convertibleTypes) {"
"GenericConversionService.java:515"$1$"					ConvertersForPair convertersForPair = getMatchableConverters(convertiblePair);"
"GenericConversionService.java:516"$1$"					convertersForPair.add(converter);"
"GenericConversionService.java:517"$1$"				}"
"GenericConversionService.java:518"$0$"			}"
"GenericConversionService.java:519"$0$"		}"
"GenericConversionService.java:520"$0$""
"GenericConversionService.java:521"$1$"		private ConvertersForPair getMatchableConverters(ConvertiblePair convertiblePair) {"
"GenericConversionService.java:522"$1$"			return this.converters.computeIfAbsent(convertiblePair, k -> new ConvertersForPair());"
"GenericConversionService.java:523"$1$"		}"
"GenericConversionService.java:524"$0$""
"GenericConversionService.java:525"$1$"		public void remove(Class<?> sourceType, Class<?> targetType) {"
"GenericConversionService.java:526"$1$"			this.converters.remove(new ConvertiblePair(sourceType, targetType));"
"GenericConversionService.java:527"$1$"		}"
"GenericConversionService.java:528"$0$""
"GenericConversionService.java:529"$0$"		/**"
"GenericConversionService.java:530"$1$"		 * Find a {@link GenericConverter} given a source and target type."
"GenericConversionService.java:531"$0$"		 * <p>This method will attempt to match all possible converters by working"
"GenericConversionService.java:532"$0$"		 * through the class and interface hierarchy of the types."
"GenericConversionService.java:533"$0$"		 * @param sourceType the source type"
"GenericConversionService.java:534"$0$"		 * @param targetType the target type"
"GenericConversionService.java:535"$1$"		 * @return a matching {@link GenericConverter}, or {@code null} if none found"
"GenericConversionService.java:536"$0$"		 */"
"GenericConversionService.java:537"$0$"		@Nullable"
"GenericConversionService.java:538"$1$"		public GenericConverter find(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:539"$0$"			// Search the full type hierarchy"
"GenericConversionService.java:540"$1$"			List<Class<?>> sourceCandidates = getClassHierarchy(sourceType.getType());"
"GenericConversionService.java:541"$1$"			List<Class<?>> targetCandidates = getClassHierarchy(targetType.getType());"
"GenericConversionService.java:542"$1$"			for (Class<?> sourceCandidate : sourceCandidates) {"
"GenericConversionService.java:543"$1$"				for (Class<?> targetCandidate : targetCandidates) {"
"GenericConversionService.java:544"$1$"					ConvertiblePair convertiblePair = new ConvertiblePair(sourceCandidate, targetCandidate);"
"GenericConversionService.java:545"$1$"					GenericConverter converter = getRegisteredConverter(sourceType, targetType, convertiblePair);"
"GenericConversionService.java:546"$1$"					if (converter != null) {"
"GenericConversionService.java:547"$1$"						return converter;"
"GenericConversionService.java:548"$1$"					}"
"GenericConversionService.java:549"$0$"				}"
"GenericConversionService.java:550"$0$"			}"
"GenericConversionService.java:551"$0$"			return null;"
"GenericConversionService.java:552"$0$"		}"
"GenericConversionService.java:553"$0$""
"GenericConversionService.java:554"$0$"		@Nullable"
"GenericConversionService.java:555"$0$"		private GenericConverter getRegisteredConverter(TypeDescriptor sourceType,"
"GenericConversionService.java:556"$1$"				TypeDescriptor targetType, ConvertiblePair convertiblePair) {"
"GenericConversionService.java:557"$1$""
"GenericConversionService.java:558"$0$"			// Check specifically registered converters"
"GenericConversionService.java:559"$1$"			ConvertersForPair convertersForPair = this.converters.get(convertiblePair);"
"GenericConversionService.java:560"$1$"			if (convertersForPair != null) {"
"GenericConversionService.java:561"$1$"				GenericConverter converter = convertersForPair.getConverter(sourceType, targetType);"
"GenericConversionService.java:562"$1$"				if (converter != null) {"
"GenericConversionService.java:563"$1$"					return converter;"
"GenericConversionService.java:564"$1$"				}"
"GenericConversionService.java:565"$0$"			}"
"GenericConversionService.java:566"$0$"			// Check ConditionalConverters for a dynamic match"
"GenericConversionService.java:567"$1$"			for (GenericConverter globalConverter : this.globalConverters) {"
"GenericConversionService.java:568"$1$"				if (((ConditionalConverter) globalConverter).matches(sourceType, targetType)) {"
"GenericConversionService.java:569"$1$"					return globalConverter;"
"GenericConversionService.java:570"$1$"				}"
"GenericConversionService.java:571"$0$"			}"
"GenericConversionService.java:572"$0$"			return null;"
"GenericConversionService.java:573"$0$"		}"
"GenericConversionService.java:574"$0$""
"GenericConversionService.java:575"$0$"		/**"
"GenericConversionService.java:576"$0$"		 * Returns an ordered class hierarchy for the given type."
"GenericConversionService.java:577"$0$"		 * @param type the type"
"GenericConversionService.java:578"$0$"		 * @return an ordered list of all classes that the given type extends or implements"
"GenericConversionService.java:579"$0$"		 */"
"GenericConversionService.java:580"$1$"		private List<Class<?>> getClassHierarchy(Class<?> type) {"
"GenericConversionService.java:581"$1$"			List<Class<?>> hierarchy = new ArrayList<>(20);"
"GenericConversionService.java:582"$1$"			Set<Class<?>> visited = new HashSet<>(20);"
"GenericConversionService.java:583"$1$"			addToClassHierarchy(0, ClassUtils.resolvePrimitiveIfNecessary(type), false, hierarchy, visited);"
"GenericConversionService.java:584"$1$"			boolean array = type.isArray();"
"GenericConversionService.java:585"$1$""
"GenericConversionService.java:586"$1$"			int i = 0;"
"GenericConversionService.java:587"$1$"			while (i < hierarchy.size()) {"
"GenericConversionService.java:588"$1$"				Class<?> candidate = hierarchy.get(i);"
"GenericConversionService.java:589"$1$"				candidate = (array ? candidate.getComponentType() : ClassUtils.resolvePrimitiveIfNecessary(candidate));"
"GenericConversionService.java:590"$1$"				Class<?> superclass = candidate.getSuperclass();"
"GenericConversionService.java:591"$1$"				if (superclass != null && superclass != Object.class && superclass != Enum.class) {"
"GenericConversionService.java:592"$1$"					addToClassHierarchy(i + 1, candidate.getSuperclass(), array, hierarchy, visited);"
"GenericConversionService.java:593"$1$"				}"
"GenericConversionService.java:594"$0$"				addInterfacesToClassHierarchy(candidate, array, hierarchy, visited);"
"GenericConversionService.java:595"$0$"				i++;"
"GenericConversionService.java:596"$0$"			}"
"GenericConversionService.java:597"$0$""
"GenericConversionService.java:598"$1$"			if (Enum.class.isAssignableFrom(type)) {"
"GenericConversionService.java:599"$1$"				addToClassHierarchy(hierarchy.size(), Enum.class, array, hierarchy, visited);"
"GenericConversionService.java:600"$1$"				addToClassHierarchy(hierarchy.size(), Enum.class, false, hierarchy, visited);"
"GenericConversionService.java:601"$1$"				addInterfacesToClassHierarchy(Enum.class, array, hierarchy, visited);"
"GenericConversionService.java:602"$1$"			}"
"GenericConversionService.java:603"$0$""
"GenericConversionService.java:604"$0$"			addToClassHierarchy(hierarchy.size(), Object.class, array, hierarchy, visited);"
"GenericConversionService.java:605"$0$"			addToClassHierarchy(hierarchy.size(), Object.class, false, hierarchy, visited);"
"GenericConversionService.java:606"$0$"			return hierarchy;"
"GenericConversionService.java:607"$0$"		}"
"GenericConversionService.java:608"$0$""
"GenericConversionService.java:609"$0$"		private void addInterfacesToClassHierarchy(Class<?> type, boolean asArray,"
"GenericConversionService.java:610"$1$"				List<Class<?>> hierarchy, Set<Class<?>> visited) {"
"GenericConversionService.java:611"$1$""
"GenericConversionService.java:612"$1$"			for (Class<?> implementedInterface : type.getInterfaces()) {"
"GenericConversionService.java:613"$1$"				addToClassHierarchy(hierarchy.size(), implementedInterface, asArray, hierarchy, visited);"
"GenericConversionService.java:614"$1$"			}"
"GenericConversionService.java:615"$0$"		}"
"GenericConversionService.java:616"$0$""
"GenericConversionService.java:617"$0$"		private void addToClassHierarchy(int index, Class<?> type, boolean asArray,"
"GenericConversionService.java:618"$1$"				List<Class<?>> hierarchy, Set<Class<?>> visited) {"
"GenericConversionService.java:619"$1$""
"GenericConversionService.java:620"$1$"			if (asArray) {"
"GenericConversionService.java:621"$1$"				type = Array.newInstance(type, 0).getClass();"
"GenericConversionService.java:622"$1$"			}"
"GenericConversionService.java:623"$1$"			if (visited.add(type)) {"
"GenericConversionService.java:624"$1$"				hierarchy.add(index, type);"
"GenericConversionService.java:625"$1$"			}"
"GenericConversionService.java:626"$0$"		}"
"GenericConversionService.java:627"$0$""
"GenericConversionService.java:628"$0$"		@Override"
"GenericConversionService.java:629"$1$"		public String toString() {"
"GenericConversionService.java:630"$1$"			StringBuilder builder = new StringBuilder();"
"GenericConversionService.java:631"$1$"			builder.append(""ConversionService converters =\n"");"
"GenericConversionService.java:632"$1$"			for (String converterString : getConverterStrings()) {"
"GenericConversionService.java:633"$1$"				builder.append('\t').append(converterString).append('\n');"
"GenericConversionService.java:634"$1$"			}"
"GenericConversionService.java:635"$0$"			return builder.toString();"
"GenericConversionService.java:636"$0$"		}"
"GenericConversionService.java:637"$0$""
"GenericConversionService.java:638"$1$"		private List<String> getConverterStrings() {"
"GenericConversionService.java:639"$1$"			List<String> converterStrings = new ArrayList<>();"
"GenericConversionService.java:640"$1$"			for (ConvertersForPair convertersForPair : this.converters.values()) {"
"GenericConversionService.java:641"$1$"				converterStrings.add(convertersForPair.toString());"
"GenericConversionService.java:642"$1$"			}"
"GenericConversionService.java:643"$0$"			Collections.sort(converterStrings);"
"GenericConversionService.java:644"$0$"			return converterStrings;"
"GenericConversionService.java:645"$0$"		}"
"GenericConversionService.java:646"$0$"	}"
"GenericConversionService.java:647"$0$""
"GenericConversionService.java:648"$0$""
"GenericConversionService.java:649"$0$"	/**"
"GenericConversionService.java:650"$1$"	 * Manages converters registered with a specific {@link ConvertiblePair}."
"GenericConversionService.java:651"$0$"	 */"
"GenericConversionService.java:652"$1$"	private static class ConvertersForPair {"
"GenericConversionService.java:653"$1$""
"GenericConversionService.java:654"$1$"		private final LinkedList<GenericConverter> converters = new LinkedList<>();"
"GenericConversionService.java:655"$1$""
"GenericConversionService.java:656"$1$"		public void add(GenericConverter converter) {"
"GenericConversionService.java:657"$1$"			this.converters.addFirst(converter);"
"GenericConversionService.java:658"$1$"		}"
"GenericConversionService.java:659"$0$""
"GenericConversionService.java:660"$0$"		@Nullable"
"GenericConversionService.java:661"$1$"		public GenericConverter getConverter(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:662"$1$"			for (GenericConverter converter : this.converters) {"
"GenericConversionService.java:663"$1$"				if (!(converter instanceof ConditionalGenericConverter) ||"
"GenericConversionService.java:664"$1$"						((ConditionalGenericConverter) converter).matches(sourceType, targetType)) {"
"GenericConversionService.java:665"$1$"					return converter;"
"GenericConversionService.java:666"$1$"				}"
"GenericConversionService.java:667"$0$"			}"
"GenericConversionService.java:668"$0$"			return null;"
"GenericConversionService.java:669"$0$"		}"
"GenericConversionService.java:670"$0$""
"GenericConversionService.java:671"$0$"		@Override"
"GenericConversionService.java:672"$1$"		public String toString() {"
"GenericConversionService.java:673"$1$"			return StringUtils.collectionToCommaDelimitedString(this.converters);"
"GenericConversionService.java:674"$1$"		}"
"GenericConversionService.java:675"$0$"	}"
"GenericConversionService.java:676"$0$""
"GenericConversionService.java:677"$0$""
"GenericConversionService.java:678"$0$"	/**"
"GenericConversionService.java:679"$0$"	 * Internal converter that performs no operation."
"GenericConversionService.java:680"$0$"	 */"
"GenericConversionService.java:681"$1$"	private static class NoOpConverter implements GenericConverter {"
"GenericConversionService.java:682"$1$""
"GenericConversionService.java:683"$1$"		private final String name;"
"GenericConversionService.java:684"$1$""
"GenericConversionService.java:685"$1$"		public NoOpConverter(String name) {"
"GenericConversionService.java:686"$1$"			this.name = name;"
"GenericConversionService.java:687"$1$"		}"
"GenericConversionService.java:688"$0$""
"GenericConversionService.java:689"$0$"		@Override"
"GenericConversionService.java:690"$1$"		public Set<ConvertiblePair> getConvertibleTypes() {"
"GenericConversionService.java:691"$1$"			return null;"
"GenericConversionService.java:692"$1$"		}"
"GenericConversionService.java:693"$0$""
"GenericConversionService.java:694"$0$"		@Override"
"GenericConversionService.java:695"$0$"		@Nullable"
"GenericConversionService.java:696"$1$"		public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"GenericConversionService.java:697"$1$"			return source;"
"GenericConversionService.java:698"$1$"		}"
"GenericConversionService.java:699"$0$""
"GenericConversionService.java:700"$0$"		@Override"
"GenericConversionService.java:701"$1$"		public String toString() {"
"GenericConversionService.java:702"$1$"			return this.name;"
"GenericConversionService.java:703"$1$"		}"
"GenericConversionService.java:704"$0$"	}"
"GenericConversionService.java:705"$0$""
"GenericConversionService.java:706"$0$"}"
"NumberUtils.java:1"$0$"/*"
"NumberUtils.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"NumberUtils.java:3"$0$" *"
"NumberUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"NumberUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"NumberUtils.java:6"$0$" * You may obtain a copy of the License at"
"NumberUtils.java:7"$0$" *"
"NumberUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"NumberUtils.java:9"$0$" *"
"NumberUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"NumberUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"NumberUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"NumberUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"NumberUtils.java:14"$0$" * limitations under the License."
"NumberUtils.java:15"$0$" */"
"NumberUtils.java:16"$0$""
"NumberUtils.java:17"$0$"package org.springframework.util;"
"NumberUtils.java:18"$0$""
"NumberUtils.java:19"$0$"import java.math.BigDecimal;"
"NumberUtils.java:20"$0$"import java.math.BigInteger;"
"NumberUtils.java:21"$0$"import java.text.DecimalFormat;"
"NumberUtils.java:22"$0$"import java.text.NumberFormat;"
"NumberUtils.java:23"$0$"import java.text.ParseException;"
"NumberUtils.java:24"$0$"import java.util.Collections;"
"NumberUtils.java:25"$0$"import java.util.HashSet;"
"NumberUtils.java:26"$0$"import java.util.Set;"
"NumberUtils.java:27"$0$""
"NumberUtils.java:28"$0$"import org.springframework.lang.Nullable;"
"NumberUtils.java:29"$0$""
"NumberUtils.java:30"$0$"/**"
"NumberUtils.java:31"$0$" * Miscellaneous utility methods for number conversion and parsing."
"NumberUtils.java:32"$0$" * <p>Mainly for internal use within the framework; consider Apache's"
"NumberUtils.java:33"$0$" * Commons Lang for a more comprehensive suite of number utilities."
"NumberUtils.java:34"$0$" *"
"NumberUtils.java:35"$0$" * @author Juergen Hoeller"
"NumberUtils.java:36"$0$" * @author Rob Harrop"
"NumberUtils.java:37"$0$" * @since 1.1.2"
"NumberUtils.java:38"$0$" */"
"NumberUtils.java:39"$1$"public abstract class NumberUtils {"
"NumberUtils.java:40"$1$""
"NumberUtils.java:41"$1$"	private static final BigInteger LONG_MIN = BigInteger.valueOf(Long.MIN_VALUE);"
"NumberUtils.java:42"$1$""
"NumberUtils.java:43"$1$"	private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);"
"NumberUtils.java:44"$1$""
"NumberUtils.java:45"$1$"	/**"
"NumberUtils.java:46"$1$"	 * Standard number types (all immutable):"
"NumberUtils.java:47"$1$"	 * Byte, Short, Integer, Long, BigInteger, Float, Double, BigDecimal."
"NumberUtils.java:48"$1$"	 */"
"NumberUtils.java:49"$1$"	public static final Set<Class<?>> STANDARD_NUMBER_TYPES;"
"NumberUtils.java:50"$1$""
"NumberUtils.java:51"$1$"	static {"
"NumberUtils.java:52"$1$"		Set<Class<?>> numberTypes = new HashSet<>(8);"
"NumberUtils.java:53"$1$"		numberTypes.add(Byte.class);"
"NumberUtils.java:54"$1$"		numberTypes.add(Short.class);"
"NumberUtils.java:55"$1$"		numberTypes.add(Integer.class);"
"NumberUtils.java:56"$1$"		numberTypes.add(Long.class);"
"NumberUtils.java:57"$1$"		numberTypes.add(BigInteger.class);"
"NumberUtils.java:58"$1$"		numberTypes.add(Float.class);"
"NumberUtils.java:59"$1$"		numberTypes.add(Double.class);"
"NumberUtils.java:60"$1$"		numberTypes.add(BigDecimal.class);"
"NumberUtils.java:61"$1$"		STANDARD_NUMBER_TYPES = Collections.unmodifiableSet(numberTypes);"
"NumberUtils.java:62"$1$"	}"
"NumberUtils.java:63"$0$""
"NumberUtils.java:64"$0$""
"NumberUtils.java:65"$0$"	/**"
"NumberUtils.java:66"$0$"	 * Convert the given number into an instance of the given target class."
"NumberUtils.java:67"$0$"	 * @param number the number to convert"
"NumberUtils.java:68"$0$"	 * @param targetClass the target class to convert to"
"NumberUtils.java:69"$0$"	 * @return the converted number"
"NumberUtils.java:70"$0$"	 * @throws IllegalArgumentException if the target class is not supported"
"NumberUtils.java:71"$0$"	 * (i.e. not a standard Number subclass as included in the JDK)"
"NumberUtils.java:72"$0$"	 * @see java.lang.Byte"
"NumberUtils.java:73"$0$"	 * @see java.lang.Short"
"NumberUtils.java:74"$0$"	 * @see java.lang.Integer"
"NumberUtils.java:75"$0$"	 * @see java.lang.Long"
"NumberUtils.java:76"$0$"	 * @see java.math.BigInteger"
"NumberUtils.java:77"$0$"	 * @see java.lang.Float"
"NumberUtils.java:78"$0$"	 * @see java.lang.Double"
"NumberUtils.java:79"$0$"	 * @see java.math.BigDecimal"
"NumberUtils.java:80"$0$"	 */"
"NumberUtils.java:81"$0$"	@SuppressWarnings(""unchecked"")"
"NumberUtils.java:82"$0$"	public static <T extends Number> T convertNumberToTargetClass(Number number, Class<T> targetClass)"
"NumberUtils.java:83"$1$"			throws IllegalArgumentException {"
"NumberUtils.java:84"$1$""
"NumberUtils.java:85"$1$"		Assert.notNull(number, ""Number must not be null"");"
"NumberUtils.java:86"$1$"		Assert.notNull(targetClass, ""Target class must not be null"");"
"NumberUtils.java:87"$1$""
"NumberUtils.java:88"$1$"		if (targetClass.isInstance(number)) {"
"NumberUtils.java:89"$1$"			return (T) number;"
"NumberUtils.java:90"$1$"		}"
"NumberUtils.java:91"$1$"		else if (Byte.class == targetClass) {"
"NumberUtils.java:92"$1$"			long value = checkedLongValue(number, targetClass);"
"NumberUtils.java:93"$1$"			if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {"
"NumberUtils.java:94"$1$"				raiseOverflowException(number, targetClass);"
"NumberUtils.java:95"$1$"			}"
"NumberUtils.java:96"$0$"			return (T) Byte.valueOf(number.byteValue());"
"NumberUtils.java:97"$0$"		}"
"NumberUtils.java:98"$1$"		else if (Short.class == targetClass) {"
"NumberUtils.java:99"$1$"			long value = checkedLongValue(number, targetClass);"
"NumberUtils.java:100"$1$"			if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {"
"NumberUtils.java:101"$1$"				raiseOverflowException(number, targetClass);"
"NumberUtils.java:102"$1$"			}"
"NumberUtils.java:103"$0$"			return (T) Short.valueOf(number.shortValue());"
"NumberUtils.java:104"$0$"		}"
"NumberUtils.java:105"$1$"		else if (Integer.class == targetClass) {"
"NumberUtils.java:106"$1$"			long value = checkedLongValue(number, targetClass);"
"NumberUtils.java:107"$1$"			if (value < Integer.MIN_VALUE || value > Integer.MAX_VALUE) {"
"NumberUtils.java:108"$1$"				raiseOverflowException(number, targetClass);"
"NumberUtils.java:109"$1$"			}"
"NumberUtils.java:110"$0$"			return (T) Integer.valueOf(number.intValue());"
"NumberUtils.java:111"$0$"		}"
"NumberUtils.java:112"$1$"		else if (Long.class == targetClass) {"
"NumberUtils.java:113"$1$"			long value = checkedLongValue(number, targetClass);"
"NumberUtils.java:114"$1$"			return (T) Long.valueOf(value);"
"NumberUtils.java:115"$1$"		}"
"NumberUtils.java:116"$1$"		else if (BigInteger.class == targetClass) {"
"NumberUtils.java:117"$1$"			if (number instanceof BigDecimal) {"
"NumberUtils.java:118"$0$"				// do not lose precision - use BigDecimal's own conversion"
"NumberUtils.java:119"$1$"				return (T) ((BigDecimal) number).toBigInteger();"
"NumberUtils.java:120"$1$"			}"
"NumberUtils.java:121"$1$"			else {"
"NumberUtils.java:122"$0$"				// original value is not a Big* number - use standard long conversion"
"NumberUtils.java:123"$1$"				return (T) BigInteger.valueOf(number.longValue());"
"NumberUtils.java:124"$1$"			}"
"NumberUtils.java:125"$0$"		}"
"NumberUtils.java:126"$1$"		else if (Float.class == targetClass) {"
"NumberUtils.java:127"$1$"			return (T) Float.valueOf(number.floatValue());"
"NumberUtils.java:128"$1$"		}"
"NumberUtils.java:129"$1$"		else if (Double.class == targetClass) {"
"NumberUtils.java:130"$1$"			return (T) Double.valueOf(number.doubleValue());"
"NumberUtils.java:131"$1$"		}"
"NumberUtils.java:132"$1$"		else if (BigDecimal.class == targetClass) {"
"NumberUtils.java:133"$0$"			// always use BigDecimal(String) here to avoid unpredictability of BigDecimal(double)"
"NumberUtils.java:134"$0$"			// (see BigDecimal javadoc for details)"
"NumberUtils.java:135"$1$"			return (T) new BigDecimal(number.toString());"
"NumberUtils.java:136"$1$"		}"
"NumberUtils.java:137"$1$"		else {"
"NumberUtils.java:138"$1$"			throw new IllegalArgumentException(""Could not convert number ["" + number + ""] of type ["" +"
"NumberUtils.java:139"$1$"					number.getClass().getName() + ""] to unsupported target class ["" + targetClass.getName() + ""]"");"
"NumberUtils.java:140"$1$"		}"
"NumberUtils.java:141"$0$"	}"
"NumberUtils.java:142"$0$""
"NumberUtils.java:143"$0$"	/**"
"NumberUtils.java:144"$1$"	 * Check for a {@code BigInteger}/{@code BigDecimal} long overflow"
"NumberUtils.java:145"$0$"	 * before returning the given number as a long value."
"NumberUtils.java:146"$0$"	 * @param number the number to convert"
"NumberUtils.java:147"$0$"	 * @param targetClass the target class to convert to"
"NumberUtils.java:148"$0$"	 * @return the long value, if convertible without overflow"
"NumberUtils.java:149"$0$"	 * @throws IllegalArgumentException if there is an overflow"
"NumberUtils.java:150"$0$"	 * @see #raiseOverflowException"
"NumberUtils.java:151"$0$"	 */"
"NumberUtils.java:152"$1$"	private static long checkedLongValue(Number number, Class<? extends Number> targetClass) {"
"NumberUtils.java:153"$1$"		BigInteger bigInt = null;"
"NumberUtils.java:154"$1$"		if (number instanceof BigInteger) {"
"NumberUtils.java:155"$1$"			bigInt = (BigInteger) number;"
"NumberUtils.java:156"$1$"		}"
"NumberUtils.java:157"$1$"		else if (number instanceof BigDecimal) {"
"NumberUtils.java:158"$1$"			bigInt = ((BigDecimal) number).toBigInteger();"
"NumberUtils.java:159"$1$"		}"
"NumberUtils.java:160"$0$"		// Effectively analogous to JDK 8's BigInteger.longValueExact()"
"NumberUtils.java:161"$1$"		if (bigInt != null && (bigInt.compareTo(LONG_MIN) < 0 || bigInt.compareTo(LONG_MAX) > 0)) {"
"NumberUtils.java:162"$1$"			raiseOverflowException(number, targetClass);"
"NumberUtils.java:163"$1$"		}"
"NumberUtils.java:164"$0$"		return number.longValue();"
"NumberUtils.java:165"$0$"	}"
"NumberUtils.java:166"$0$""
"NumberUtils.java:167"$0$"	/**"
"NumberUtils.java:168"$0$"	 * Raise an <em>overflow</em> exception for the given number and target class."
"NumberUtils.java:169"$0$"	 * @param number the number we tried to convert"
"NumberUtils.java:170"$0$"	 * @param targetClass the target class we tried to convert to"
"NumberUtils.java:171"$0$"	 * @throws IllegalArgumentException if there is an overflow"
"NumberUtils.java:172"$0$"	 */"
"NumberUtils.java:173"$1$"	private static void raiseOverflowException(Number number, Class<?> targetClass) {"
"NumberUtils.java:174"$1$"		throw new IllegalArgumentException(""Could not convert number ["" + number + ""] of type ["" +"
"NumberUtils.java:175"$1$"				number.getClass().getName() + ""] to target class ["" + targetClass.getName() + ""]: overflow"");"
"NumberUtils.java:176"$1$"	}"
"NumberUtils.java:177"$0$""
"NumberUtils.java:178"$0$"	/**"
"NumberUtils.java:179"$1$"	 * Parse the given {@code text} into a {@link Number} instance of the given"
"NumberUtils.java:180"$1$"	 * target class, using the corresponding {@code decode} / {@code valueOf} method."
"NumberUtils.java:181"$0$"	 * <p>Trims all whitespace (leading, trailing, and in between characters) from"
"NumberUtils.java:182"$1$"	 * the input {@code String} before attempting to parse the number."
"NumberUtils.java:183"$0$"	 * <p>Supports numbers in hex format (with leading ""0x"", ""0X"", or ""#"") as well."
"NumberUtils.java:184"$0$"	 * @param text the text to convert"
"NumberUtils.java:185"$0$"	 * @param targetClass the target class to parse into"
"NumberUtils.java:186"$0$"	 * @return the parsed number"
"NumberUtils.java:187"$0$"	 * @throws IllegalArgumentException if the target class is not supported"
"NumberUtils.java:188"$0$"	 * (i.e. not a standard Number subclass as included in the JDK)"
"NumberUtils.java:189"$0$"	 * @see Byte#decode"
"NumberUtils.java:190"$0$"	 * @see Short#decode"
"NumberUtils.java:191"$0$"	 * @see Integer#decode"
"NumberUtils.java:192"$0$"	 * @see Long#decode"
"NumberUtils.java:193"$0$"	 * @see #decodeBigInteger(String)"
"NumberUtils.java:194"$0$"	 * @see Float#valueOf"
"NumberUtils.java:195"$0$"	 * @see Double#valueOf"
"NumberUtils.java:196"$0$"	 * @see java.math.BigDecimal#BigDecimal(String)"
"NumberUtils.java:197"$0$"	 */"
"NumberUtils.java:198"$0$"	@SuppressWarnings(""unchecked"")"
"NumberUtils.java:199"$1$"	public static <T extends Number> T parseNumber(String text, Class<T> targetClass) {"
"NumberUtils.java:200"$1$"		Assert.notNull(text, ""Text must not be null"");"
"NumberUtils.java:201"$1$"		Assert.notNull(targetClass, ""Target class must not be null"");"
"NumberUtils.java:202"$1$"		String trimmed = StringUtils.trimAllWhitespace(text);"
"NumberUtils.java:203"$1$""
"NumberUtils.java:204"$1$"		if (Byte.class == targetClass) {"
"NumberUtils.java:205"$1$"			return (T) (isHexNumber(trimmed) ? Byte.decode(trimmed) : Byte.valueOf(trimmed));"
"NumberUtils.java:206"$1$"		}"
"NumberUtils.java:207"$1$"		else if (Short.class == targetClass) {"
"NumberUtils.java:208"$1$"			return (T) (isHexNumber(trimmed) ? Short.decode(trimmed) : Short.valueOf(trimmed));"
"NumberUtils.java:209"$1$"		}"
"NumberUtils.java:210"$1$"		else if (Integer.class == targetClass) {"
"NumberUtils.java:211"$1$"			return (T) (isHexNumber(trimmed) ? Integer.decode(trimmed) : Integer.valueOf(trimmed));"
"NumberUtils.java:212"$1$"		}"
"NumberUtils.java:213"$1$"		else if (Long.class == targetClass) {"
"NumberUtils.java:214"$1$"			return (T) (isHexNumber(trimmed) ? Long.decode(trimmed) : Long.valueOf(trimmed));"
"NumberUtils.java:215"$1$"		}"
"NumberUtils.java:216"$1$"		else if (BigInteger.class == targetClass) {"
"NumberUtils.java:217"$1$"			return (T) (isHexNumber(trimmed) ? decodeBigInteger(trimmed) : new BigInteger(trimmed));"
"NumberUtils.java:218"$1$"		}"
"NumberUtils.java:219"$1$"		else if (Float.class == targetClass) {"
"NumberUtils.java:220"$1$"			return (T) Float.valueOf(trimmed);"
"NumberUtils.java:221"$1$"		}"
"NumberUtils.java:222"$1$"		else if (Double.class == targetClass) {"
"NumberUtils.java:223"$1$"			return (T) Double.valueOf(trimmed);"
"NumberUtils.java:224"$1$"		}"
"NumberUtils.java:225"$1$"		else if (BigDecimal.class == targetClass || Number.class == targetClass) {"
"NumberUtils.java:226"$1$"			return (T) new BigDecimal(trimmed);"
"NumberUtils.java:227"$1$"		}"
"NumberUtils.java:228"$1$"		else {"
"NumberUtils.java:229"$1$"			throw new IllegalArgumentException("
"NumberUtils.java:230"$1$"					""Cannot convert String ["" + text + ""] to target class ["" + targetClass.getName() + ""]"");"
"NumberUtils.java:231"$1$"		}"
"NumberUtils.java:232"$0$"	}"
"NumberUtils.java:233"$0$""
"NumberUtils.java:234"$0$"	/**"
"NumberUtils.java:235"$1$"	 * Parse the given {@code text} into a {@link Number} instance of the"
"NumberUtils.java:236"$1$"	 * given target class, using the supplied {@link NumberFormat}."
"NumberUtils.java:237"$1$"	 * <p>Trims the input {@code String} before attempting to parse the number."
"NumberUtils.java:238"$0$"	 * @param text the text to convert"
"NumberUtils.java:239"$0$"	 * @param targetClass the target class to parse into"
"NumberUtils.java:240"$1$"	 * @param numberFormat the {@code NumberFormat} to use for parsing (if"
"NumberUtils.java:241"$1$"	 * {@code null}, this method falls back to {@link #parseNumber(String, Class)})"
"NumberUtils.java:242"$0$"	 * @return the parsed number"
"NumberUtils.java:243"$0$"	 * @throws IllegalArgumentException if the target class is not supported"
"NumberUtils.java:244"$0$"	 * (i.e. not a standard Number subclass as included in the JDK)"
"NumberUtils.java:245"$0$"	 * @see java.text.NumberFormat#parse"
"NumberUtils.java:246"$0$"	 * @see #convertNumberToTargetClass"
"NumberUtils.java:247"$0$"	 * @see #parseNumber(String, Class)"
"NumberUtils.java:248"$0$"	 */"
"NumberUtils.java:249"$0$"	public static <T extends Number> T parseNumber("
"NumberUtils.java:250"$1$"			String text, Class<T> targetClass, @Nullable NumberFormat numberFormat) {"
"NumberUtils.java:251"$1$""
"NumberUtils.java:252"$1$"		if (numberFormat != null) {"
"NumberUtils.java:253"$1$"			Assert.notNull(text, ""Text must not be null"");"
"NumberUtils.java:254"$1$"			Assert.notNull(targetClass, ""Target class must not be null"");"
"NumberUtils.java:255"$1$"			DecimalFormat decimalFormat = null;"
"NumberUtils.java:256"$1$"			boolean resetBigDecimal = false;"
"NumberUtils.java:257"$1$"			if (numberFormat instanceof DecimalFormat) {"
"NumberUtils.java:258"$1$"				decimalFormat = (DecimalFormat) numberFormat;"
"NumberUtils.java:259"$1$"				if (BigDecimal.class == targetClass && !decimalFormat.isParseBigDecimal()) {"
"NumberUtils.java:260"$1$"					decimalFormat.setParseBigDecimal(true);"
"NumberUtils.java:261"$1$"					resetBigDecimal = true;"
"NumberUtils.java:262"$1$"				}"
"NumberUtils.java:263"$0$"			}"
"NumberUtils.java:264"$1$"			try {"
"NumberUtils.java:265"$1$"				Number number = numberFormat.parse(StringUtils.trimAllWhitespace(text));"
"NumberUtils.java:266"$1$"				return convertNumberToTargetClass(number, targetClass);"
"NumberUtils.java:267"$1$"			}"
"NumberUtils.java:268"$1$"			catch (ParseException ex) {"
"NumberUtils.java:269"$1$"				throw new IllegalArgumentException(""Could not parse number: "" + ex.getMessage());"
"NumberUtils.java:270"$1$"			}"
"NumberUtils.java:271"$1$"			finally {"
"NumberUtils.java:272"$1$"				if (resetBigDecimal) {"
"NumberUtils.java:273"$1$"					decimalFormat.setParseBigDecimal(false);"
"NumberUtils.java:274"$1$"				}"
"NumberUtils.java:275"$0$"			}"
"NumberUtils.java:276"$0$"		}"
"NumberUtils.java:277"$1$"		else {"
"NumberUtils.java:278"$1$"			return parseNumber(text, targetClass);"
"NumberUtils.java:279"$1$"		}"
"NumberUtils.java:280"$0$"	}"
"NumberUtils.java:281"$0$""
"NumberUtils.java:282"$0$"	/**"
"NumberUtils.java:283"$1$"	 * Determine whether the given {@code value} String indicates a hex number,"
"NumberUtils.java:284"$1$"	 * i.e. needs to be passed into {@code Integer.decode} instead of"
"NumberUtils.java:285"$1$"	 * {@code Integer.valueOf}, etc."
"NumberUtils.java:286"$0$"	 */"
"NumberUtils.java:287"$1$"	private static boolean isHexNumber(String value) {"
"NumberUtils.java:288"$1$"		int index = (value.startsWith(""-"") ? 1 : 0);"
"NumberUtils.java:289"$1$"		return (value.startsWith(""0x"", index) || value.startsWith(""0X"", index) || value.startsWith(""#"", index));"
"NumberUtils.java:290"$1$"	}"
"NumberUtils.java:291"$0$""
"NumberUtils.java:292"$0$"	/**"
"NumberUtils.java:293"$1$"	 * Decode a {@link java.math.BigInteger} from the supplied {@link String} value."
"NumberUtils.java:294"$0$"	 * <p>Supports decimal, hex, and octal notation."
"NumberUtils.java:295"$0$"	 * @see BigInteger#BigInteger(String, int)"
"NumberUtils.java:296"$0$"	 */"
"NumberUtils.java:297"$1$"	private static BigInteger decodeBigInteger(String value) {"
"NumberUtils.java:298"$1$"		int radix = 10;"
"NumberUtils.java:299"$1$"		int index = 0;"
"NumberUtils.java:300"$1$"		boolean negative = false;"
"NumberUtils.java:301"$1$""
"NumberUtils.java:302"$0$"		// Handle minus sign, if present."
"NumberUtils.java:303"$1$"		if (value.startsWith(""-"")) {"
"NumberUtils.java:304"$1$"			negative = true;"
"NumberUtils.java:305"$1$"			index++;"
"NumberUtils.java:306"$1$"		}"
"NumberUtils.java:307"$0$""
"NumberUtils.java:308"$0$"		// Handle radix specifier, if present."
"NumberUtils.java:309"$1$"		if (value.startsWith(""0x"", index) || value.startsWith(""0X"", index)) {"
"NumberUtils.java:310"$1$"			index += 2;"
"NumberUtils.java:311"$1$"			radix = 16;"
"NumberUtils.java:312"$1$"		}"
"NumberUtils.java:313"$1$"		else if (value.startsWith(""#"", index)) {"
"NumberUtils.java:314"$1$"			index++;"
"NumberUtils.java:315"$1$"			radix = 16;"
"NumberUtils.java:316"$1$"		}"
"NumberUtils.java:317"$1$"		else if (value.startsWith(""0"", index) && value.length() > 1 + index) {"
"NumberUtils.java:318"$1$"			index++;"
"NumberUtils.java:319"$1$"			radix = 8;"
"NumberUtils.java:320"$1$"		}"
"NumberUtils.java:321"$0$""
"NumberUtils.java:322"$0$"		BigInteger result = new BigInteger(value.substring(index), radix);"
"NumberUtils.java:323"$0$"		return (negative ? result.negate() : result);"
"NumberUtils.java:324"$0$"	}"
"NumberUtils.java:325"$0$""
"NumberUtils.java:326"$0$"}"
"DataSize.java:1"$0$"/*"
"DataSize.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DataSize.java:3"$0$" *"
"DataSize.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DataSize.java:5"$0$" * you may not use this file except in compliance with the License."
"DataSize.java:6"$0$" * You may obtain a copy of the License at"
"DataSize.java:7"$0$" *"
"DataSize.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DataSize.java:9"$0$" *"
"DataSize.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DataSize.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DataSize.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DataSize.java:13"$0$" * See the License for the specific language governing permissions and"
"DataSize.java:14"$0$" * limitations under the License."
"DataSize.java:15"$0$" */"
"DataSize.java:16"$0$""
"DataSize.java:17"$0$"package org.springframework.util.unit;"
"DataSize.java:18"$0$""
"DataSize.java:19"$0$"import java.util.regex.Matcher;"
"DataSize.java:20"$0$"import java.util.regex.Pattern;"
"DataSize.java:21"$0$""
"DataSize.java:22"$0$"import org.springframework.lang.Nullable;"
"DataSize.java:23"$0$"import org.springframework.util.Assert;"
"DataSize.java:24"$0$"import org.springframework.util.StringUtils;"
"DataSize.java:25"$0$""
"DataSize.java:26"$0$"/**"
"DataSize.java:27"$0$" * A data size, such as '12MB'."
"DataSize.java:28"$0$" *"
"DataSize.java:29"$0$" * <p>This class models data size in terms of bytes and is immutable and thread-safe."
"DataSize.java:30"$0$" *"
"DataSize.java:31"$0$" * <p>The terms and units used in this class are based on"
"DataSize.java:32"$0$" * <a href=""https://en.wikipedia.org/wiki/Binary_prefix"">binary prefixes</a>"
"DataSize.java:33"$0$" * indicating multiplication by powers of 2. Consult the following table and"
"DataSize.java:34"$1$" * the Javadoc for {@link DataUnit} for details."
"DataSize.java:35"$0$" *"
"DataSize.java:36"$0$" * <p>"
"DataSize.java:37"$0$" * <table border=""1"">"
"DataSize.java:38"$0$" * <tr><th>Term</th><th>Data Size</th><th>Size in Bytes</th></tr>"
"DataSize.java:39"$0$" * <tr><td>byte</td><td>1B</td><td>1</td></tr>"
"DataSize.java:40"$0$" * <tr><td>kilobyte</td><td>1KB</td><td>1,024</td></tr>"
"DataSize.java:41"$0$" * <tr><td>megabyte</td><td>1MB</td><td>1,048,576</td></tr>"
"DataSize.java:42"$0$" * <tr><td>gigabyte</td><td>1GB</td><td>1,073,741,824</td></tr>"
"DataSize.java:43"$0$" * <tr><td>terabyte</td><td>1TB</td><td>1,099,511,627,776</td></tr>"
"DataSize.java:44"$0$" * </table>"
"DataSize.java:45"$0$" *"
"DataSize.java:46"$0$" * @author Stephane Nicoll"
"DataSize.java:47"$0$" * @author Sam Brannen"
"DataSize.java:48"$0$" * @since 5.1"
"DataSize.java:49"$0$" * @see DataUnit"
"DataSize.java:50"$0$" */"
"DataSize.java:51"$1$"public final class DataSize implements Comparable<DataSize> {"
"DataSize.java:52"$1$""
"DataSize.java:53"$1$"	/**"
"DataSize.java:54"$1$"	 * The pattern for parsing."
"DataSize.java:55"$1$"	 */"
"DataSize.java:56"$1$"	private static final Pattern PATTERN = Pattern.compile(""^([+\\-]?\\d+)([a-zA-Z]{0,2})$"");"
"DataSize.java:57"$1$""
"DataSize.java:58"$1$"	/**"
"DataSize.java:59"$1$"	 * Bytes per Kilobyte."
"DataSize.java:60"$1$"	 */"
"DataSize.java:61"$1$"	private static final long BYTES_PER_KB = 1024;"
"DataSize.java:62"$1$""
"DataSize.java:63"$1$"	/**"
"DataSize.java:64"$1$"	 * Bytes per Megabyte."
"DataSize.java:65"$1$"	 */"
"DataSize.java:66"$1$"	private static final long BYTES_PER_MB = BYTES_PER_KB * 1024;"
"DataSize.java:67"$1$""
"DataSize.java:68"$1$"	/**"
"DataSize.java:69"$1$"	 * Bytes per Gigabyte."
"DataSize.java:70"$1$"	 */"
"DataSize.java:71"$1$"	private static final long BYTES_PER_GB = BYTES_PER_MB * 1024;"
"DataSize.java:72"$1$""
"DataSize.java:73"$1$"	/**"
"DataSize.java:74"$1$"	 * Bytes per Terabyte."
"DataSize.java:75"$1$"	 */"
"DataSize.java:76"$1$"	private static final long BYTES_PER_TB = BYTES_PER_GB * 1024;"
"DataSize.java:77"$1$""
"DataSize.java:78"$1$""
"DataSize.java:79"$1$"	private final long bytes;"
"DataSize.java:80"$1$""
"DataSize.java:81"$1$""
"DataSize.java:82"$1$"	private DataSize(long bytes) {"
"DataSize.java:83"$1$"		this.bytes = bytes;"
"DataSize.java:84"$1$"	}"
"DataSize.java:85"$0$""
"DataSize.java:86"$0$""
"DataSize.java:87"$0$"	/**"
"DataSize.java:88"$1$"	 * Obtain a {@link DataSize} representing the specified number of bytes."
"DataSize.java:89"$0$"	 * @param bytes the number of bytes, positive or negative"
"DataSize.java:90"$1$"	 * @return a {@link DataSize}"
"DataSize.java:91"$0$"	 */"
"DataSize.java:92"$1$"	public static DataSize ofBytes(long bytes) {"
"DataSize.java:93"$1$"		return new DataSize(bytes);"
"DataSize.java:94"$1$"	}"
"DataSize.java:95"$0$""
"DataSize.java:96"$0$"	/**"
"DataSize.java:97"$1$"	 * Obtain a {@link DataSize} representing the specified number of kilobytes."
"DataSize.java:98"$0$"	 * @param kilobytes the number of kilobytes, positive or negative"
"DataSize.java:99"$1$"	 * @return a {@link DataSize}"
"DataSize.java:100"$0$"	 */"
"DataSize.java:101"$1$"	public static DataSize ofKilobytes(long kilobytes) {"
"DataSize.java:102"$1$"		return new DataSize(Math.multiplyExact(kilobytes, BYTES_PER_KB));"
"DataSize.java:103"$1$"	}"
"DataSize.java:104"$0$""
"DataSize.java:105"$0$"	/**"
"DataSize.java:106"$1$"	 * Obtain a {@link DataSize} representing the specified number of megabytes."
"DataSize.java:107"$0$"	 * @param megabytes the number of megabytes, positive or negative"
"DataSize.java:108"$1$"	 * @return a {@link DataSize}"
"DataSize.java:109"$0$"	 */"
"DataSize.java:110"$1$"	public static DataSize ofMegabytes(long megabytes) {"
"DataSize.java:111"$1$"		return new DataSize(Math.multiplyExact(megabytes, BYTES_PER_MB));"
"DataSize.java:112"$1$"	}"
"DataSize.java:113"$0$""
"DataSize.java:114"$0$"	/**"
"DataSize.java:115"$1$"	 * Obtain a {@link DataSize} representing the specified number of gigabytes."
"DataSize.java:116"$0$"	 * @param gigabytes the number of gigabytes, positive or negative"
"DataSize.java:117"$1$"	 * @return a {@link DataSize}"
"DataSize.java:118"$0$"	 */"
"DataSize.java:119"$1$"	public static DataSize ofGigabytes(long gigabytes) {"
"DataSize.java:120"$1$"		return new DataSize(Math.multiplyExact(gigabytes, BYTES_PER_GB));"
"DataSize.java:121"$1$"	}"
"DataSize.java:122"$0$""
"DataSize.java:123"$0$"	/**"
"DataSize.java:124"$1$"	 * Obtain a {@link DataSize} representing the specified number of terabytes."
"DataSize.java:125"$0$"	 * @param terabytes the number of terabytes, positive or negative"
"DataSize.java:126"$1$"	 * @return a {@link DataSize}"
"DataSize.java:127"$0$"	 */"
"DataSize.java:128"$1$"	public static DataSize ofTerabytes(long terabytes) {"
"DataSize.java:129"$1$"		return new DataSize(Math.multiplyExact(terabytes, BYTES_PER_TB));"
"DataSize.java:130"$1$"	}"
"DataSize.java:131"$0$""
"DataSize.java:132"$0$"	/**"
"DataSize.java:133"$1$"	 * Obtain a {@link DataSize} representing an amount in the specified {@link DataUnit}."
"DataSize.java:134"$0$"	 * @param amount the amount of the size, measured in terms of the unit,"
"DataSize.java:135"$0$"	 * positive or negative"
"DataSize.java:136"$1$"	 * @return a corresponding {@link DataSize}"
"DataSize.java:137"$0$"	 */"
"DataSize.java:138"$1$"	public static DataSize of(long amount, DataUnit unit) {"
"DataSize.java:139"$1$"		Assert.notNull(unit, ""Unit must not be null"");"
"DataSize.java:140"$1$"		return new DataSize(Math.multiplyExact(amount, unit.size().toBytes()));"
"DataSize.java:141"$1$"	}"
"DataSize.java:142"$0$""
"DataSize.java:143"$0$"	/**"
"DataSize.java:144"$1$"	 * Obtain a {@link DataSize} from a text string such as {@code 12MB} using"
"DataSize.java:145"$1$"	 * {@link DataUnit#BYTES} if no unit is specified."
"DataSize.java:146"$0$"	 * <p>"
"DataSize.java:147"$0$"	 * Examples:"
"DataSize.java:148"$0$"	 * <pre>"
"DataSize.java:149"$0$"	 * ""12KB"" -- parses as ""12 kilobytes"""
"DataSize.java:150"$0$"	 * ""5MB""  -- parses as ""5 megabytes"""
"DataSize.java:151"$0$"	 * ""20""   -- parses as ""20 bytes"""
"DataSize.java:152"$0$"	 * </pre>"
"DataSize.java:153"$0$"	 * @param text the text to parse"
"DataSize.java:154"$1$"	 * @return the parsed {@link DataSize}"
"DataSize.java:155"$0$"	 * @see #parse(CharSequence, DataUnit)"
"DataSize.java:156"$0$"	 */"
"DataSize.java:157"$1$"	public static DataSize parse(CharSequence text) {"
"DataSize.java:158"$1$"		return parse(text, null);"
"DataSize.java:159"$1$"	}"
"DataSize.java:160"$0$""
"DataSize.java:161"$0$"	/**"
"DataSize.java:162"$1$"	 * Obtain a {@link DataSize} from a text string such as {@code 12MB} using"
"DataSize.java:163"$1$"	 * the specified default {@link DataUnit} if no unit is specified."
"DataSize.java:164"$0$"	 * <p>"
"DataSize.java:165"$0$"	 * The string starts with a number followed optionally by a unit matching one of the"
"DataSize.java:166"$1$"	 * supported {@linkplain DataUnit suffixes}."
"DataSize.java:167"$0$"	 * <p>"
"DataSize.java:168"$0$"	 * Examples:"
"DataSize.java:169"$0$"	 * <pre>"
"DataSize.java:170"$0$"	 * ""12KB"" -- parses as ""12 kilobytes"""
"DataSize.java:171"$0$"	 * ""5MB""  -- parses as ""5 megabytes"""
"DataSize.java:172"$1$"	 * ""20""   -- parses as ""20 kilobytes"" (where the {@code defaultUnit} is {@link DataUnit#KILOBYTES})"
"DataSize.java:173"$0$"	 * </pre>"
"DataSize.java:174"$0$"	 * @param text the text to parse"
"DataSize.java:175"$1$"	 * @return the parsed {@link DataSize}"
"DataSize.java:176"$0$"	 */"
"DataSize.java:177"$1$"	public static DataSize parse(CharSequence text, @Nullable DataUnit defaultUnit) {"
"DataSize.java:178"$1$"		Assert.notNull(text, ""Text must not be null"");"
"DataSize.java:179"$1$"		try {"
"DataSize.java:180"$1$"			Matcher matcher = PATTERN.matcher(text);"
"DataSize.java:181"$1$"			Assert.state(matcher.matches(), ""Does not match data size pattern"");"
"DataSize.java:182"$1$"			DataUnit unit = determineDataUnit(matcher.group(2), defaultUnit);"
"DataSize.java:183"$1$"			long amount = Long.parseLong(matcher.group(1));"
"DataSize.java:184"$1$"			return DataSize.of(amount, unit);"
"DataSize.java:185"$1$"		}"
"DataSize.java:186"$1$"		catch (Exception ex) {"
"DataSize.java:187"$1$"			throw new IllegalArgumentException(""'"" + text + ""' is not a valid data size"", ex);"
"DataSize.java:188"$1$"		}"
"DataSize.java:189"$0$"	}"
"DataSize.java:190"$0$""
"DataSize.java:191"$1$"	private static DataUnit determineDataUnit(String suffix, @Nullable DataUnit defaultUnit) {"
"DataSize.java:192"$1$"		DataUnit defaultUnitToUse = (defaultUnit != null ? defaultUnit : DataUnit.BYTES);"
"DataSize.java:193"$1$"		return (StringUtils.hasLength(suffix) ? DataUnit.fromSuffix(suffix) : defaultUnitToUse);"
"DataSize.java:194"$1$"	}"
"DataSize.java:195"$0$""
"DataSize.java:196"$0$"	/**"
"DataSize.java:197"$0$"	 * Checks if this size is negative, excluding zero."
"DataSize.java:198"$0$"	 * @return true if this size has a size less than zero bytes"
"DataSize.java:199"$0$"	 */"
"DataSize.java:200"$1$"	public boolean isNegative() {"
"DataSize.java:201"$1$"		return this.bytes < 0;"
"DataSize.java:202"$1$"	}"
"DataSize.java:203"$0$""
"DataSize.java:204"$0$"	/**"
"DataSize.java:205"$0$"	 * Return the number of bytes in this instance."
"DataSize.java:206"$0$"	 * @return the number of bytes"
"DataSize.java:207"$0$"	 */"
"DataSize.java:208"$1$"	public long toBytes() {"
"DataSize.java:209"$1$"		return this.bytes;"
"DataSize.java:210"$1$"	}"
"DataSize.java:211"$0$""
"DataSize.java:212"$0$"	/**"
"DataSize.java:213"$0$"	 * Return the number of kilobytes in this instance."
"DataSize.java:214"$0$"	 * @return the number of kilobytes"
"DataSize.java:215"$0$"	 */"
"DataSize.java:216"$1$"	public long toKilobytes() {"
"DataSize.java:217"$1$"		return this.bytes / BYTES_PER_KB;"
"DataSize.java:218"$1$"	}"
"DataSize.java:219"$0$""
"DataSize.java:220"$0$"	/**"
"DataSize.java:221"$0$"	 * Return the number of megabytes in this instance."
"DataSize.java:222"$0$"	 * @return the number of megabytes"
"DataSize.java:223"$0$"	 */"
"DataSize.java:224"$1$"	public long toMegabytes() {"
"DataSize.java:225"$1$"		return this.bytes / BYTES_PER_MB;"
"DataSize.java:226"$1$"	}"
"DataSize.java:227"$0$""
"DataSize.java:228"$0$"	/**"
"DataSize.java:229"$0$"	 * Return the number of gigabytes in this instance."
"DataSize.java:230"$0$"	 * @return the number of gigabytes"
"DataSize.java:231"$0$"	 */"
"DataSize.java:232"$1$"	public long toGigabytes() {"
"DataSize.java:233"$1$"		return this.bytes / BYTES_PER_GB;"
"DataSize.java:234"$1$"	}"
"DataSize.java:235"$0$""
"DataSize.java:236"$0$"	/**"
"DataSize.java:237"$0$"	 * Return the number of terabytes in this instance."
"DataSize.java:238"$0$"	 * @return the number of terabytes"
"DataSize.java:239"$0$"	 */"
"DataSize.java:240"$1$"	public long toTerabytes() {"
"DataSize.java:241"$1$"		return this.bytes / BYTES_PER_TB;"
"DataSize.java:242"$1$"	}"
"DataSize.java:243"$0$""
"DataSize.java:244"$0$"	@Override"
"DataSize.java:245"$1$"	public int compareTo(DataSize other) {"
"DataSize.java:246"$1$"		return Long.compare(this.bytes, other.bytes);"
"DataSize.java:247"$1$"	}"
"DataSize.java:248"$0$""
"DataSize.java:249"$0$"	@Override"
"DataSize.java:250"$1$"	public String toString() {"
"DataSize.java:251"$1$"		return String.format(""%dB"", this.bytes);"
"DataSize.java:252"$1$"	}"
"DataSize.java:253"$0$""
"DataSize.java:254"$0$""
"DataSize.java:255"$0$"	@Override"
"DataSize.java:256"$1$"	public boolean equals(@Nullable Object other) {"
"DataSize.java:257"$1$"		if (this == other) {"
"DataSize.java:258"$1$"			return true;"
"DataSize.java:259"$1$"		}"
"DataSize.java:260"$1$"		if (other == null || getClass() != other.getClass()) {"
"DataSize.java:261"$1$"			return false;"
"DataSize.java:262"$1$"		}"
"DataSize.java:263"$0$"		DataSize otherSize = (DataSize) other;"
"DataSize.java:264"$0$"		return (this.bytes == otherSize.bytes);"
"DataSize.java:265"$0$"	}"
"DataSize.java:266"$0$""
"DataSize.java:267"$0$"	@Override"
"DataSize.java:268"$1$"	public int hashCode() {"
"DataSize.java:269"$1$"		return Long.hashCode(this.bytes);"
"DataSize.java:270"$1$"	}"
"DataSize.java:271"$0$""
"DataSize.java:272"$0$"}"
"AnnotationAwareOrderComparator.java:1"$0$"/*"
"AnnotationAwareOrderComparator.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotationAwareOrderComparator.java:3"$0$" *"
"AnnotationAwareOrderComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationAwareOrderComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationAwareOrderComparator.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationAwareOrderComparator.java:7"$0$" *"
"AnnotationAwareOrderComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationAwareOrderComparator.java:9"$0$" *"
"AnnotationAwareOrderComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationAwareOrderComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationAwareOrderComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationAwareOrderComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationAwareOrderComparator.java:14"$0$" * limitations under the License."
"AnnotationAwareOrderComparator.java:15"$0$" */"
"AnnotationAwareOrderComparator.java:16"$0$""
"AnnotationAwareOrderComparator.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationAwareOrderComparator.java:18"$0$""
"AnnotationAwareOrderComparator.java:19"$0$"import java.lang.reflect.AnnotatedElement;"
"AnnotationAwareOrderComparator.java:20"$0$"import java.util.Arrays;"
"AnnotationAwareOrderComparator.java:21"$0$"import java.util.List;"
"AnnotationAwareOrderComparator.java:22"$0$""
"AnnotationAwareOrderComparator.java:23"$0$"import org.springframework.core.DecoratingProxy;"
"AnnotationAwareOrderComparator.java:24"$0$"import org.springframework.core.OrderComparator;"
"AnnotationAwareOrderComparator.java:25"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"AnnotationAwareOrderComparator.java:26"$0$"import org.springframework.lang.Nullable;"
"AnnotationAwareOrderComparator.java:27"$0$""
"AnnotationAwareOrderComparator.java:28"$0$"/**"
"AnnotationAwareOrderComparator.java:29"$1$" * {@code AnnotationAwareOrderComparator} is an extension of"
"AnnotationAwareOrderComparator.java:30"$1$" * {@link OrderComparator} that supports Spring's"
"AnnotationAwareOrderComparator.java:31"$1$" * {@link org.springframework.core.Ordered} interface as well as the"
"AnnotationAwareOrderComparator.java:32"$1$" * {@link Order @Order} and {@link javax.annotation.Priority @Priority}"
"AnnotationAwareOrderComparator.java:33"$1$" * annotations, with an order value provided by an {@code Ordered}"
"AnnotationAwareOrderComparator.java:34"$0$" * instance overriding a statically defined annotation value (if any)."
"AnnotationAwareOrderComparator.java:35"$0$" *"
"AnnotationAwareOrderComparator.java:36"$1$" * <p>Consult the Javadoc for {@link OrderComparator} for details on the"
"AnnotationAwareOrderComparator.java:37"$0$" * sort semantics for non-ordered objects."
"AnnotationAwareOrderComparator.java:38"$0$" *"
"AnnotationAwareOrderComparator.java:39"$0$" * @author Juergen Hoeller"
"AnnotationAwareOrderComparator.java:40"$0$" * @author Oliver Gierke"
"AnnotationAwareOrderComparator.java:41"$0$" * @author Stephane Nicoll"
"AnnotationAwareOrderComparator.java:42"$0$" * @since 2.0.1"
"AnnotationAwareOrderComparator.java:43"$0$" * @see org.springframework.core.Ordered"
"AnnotationAwareOrderComparator.java:44"$0$" * @see org.springframework.core.annotation.Order"
"AnnotationAwareOrderComparator.java:45"$0$" * @see javax.annotation.Priority"
"AnnotationAwareOrderComparator.java:46"$0$" */"
"AnnotationAwareOrderComparator.java:47"$1$"public class AnnotationAwareOrderComparator extends OrderComparator {"
"AnnotationAwareOrderComparator.java:48"$1$""
"AnnotationAwareOrderComparator.java:49"$1$"	/**"
"AnnotationAwareOrderComparator.java:50"$1$"	 * Shared default instance of {@code AnnotationAwareOrderComparator}."
"AnnotationAwareOrderComparator.java:51"$1$"	 */"
"AnnotationAwareOrderComparator.java:52"$1$"	public static final AnnotationAwareOrderComparator INSTANCE = new AnnotationAwareOrderComparator();"
"AnnotationAwareOrderComparator.java:53"$1$""
"AnnotationAwareOrderComparator.java:54"$1$""
"AnnotationAwareOrderComparator.java:55"$1$"	/**"
"AnnotationAwareOrderComparator.java:56"$1$"	 * This implementation checks for {@link Order @Order} or"
"AnnotationAwareOrderComparator.java:57"$1$"	 * {@link javax.annotation.Priority @Priority} on various kinds of"
"AnnotationAwareOrderComparator.java:58"$1$"	 * elements, in addition to the {@link org.springframework.core.Ordered}"
"AnnotationAwareOrderComparator.java:59"$1$"	 * check in the superclass."
"AnnotationAwareOrderComparator.java:60"$1$"	 */"
"AnnotationAwareOrderComparator.java:61"$1$"	@Override"
"AnnotationAwareOrderComparator.java:62"$1$"	@Nullable"
"AnnotationAwareOrderComparator.java:63"$1$"	protected Integer findOrder(Object obj) {"
"AnnotationAwareOrderComparator.java:64"$1$"		Integer order = super.findOrder(obj);"
"AnnotationAwareOrderComparator.java:65"$1$"		if (order != null) {"
"AnnotationAwareOrderComparator.java:66"$1$"			return order;"
"AnnotationAwareOrderComparator.java:67"$1$"		}"
"AnnotationAwareOrderComparator.java:68"$0$"		return findOrderFromAnnotation(obj);"
"AnnotationAwareOrderComparator.java:69"$0$"	}"
"AnnotationAwareOrderComparator.java:70"$0$""
"AnnotationAwareOrderComparator.java:71"$0$"	@Nullable"
"AnnotationAwareOrderComparator.java:72"$1$"	private Integer findOrderFromAnnotation(Object obj) {"
"AnnotationAwareOrderComparator.java:73"$1$"		AnnotatedElement element = (obj instanceof AnnotatedElement ? (AnnotatedElement) obj : obj.getClass());"
"AnnotationAwareOrderComparator.java:74"$1$"		MergedAnnotations annotations = MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY);"
"AnnotationAwareOrderComparator.java:75"$1$"		Integer order = OrderUtils.getOrderFromAnnotations(element, annotations);"
"AnnotationAwareOrderComparator.java:76"$1$"		if (order == null && obj instanceof DecoratingProxy) {"
"AnnotationAwareOrderComparator.java:77"$1$"			return findOrderFromAnnotation(((DecoratingProxy) obj).getDecoratedClass());"
"AnnotationAwareOrderComparator.java:78"$1$"		}"
"AnnotationAwareOrderComparator.java:79"$0$"		return order;"
"AnnotationAwareOrderComparator.java:80"$0$"	}"
"AnnotationAwareOrderComparator.java:81"$0$""
"AnnotationAwareOrderComparator.java:82"$0$"	/**"
"AnnotationAwareOrderComparator.java:83"$1$"	 * This implementation retrieves an @{@link javax.annotation.Priority}"
"AnnotationAwareOrderComparator.java:84"$1$"	 * value, allowing for additional semantics over the regular @{@link Order}"
"AnnotationAwareOrderComparator.java:85"$0$"	 * annotation: typically, selecting one object over another in case of"
"AnnotationAwareOrderComparator.java:86"$0$"	 * multiple matches but only one object to be returned."
"AnnotationAwareOrderComparator.java:87"$0$"	 */"
"AnnotationAwareOrderComparator.java:88"$0$"	@Override"
"AnnotationAwareOrderComparator.java:89"$0$"	@Nullable"
"AnnotationAwareOrderComparator.java:90"$1$"	public Integer getPriority(Object obj) {"
"AnnotationAwareOrderComparator.java:91"$1$"		if (obj instanceof Class) {"
"AnnotationAwareOrderComparator.java:92"$1$"			return OrderUtils.getPriority((Class<?>) obj);"
"AnnotationAwareOrderComparator.java:93"$1$"		}"
"AnnotationAwareOrderComparator.java:94"$0$"		Integer priority = OrderUtils.getPriority(obj.getClass());"
"AnnotationAwareOrderComparator.java:95"$1$"		if (priority == null  && obj instanceof DecoratingProxy) {"
"AnnotationAwareOrderComparator.java:96"$1$"			return getPriority(((DecoratingProxy) obj).getDecoratedClass());"
"AnnotationAwareOrderComparator.java:97"$1$"		}"
"AnnotationAwareOrderComparator.java:98"$0$"		return priority;"
"AnnotationAwareOrderComparator.java:99"$0$"	}"
"AnnotationAwareOrderComparator.java:100"$0$""
"AnnotationAwareOrderComparator.java:101"$0$""
"AnnotationAwareOrderComparator.java:102"$0$"	/**"
"AnnotationAwareOrderComparator.java:103"$1$"	 * Sort the given list with a default {@link AnnotationAwareOrderComparator}."
"AnnotationAwareOrderComparator.java:104"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"AnnotationAwareOrderComparator.java:105"$0$"	 * in order to avoid unnecessary array extraction."
"AnnotationAwareOrderComparator.java:106"$0$"	 * @param list the List to sort"
"AnnotationAwareOrderComparator.java:107"$0$"	 * @see java.util.List#sort(java.util.Comparator)"
"AnnotationAwareOrderComparator.java:108"$0$"	 */"
"AnnotationAwareOrderComparator.java:109"$1$"	public static void sort(List<?> list) {"
"AnnotationAwareOrderComparator.java:110"$1$"		if (list.size() > 1) {"
"AnnotationAwareOrderComparator.java:111"$1$"			list.sort(INSTANCE);"
"AnnotationAwareOrderComparator.java:112"$1$"		}"
"AnnotationAwareOrderComparator.java:113"$0$"	}"
"AnnotationAwareOrderComparator.java:114"$0$""
"AnnotationAwareOrderComparator.java:115"$0$"	/**"
"AnnotationAwareOrderComparator.java:116"$0$"	 * Sort the given array with a default AnnotationAwareOrderComparator."
"AnnotationAwareOrderComparator.java:117"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"AnnotationAwareOrderComparator.java:118"$0$"	 * in order to avoid unnecessary array extraction."
"AnnotationAwareOrderComparator.java:119"$0$"	 * @param array the array to sort"
"AnnotationAwareOrderComparator.java:120"$0$"	 * @see java.util.Arrays#sort(Object[], java.util.Comparator)"
"AnnotationAwareOrderComparator.java:121"$0$"	 */"
"AnnotationAwareOrderComparator.java:122"$1$"	public static void sort(Object[] array) {"
"AnnotationAwareOrderComparator.java:123"$1$"		if (array.length > 1) {"
"AnnotationAwareOrderComparator.java:124"$1$"			Arrays.sort(array, INSTANCE);"
"AnnotationAwareOrderComparator.java:125"$1$"		}"
"AnnotationAwareOrderComparator.java:126"$0$"	}"
"AnnotationAwareOrderComparator.java:127"$0$""
"AnnotationAwareOrderComparator.java:128"$0$"	/**"
"AnnotationAwareOrderComparator.java:129"$0$"	 * Sort the given array or List with a default AnnotationAwareOrderComparator,"
"AnnotationAwareOrderComparator.java:130"$0$"	 * if necessary. Simply skips sorting when given any other value."
"AnnotationAwareOrderComparator.java:131"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"AnnotationAwareOrderComparator.java:132"$0$"	 * in order to avoid unnecessary array extraction."
"AnnotationAwareOrderComparator.java:133"$0$"	 * @param value the array or List to sort"
"AnnotationAwareOrderComparator.java:134"$0$"	 * @see java.util.Arrays#sort(Object[], java.util.Comparator)"
"AnnotationAwareOrderComparator.java:135"$0$"	 */"
"AnnotationAwareOrderComparator.java:136"$1$"	public static void sortIfNecessary(Object value) {"
"AnnotationAwareOrderComparator.java:137"$1$"		if (value instanceof Object[]) {"
"AnnotationAwareOrderComparator.java:138"$1$"			sort((Object[]) value);"
"AnnotationAwareOrderComparator.java:139"$1$"		}"
"AnnotationAwareOrderComparator.java:140"$1$"		else if (value instanceof List) {"
"AnnotationAwareOrderComparator.java:141"$1$"			sort((List<?>) value);"
"AnnotationAwareOrderComparator.java:142"$1$"		}"
"AnnotationAwareOrderComparator.java:143"$0$"	}"
"AnnotationAwareOrderComparator.java:144"$0$""
"AnnotationAwareOrderComparator.java:145"$0$"}"
"StaxStreamXMLReader.java:1"$0$"/*"
"StaxStreamXMLReader.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"StaxStreamXMLReader.java:3"$0$" *"
"StaxStreamXMLReader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxStreamXMLReader.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxStreamXMLReader.java:6"$0$" * You may obtain a copy of the License at"
"StaxStreamXMLReader.java:7"$0$" *"
"StaxStreamXMLReader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxStreamXMLReader.java:9"$0$" *"
"StaxStreamXMLReader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxStreamXMLReader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxStreamXMLReader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxStreamXMLReader.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxStreamXMLReader.java:14"$0$" * limitations under the License."
"StaxStreamXMLReader.java:15"$0$" */"
"StaxStreamXMLReader.java:16"$0$""
"StaxStreamXMLReader.java:17"$0$"package org.springframework.util.xml;"
"StaxStreamXMLReader.java:18"$0$""
"StaxStreamXMLReader.java:19"$0$"import javax.xml.namespace.QName;"
"StaxStreamXMLReader.java:20"$0$"import javax.xml.stream.Location;"
"StaxStreamXMLReader.java:21"$0$"import javax.xml.stream.XMLStreamConstants;"
"StaxStreamXMLReader.java:22"$0$"import javax.xml.stream.XMLStreamException;"
"StaxStreamXMLReader.java:23"$0$"import javax.xml.stream.XMLStreamReader;"
"StaxStreamXMLReader.java:24"$0$""
"StaxStreamXMLReader.java:25"$0$"import org.xml.sax.Attributes;"
"StaxStreamXMLReader.java:26"$0$"import org.xml.sax.SAXException;"
"StaxStreamXMLReader.java:27"$0$"import org.xml.sax.ext.Locator2;"
"StaxStreamXMLReader.java:28"$0$"import org.xml.sax.helpers.AttributesImpl;"
"StaxStreamXMLReader.java:29"$0$""
"StaxStreamXMLReader.java:30"$0$"import org.springframework.lang.Nullable;"
"StaxStreamXMLReader.java:31"$0$"import org.springframework.util.StringUtils;"
"StaxStreamXMLReader.java:32"$0$""
"StaxStreamXMLReader.java:33"$0$"/**"
"StaxStreamXMLReader.java:34"$1$" * SAX {@code XMLReader} that reads from a StAX {@code XMLStreamReader}. Reads from an"
"StaxStreamXMLReader.java:35"$1$" * {@code XMLStreamReader}, and calls the corresponding methods on the SAX callback interfaces."
"StaxStreamXMLReader.java:36"$0$" *"
"StaxStreamXMLReader.java:37"$0$" * @author Arjen Poutsma"
"StaxStreamXMLReader.java:38"$0$" * @since 3.0"
"StaxStreamXMLReader.java:39"$0$" * @see XMLStreamReader"
"StaxStreamXMLReader.java:40"$0$" * @see #setContentHandler(org.xml.sax.ContentHandler)"
"StaxStreamXMLReader.java:41"$0$" * @see #setDTDHandler(org.xml.sax.DTDHandler)"
"StaxStreamXMLReader.java:42"$0$" * @see #setEntityResolver(org.xml.sax.EntityResolver)"
"StaxStreamXMLReader.java:43"$0$" * @see #setErrorHandler(org.xml.sax.ErrorHandler)"
"StaxStreamXMLReader.java:44"$0$" */"
"StaxStreamXMLReader.java:45"$1$"class StaxStreamXMLReader extends AbstractStaxXMLReader {"
"StaxStreamXMLReader.java:46"$1$""
"StaxStreamXMLReader.java:47"$1$"	private static final String DEFAULT_XML_VERSION = ""1.0"";"
"StaxStreamXMLReader.java:48"$1$""
"StaxStreamXMLReader.java:49"$1$"	private final XMLStreamReader reader;"
"StaxStreamXMLReader.java:50"$1$""
"StaxStreamXMLReader.java:51"$1$"	private String xmlVersion = DEFAULT_XML_VERSION;"
"StaxStreamXMLReader.java:52"$1$""
"StaxStreamXMLReader.java:53"$1$"	@Nullable"
"StaxStreamXMLReader.java:54"$1$"	private String encoding;"
"StaxStreamXMLReader.java:55"$1$""
"StaxStreamXMLReader.java:56"$1$""
"StaxStreamXMLReader.java:57"$1$"	/**"
"StaxStreamXMLReader.java:58"$1$"	 * Construct a new instance of the {@code StaxStreamXmlReader} that reads from the given"
"StaxStreamXMLReader.java:59"$1$"	 * {@code XMLStreamReader}. The supplied stream reader must be in {@code XMLStreamConstants.START_DOCUMENT}"
"StaxStreamXMLReader.java:60"$1$"	 * or {@code XMLStreamConstants.START_ELEMENT} state."
"StaxStreamXMLReader.java:61"$1$"	 * @param reader the {@code XMLEventReader} to read from"
"StaxStreamXMLReader.java:62"$1$"	 * @throws IllegalStateException if the reader is not at the start of a document or element"
"StaxStreamXMLReader.java:63"$1$"	 */"
"StaxStreamXMLReader.java:64"$1$"	StaxStreamXMLReader(XMLStreamReader reader) {"
"StaxStreamXMLReader.java:65"$1$"		int event = reader.getEventType();"
"StaxStreamXMLReader.java:66"$1$"		if (!(event == XMLStreamConstants.START_DOCUMENT || event == XMLStreamConstants.START_ELEMENT)) {"
"StaxStreamXMLReader.java:67"$1$"			throw new IllegalStateException(""XMLEventReader not at start of document or element"");"
"StaxStreamXMLReader.java:68"$1$"		}"
"StaxStreamXMLReader.java:69"$0$"		this.reader = reader;"
"StaxStreamXMLReader.java:70"$0$"	}"
"StaxStreamXMLReader.java:71"$0$""
"StaxStreamXMLReader.java:72"$0$""
"StaxStreamXMLReader.java:73"$0$"	@Override"
"StaxStreamXMLReader.java:74"$1$"	protected void parseInternal() throws SAXException, XMLStreamException {"
"StaxStreamXMLReader.java:75"$1$"		boolean documentStarted = false;"
"StaxStreamXMLReader.java:76"$1$"		boolean documentEnded = false;"
"StaxStreamXMLReader.java:77"$1$"		int elementDepth = 0;"
"StaxStreamXMLReader.java:78"$1$"		int eventType = this.reader.getEventType();"
"StaxStreamXMLReader.java:79"$1$"		while (true) {"
"StaxStreamXMLReader.java:80"$1$"			if (eventType != XMLStreamConstants.START_DOCUMENT && eventType != XMLStreamConstants.END_DOCUMENT &&"
"StaxStreamXMLReader.java:81"$1$"					!documentStarted) {"
"StaxStreamXMLReader.java:82"$1$"				handleStartDocument();"
"StaxStreamXMLReader.java:83"$1$"				documentStarted = true;"
"StaxStreamXMLReader.java:84"$1$"			}"
"StaxStreamXMLReader.java:85"$1$"			switch (eventType) {"
"StaxStreamXMLReader.java:86"$1$"				case XMLStreamConstants.START_ELEMENT:"
"StaxStreamXMLReader.java:87"$1$"					elementDepth++;"
"StaxStreamXMLReader.java:88"$1$"					handleStartElement();"
"StaxStreamXMLReader.java:89"$1$"					break;"
"StaxStreamXMLReader.java:90"$1$"				case XMLStreamConstants.END_ELEMENT:"
"StaxStreamXMLReader.java:91"$1$"					elementDepth--;"
"StaxStreamXMLReader.java:92"$1$"					if (elementDepth >= 0) {"
"StaxStreamXMLReader.java:93"$1$"						handleEndElement();"
"StaxStreamXMLReader.java:94"$1$"					}"
"StaxStreamXMLReader.java:95"$0$"					break;"
"StaxStreamXMLReader.java:96"$0$"				case XMLStreamConstants.PROCESSING_INSTRUCTION:"
"StaxStreamXMLReader.java:97"$0$"					handleProcessingInstruction();"
"StaxStreamXMLReader.java:98"$0$"					break;"
"StaxStreamXMLReader.java:99"$0$"				case XMLStreamConstants.CHARACTERS:"
"StaxStreamXMLReader.java:100"$0$"				case XMLStreamConstants.SPACE:"
"StaxStreamXMLReader.java:101"$0$"				case XMLStreamConstants.CDATA:"
"StaxStreamXMLReader.java:102"$0$"					handleCharacters();"
"StaxStreamXMLReader.java:103"$0$"					break;"
"StaxStreamXMLReader.java:104"$0$"				case XMLStreamConstants.START_DOCUMENT:"
"StaxStreamXMLReader.java:105"$0$"					handleStartDocument();"
"StaxStreamXMLReader.java:106"$0$"					documentStarted = true;"
"StaxStreamXMLReader.java:107"$0$"					break;"
"StaxStreamXMLReader.java:108"$0$"				case XMLStreamConstants.END_DOCUMENT:"
"StaxStreamXMLReader.java:109"$0$"					handleEndDocument();"
"StaxStreamXMLReader.java:110"$0$"					documentEnded = true;"
"StaxStreamXMLReader.java:111"$0$"					break;"
"StaxStreamXMLReader.java:112"$0$"				case XMLStreamConstants.COMMENT:"
"StaxStreamXMLReader.java:113"$0$"					handleComment();"
"StaxStreamXMLReader.java:114"$0$"					break;"
"StaxStreamXMLReader.java:115"$0$"				case XMLStreamConstants.DTD:"
"StaxStreamXMLReader.java:116"$0$"					handleDtd();"
"StaxStreamXMLReader.java:117"$0$"					break;"
"StaxStreamXMLReader.java:118"$0$"				case XMLStreamConstants.ENTITY_REFERENCE:"
"StaxStreamXMLReader.java:119"$0$"					handleEntityReference();"
"StaxStreamXMLReader.java:120"$0$"					break;"
"StaxStreamXMLReader.java:121"$0$"			}"
"StaxStreamXMLReader.java:122"$1$"			if (this.reader.hasNext() && elementDepth >= 0) {"
"StaxStreamXMLReader.java:123"$1$"				eventType = this.reader.next();"
"StaxStreamXMLReader.java:124"$1$"			}"
"StaxStreamXMLReader.java:125"$1$"			else {"
"StaxStreamXMLReader.java:126"$1$"				break;"
"StaxStreamXMLReader.java:127"$1$"			}"
"StaxStreamXMLReader.java:128"$0$"		}"
"StaxStreamXMLReader.java:129"$1$"		if (!documentEnded) {"
"StaxStreamXMLReader.java:130"$1$"			handleEndDocument();"
"StaxStreamXMLReader.java:131"$1$"		}"
"StaxStreamXMLReader.java:132"$0$"	}"
"StaxStreamXMLReader.java:133"$0$""
"StaxStreamXMLReader.java:134"$1$"	private void handleStartDocument() throws SAXException {"
"StaxStreamXMLReader.java:135"$1$"		if (XMLStreamConstants.START_DOCUMENT == this.reader.getEventType()) {"
"StaxStreamXMLReader.java:136"$1$"			String xmlVersion = this.reader.getVersion();"
"StaxStreamXMLReader.java:137"$1$"			if (StringUtils.hasLength(xmlVersion)) {"
"StaxStreamXMLReader.java:138"$1$"				this.xmlVersion = xmlVersion;"
"StaxStreamXMLReader.java:139"$1$"			}"
"StaxStreamXMLReader.java:140"$0$"			this.encoding = this.reader.getCharacterEncodingScheme();"
"StaxStreamXMLReader.java:141"$0$"		}"
"StaxStreamXMLReader.java:142"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:143"$1$"			final Location location = this.reader.getLocation();"
"StaxStreamXMLReader.java:144"$1$"			getContentHandler().setDocumentLocator(new Locator2() {"
"StaxStreamXMLReader.java:145"$1$"				@Override"
"StaxStreamXMLReader.java:146"$1$"				public int getColumnNumber() {"
"StaxStreamXMLReader.java:147"$1$"					return (location != null ? location.getColumnNumber() : -1);"
"StaxStreamXMLReader.java:148"$1$"				}"
"StaxStreamXMLReader.java:149"$0$"				@Override"
"StaxStreamXMLReader.java:150"$1$"				public int getLineNumber() {"
"StaxStreamXMLReader.java:151"$1$"					return (location != null ? location.getLineNumber() : -1);"
"StaxStreamXMLReader.java:152"$1$"				}"
"StaxStreamXMLReader.java:153"$0$"				@Override"
"StaxStreamXMLReader.java:154"$0$"				@Nullable"
"StaxStreamXMLReader.java:155"$1$"				public String getPublicId() {"
"StaxStreamXMLReader.java:156"$1$"					return (location != null ? location.getPublicId() : null);"
"StaxStreamXMLReader.java:157"$1$"				}"
"StaxStreamXMLReader.java:158"$0$"				@Override"
"StaxStreamXMLReader.java:159"$0$"				@Nullable"
"StaxStreamXMLReader.java:160"$1$"				public String getSystemId() {"
"StaxStreamXMLReader.java:161"$1$"					return (location != null ? location.getSystemId() : null);"
"StaxStreamXMLReader.java:162"$1$"				}"
"StaxStreamXMLReader.java:163"$0$"				@Override"
"StaxStreamXMLReader.java:164"$1$"				public String getXMLVersion() {"
"StaxStreamXMLReader.java:165"$1$"					return xmlVersion;"
"StaxStreamXMLReader.java:166"$1$"				}"
"StaxStreamXMLReader.java:167"$0$"				@Override"
"StaxStreamXMLReader.java:168"$0$"				@Nullable"
"StaxStreamXMLReader.java:169"$1$"				public String getEncoding() {"
"StaxStreamXMLReader.java:170"$1$"					return encoding;"
"StaxStreamXMLReader.java:171"$1$"				}"
"StaxStreamXMLReader.java:172"$0$"			});"
"StaxStreamXMLReader.java:173"$0$"			getContentHandler().startDocument();"
"StaxStreamXMLReader.java:174"$1$"			if (this.reader.standaloneSet()) {"
"StaxStreamXMLReader.java:175"$1$"				setStandalone(this.reader.isStandalone());"
"StaxStreamXMLReader.java:176"$1$"			}"
"StaxStreamXMLReader.java:177"$0$"		}"
"StaxStreamXMLReader.java:178"$0$"	}"
"StaxStreamXMLReader.java:179"$0$""
"StaxStreamXMLReader.java:180"$1$"	private void handleStartElement() throws SAXException {"
"StaxStreamXMLReader.java:181"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:182"$1$"			QName qName = this.reader.getName();"
"StaxStreamXMLReader.java:183"$1$"			if (hasNamespacesFeature()) {"
"StaxStreamXMLReader.java:184"$1$"				for (int i = 0; i < this.reader.getNamespaceCount(); i++) {"
"StaxStreamXMLReader.java:185"$1$"					startPrefixMapping(this.reader.getNamespacePrefix(i), this.reader.getNamespaceURI(i));"
"StaxStreamXMLReader.java:186"$1$"				}"
"StaxStreamXMLReader.java:187"$1$"				for (int i = 0; i < this.reader.getAttributeCount(); i++) {"
"StaxStreamXMLReader.java:188"$1$"					String prefix = this.reader.getAttributePrefix(i);"
"StaxStreamXMLReader.java:189"$1$"					String namespace = this.reader.getAttributeNamespace(i);"
"StaxStreamXMLReader.java:190"$1$"					if (StringUtils.hasLength(namespace)) {"
"StaxStreamXMLReader.java:191"$1$"						startPrefixMapping(prefix, namespace);"
"StaxStreamXMLReader.java:192"$1$"					}"
"StaxStreamXMLReader.java:193"$0$"				}"
"StaxStreamXMLReader.java:194"$0$"				getContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalPart(),"
"StaxStreamXMLReader.java:195"$0$"						toQualifiedName(qName), getAttributes());"
"StaxStreamXMLReader.java:196"$0$"			}"
"StaxStreamXMLReader.java:197"$1$"			else {"
"StaxStreamXMLReader.java:198"$1$"				getContentHandler().startElement("""", """", toQualifiedName(qName), getAttributes());"
"StaxStreamXMLReader.java:199"$1$"			}"
"StaxStreamXMLReader.java:200"$0$"		}"
"StaxStreamXMLReader.java:201"$0$"	}"
"StaxStreamXMLReader.java:202"$0$""
"StaxStreamXMLReader.java:203"$1$"	private void handleEndElement() throws SAXException {"
"StaxStreamXMLReader.java:204"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:205"$1$"			QName qName = this.reader.getName();"
"StaxStreamXMLReader.java:206"$1$"			if (hasNamespacesFeature()) {"
"StaxStreamXMLReader.java:207"$1$"				getContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName));"
"StaxStreamXMLReader.java:208"$1$"				for (int i = 0; i < this.reader.getNamespaceCount(); i++) {"
"StaxStreamXMLReader.java:209"$1$"					String prefix = this.reader.getNamespacePrefix(i);"
"StaxStreamXMLReader.java:210"$1$"					if (prefix == null) {"
"StaxStreamXMLReader.java:211"$1$"						prefix = """";"
"StaxStreamXMLReader.java:212"$1$"					}"
"StaxStreamXMLReader.java:213"$0$"					endPrefixMapping(prefix);"
"StaxStreamXMLReader.java:214"$0$"				}"
"StaxStreamXMLReader.java:215"$0$"			}"
"StaxStreamXMLReader.java:216"$1$"			else {"
"StaxStreamXMLReader.java:217"$1$"				getContentHandler().endElement("""", """", toQualifiedName(qName));"
"StaxStreamXMLReader.java:218"$1$"			}"
"StaxStreamXMLReader.java:219"$0$"		}"
"StaxStreamXMLReader.java:220"$0$"	}"
"StaxStreamXMLReader.java:221"$0$""
"StaxStreamXMLReader.java:222"$1$"	private void handleCharacters() throws SAXException {"
"StaxStreamXMLReader.java:223"$1$"		if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:224"$1$"			getLexicalHandler().startCDATA();"
"StaxStreamXMLReader.java:225"$1$"		}"
"StaxStreamXMLReader.java:226"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:227"$1$"			getContentHandler().characters(this.reader.getTextCharacters(),"
"StaxStreamXMLReader.java:228"$1$"					this.reader.getTextStart(), this.reader.getTextLength());"
"StaxStreamXMLReader.java:229"$1$"		}"
"StaxStreamXMLReader.java:230"$1$"		if (XMLStreamConstants.CDATA == this.reader.getEventType() && getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:231"$1$"			getLexicalHandler().endCDATA();"
"StaxStreamXMLReader.java:232"$1$"		}"
"StaxStreamXMLReader.java:233"$0$"	}"
"StaxStreamXMLReader.java:234"$0$""
"StaxStreamXMLReader.java:235"$1$"	private void handleComment() throws SAXException {"
"StaxStreamXMLReader.java:236"$1$"		if (getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:237"$1$"			getLexicalHandler().comment(this.reader.getTextCharacters(),"
"StaxStreamXMLReader.java:238"$1$"					this.reader.getTextStart(), this.reader.getTextLength());"
"StaxStreamXMLReader.java:239"$1$"		}"
"StaxStreamXMLReader.java:240"$0$"	}"
"StaxStreamXMLReader.java:241"$0$""
"StaxStreamXMLReader.java:242"$1$"	private void handleDtd() throws SAXException {"
"StaxStreamXMLReader.java:243"$1$"		if (getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:244"$1$"			Location location = this.reader.getLocation();"
"StaxStreamXMLReader.java:245"$1$"			getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());"
"StaxStreamXMLReader.java:246"$1$"		}"
"StaxStreamXMLReader.java:247"$1$"		if (getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:248"$1$"			getLexicalHandler().endDTD();"
"StaxStreamXMLReader.java:249"$1$"		}"
"StaxStreamXMLReader.java:250"$0$"	}"
"StaxStreamXMLReader.java:251"$0$""
"StaxStreamXMLReader.java:252"$1$"	private void handleEntityReference() throws SAXException {"
"StaxStreamXMLReader.java:253"$1$"		if (getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:254"$1$"			getLexicalHandler().startEntity(this.reader.getLocalName());"
"StaxStreamXMLReader.java:255"$1$"		}"
"StaxStreamXMLReader.java:256"$1$"		if (getLexicalHandler() != null) {"
"StaxStreamXMLReader.java:257"$1$"			getLexicalHandler().endEntity(this.reader.getLocalName());"
"StaxStreamXMLReader.java:258"$1$"		}"
"StaxStreamXMLReader.java:259"$0$"	}"
"StaxStreamXMLReader.java:260"$0$""
"StaxStreamXMLReader.java:261"$1$"	private void handleEndDocument() throws SAXException {"
"StaxStreamXMLReader.java:262"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:263"$1$"			getContentHandler().endDocument();"
"StaxStreamXMLReader.java:264"$1$"		}"
"StaxStreamXMLReader.java:265"$0$"	}"
"StaxStreamXMLReader.java:266"$0$""
"StaxStreamXMLReader.java:267"$1$"	private void handleProcessingInstruction() throws SAXException {"
"StaxStreamXMLReader.java:268"$1$"		if (getContentHandler() != null) {"
"StaxStreamXMLReader.java:269"$1$"			getContentHandler().processingInstruction(this.reader.getPITarget(), this.reader.getPIData());"
"StaxStreamXMLReader.java:270"$1$"		}"
"StaxStreamXMLReader.java:271"$0$"	}"
"StaxStreamXMLReader.java:272"$0$""
"StaxStreamXMLReader.java:273"$1$"	private Attributes getAttributes() {"
"StaxStreamXMLReader.java:274"$1$"		AttributesImpl attributes = new AttributesImpl();"
"StaxStreamXMLReader.java:275"$1$"		for (int i = 0; i < this.reader.getAttributeCount(); i++) {"
"StaxStreamXMLReader.java:276"$1$"			String namespace = this.reader.getAttributeNamespace(i);"
"StaxStreamXMLReader.java:277"$1$"			if (namespace == null || !hasNamespacesFeature()) {"
"StaxStreamXMLReader.java:278"$1$"				namespace = """";"
"StaxStreamXMLReader.java:279"$1$"			}"
"StaxStreamXMLReader.java:280"$0$"			String type = this.reader.getAttributeType(i);"
"StaxStreamXMLReader.java:281"$1$"			if (type == null) {"
"StaxStreamXMLReader.java:282"$1$"				type = ""CDATA"";"
"StaxStreamXMLReader.java:283"$1$"			}"
"StaxStreamXMLReader.java:284"$0$"			attributes.addAttribute(namespace, this.reader.getAttributeLocalName(i),"
"StaxStreamXMLReader.java:285"$0$"					toQualifiedName(this.reader.getAttributeName(i)), type, this.reader.getAttributeValue(i));"
"StaxStreamXMLReader.java:286"$0$"		}"
"StaxStreamXMLReader.java:287"$1$"		if (hasNamespacePrefixesFeature()) {"
"StaxStreamXMLReader.java:288"$1$"			for (int i = 0; i < this.reader.getNamespaceCount(); i++) {"
"StaxStreamXMLReader.java:289"$1$"				String prefix = this.reader.getNamespacePrefix(i);"
"StaxStreamXMLReader.java:290"$1$"				String namespaceUri = this.reader.getNamespaceURI(i);"
"StaxStreamXMLReader.java:291"$1$"				String qName;"
"StaxStreamXMLReader.java:292"$1$"				if (StringUtils.hasLength(prefix)) {"
"StaxStreamXMLReader.java:293"$1$"					qName = ""xmlns:"" + prefix;"
"StaxStreamXMLReader.java:294"$1$"				}"
"StaxStreamXMLReader.java:295"$1$"				else {"
"StaxStreamXMLReader.java:296"$1$"					qName = ""xmlns"";"
"StaxStreamXMLReader.java:297"$1$"				}"
"StaxStreamXMLReader.java:298"$0$"				attributes.addAttribute("""", """", qName, ""CDATA"", namespaceUri);"
"StaxStreamXMLReader.java:299"$0$"			}"
"StaxStreamXMLReader.java:300"$0$"		}"
"StaxStreamXMLReader.java:301"$0$""
"StaxStreamXMLReader.java:302"$0$"		return attributes;"
"StaxStreamXMLReader.java:303"$0$"	}"
"StaxStreamXMLReader.java:304"$0$""
"StaxStreamXMLReader.java:305"$0$"}"
"OrderComparator.java:1"$0$"/*"
"OrderComparator.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"OrderComparator.java:3"$0$" *"
"OrderComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"OrderComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"OrderComparator.java:6"$0$" * You may obtain a copy of the License at"
"OrderComparator.java:7"$0$" *"
"OrderComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"OrderComparator.java:9"$0$" *"
"OrderComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"OrderComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"OrderComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"OrderComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"OrderComparator.java:14"$0$" * limitations under the License."
"OrderComparator.java:15"$0$" */"
"OrderComparator.java:16"$0$""
"OrderComparator.java:17"$0$"package org.springframework.core;"
"OrderComparator.java:18"$0$""
"OrderComparator.java:19"$0$"import java.util.Arrays;"
"OrderComparator.java:20"$0$"import java.util.Comparator;"
"OrderComparator.java:21"$0$"import java.util.List;"
"OrderComparator.java:22"$0$""
"OrderComparator.java:23"$0$"import org.springframework.lang.Nullable;"
"OrderComparator.java:24"$0$"import org.springframework.util.ObjectUtils;"
"OrderComparator.java:25"$0$""
"OrderComparator.java:26"$0$"/**"
"OrderComparator.java:27"$1$" * {@link Comparator} implementation for {@link Ordered} objects, sorting"
"OrderComparator.java:28"$0$" * by order value ascending, respectively by priority descending."
"OrderComparator.java:29"$0$" *"
"OrderComparator.java:30"$1$" * <h3>{@code PriorityOrdered} Objects</h3>"
"OrderComparator.java:31"$1$" * <p>{@link PriorityOrdered} objects will be sorted with higher priority than"
"OrderComparator.java:32"$1$" * <em>plain</em> {@code Ordered} objects."
"OrderComparator.java:33"$0$" *"
"OrderComparator.java:34"$0$" * <h3>Same Order Objects</h3>"
"OrderComparator.java:35"$0$" * <p>Objects that have the same order value will be sorted with arbitrary"
"OrderComparator.java:36"$0$" * ordering with respect to other objects with the same order value."
"OrderComparator.java:37"$0$" *"
"OrderComparator.java:38"$0$" * <h3>Non-ordered Objects</h3>"
"OrderComparator.java:39"$0$" * <p>Any object that does not provide its own order value is implicitly"
"OrderComparator.java:40"$1$" * assigned a value of {@link Ordered#LOWEST_PRECEDENCE}, thus ending up"
"OrderComparator.java:41"$0$" * at the end of a sorted collection in arbitrary order with respect to"
"OrderComparator.java:42"$0$" * other objects with the same order value."
"OrderComparator.java:43"$0$" *"
"OrderComparator.java:44"$0$" * @author Juergen Hoeller"
"OrderComparator.java:45"$0$" * @author Sam Brannen"
"OrderComparator.java:46"$0$" * @since 07.04.2003"
"OrderComparator.java:47"$0$" * @see Ordered"
"OrderComparator.java:48"$0$" * @see PriorityOrdered"
"OrderComparator.java:49"$0$" * @see org.springframework.core.annotation.AnnotationAwareOrderComparator"
"OrderComparator.java:50"$0$" * @see java.util.List#sort(java.util.Comparator)"
"OrderComparator.java:51"$0$" * @see java.util.Arrays#sort(Object[], java.util.Comparator)"
"OrderComparator.java:52"$0$" */"
"OrderComparator.java:53"$1$"public class OrderComparator implements Comparator<Object> {"
"OrderComparator.java:54"$1$""
"OrderComparator.java:55"$1$"	/**"
"OrderComparator.java:56"$1$"	 * Shared default instance of {@code OrderComparator}."
"OrderComparator.java:57"$1$"	 */"
"OrderComparator.java:58"$1$"	public static final OrderComparator INSTANCE = new OrderComparator();"
"OrderComparator.java:59"$1$""
"OrderComparator.java:60"$1$""
"OrderComparator.java:61"$1$"	/**"
"OrderComparator.java:62"$1$"	 * Build an adapted order comparator with the given source provider."
"OrderComparator.java:63"$1$"	 * @param sourceProvider the order source provider to use"
"OrderComparator.java:64"$1$"	 * @return the adapted comparator"
"OrderComparator.java:65"$1$"	 * @since 4.1"
"OrderComparator.java:66"$1$"	 */"
"OrderComparator.java:67"$1$"	public Comparator<Object> withSourceProvider(OrderSourceProvider sourceProvider) {"
"OrderComparator.java:68"$1$"		return (o1, o2) -> doCompare(o1, o2, sourceProvider);"
"OrderComparator.java:69"$1$"	}"
"OrderComparator.java:70"$0$""
"OrderComparator.java:71"$0$"	@Override"
"OrderComparator.java:72"$1$"	public int compare(@Nullable Object o1, @Nullable Object o2) {"
"OrderComparator.java:73"$1$"		return doCompare(o1, o2, null);"
"OrderComparator.java:74"$1$"	}"
"OrderComparator.java:75"$0$""
"OrderComparator.java:76"$1$"	private int doCompare(@Nullable Object o1, @Nullable Object o2, @Nullable OrderSourceProvider sourceProvider) {"
"OrderComparator.java:77"$1$"		boolean p1 = (o1 instanceof PriorityOrdered);"
"OrderComparator.java:78"$1$"		boolean p2 = (o2 instanceof PriorityOrdered);"
"OrderComparator.java:79"$1$"		if (p1 && !p2) {"
"OrderComparator.java:80"$1$"			return -1;"
"OrderComparator.java:81"$1$"		}"
"OrderComparator.java:82"$1$"		else if (p2 && !p1) {"
"OrderComparator.java:83"$1$"			return 1;"
"OrderComparator.java:84"$1$"		}"
"OrderComparator.java:85"$0$""
"OrderComparator.java:86"$0$"		int i1 = getOrder(o1, sourceProvider);"
"OrderComparator.java:87"$0$"		int i2 = getOrder(o2, sourceProvider);"
"OrderComparator.java:88"$0$"		return Integer.compare(i1, i2);"
"OrderComparator.java:89"$0$"	}"
"OrderComparator.java:90"$0$""
"OrderComparator.java:91"$0$"	/**"
"OrderComparator.java:92"$0$"	 * Determine the order value for the given object."
"OrderComparator.java:93"$1$"	 * <p>The default implementation checks against the given {@link OrderSourceProvider}"
"OrderComparator.java:94"$1$"	 * using {@link #findOrder} and falls back to a regular {@link #getOrder(Object)} call."
"OrderComparator.java:95"$0$"	 * @param obj the object to check"
"OrderComparator.java:96"$1$"	 * @return the order value, or {@code Ordered.LOWEST_PRECEDENCE} as fallback"
"OrderComparator.java:97"$0$"	 */"
"OrderComparator.java:98"$1$"	private int getOrder(@Nullable Object obj, @Nullable OrderSourceProvider sourceProvider) {"
"OrderComparator.java:99"$1$"		Integer order = null;"
"OrderComparator.java:100"$1$"		if (obj != null && sourceProvider != null) {"
"OrderComparator.java:101"$1$"			Object orderSource = sourceProvider.getOrderSource(obj);"
"OrderComparator.java:102"$1$"			if (orderSource != null) {"
"OrderComparator.java:103"$1$"				if (orderSource.getClass().isArray()) {"
"OrderComparator.java:104"$1$"					Object[] sources = ObjectUtils.toObjectArray(orderSource);"
"OrderComparator.java:105"$1$"					for (Object source : sources) {"
"OrderComparator.java:106"$1$"						order = findOrder(source);"
"OrderComparator.java:107"$1$"						if (order != null) {"
"OrderComparator.java:108"$1$"							break;"
"OrderComparator.java:109"$1$"						}"
"OrderComparator.java:110"$0$"					}"
"OrderComparator.java:111"$0$"				}"
"OrderComparator.java:112"$1$"				else {"
"OrderComparator.java:113"$1$"					order = findOrder(orderSource);"
"OrderComparator.java:114"$1$"				}"
"OrderComparator.java:115"$0$"			}"
"OrderComparator.java:116"$0$"		}"
"OrderComparator.java:117"$0$"		return (order != null ? order : getOrder(obj));"
"OrderComparator.java:118"$0$"	}"
"OrderComparator.java:119"$0$""
"OrderComparator.java:120"$0$"	/**"
"OrderComparator.java:121"$0$"	 * Determine the order value for the given object."
"OrderComparator.java:122"$1$"	 * <p>The default implementation checks against the {@link Ordered} interface"
"OrderComparator.java:123"$1$"	 * through delegating to {@link #findOrder}. Can be overridden in subclasses."
"OrderComparator.java:124"$0$"	 * @param obj the object to check"
"OrderComparator.java:125"$1$"	 * @return the order value, or {@code Ordered.LOWEST_PRECEDENCE} as fallback"
"OrderComparator.java:126"$0$"	 */"
"OrderComparator.java:127"$1$"	protected int getOrder(@Nullable Object obj) {"
"OrderComparator.java:128"$1$"		if (obj != null) {"
"OrderComparator.java:129"$1$"			Integer order = findOrder(obj);"
"OrderComparator.java:130"$1$"			if (order != null) {"
"OrderComparator.java:131"$1$"				return order;"
"OrderComparator.java:132"$1$"			}"
"OrderComparator.java:133"$0$"		}"
"OrderComparator.java:134"$0$"		return Ordered.LOWEST_PRECEDENCE;"
"OrderComparator.java:135"$0$"	}"
"OrderComparator.java:136"$0$""
"OrderComparator.java:137"$0$"	/**"
"OrderComparator.java:138"$0$"	 * Find an order value indicated by the given object."
"OrderComparator.java:139"$1$"	 * <p>The default implementation checks against the {@link Ordered} interface."
"OrderComparator.java:140"$0$"	 * Can be overridden in subclasses."
"OrderComparator.java:141"$0$"	 * @param obj the object to check"
"OrderComparator.java:142"$1$"	 * @return the order value, or {@code null} if none found"
"OrderComparator.java:143"$0$"	 */"
"OrderComparator.java:144"$0$"	@Nullable"
"OrderComparator.java:145"$1$"	protected Integer findOrder(Object obj) {"
"OrderComparator.java:146"$1$"		return (obj instanceof Ordered ? ((Ordered) obj).getOrder() : null);"
"OrderComparator.java:147"$1$"	}"
"OrderComparator.java:148"$0$""
"OrderComparator.java:149"$0$"	/**"
"OrderComparator.java:150"$0$"	 * Determine a priority value for the given object, if any."
"OrderComparator.java:151"$1$"	 * <p>The default implementation always returns {@code null}."
"OrderComparator.java:152"$0$"	 * Subclasses may override this to give specific kinds of values a"
"OrderComparator.java:153"$0$"	 * 'priority' characteristic, in addition to their 'order' semantics."
"OrderComparator.java:154"$0$"	 * A priority indicates that it may be used for selecting one object over"
"OrderComparator.java:155"$0$"	 * another, in addition to serving for ordering purposes in a list/array."
"OrderComparator.java:156"$0$"	 * @param obj the object to check"
"OrderComparator.java:157"$1$"	 * @return the priority value, or {@code null} if none"
"OrderComparator.java:158"$0$"	 * @since 4.1"
"OrderComparator.java:159"$0$"	 */"
"OrderComparator.java:160"$0$"	@Nullable"
"OrderComparator.java:161"$1$"	public Integer getPriority(Object obj) {"
"OrderComparator.java:162"$1$"		return null;"
"OrderComparator.java:163"$1$"	}"
"OrderComparator.java:164"$0$""
"OrderComparator.java:165"$0$""
"OrderComparator.java:166"$0$"	/**"
"OrderComparator.java:167"$0$"	 * Sort the given List with a default OrderComparator."
"OrderComparator.java:168"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"OrderComparator.java:169"$0$"	 * in order to avoid unnecessary array extraction."
"OrderComparator.java:170"$0$"	 * @param list the List to sort"
"OrderComparator.java:171"$0$"	 * @see java.util.List#sort(java.util.Comparator)"
"OrderComparator.java:172"$0$"	 */"
"OrderComparator.java:173"$1$"	public static void sort(List<?> list) {"
"OrderComparator.java:174"$1$"		if (list.size() > 1) {"
"OrderComparator.java:175"$1$"			list.sort(INSTANCE);"
"OrderComparator.java:176"$1$"		}"
"OrderComparator.java:177"$0$"	}"
"OrderComparator.java:178"$0$""
"OrderComparator.java:179"$0$"	/**"
"OrderComparator.java:180"$0$"	 * Sort the given array with a default OrderComparator."
"OrderComparator.java:181"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"OrderComparator.java:182"$0$"	 * in order to avoid unnecessary array extraction."
"OrderComparator.java:183"$0$"	 * @param array the array to sort"
"OrderComparator.java:184"$0$"	 * @see java.util.Arrays#sort(Object[], java.util.Comparator)"
"OrderComparator.java:185"$0$"	 */"
"OrderComparator.java:186"$1$"	public static void sort(Object[] array) {"
"OrderComparator.java:187"$1$"		if (array.length > 1) {"
"OrderComparator.java:188"$1$"			Arrays.sort(array, INSTANCE);"
"OrderComparator.java:189"$1$"		}"
"OrderComparator.java:190"$0$"	}"
"OrderComparator.java:191"$0$""
"OrderComparator.java:192"$0$"	/**"
"OrderComparator.java:193"$0$"	 * Sort the given array or List with a default OrderComparator,"
"OrderComparator.java:194"$0$"	 * if necessary. Simply skips sorting when given any other value."
"OrderComparator.java:195"$0$"	 * <p>Optimized to skip sorting for lists with size 0 or 1,"
"OrderComparator.java:196"$0$"	 * in order to avoid unnecessary array extraction."
"OrderComparator.java:197"$0$"	 * @param value the array or List to sort"
"OrderComparator.java:198"$0$"	 * @see java.util.Arrays#sort(Object[], java.util.Comparator)"
"OrderComparator.java:199"$0$"	 */"
"OrderComparator.java:200"$1$"	public static void sortIfNecessary(Object value) {"
"OrderComparator.java:201"$1$"		if (value instanceof Object[]) {"
"OrderComparator.java:202"$1$"			sort((Object[]) value);"
"OrderComparator.java:203"$1$"		}"
"OrderComparator.java:204"$1$"		else if (value instanceof List) {"
"OrderComparator.java:205"$1$"			sort((List<?>) value);"
"OrderComparator.java:206"$1$"		}"
"OrderComparator.java:207"$0$"	}"
"OrderComparator.java:208"$0$""
"OrderComparator.java:209"$0$""
"OrderComparator.java:210"$0$"	/**"
"OrderComparator.java:211"$0$"	 * Strategy interface to provide an order source for a given object."
"OrderComparator.java:212"$0$"	 * @since 4.1"
"OrderComparator.java:213"$0$"	 */"
"OrderComparator.java:214"$0$"	@FunctionalInterface"
"OrderComparator.java:215"$1$"	public interface OrderSourceProvider {"
"OrderComparator.java:216"$1$""
"OrderComparator.java:217"$1$"		/**"
"OrderComparator.java:218"$1$"		 * Return an order source for the specified object, i.e. an object that"
"OrderComparator.java:219"$1$"		 * should be checked for an order value as a replacement to the given object."
"OrderComparator.java:220"$1$"		 * <p>Can also be an array of order source objects."
"OrderComparator.java:221"$1$"		 * <p>If the returned object does not indicate any order, the comparator"
"OrderComparator.java:222"$1$"		 * will fall back to checking the original object."
"OrderComparator.java:223"$1$"		 * @param obj the object to find an order source for"
"OrderComparator.java:224"$1$"		 * @return the order source for that object, or {@code null} if none found"
"OrderComparator.java:225"$1$"		 */"
"OrderComparator.java:226"$1$"		@Nullable"
"OrderComparator.java:227"$1$"		Object getOrderSource(Object obj);"
"OrderComparator.java:228"$1$"	}"
"OrderComparator.java:229"$0$""
"OrderComparator.java:230"$0$"}"
"ResourceRegionEncoder.java:1"$0$"/*"
"ResourceRegionEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ResourceRegionEncoder.java:3"$0$" *"
"ResourceRegionEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceRegionEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceRegionEncoder.java:6"$0$" * You may obtain a copy of the License at"
"ResourceRegionEncoder.java:7"$0$" *"
"ResourceRegionEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceRegionEncoder.java:9"$0$" *"
"ResourceRegionEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceRegionEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceRegionEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceRegionEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceRegionEncoder.java:14"$0$" * limitations under the License."
"ResourceRegionEncoder.java:15"$0$" */"
"ResourceRegionEncoder.java:16"$0$""
"ResourceRegionEncoder.java:17"$0$"package org.springframework.core.codec;"
"ResourceRegionEncoder.java:18"$0$""
"ResourceRegionEncoder.java:19"$0$"import java.io.IOException;"
"ResourceRegionEncoder.java:20"$0$"import java.nio.charset.StandardCharsets;"
"ResourceRegionEncoder.java:21"$0$"import java.util.Map;"
"ResourceRegionEncoder.java:22"$0$"import java.util.OptionalLong;"
"ResourceRegionEncoder.java:23"$0$""
"ResourceRegionEncoder.java:24"$0$"import org.reactivestreams.Publisher;"
"ResourceRegionEncoder.java:25"$0$"import reactor.core.publisher.Flux;"
"ResourceRegionEncoder.java:26"$0$"import reactor.core.publisher.Mono;"
"ResourceRegionEncoder.java:27"$0$""
"ResourceRegionEncoder.java:28"$0$"import org.springframework.core.ResolvableType;"
"ResourceRegionEncoder.java:29"$0$"import org.springframework.core.io.InputStreamResource;"
"ResourceRegionEncoder.java:30"$0$"import org.springframework.core.io.Resource;"
"ResourceRegionEncoder.java:31"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ResourceRegionEncoder.java:32"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"ResourceRegionEncoder.java:33"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"ResourceRegionEncoder.java:34"$0$"import org.springframework.core.io.support.ResourceRegion;"
"ResourceRegionEncoder.java:35"$0$"import org.springframework.lang.Nullable;"
"ResourceRegionEncoder.java:36"$0$"import org.springframework.util.Assert;"
"ResourceRegionEncoder.java:37"$0$"import org.springframework.util.MimeType;"
"ResourceRegionEncoder.java:38"$0$"import org.springframework.util.MimeTypeUtils;"
"ResourceRegionEncoder.java:39"$0$"import org.springframework.util.StreamUtils;"
"ResourceRegionEncoder.java:40"$0$""
"ResourceRegionEncoder.java:41"$0$"/**"
"ResourceRegionEncoder.java:42"$1$" * Encoder for {@link ResourceRegion ResourceRegions}."
"ResourceRegionEncoder.java:43"$0$" *"
"ResourceRegionEncoder.java:44"$0$" * @author Brian Clozel"
"ResourceRegionEncoder.java:45"$0$" * @since 5.0"
"ResourceRegionEncoder.java:46"$0$" */"
"ResourceRegionEncoder.java:47"$1$"public class ResourceRegionEncoder extends AbstractEncoder<ResourceRegion> {"
"ResourceRegionEncoder.java:48"$1$""
"ResourceRegionEncoder.java:49"$1$"	/**"
"ResourceRegionEncoder.java:50"$1$"	 * The default buffer size used by the encoder."
"ResourceRegionEncoder.java:51"$1$"	 */"
"ResourceRegionEncoder.java:52"$1$"	public static final int DEFAULT_BUFFER_SIZE = StreamUtils.BUFFER_SIZE;"
"ResourceRegionEncoder.java:53"$1$""
"ResourceRegionEncoder.java:54"$1$"	/**"
"ResourceRegionEncoder.java:55"$1$"	 * The hint key that contains the boundary string."
"ResourceRegionEncoder.java:56"$1$"	 */"
"ResourceRegionEncoder.java:57"$1$"	public static final String BOUNDARY_STRING_HINT = ResourceRegionEncoder.class.getName() + "".boundaryString"";"
"ResourceRegionEncoder.java:58"$1$""
"ResourceRegionEncoder.java:59"$1$"	private final int bufferSize;"
"ResourceRegionEncoder.java:60"$1$""
"ResourceRegionEncoder.java:61"$1$""
"ResourceRegionEncoder.java:62"$1$"	public ResourceRegionEncoder() {"
"ResourceRegionEncoder.java:63"$1$"		this(DEFAULT_BUFFER_SIZE);"
"ResourceRegionEncoder.java:64"$1$"	}"
"ResourceRegionEncoder.java:65"$0$""
"ResourceRegionEncoder.java:66"$1$"	public ResourceRegionEncoder(int bufferSize) {"
"ResourceRegionEncoder.java:67"$1$"		super(MimeTypeUtils.APPLICATION_OCTET_STREAM, MimeTypeUtils.ALL);"
"ResourceRegionEncoder.java:68"$1$"		Assert.isTrue(bufferSize > 0, ""'bufferSize' must be larger than 0"");"
"ResourceRegionEncoder.java:69"$1$"		this.bufferSize = bufferSize;"
"ResourceRegionEncoder.java:70"$1$"	}"
"ResourceRegionEncoder.java:71"$0$""
"ResourceRegionEncoder.java:72"$0$"	@Override"
"ResourceRegionEncoder.java:73"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ResourceRegionEncoder.java:74"$1$"		return super.canEncode(elementType, mimeType)"
"ResourceRegionEncoder.java:75"$1$"				&& ResourceRegion.class.isAssignableFrom(elementType.toClass());"
"ResourceRegionEncoder.java:76"$1$"	}"
"ResourceRegionEncoder.java:77"$0$""
"ResourceRegionEncoder.java:78"$0$"	@Override"
"ResourceRegionEncoder.java:79"$0$"	public Flux<DataBuffer> encode(Publisher<? extends ResourceRegion> input,"
"ResourceRegionEncoder.java:80"$0$"			DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,"
"ResourceRegionEncoder.java:81"$1$"			@Nullable Map<String, Object> hints) {"
"ResourceRegionEncoder.java:82"$1$""
"ResourceRegionEncoder.java:83"$1$"		Assert.notNull(input, ""'inputStream' must not be null"");"
"ResourceRegionEncoder.java:84"$1$"		Assert.notNull(bufferFactory, ""'bufferFactory' must not be null"");"
"ResourceRegionEncoder.java:85"$1$"		Assert.notNull(elementType, ""'elementType' must not be null"");"
"ResourceRegionEncoder.java:86"$1$""
"ResourceRegionEncoder.java:87"$1$"		if (input instanceof Mono) {"
"ResourceRegionEncoder.java:88"$1$"			return Mono.from(input)"
"ResourceRegionEncoder.java:89"$1$"					.flatMapMany(region -> {"
"ResourceRegionEncoder.java:90"$1$"						if (!region.getResource().isReadable()) {"
"ResourceRegionEncoder.java:91"$1$"							return Flux.error(new EncodingException("
"ResourceRegionEncoder.java:92"$1$"									""Resource "" + region.getResource() + "" is not readable""));"
"ResourceRegionEncoder.java:93"$1$"						}"
"ResourceRegionEncoder.java:94"$0$"						return writeResourceRegion(region, bufferFactory, hints);"
"ResourceRegionEncoder.java:95"$0$"					});"
"ResourceRegionEncoder.java:96"$0$"		}"
"ResourceRegionEncoder.java:97"$1$"		else {"
"ResourceRegionEncoder.java:98"$1$"			final String boundaryString = Hints.getRequiredHint(hints, BOUNDARY_STRING_HINT);"
"ResourceRegionEncoder.java:99"$1$"			byte[] startBoundary = toAsciiBytes(""\r\n--"" + boundaryString + ""\r\n"");"
"ResourceRegionEncoder.java:100"$1$"			byte[] contentType = mimeType != null ? toAsciiBytes(""Content-Type: "" + mimeType + ""\r\n"") : new byte[0];"
"ResourceRegionEncoder.java:101"$1$""
"ResourceRegionEncoder.java:102"$1$"			return Flux.from(input)"
"ResourceRegionEncoder.java:103"$1$"					.concatMap(region -> {"
"ResourceRegionEncoder.java:104"$1$"						if (!region.getResource().isReadable()) {"
"ResourceRegionEncoder.java:105"$1$"							return Flux.error(new EncodingException("
"ResourceRegionEncoder.java:106"$1$"									""Resource "" + region.getResource() + "" is not readable""));"
"ResourceRegionEncoder.java:107"$1$"						}"
"ResourceRegionEncoder.java:108"$0$"						Flux<DataBuffer> prefix = Flux.just("
"ResourceRegionEncoder.java:109"$0$"								bufferFactory.wrap(startBoundary),"
"ResourceRegionEncoder.java:110"$0$"								bufferFactory.wrap(contentType),"
"ResourceRegionEncoder.java:111"$0$"								bufferFactory.wrap(getContentRangeHeader(region))); // only wrapping, no allocation"
"ResourceRegionEncoder.java:112"$0$""
"ResourceRegionEncoder.java:113"$0$"						return prefix.concatWith(writeResourceRegion(region, bufferFactory, hints));"
"ResourceRegionEncoder.java:114"$0$"					})"
"ResourceRegionEncoder.java:115"$0$"					.concatWithValues(getRegionSuffix(bufferFactory, boundaryString));"
"ResourceRegionEncoder.java:116"$0$"		}"
"ResourceRegionEncoder.java:117"$0$"		// No doOnDiscard (no caching after DataBufferUtils#read)"
"ResourceRegionEncoder.java:118"$0$"	}"
"ResourceRegionEncoder.java:119"$0$""
"ResourceRegionEncoder.java:120"$0$"	private Flux<DataBuffer> writeResourceRegion("
"ResourceRegionEncoder.java:121"$1$"			ResourceRegion region, DataBufferFactory bufferFactory, @Nullable Map<String, Object> hints) {"
"ResourceRegionEncoder.java:122"$1$""
"ResourceRegionEncoder.java:123"$1$"		Resource resource = region.getResource();"
"ResourceRegionEncoder.java:124"$1$"		long position = region.getPosition();"
"ResourceRegionEncoder.java:125"$1$"		long count = region.getCount();"
"ResourceRegionEncoder.java:126"$1$""
"ResourceRegionEncoder.java:127"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"ResourceRegionEncoder.java:128"$1$"			logger.debug(Hints.getLogPrefix(hints) +"
"ResourceRegionEncoder.java:129"$1$"					""Writing region "" + position + ""-"" + (position + count) + "" of ["" + resource + ""]"");"
"ResourceRegionEncoder.java:130"$1$"		}"
"ResourceRegionEncoder.java:131"$0$""
"ResourceRegionEncoder.java:132"$0$"		Flux<DataBuffer> in = DataBufferUtils.read(resource, position, bufferFactory, this.bufferSize);"
"ResourceRegionEncoder.java:133"$0$"		return DataBufferUtils.takeUntilByteCount(in, count);"
"ResourceRegionEncoder.java:134"$0$"	}"
"ResourceRegionEncoder.java:135"$0$""
"ResourceRegionEncoder.java:136"$1$"	private DataBuffer getRegionSuffix(DataBufferFactory bufferFactory, String boundaryString) {"
"ResourceRegionEncoder.java:137"$1$"		byte[] endBoundary = toAsciiBytes(""\r\n--"" + boundaryString + ""--"");"
"ResourceRegionEncoder.java:138"$1$"		return bufferFactory.wrap(endBoundary);"
"ResourceRegionEncoder.java:139"$1$"	}"
"ResourceRegionEncoder.java:140"$0$""
"ResourceRegionEncoder.java:141"$1$"	private byte[] toAsciiBytes(String in) {"
"ResourceRegionEncoder.java:142"$1$"		return in.getBytes(StandardCharsets.US_ASCII);"
"ResourceRegionEncoder.java:143"$1$"	}"
"ResourceRegionEncoder.java:144"$0$""
"ResourceRegionEncoder.java:145"$1$"	private byte[] getContentRangeHeader(ResourceRegion region) {"
"ResourceRegionEncoder.java:146"$1$"		long start = region.getPosition();"
"ResourceRegionEncoder.java:147"$1$"		long end = start + region.getCount() - 1;"
"ResourceRegionEncoder.java:148"$1$"		OptionalLong contentLength = contentLength(region.getResource());"
"ResourceRegionEncoder.java:149"$1$"		if (contentLength.isPresent()) {"
"ResourceRegionEncoder.java:150"$1$"			long length = contentLength.getAsLong();"
"ResourceRegionEncoder.java:151"$1$"			return toAsciiBytes(""Content-Range: bytes "" + start + '-' + end + '/' + length + ""\r\n\r\n"");"
"ResourceRegionEncoder.java:152"$1$"		}"
"ResourceRegionEncoder.java:153"$1$"		else {"
"ResourceRegionEncoder.java:154"$1$"			return toAsciiBytes(""Content-Range: bytes "" + start + '-' + end + ""\r\n\r\n"");"
"ResourceRegionEncoder.java:155"$1$"		}"
"ResourceRegionEncoder.java:156"$0$"	}"
"ResourceRegionEncoder.java:157"$0$""
"ResourceRegionEncoder.java:158"$0$"	/**"
"ResourceRegionEncoder.java:159"$0$"	 * Determine, if possible, the contentLength of the given resource without reading it."
"ResourceRegionEncoder.java:160"$0$"	 * @param resource the resource instance"
"ResourceRegionEncoder.java:161"$0$"	 * @return the contentLength of the resource"
"ResourceRegionEncoder.java:162"$0$"	 */"
"ResourceRegionEncoder.java:163"$1$"	private OptionalLong contentLength(Resource resource) {"
"ResourceRegionEncoder.java:164"$0$"		// Don't try to determine contentLength on InputStreamResource - cannot be read afterwards..."
"ResourceRegionEncoder.java:165"$0$"		// Note: custom InputStreamResource subclasses could provide a pre-calculated content length!"
"ResourceRegionEncoder.java:166"$1$"		if (InputStreamResource.class != resource.getClass()) {"
"ResourceRegionEncoder.java:167"$1$"			try {"
"ResourceRegionEncoder.java:168"$1$"				return OptionalLong.of(resource.contentLength());"
"ResourceRegionEncoder.java:169"$1$"			}"
"ResourceRegionEncoder.java:170"$1$"			catch (IOException ignored) {"
"ResourceRegionEncoder.java:171"$1$"			}"
"ResourceRegionEncoder.java:172"$0$"		}"
"ResourceRegionEncoder.java:173"$0$"		return OptionalLong.empty();"
"ResourceRegionEncoder.java:174"$0$"	}"
"ResourceRegionEncoder.java:175"$0$""
"ResourceRegionEncoder.java:176"$0$"}"
"ResourceDecoder.java:1"$0$"/*"
"ResourceDecoder.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"ResourceDecoder.java:3"$0$" *"
"ResourceDecoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceDecoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceDecoder.java:6"$0$" * You may obtain a copy of the License at"
"ResourceDecoder.java:7"$0$" *"
"ResourceDecoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceDecoder.java:9"$0$" *"
"ResourceDecoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceDecoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceDecoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceDecoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceDecoder.java:14"$0$" * limitations under the License."
"ResourceDecoder.java:15"$0$" */"
"ResourceDecoder.java:16"$0$""
"ResourceDecoder.java:17"$0$"package org.springframework.core.codec;"
"ResourceDecoder.java:18"$0$""
"ResourceDecoder.java:19"$0$"import java.io.ByteArrayInputStream;"
"ResourceDecoder.java:20"$0$"import java.util.Map;"
"ResourceDecoder.java:21"$0$""
"ResourceDecoder.java:22"$0$"import org.reactivestreams.Publisher;"
"ResourceDecoder.java:23"$0$"import reactor.core.publisher.Flux;"
"ResourceDecoder.java:24"$0$""
"ResourceDecoder.java:25"$0$"import org.springframework.core.ResolvableType;"
"ResourceDecoder.java:26"$0$"import org.springframework.core.io.ByteArrayResource;"
"ResourceDecoder.java:27"$0$"import org.springframework.core.io.InputStreamResource;"
"ResourceDecoder.java:28"$0$"import org.springframework.core.io.Resource;"
"ResourceDecoder.java:29"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ResourceDecoder.java:30"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"ResourceDecoder.java:31"$0$"import org.springframework.lang.Nullable;"
"ResourceDecoder.java:32"$0$"import org.springframework.util.MimeType;"
"ResourceDecoder.java:33"$0$"import org.springframework.util.MimeTypeUtils;"
"ResourceDecoder.java:34"$0$""
"ResourceDecoder.java:35"$0$"/**"
"ResourceDecoder.java:36"$1$" * Decoder for {@link Resource Resources}."
"ResourceDecoder.java:37"$0$" *"
"ResourceDecoder.java:38"$0$" * @author Arjen Poutsma"
"ResourceDecoder.java:39"$0$" * @author Rossen Stoyanchev"
"ResourceDecoder.java:40"$0$" * @since 5.0"
"ResourceDecoder.java:41"$0$" */"
"ResourceDecoder.java:42"$1$"public class ResourceDecoder extends AbstractDataBufferDecoder<Resource> {"
"ResourceDecoder.java:43"$1$""
"ResourceDecoder.java:44"$1$"	/** Name of hint with a filename for the resource(e.g. from ""Content-Disposition"" HTTP header). */"
"ResourceDecoder.java:45"$1$"	public static String FILENAME_HINT = ResourceDecoder.class.getName() + "".filename"";"
"ResourceDecoder.java:46"$1$""
"ResourceDecoder.java:47"$1$""
"ResourceDecoder.java:48"$1$"	public ResourceDecoder() {"
"ResourceDecoder.java:49"$1$"		super(MimeTypeUtils.ALL);"
"ResourceDecoder.java:50"$1$"	}"
"ResourceDecoder.java:51"$0$""
"ResourceDecoder.java:52"$0$""
"ResourceDecoder.java:53"$0$"	@Override"
"ResourceDecoder.java:54"$1$"	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ResourceDecoder.java:55"$1$"		return (Resource.class.isAssignableFrom(elementType.toClass()) &&"
"ResourceDecoder.java:56"$1$"				super.canDecode(elementType, mimeType));"
"ResourceDecoder.java:57"$1$"	}"
"ResourceDecoder.java:58"$0$""
"ResourceDecoder.java:59"$0$"	@Override"
"ResourceDecoder.java:60"$0$"	public Flux<Resource> decode(Publisher<DataBuffer> inputStream, ResolvableType elementType,"
"ResourceDecoder.java:61"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ResourceDecoder.java:62"$1$""
"ResourceDecoder.java:63"$1$"		return Flux.from(decodeToMono(inputStream, elementType, mimeType, hints));"
"ResourceDecoder.java:64"$1$"	}"
"ResourceDecoder.java:65"$0$""
"ResourceDecoder.java:66"$0$"	@Override"
"ResourceDecoder.java:67"$0$"	public Resource decode(DataBuffer dataBuffer, ResolvableType elementType,"
"ResourceDecoder.java:68"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ResourceDecoder.java:69"$1$""
"ResourceDecoder.java:70"$1$"		byte[] bytes = new byte[dataBuffer.readableByteCount()];"
"ResourceDecoder.java:71"$1$"		dataBuffer.read(bytes);"
"ResourceDecoder.java:72"$1$"		DataBufferUtils.release(dataBuffer);"
"ResourceDecoder.java:73"$1$""
"ResourceDecoder.java:74"$1$"		if (logger.isDebugEnabled()) {"
"ResourceDecoder.java:75"$1$"			logger.debug(Hints.getLogPrefix(hints) + ""Read "" + bytes.length + "" bytes"");"
"ResourceDecoder.java:76"$1$"		}"
"ResourceDecoder.java:77"$0$""
"ResourceDecoder.java:78"$0$"		Class<?> clazz = elementType.toClass();"
"ResourceDecoder.java:79"$0$"		String filename = hints != null ? (String) hints.get(FILENAME_HINT) : null;"
"ResourceDecoder.java:80"$1$"		if (clazz == InputStreamResource.class) {"
"ResourceDecoder.java:81"$1$"			return new InputStreamResource(new ByteArrayInputStream(bytes)) {"
"ResourceDecoder.java:82"$1$"				@Override"
"ResourceDecoder.java:83"$1$"				public String getFilename() {"
"ResourceDecoder.java:84"$1$"					return filename;"
"ResourceDecoder.java:85"$1$"				}"
"ResourceDecoder.java:86"$0$"				@Override"
"ResourceDecoder.java:87"$1$"				public long contentLength() {"
"ResourceDecoder.java:88"$1$"					return bytes.length;"
"ResourceDecoder.java:89"$1$"				}"
"ResourceDecoder.java:90"$0$"			};"
"ResourceDecoder.java:91"$0$"		}"
"ResourceDecoder.java:92"$1$"		else if (Resource.class.isAssignableFrom(clazz)) {"
"ResourceDecoder.java:93"$1$"			return new ByteArrayResource(bytes) {"
"ResourceDecoder.java:94"$1$"				@Override"
"ResourceDecoder.java:95"$1$"				public String getFilename() {"
"ResourceDecoder.java:96"$1$"					return filename;"
"ResourceDecoder.java:97"$1$"				}"
"ResourceDecoder.java:98"$0$"			};"
"ResourceDecoder.java:99"$0$"		}"
"ResourceDecoder.java:100"$1$"		else {"
"ResourceDecoder.java:101"$1$"			throw new IllegalStateException(""Unsupported resource class: "" + clazz);"
"ResourceDecoder.java:102"$1$"		}"
"ResourceDecoder.java:103"$0$"	}"
"ResourceDecoder.java:104"$0$""
"ResourceDecoder.java:105"$0$"}"
"SystemEnvironmentPropertySource.java:1"$0$"/*"
"SystemEnvironmentPropertySource.java:2"$0$" * Copyright 2002-2015 the original author or authors."
"SystemEnvironmentPropertySource.java:3"$0$" *"
"SystemEnvironmentPropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SystemEnvironmentPropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"SystemEnvironmentPropertySource.java:6"$0$" * You may obtain a copy of the License at"
"SystemEnvironmentPropertySource.java:7"$0$" *"
"SystemEnvironmentPropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SystemEnvironmentPropertySource.java:9"$0$" *"
"SystemEnvironmentPropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SystemEnvironmentPropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SystemEnvironmentPropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SystemEnvironmentPropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"SystemEnvironmentPropertySource.java:14"$0$" * limitations under the License."
"SystemEnvironmentPropertySource.java:15"$0$" */"
"SystemEnvironmentPropertySource.java:16"$0$""
"SystemEnvironmentPropertySource.java:17"$0$"package org.springframework.core.env;"
"SystemEnvironmentPropertySource.java:18"$0$""
"SystemEnvironmentPropertySource.java:19"$0$"import java.util.Map;"
"SystemEnvironmentPropertySource.java:20"$0$""
"SystemEnvironmentPropertySource.java:21"$0$"import org.springframework.lang.Nullable;"
"SystemEnvironmentPropertySource.java:22"$0$"import org.springframework.util.Assert;"
"SystemEnvironmentPropertySource.java:23"$0$""
"SystemEnvironmentPropertySource.java:24"$0$"/**"
"SystemEnvironmentPropertySource.java:25"$1$" * Specialization of {@link MapPropertySource} designed for use with"
"SystemEnvironmentPropertySource.java:26"$1$" * {@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables}."
"SystemEnvironmentPropertySource.java:27"$0$" * Compensates for constraints in Bash and other shells that do not allow for variables"
"SystemEnvironmentPropertySource.java:28"$0$" * containing the period character and/or hyphen character; also allows for uppercase"
"SystemEnvironmentPropertySource.java:29"$0$" * variations on property names for more idiomatic shell use."
"SystemEnvironmentPropertySource.java:30"$0$" *"
"SystemEnvironmentPropertySource.java:31"$1$" * <p>For example, a call to {@code getProperty(""foo.bar"")} will attempt to find a value"
"SystemEnvironmentPropertySource.java:32"$0$" * for the original property or any 'equivalent' property, returning the first found:"
"SystemEnvironmentPropertySource.java:33"$0$" * <ul>"
"SystemEnvironmentPropertySource.java:34"$1$" * <li>{@code foo.bar} - the original name</li>"
"SystemEnvironmentPropertySource.java:35"$1$" * <li>{@code foo_bar} - with underscores for periods (if any)</li>"
"SystemEnvironmentPropertySource.java:36"$1$" * <li>{@code FOO.BAR} - original, with upper case</li>"
"SystemEnvironmentPropertySource.java:37"$1$" * <li>{@code FOO_BAR} - with underscores and upper case</li>"
"SystemEnvironmentPropertySource.java:38"$0$" * </ul>"
"SystemEnvironmentPropertySource.java:39"$0$" * Any hyphen variant of the above would work as well, or even mix dot/hyphen variants."
"SystemEnvironmentPropertySource.java:40"$0$" *"
"SystemEnvironmentPropertySource.java:41"$1$" * <p>The same applies for calls to {@link #containsProperty(String)}, which returns"
"SystemEnvironmentPropertySource.java:42"$1$" * {@code true} if any of the above properties are present, otherwise {@code false}."
"SystemEnvironmentPropertySource.java:43"$0$" *"
"SystemEnvironmentPropertySource.java:44"$0$" * <p>This feature is particularly useful when specifying active or default profiles as"
"SystemEnvironmentPropertySource.java:45"$0$" * environment variables. The following is not allowable under Bash:"
"SystemEnvironmentPropertySource.java:46"$0$" *"
"SystemEnvironmentPropertySource.java:47"$0$" * <pre class=""code"">spring.profiles.active=p1 java -classpath ... MyApp</pre>"
"SystemEnvironmentPropertySource.java:48"$0$" *"
"SystemEnvironmentPropertySource.java:49"$0$" * However, the following syntax is permitted and is also more conventional:"
"SystemEnvironmentPropertySource.java:50"$0$" *"
"SystemEnvironmentPropertySource.java:51"$0$" * <pre class=""code"">SPRING_PROFILES_ACTIVE=p1 java -classpath ... MyApp</pre>"
"SystemEnvironmentPropertySource.java:52"$0$" *"
"SystemEnvironmentPropertySource.java:53"$0$" * <p>Enable debug- or trace-level logging for this class (or package) for messages"
"SystemEnvironmentPropertySource.java:54"$0$" * explaining when these 'property name resolutions' occur."
"SystemEnvironmentPropertySource.java:55"$0$" *"
"SystemEnvironmentPropertySource.java:56"$1$" * <p>This property source is included by default in {@link StandardEnvironment}"
"SystemEnvironmentPropertySource.java:57"$0$" * and all its subclasses."
"SystemEnvironmentPropertySource.java:58"$0$" *"
"SystemEnvironmentPropertySource.java:59"$0$" * @author Chris Beams"
"SystemEnvironmentPropertySource.java:60"$0$" * @author Juergen Hoeller"
"SystemEnvironmentPropertySource.java:61"$0$" * @since 3.1"
"SystemEnvironmentPropertySource.java:62"$0$" * @see StandardEnvironment"
"SystemEnvironmentPropertySource.java:63"$0$" * @see AbstractEnvironment#getSystemEnvironment()"
"SystemEnvironmentPropertySource.java:64"$0$" * @see AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME"
"SystemEnvironmentPropertySource.java:65"$0$" */"
"SystemEnvironmentPropertySource.java:66"$1$"public class SystemEnvironmentPropertySource extends MapPropertySource {"
"SystemEnvironmentPropertySource.java:67"$1$""
"SystemEnvironmentPropertySource.java:68"$1$"	/**"
"SystemEnvironmentPropertySource.java:69"$1$"	 * Create a new {@code SystemEnvironmentPropertySource} with the given name and"
"SystemEnvironmentPropertySource.java:70"$1$"	 * delegating to the given {@code MapPropertySource}."
"SystemEnvironmentPropertySource.java:71"$1$"	 */"
"SystemEnvironmentPropertySource.java:72"$1$"	public SystemEnvironmentPropertySource(String name, Map<String, Object> source) {"
"SystemEnvironmentPropertySource.java:73"$1$"		super(name, source);"
"SystemEnvironmentPropertySource.java:74"$1$"	}"
"SystemEnvironmentPropertySource.java:75"$0$""
"SystemEnvironmentPropertySource.java:76"$0$""
"SystemEnvironmentPropertySource.java:77"$0$"	/**"
"SystemEnvironmentPropertySource.java:78"$1$"	 * Return {@code true} if a property with the given name or any underscore/uppercase variant"
"SystemEnvironmentPropertySource.java:79"$0$"	 * thereof exists in this property source."
"SystemEnvironmentPropertySource.java:80"$0$"	 */"
"SystemEnvironmentPropertySource.java:81"$0$"	@Override"
"SystemEnvironmentPropertySource.java:82"$1$"	public boolean containsProperty(String name) {"
"SystemEnvironmentPropertySource.java:83"$1$"		return (getProperty(name) != null);"
"SystemEnvironmentPropertySource.java:84"$1$"	}"
"SystemEnvironmentPropertySource.java:85"$0$""
"SystemEnvironmentPropertySource.java:86"$0$"	/**"
"SystemEnvironmentPropertySource.java:87"$1$"	 * This implementation returns {@code true} if a property with the given name or"
"SystemEnvironmentPropertySource.java:88"$0$"	 * any underscore/uppercase variant thereof exists in this property source."
"SystemEnvironmentPropertySource.java:89"$0$"	 */"
"SystemEnvironmentPropertySource.java:90"$0$"	@Override"
"SystemEnvironmentPropertySource.java:91"$0$"	@Nullable"
"SystemEnvironmentPropertySource.java:92"$1$"	public Object getProperty(String name) {"
"SystemEnvironmentPropertySource.java:93"$1$"		String actualName = resolvePropertyName(name);"
"SystemEnvironmentPropertySource.java:94"$1$"		if (logger.isDebugEnabled() && !name.equals(actualName)) {"
"SystemEnvironmentPropertySource.java:95"$1$"			logger.debug(""PropertySource '"" + getName() + ""' does not contain property '"" + name +"
"SystemEnvironmentPropertySource.java:96"$1$"					""', but found equivalent '"" + actualName + ""'"");"
"SystemEnvironmentPropertySource.java:97"$1$"		}"
"SystemEnvironmentPropertySource.java:98"$0$"		return super.getProperty(actualName);"
"SystemEnvironmentPropertySource.java:99"$0$"	}"
"SystemEnvironmentPropertySource.java:100"$0$""
"SystemEnvironmentPropertySource.java:101"$0$"	/**"
"SystemEnvironmentPropertySource.java:102"$0$"	 * Check to see if this property source contains a property with the given name, or"
"SystemEnvironmentPropertySource.java:103"$0$"	 * any underscore / uppercase variation thereof. Return the resolved name if one is"
"SystemEnvironmentPropertySource.java:104"$1$"	 * found or otherwise the original name. Never returns {@code null}."
"SystemEnvironmentPropertySource.java:105"$0$"	 */"
"SystemEnvironmentPropertySource.java:106"$1$"	protected final String resolvePropertyName(String name) {"
"SystemEnvironmentPropertySource.java:107"$1$"		Assert.notNull(name, ""Property name must not be null"");"
"SystemEnvironmentPropertySource.java:108"$1$"		String resolvedName = checkPropertyName(name);"
"SystemEnvironmentPropertySource.java:109"$1$"		if (resolvedName != null) {"
"SystemEnvironmentPropertySource.java:110"$1$"			return resolvedName;"
"SystemEnvironmentPropertySource.java:111"$1$"		}"
"SystemEnvironmentPropertySource.java:112"$0$"		String uppercasedName = name.toUpperCase();"
"SystemEnvironmentPropertySource.java:113"$1$"		if (!name.equals(uppercasedName)) {"
"SystemEnvironmentPropertySource.java:114"$1$"			resolvedName = checkPropertyName(uppercasedName);"
"SystemEnvironmentPropertySource.java:115"$1$"			if (resolvedName != null) {"
"SystemEnvironmentPropertySource.java:116"$1$"				return resolvedName;"
"SystemEnvironmentPropertySource.java:117"$1$"			}"
"SystemEnvironmentPropertySource.java:118"$0$"		}"
"SystemEnvironmentPropertySource.java:119"$0$"		return name;"
"SystemEnvironmentPropertySource.java:120"$0$"	}"
"SystemEnvironmentPropertySource.java:121"$0$""
"SystemEnvironmentPropertySource.java:122"$0$"	@Nullable"
"SystemEnvironmentPropertySource.java:123"$1$"	private String checkPropertyName(String name) {"
"SystemEnvironmentPropertySource.java:124"$0$"		// Check name as-is"
"SystemEnvironmentPropertySource.java:125"$1$"		if (containsKey(name)) {"
"SystemEnvironmentPropertySource.java:126"$1$"			return name;"
"SystemEnvironmentPropertySource.java:127"$1$"		}"
"SystemEnvironmentPropertySource.java:128"$0$"		// Check name with just dots replaced"
"SystemEnvironmentPropertySource.java:129"$0$"		String noDotName = name.replace('.', '_');"
"SystemEnvironmentPropertySource.java:130"$1$"		if (!name.equals(noDotName) && containsKey(noDotName)) {"
"SystemEnvironmentPropertySource.java:131"$1$"			return noDotName;"
"SystemEnvironmentPropertySource.java:132"$1$"		}"
"SystemEnvironmentPropertySource.java:133"$0$"		// Check name with just hyphens replaced"
"SystemEnvironmentPropertySource.java:134"$0$"		String noHyphenName = name.replace('-', '_');"
"SystemEnvironmentPropertySource.java:135"$1$"		if (!name.equals(noHyphenName) && containsKey(noHyphenName)) {"
"SystemEnvironmentPropertySource.java:136"$1$"			return noHyphenName;"
"SystemEnvironmentPropertySource.java:137"$1$"		}"
"SystemEnvironmentPropertySource.java:138"$0$"		// Check name with dots and hyphens replaced"
"SystemEnvironmentPropertySource.java:139"$0$"		String noDotNoHyphenName = noDotName.replace('-', '_');"
"SystemEnvironmentPropertySource.java:140"$1$"		if (!noDotName.equals(noDotNoHyphenName) && containsKey(noDotNoHyphenName)) {"
"SystemEnvironmentPropertySource.java:141"$1$"			return noDotNoHyphenName;"
"SystemEnvironmentPropertySource.java:142"$1$"		}"
"SystemEnvironmentPropertySource.java:143"$0$"		// Give up"
"SystemEnvironmentPropertySource.java:144"$0$"		return null;"
"SystemEnvironmentPropertySource.java:145"$0$"	}"
"SystemEnvironmentPropertySource.java:146"$0$""
"SystemEnvironmentPropertySource.java:147"$1$"	private boolean containsKey(String name) {"
"SystemEnvironmentPropertySource.java:148"$1$"		return (isSecurityManagerPresent() ? this.source.keySet().contains(name) : this.source.containsKey(name));"
"SystemEnvironmentPropertySource.java:149"$1$"	}"
"SystemEnvironmentPropertySource.java:150"$0$""
"SystemEnvironmentPropertySource.java:151"$1$"	protected boolean isSecurityManagerPresent() {"
"SystemEnvironmentPropertySource.java:152"$1$"		return (System.getSecurityManager() != null);"
"SystemEnvironmentPropertySource.java:153"$1$"	}"
"SystemEnvironmentPropertySource.java:154"$0$""
"SystemEnvironmentPropertySource.java:155"$0$"}"
"BooleanComparator.java:1"$0$"/*"
"BooleanComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"BooleanComparator.java:3"$0$" *"
"BooleanComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"BooleanComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"BooleanComparator.java:6"$0$" * You may obtain a copy of the License at"
"BooleanComparator.java:7"$0$" *"
"BooleanComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"BooleanComparator.java:9"$0$" *"
"BooleanComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"BooleanComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"BooleanComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"BooleanComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"BooleanComparator.java:14"$0$" * limitations under the License."
"BooleanComparator.java:15"$0$" */"
"BooleanComparator.java:16"$0$""
"BooleanComparator.java:17"$0$"package org.springframework.util.comparator;"
"BooleanComparator.java:18"$0$""
"BooleanComparator.java:19"$0$"import java.io.Serializable;"
"BooleanComparator.java:20"$0$"import java.util.Comparator;"
"BooleanComparator.java:21"$0$""
"BooleanComparator.java:22"$0$"import org.springframework.lang.Nullable;"
"BooleanComparator.java:23"$0$""
"BooleanComparator.java:24"$0$"/**"
"BooleanComparator.java:25"$1$" * A {@link Comparator} for {@link Boolean} objects that can sort either"
"BooleanComparator.java:26"$1$" * {@code true} or {@code false} first."
"BooleanComparator.java:27"$0$" *"
"BooleanComparator.java:28"$0$" * @author Keith Donald"
"BooleanComparator.java:29"$0$" * @since 1.2.2"
"BooleanComparator.java:30"$0$" */"
"BooleanComparator.java:31"$0$"SuppressWarnings(""serial"")"
"BooleanComparator.java:32"$1$"public class BooleanComparator implements Comparator<Boolean>, Serializable {"
"BooleanComparator.java:33"$1$""
"BooleanComparator.java:34"$1$"	/**"
"BooleanComparator.java:35"$1$"	 * A shared default instance of this comparator,"
"BooleanComparator.java:36"$1$"	 * treating {@code true} lower than {@code false}."
"BooleanComparator.java:37"$1$"	 */"
"BooleanComparator.java:38"$1$"	public static final BooleanComparator TRUE_LOW = new BooleanComparator(true);"
"BooleanComparator.java:39"$1$""
"BooleanComparator.java:40"$1$"	/**"
"BooleanComparator.java:41"$1$"	 * A shared default instance of this comparator,"
"BooleanComparator.java:42"$1$"	 * treating {@code true} higher than {@code false}."
"BooleanComparator.java:43"$1$"	 */"
"BooleanComparator.java:44"$1$"	public static final BooleanComparator TRUE_HIGH = new BooleanComparator(false);"
"BooleanComparator.java:45"$1$""
"BooleanComparator.java:46"$1$""
"BooleanComparator.java:47"$1$"	private final boolean trueLow;"
"BooleanComparator.java:48"$1$""
"BooleanComparator.java:49"$1$""
"BooleanComparator.java:50"$1$"	/**"
"BooleanComparator.java:51"$1$"	 * Create a BooleanComparator that sorts boolean values based on"
"BooleanComparator.java:52"$1$"	 * the provided flag."
"BooleanComparator.java:53"$1$"	 * <p>Alternatively, you can use the default shared instances:"
"BooleanComparator.java:54"$1$"	 * {@code BooleanComparator.TRUE_LOW} and"
"BooleanComparator.java:55"$1$"	 * {@code BooleanComparator.TRUE_HIGH}."
"BooleanComparator.java:56"$1$"	 * @param trueLow whether to treat true as lower or higher than false"
"BooleanComparator.java:57"$1$"	 * @see #TRUE_LOW"
"BooleanComparator.java:58"$1$"	 * @see #TRUE_HIGH"
"BooleanComparator.java:59"$1$"	 */"
"BooleanComparator.java:60"$1$"	public BooleanComparator(boolean trueLow) {"
"BooleanComparator.java:61"$1$"		this.trueLow = trueLow;"
"BooleanComparator.java:62"$1$"	}"
"BooleanComparator.java:63"$0$""
"BooleanComparator.java:64"$0$""
"BooleanComparator.java:65"$0$"	@Override"
"BooleanComparator.java:66"$1$"	public int compare(Boolean v1, Boolean v2) {"
"BooleanComparator.java:67"$1$"		return (v1 ^ v2) ? ((v1 ^ this.trueLow) ? 1 : -1) : 0;"
"BooleanComparator.java:68"$1$"	}"
"BooleanComparator.java:69"$0$""
"BooleanComparator.java:70"$0$""
"BooleanComparator.java:71"$0$"	@Override"
"BooleanComparator.java:72"$1$"	public boolean equals(@Nullable Object other) {"
"BooleanComparator.java:73"$1$"		return (this == other || (other instanceof BooleanComparator &&"
"BooleanComparator.java:74"$1$"				this.trueLow == ((BooleanComparator) other).trueLow));"
"BooleanComparator.java:75"$1$"	}"
"BooleanComparator.java:76"$0$""
"BooleanComparator.java:77"$0$"	@Override"
"BooleanComparator.java:78"$1$"	public int hashCode() {"
"BooleanComparator.java:79"$1$"		return getClass().hashCode() * (this.trueLow ? -1 : 1);"
"BooleanComparator.java:80"$1$"	}"
"BooleanComparator.java:81"$0$""
"BooleanComparator.java:82"$0$"	@Override"
"BooleanComparator.java:83"$1$"	public String toString() {"
"BooleanComparator.java:84"$1$"		return ""BooleanComparator: "" + (this.trueLow ? ""true low"" : ""true high"");"
"BooleanComparator.java:85"$1$"	}"
"BooleanComparator.java:86"$0$""
"BooleanComparator.java:87"$0$"}"
"DefaultValueStyler.java:1"$0$"/*"
"DefaultValueStyler.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DefaultValueStyler.java:3"$0$" *"
"DefaultValueStyler.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DefaultValueStyler.java:5"$0$" * you may not use this file except in compliance with the License."
"DefaultValueStyler.java:6"$0$" * You may obtain a copy of the License at"
"DefaultValueStyler.java:7"$0$" *"
"DefaultValueStyler.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DefaultValueStyler.java:9"$0$" *"
"DefaultValueStyler.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DefaultValueStyler.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DefaultValueStyler.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DefaultValueStyler.java:13"$0$" * See the License for the specific language governing permissions and"
"DefaultValueStyler.java:14"$0$" * limitations under the License."
"DefaultValueStyler.java:15"$0$" */"
"DefaultValueStyler.java:16"$0$""
"DefaultValueStyler.java:17"$0$"package org.springframework.core.style;"
"DefaultValueStyler.java:18"$0$""
"DefaultValueStyler.java:19"$0$"import java.lang.reflect.Method;"
"DefaultValueStyler.java:20"$0$"import java.util.Collection;"
"DefaultValueStyler.java:21"$0$"import java.util.List;"
"DefaultValueStyler.java:22"$0$"import java.util.Map;"
"DefaultValueStyler.java:23"$0$"import java.util.Set;"
"DefaultValueStyler.java:24"$0$"import java.util.StringJoiner;"
"DefaultValueStyler.java:25"$0$""
"DefaultValueStyler.java:26"$0$"import org.springframework.lang.Nullable;"
"DefaultValueStyler.java:27"$0$"import org.springframework.util.ClassUtils;"
"DefaultValueStyler.java:28"$0$"import org.springframework.util.ObjectUtils;"
"DefaultValueStyler.java:29"$0$""
"DefaultValueStyler.java:30"$0$"/**"
"DefaultValueStyler.java:31"$0$" * Converts objects to String form, generally for debugging purposes,"
"DefaultValueStyler.java:32"$1$" * using Spring's {@code toString} styling conventions."
"DefaultValueStyler.java:33"$0$" *"
"DefaultValueStyler.java:34"$0$" * <p>Uses the reflective visitor pattern underneath the hood to nicely"
"DefaultValueStyler.java:35"$0$" * encapsulate styling algorithms for each type of styled object."
"DefaultValueStyler.java:36"$0$" *"
"DefaultValueStyler.java:37"$0$" * @author Keith Donald"
"DefaultValueStyler.java:38"$0$" * @author Juergen Hoeller"
"DefaultValueStyler.java:39"$0$" * @since 1.2.2"
"DefaultValueStyler.java:40"$0$" */"
"DefaultValueStyler.java:41"$1$"public class DefaultValueStyler implements ValueStyler {"
"DefaultValueStyler.java:42"$1$""
"DefaultValueStyler.java:43"$1$"	private static final String EMPTY = ""[[empty]]"";"
"DefaultValueStyler.java:44"$1$"	private static final String NULL = ""[null]"";"
"DefaultValueStyler.java:45"$1$"	private static final String COLLECTION = ""collection"";"
"DefaultValueStyler.java:46"$1$"	private static final String SET = ""set"";"
"DefaultValueStyler.java:47"$1$"	private static final String LIST = ""list"";"
"DefaultValueStyler.java:48"$1$"	private static final String MAP = ""map"";"
"DefaultValueStyler.java:49"$1$"	private static final String EMPTY_MAP = MAP + EMPTY;"
"DefaultValueStyler.java:50"$1$"	private static final String ARRAY = ""array"";"
"DefaultValueStyler.java:51"$1$""
"DefaultValueStyler.java:52"$1$""
"DefaultValueStyler.java:53"$1$"	@Override"
"DefaultValueStyler.java:54"$1$"	public String style(@Nullable Object value) {"
"DefaultValueStyler.java:55"$1$"		if (value == null) {"
"DefaultValueStyler.java:56"$1$"			return NULL;"
"DefaultValueStyler.java:57"$1$"		}"
"DefaultValueStyler.java:58"$1$"		else if (value instanceof String) {"
"DefaultValueStyler.java:59"$1$"			return ""\'"" + value + ""\'"";"
"DefaultValueStyler.java:60"$1$"		}"
"DefaultValueStyler.java:61"$1$"		else if (value instanceof Class) {"
"DefaultValueStyler.java:62"$1$"			return ClassUtils.getShortName((Class<?>) value);"
"DefaultValueStyler.java:63"$1$"		}"
"DefaultValueStyler.java:64"$1$"		else if (value instanceof Method) {"
"DefaultValueStyler.java:65"$1$"			Method method = (Method) value;"
"DefaultValueStyler.java:66"$1$"			return method.getName() + ""@"" + ClassUtils.getShortName(method.getDeclaringClass());"
"DefaultValueStyler.java:67"$1$"		}"
"DefaultValueStyler.java:68"$1$"		else if (value instanceof Map) {"
"DefaultValueStyler.java:69"$1$"			return style((Map<?, ?>) value);"
"DefaultValueStyler.java:70"$1$"		}"
"DefaultValueStyler.java:71"$1$"		else if (value instanceof Map.Entry) {"
"DefaultValueStyler.java:72"$1$"			return style((Map.Entry<? ,?>) value);"
"DefaultValueStyler.java:73"$1$"		}"
"DefaultValueStyler.java:74"$1$"		else if (value instanceof Collection) {"
"DefaultValueStyler.java:75"$1$"			return style((Collection<?>) value);"
"DefaultValueStyler.java:76"$1$"		}"
"DefaultValueStyler.java:77"$1$"		else if (value.getClass().isArray()) {"
"DefaultValueStyler.java:78"$1$"			return styleArray(ObjectUtils.toObjectArray(value));"
"DefaultValueStyler.java:79"$1$"		}"
"DefaultValueStyler.java:80"$1$"		else {"
"DefaultValueStyler.java:81"$1$"			return String.valueOf(value);"
"DefaultValueStyler.java:82"$1$"		}"
"DefaultValueStyler.java:83"$0$"	}"
"DefaultValueStyler.java:84"$0$""
"DefaultValueStyler.java:85"$1$"	private <K, V> String style(Map<K, V> value) {"
"DefaultValueStyler.java:86"$1$"		if (value.isEmpty()) {"
"DefaultValueStyler.java:87"$1$"			return EMPTY_MAP;"
"DefaultValueStyler.java:88"$1$"		}"
"DefaultValueStyler.java:89"$0$""
"DefaultValueStyler.java:90"$0$"		StringJoiner result = new StringJoiner("", "", ""["", ""]"");"
"DefaultValueStyler.java:91"$1$"		for (Map.Entry<K, V> entry : value.entrySet()) {"
"DefaultValueStyler.java:92"$1$"			result.add(style(entry));"
"DefaultValueStyler.java:93"$1$"		}"
"DefaultValueStyler.java:94"$0$"		return MAP + result;"
"DefaultValueStyler.java:95"$0$"	}"
"DefaultValueStyler.java:96"$0$""
"DefaultValueStyler.java:97"$1$"	private String style(Map.Entry<?, ?> value) {"
"DefaultValueStyler.java:98"$1$"		return style(value.getKey()) + "" -> "" + style(value.getValue());"
"DefaultValueStyler.java:99"$1$"	}"
"DefaultValueStyler.java:100"$0$""
"DefaultValueStyler.java:101"$1$"	private String style(Collection<?> value) {"
"DefaultValueStyler.java:102"$1$"		String collectionType = getCollectionTypeString(value);"
"DefaultValueStyler.java:103"$1$""
"DefaultValueStyler.java:104"$1$"		if (value.isEmpty()) {"
"DefaultValueStyler.java:105"$1$"			return collectionType + EMPTY;"
"DefaultValueStyler.java:106"$1$"		}"
"DefaultValueStyler.java:107"$0$""
"DefaultValueStyler.java:108"$0$"		StringJoiner result = new StringJoiner("", "", ""["", ""]"");"
"DefaultValueStyler.java:109"$1$"		for (Object o : value) {"
"DefaultValueStyler.java:110"$1$"			result.add(style(o));"
"DefaultValueStyler.java:111"$1$"		}"
"DefaultValueStyler.java:112"$0$"		return collectionType + result;"
"DefaultValueStyler.java:113"$0$"	}"
"DefaultValueStyler.java:114"$0$""
"DefaultValueStyler.java:115"$1$"	private String getCollectionTypeString(Collection<?> value) {"
"DefaultValueStyler.java:116"$1$"		if (value instanceof List) {"
"DefaultValueStyler.java:117"$1$"			return LIST;"
"DefaultValueStyler.java:118"$1$"		}"
"DefaultValueStyler.java:119"$1$"		else if (value instanceof Set) {"
"DefaultValueStyler.java:120"$1$"			return SET;"
"DefaultValueStyler.java:121"$1$"		}"
"DefaultValueStyler.java:122"$1$"		else {"
"DefaultValueStyler.java:123"$1$"			return COLLECTION;"
"DefaultValueStyler.java:124"$1$"		}"
"DefaultValueStyler.java:125"$0$"	}"
"DefaultValueStyler.java:126"$0$""
"DefaultValueStyler.java:127"$1$"	private String styleArray(Object[] array) {"
"DefaultValueStyler.java:128"$1$"		if (array.length == 0) {"
"DefaultValueStyler.java:129"$1$"			return ARRAY + '<' + ClassUtils.getShortName(array.getClass().getComponentType()) + '>' + EMPTY;"
"DefaultValueStyler.java:130"$1$"		}"
"DefaultValueStyler.java:131"$0$""
"DefaultValueStyler.java:132"$0$"		StringJoiner result = new StringJoiner("", "", ""["", ""]"");"
"DefaultValueStyler.java:133"$1$"		for (Object o : array) {"
"DefaultValueStyler.java:134"$1$"			result.add(style(o));"
"DefaultValueStyler.java:135"$1$"		}"
"DefaultValueStyler.java:136"$0$"		return ARRAY + '<' + ClassUtils.getShortName(array.getClass().getComponentType()) + '>' + result;"
"DefaultValueStyler.java:137"$0$"	}"
"DefaultValueStyler.java:138"$0$""
"DefaultValueStyler.java:139"$0$"}"
"Constants.java:1"$0$"/*"
"Constants.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"Constants.java:3"$0$" *"
"Constants.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Constants.java:5"$0$" * you may not use this file except in compliance with the License."
"Constants.java:6"$0$" * You may obtain a copy of the License at"
"Constants.java:7"$0$" *"
"Constants.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Constants.java:9"$0$" *"
"Constants.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Constants.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Constants.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Constants.java:13"$0$" * See the License for the specific language governing permissions and"
"Constants.java:14"$0$" * limitations under the License."
"Constants.java:15"$0$" */"
"Constants.java:16"$0$""
"Constants.java:17"$0$"package org.springframework.core;"
"Constants.java:18"$0$""
"Constants.java:19"$0$"import java.lang.reflect.Field;"
"Constants.java:20"$0$"import java.util.HashMap;"
"Constants.java:21"$0$"import java.util.HashSet;"
"Constants.java:22"$0$"import java.util.Locale;"
"Constants.java:23"$0$"import java.util.Map;"
"Constants.java:24"$0$"import java.util.Set;"
"Constants.java:25"$0$""
"Constants.java:26"$0$"import org.springframework.lang.Nullable;"
"Constants.java:27"$0$"import org.springframework.util.Assert;"
"Constants.java:28"$0$"import org.springframework.util.ReflectionUtils;"
"Constants.java:29"$0$""
"Constants.java:30"$0$"/**"
"Constants.java:31"$0$" * This class can be used to parse other classes containing constant definitions"
"Constants.java:32"$1$" * in public static final members. The {@code asXXXX} methods of this class"
"Constants.java:33"$0$" * allow these constant values to be accessed via their string names."
"Constants.java:34"$0$" *"
"Constants.java:35"$1$" * <p>Consider class Foo containing {@code public final static int CONSTANT1 = 66;}"
"Constants.java:36"$1$" * An instance of this class wrapping {@code Foo.class} will return the constant value"
"Constants.java:37"$1$" * of 66 from its {@code asNumber} method given the argument {@code ""CONSTANT1""}."
"Constants.java:38"$0$" *"
"Constants.java:39"$0$" * <p>This class is ideal for use in PropertyEditors, enabling them to"
"Constants.java:40"$0$" * recognize the same names as the constants themselves, and freeing them"
"Constants.java:41"$0$" * from maintaining their own mapping."
"Constants.java:42"$0$" *"
"Constants.java:43"$0$" * @author Rod Johnson"
"Constants.java:44"$0$" * @author Juergen Hoeller"
"Constants.java:45"$0$" * @since 16.03.2003"
"Constants.java:46"$0$" */"
"Constants.java:47"$1$"public class Constants {"
"Constants.java:48"$1$""
"Constants.java:49"$1$"	/** The name of the introspected class. */"
"Constants.java:50"$1$"	private final String className;"
"Constants.java:51"$1$""
"Constants.java:52"$1$"	/** Map from String field name to object value. */"
"Constants.java:53"$1$"	private final Map<String, Object> fieldCache = new HashMap<>();"
"Constants.java:54"$1$""
"Constants.java:55"$1$""
"Constants.java:56"$1$"	/**"
"Constants.java:57"$1$"	 * Create a new Constants converter class wrapping the given class."
"Constants.java:58"$1$"	 * <p>All <b>public</b> static final variables will be exposed, whatever their type."
"Constants.java:59"$1$"	 * @param clazz the class to analyze"
"Constants.java:60"$1$"	 * @throws IllegalArgumentException if the supplied {@code clazz} is {@code null}"
"Constants.java:61"$1$"	 */"
"Constants.java:62"$1$"	public Constants(Class<?> clazz) {"
"Constants.java:63"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"Constants.java:64"$1$"		this.className = clazz.getName();"
"Constants.java:65"$1$"		Field[] fields = clazz.getFields();"
"Constants.java:66"$1$"		for (Field field : fields) {"
"Constants.java:67"$1$"			if (ReflectionUtils.isPublicStaticFinal(field)) {"
"Constants.java:68"$1$"				String name = field.getName();"
"Constants.java:69"$1$"				try {"
"Constants.java:70"$1$"					Object value = field.get(null);"
"Constants.java:71"$1$"					this.fieldCache.put(name, value);"
"Constants.java:72"$1$"				}"
"Constants.java:73"$1$"				catch (IllegalAccessException ex) {"
"Constants.java:74"$0$"					// just leave this field and continue"
"Constants.java:75"$1$"				}"
"Constants.java:76"$0$"			}"
"Constants.java:77"$0$"		}"
"Constants.java:78"$0$"	}"
"Constants.java:79"$0$""
"Constants.java:80"$0$""
"Constants.java:81"$0$"	/**"
"Constants.java:82"$0$"	 * Return the name of the analyzed class."
"Constants.java:83"$0$"	 */"
"Constants.java:84"$1$"	public final String getClassName() {"
"Constants.java:85"$1$"		return this.className;"
"Constants.java:86"$1$"	}"
"Constants.java:87"$0$""
"Constants.java:88"$0$"	/**"
"Constants.java:89"$0$"	 * Return the number of constants exposed."
"Constants.java:90"$0$"	 */"
"Constants.java:91"$1$"	public final int getSize() {"
"Constants.java:92"$1$"		return this.fieldCache.size();"
"Constants.java:93"$1$"	}"
"Constants.java:94"$0$""
"Constants.java:95"$0$"	/**"
"Constants.java:96"$0$"	 * Exposes the field cache to subclasses:"
"Constants.java:97"$0$"	 * a Map from String field name to object value."
"Constants.java:98"$0$"	 */"
"Constants.java:99"$1$"	protected final Map<String, Object> getFieldCache() {"
"Constants.java:100"$1$"		return this.fieldCache;"
"Constants.java:101"$1$"	}"
"Constants.java:102"$0$""
"Constants.java:103"$0$""
"Constants.java:104"$0$"	/**"
"Constants.java:105"$0$"	 * Return a constant value cast to a Number."
"Constants.java:106"$1$"	 * @param code the name of the field (never {@code null})"
"Constants.java:107"$0$"	 * @return the Number value"
"Constants.java:108"$0$"	 * @throws ConstantException if the field name wasn't found"
"Constants.java:109"$0$"	 * or if the type wasn't compatible with Number"
"Constants.java:110"$0$"	 * @see #asObject"
"Constants.java:111"$0$"	 */"
"Constants.java:112"$1$"	public Number asNumber(String code) throws ConstantException {"
"Constants.java:113"$1$"		Object obj = asObject(code);"
"Constants.java:114"$1$"		if (!(obj instanceof Number)) {"
"Constants.java:115"$1$"			throw new ConstantException(this.className, code, ""not a Number"");"
"Constants.java:116"$1$"		}"
"Constants.java:117"$0$"		return (Number) obj;"
"Constants.java:118"$0$"	}"
"Constants.java:119"$0$""
"Constants.java:120"$0$"	/**"
"Constants.java:121"$0$"	 * Return a constant value as a String."
"Constants.java:122"$1$"	 * @param code the name of the field (never {@code null})"
"Constants.java:123"$0$"	 * @return the String value"
"Constants.java:124"$1$"	 * Works even if it's not a string (invokes {@code toString()})."
"Constants.java:125"$0$"	 * @throws ConstantException if the field name wasn't found"
"Constants.java:126"$0$"	 * @see #asObject"
"Constants.java:127"$0$"	 */"
"Constants.java:128"$1$"	public String asString(String code) throws ConstantException {"
"Constants.java:129"$1$"		return asObject(code).toString();"
"Constants.java:130"$1$"	}"
"Constants.java:131"$0$""
"Constants.java:132"$0$"	/**"
"Constants.java:133"$0$"	 * Parse the given String (upper or lower case accepted) and return"
"Constants.java:134"$0$"	 * the appropriate value if it's the name of a constant field in the"
"Constants.java:135"$0$"	 * class that we're analysing."
"Constants.java:136"$1$"	 * @param code the name of the field (never {@code null})"
"Constants.java:137"$0$"	 * @return the Object value"
"Constants.java:138"$0$"	 * @throws ConstantException if there's no such field"
"Constants.java:139"$0$"	 */"
"Constants.java:140"$1$"	public Object asObject(String code) throws ConstantException {"
"Constants.java:141"$1$"		Assert.notNull(code, ""Code must not be null"");"
"Constants.java:142"$1$"		String codeToUse = code.toUpperCase(Locale.ENGLISH);"
"Constants.java:143"$1$"		Object val = this.fieldCache.get(codeToUse);"
"Constants.java:144"$1$"		if (val == null) {"
"Constants.java:145"$1$"			throw new ConstantException(this.className, codeToUse, ""not found"");"
"Constants.java:146"$1$"		}"
"Constants.java:147"$0$"		return val;"
"Constants.java:148"$0$"	}"
"Constants.java:149"$0$""
"Constants.java:150"$0$""
"Constants.java:151"$0$"	/**"
"Constants.java:152"$0$"	 * Return all names of the given group of constants."
"Constants.java:153"$0$"	 * <p>Note that this method assumes that constants are named"
"Constants.java:154"$0$"	 * in accordance with the standard Java convention for constant"
"Constants.java:155"$1$"	 * values (i.e. all uppercase). The supplied {@code namePrefix}"
"Constants.java:156"$0$"	 * will be uppercased (in a locale-insensitive fashion) prior to"
"Constants.java:157"$0$"	 * the main logic of this method kicking in."
"Constants.java:158"$1$"	 * @param namePrefix prefix of the constant names to search (may be {@code null})"
"Constants.java:159"$0$"	 * @return the set of constant names"
"Constants.java:160"$0$"	 */"
"Constants.java:161"$1$"	public Set<String> getNames(@Nullable String namePrefix) {"
"Constants.java:162"$1$"		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:163"$1$"		Set<String> names = new HashSet<>();"
"Constants.java:164"$1$"		for (String code : this.fieldCache.keySet()) {"
"Constants.java:165"$1$"			if (code.startsWith(prefixToUse)) {"
"Constants.java:166"$1$"				names.add(code);"
"Constants.java:167"$1$"			}"
"Constants.java:168"$0$"		}"
"Constants.java:169"$0$"		return names;"
"Constants.java:170"$0$"	}"
"Constants.java:171"$0$""
"Constants.java:172"$0$"	/**"
"Constants.java:173"$0$"	 * Return all names of the group of constants for the"
"Constants.java:174"$0$"	 * given bean property name."
"Constants.java:175"$0$"	 * @param propertyName the name of the bean property"
"Constants.java:176"$0$"	 * @return the set of values"
"Constants.java:177"$0$"	 * @see #propertyToConstantNamePrefix"
"Constants.java:178"$0$"	 */"
"Constants.java:179"$1$"	public Set<String> getNamesForProperty(String propertyName) {"
"Constants.java:180"$1$"		return getNames(propertyToConstantNamePrefix(propertyName));"
"Constants.java:181"$1$"	}"
"Constants.java:182"$0$""
"Constants.java:183"$0$"	/**"
"Constants.java:184"$0$"	 * Return all names of the given group of constants."
"Constants.java:185"$0$"	 * <p>Note that this method assumes that constants are named"
"Constants.java:186"$0$"	 * in accordance with the standard Java convention for constant"
"Constants.java:187"$1$"	 * values (i.e. all uppercase). The supplied {@code nameSuffix}"
"Constants.java:188"$0$"	 * will be uppercased (in a locale-insensitive fashion) prior to"
"Constants.java:189"$0$"	 * the main logic of this method kicking in."
"Constants.java:190"$1$"	 * @param nameSuffix suffix of the constant names to search (may be {@code null})"
"Constants.java:191"$0$"	 * @return the set of constant names"
"Constants.java:192"$0$"	 */"
"Constants.java:193"$1$"	public Set<String> getNamesForSuffix(@Nullable String nameSuffix) {"
"Constants.java:194"$1$"		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:195"$1$"		Set<String> names = new HashSet<>();"
"Constants.java:196"$1$"		for (String code : this.fieldCache.keySet()) {"
"Constants.java:197"$1$"			if (code.endsWith(suffixToUse)) {"
"Constants.java:198"$1$"				names.add(code);"
"Constants.java:199"$1$"			}"
"Constants.java:200"$0$"		}"
"Constants.java:201"$0$"		return names;"
"Constants.java:202"$0$"	}"
"Constants.java:203"$0$""
"Constants.java:204"$0$""
"Constants.java:205"$0$"	/**"
"Constants.java:206"$0$"	 * Return all values of the given group of constants."
"Constants.java:207"$0$"	 * <p>Note that this method assumes that constants are named"
"Constants.java:208"$0$"	 * in accordance with the standard Java convention for constant"
"Constants.java:209"$1$"	 * values (i.e. all uppercase). The supplied {@code namePrefix}"
"Constants.java:210"$0$"	 * will be uppercased (in a locale-insensitive fashion) prior to"
"Constants.java:211"$0$"	 * the main logic of this method kicking in."
"Constants.java:212"$1$"	 * @param namePrefix prefix of the constant names to search (may be {@code null})"
"Constants.java:213"$0$"	 * @return the set of values"
"Constants.java:214"$0$"	 */"
"Constants.java:215"$1$"	public Set<Object> getValues(@Nullable String namePrefix) {"
"Constants.java:216"$1$"		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:217"$1$"		Set<Object> values = new HashSet<>();"
"Constants.java:218"$1$"		this.fieldCache.forEach((code, value) -> {"
"Constants.java:219"$1$"			if (code.startsWith(prefixToUse)) {"
"Constants.java:220"$1$"				values.add(value);"
"Constants.java:221"$1$"			}"
"Constants.java:222"$0$"		});"
"Constants.java:223"$0$"		return values;"
"Constants.java:224"$0$"	}"
"Constants.java:225"$0$""
"Constants.java:226"$0$"	/**"
"Constants.java:227"$0$"	 * Return all values of the group of constants for the"
"Constants.java:228"$0$"	 * given bean property name."
"Constants.java:229"$0$"	 * @param propertyName the name of the bean property"
"Constants.java:230"$0$"	 * @return the set of values"
"Constants.java:231"$0$"	 * @see #propertyToConstantNamePrefix"
"Constants.java:232"$0$"	 */"
"Constants.java:233"$1$"	public Set<Object> getValuesForProperty(String propertyName) {"
"Constants.java:234"$1$"		return getValues(propertyToConstantNamePrefix(propertyName));"
"Constants.java:235"$1$"	}"
"Constants.java:236"$0$""
"Constants.java:237"$0$"	/**"
"Constants.java:238"$0$"	 * Return all values of the given group of constants."
"Constants.java:239"$0$"	 * <p>Note that this method assumes that constants are named"
"Constants.java:240"$0$"	 * in accordance with the standard Java convention for constant"
"Constants.java:241"$1$"	 * values (i.e. all uppercase). The supplied {@code nameSuffix}"
"Constants.java:242"$0$"	 * will be uppercased (in a locale-insensitive fashion) prior to"
"Constants.java:243"$0$"	 * the main logic of this method kicking in."
"Constants.java:244"$1$"	 * @param nameSuffix suffix of the constant names to search (may be {@code null})"
"Constants.java:245"$0$"	 * @return the set of values"
"Constants.java:246"$0$"	 */"
"Constants.java:247"$1$"	public Set<Object> getValuesForSuffix(@Nullable String nameSuffix) {"
"Constants.java:248"$1$"		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:249"$1$"		Set<Object> values = new HashSet<>();"
"Constants.java:250"$1$"		this.fieldCache.forEach((code, value) -> {"
"Constants.java:251"$1$"			if (code.endsWith(suffixToUse)) {"
"Constants.java:252"$1$"				values.add(value);"
"Constants.java:253"$1$"			}"
"Constants.java:254"$0$"		});"
"Constants.java:255"$0$"		return values;"
"Constants.java:256"$0$"	}"
"Constants.java:257"$0$""
"Constants.java:258"$0$""
"Constants.java:259"$0$"	/**"
"Constants.java:260"$0$"	 * Look up the given value within the given group of constants."
"Constants.java:261"$0$"	 * <p>Will return the first match."
"Constants.java:262"$0$"	 * @param value constant value to look up"
"Constants.java:263"$1$"	 * @param namePrefix prefix of the constant names to search (may be {@code null})"
"Constants.java:264"$0$"	 * @return the name of the constant field"
"Constants.java:265"$0$"	 * @throws ConstantException if the value wasn't found"
"Constants.java:266"$0$"	 */"
"Constants.java:267"$1$"	public String toCode(Object value, @Nullable String namePrefix) throws ConstantException {"
"Constants.java:268"$1$"		String prefixToUse = (namePrefix != null ? namePrefix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:269"$1$"		for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {"
"Constants.java:270"$1$"			if (entry.getKey().startsWith(prefixToUse) && entry.getValue().equals(value)) {"
"Constants.java:271"$1$"				return entry.getKey();"
"Constants.java:272"$1$"			}"
"Constants.java:273"$0$"		}"
"Constants.java:274"$0$"		throw new ConstantException(this.className, prefixToUse, value);"
"Constants.java:275"$0$"	}"
"Constants.java:276"$0$""
"Constants.java:277"$0$"	/**"
"Constants.java:278"$0$"	 * Look up the given value within the group of constants for"
"Constants.java:279"$0$"	 * the given bean property name. Will return the first match."
"Constants.java:280"$0$"	 * @param value constant value to look up"
"Constants.java:281"$0$"	 * @param propertyName the name of the bean property"
"Constants.java:282"$0$"	 * @return the name of the constant field"
"Constants.java:283"$0$"	 * @throws ConstantException if the value wasn't found"
"Constants.java:284"$0$"	 * @see #propertyToConstantNamePrefix"
"Constants.java:285"$0$"	 */"
"Constants.java:286"$1$"	public String toCodeForProperty(Object value, String propertyName) throws ConstantException {"
"Constants.java:287"$1$"		return toCode(value, propertyToConstantNamePrefix(propertyName));"
"Constants.java:288"$1$"	}"
"Constants.java:289"$0$""
"Constants.java:290"$0$"	/**"
"Constants.java:291"$0$"	 * Look up the given value within the given group of constants."
"Constants.java:292"$0$"	 * <p>Will return the first match."
"Constants.java:293"$0$"	 * @param value constant value to look up"
"Constants.java:294"$1$"	 * @param nameSuffix suffix of the constant names to search (may be {@code null})"
"Constants.java:295"$0$"	 * @return the name of the constant field"
"Constants.java:296"$0$"	 * @throws ConstantException if the value wasn't found"
"Constants.java:297"$0$"	 */"
"Constants.java:298"$1$"	public String toCodeForSuffix(Object value, @Nullable String nameSuffix) throws ConstantException {"
"Constants.java:299"$1$"		String suffixToUse = (nameSuffix != null ? nameSuffix.trim().toUpperCase(Locale.ENGLISH) : """");"
"Constants.java:300"$1$"		for (Map.Entry<String, Object> entry : this.fieldCache.entrySet()) {"
"Constants.java:301"$1$"			if (entry.getKey().endsWith(suffixToUse) && entry.getValue().equals(value)) {"
"Constants.java:302"$1$"				return entry.getKey();"
"Constants.java:303"$1$"			}"
"Constants.java:304"$0$"		}"
"Constants.java:305"$0$"		throw new ConstantException(this.className, suffixToUse, value);"
"Constants.java:306"$0$"	}"
"Constants.java:307"$0$""
"Constants.java:308"$0$""
"Constants.java:309"$0$"	/**"
"Constants.java:310"$0$"	 * Convert the given bean property name to a constant name prefix."
"Constants.java:311"$0$"	 * <p>Uses a common naming idiom: turning all lower case characters to"
"Constants.java:312"$0$"	 * upper case, and prepending upper case characters with an underscore."
"Constants.java:313"$0$"	 * <p>Example: ""imageSize"" -> ""IMAGE_SIZE""<br>"
"Constants.java:314"$0$"	 * Example: ""imagesize"" -> ""IMAGESIZE"".<br>"
"Constants.java:315"$0$"	 * Example: ""ImageSize"" -> ""_IMAGE_SIZE"".<br>"
"Constants.java:316"$0$"	 * Example: ""IMAGESIZE"" -> ""_I_M_A_G_E_S_I_Z_E"""
"Constants.java:317"$0$"	 * @param propertyName the name of the bean property"
"Constants.java:318"$0$"	 * @return the corresponding constant name prefix"
"Constants.java:319"$0$"	 * @see #getValuesForProperty"
"Constants.java:320"$0$"	 * @see #toCodeForProperty"
"Constants.java:321"$0$"	 */"
"Constants.java:322"$1$"	public String propertyToConstantNamePrefix(String propertyName) {"
"Constants.java:323"$1$"		StringBuilder parsedPrefix = new StringBuilder();"
"Constants.java:324"$1$"		for (int i = 0; i < propertyName.length(); i++) {"
"Constants.java:325"$1$"			char c = propertyName.charAt(i);"
"Constants.java:326"$1$"			if (Character.isUpperCase(c)) {"
"Constants.java:327"$1$"				parsedPrefix.append(""_"");"
"Constants.java:328"$1$"				parsedPrefix.append(c);"
"Constants.java:329"$1$"			}"
"Constants.java:330"$1$"			else {"
"Constants.java:331"$1$"				parsedPrefix.append(Character.toUpperCase(c));"
"Constants.java:332"$1$"			}"
"Constants.java:333"$0$"		}"
"Constants.java:334"$0$"		return parsedPrefix.toString();"
"Constants.java:335"$0$"	}"
"Constants.java:336"$0$""
"Constants.java:337"$0$""
"Constants.java:338"$0$"	/**"
"Constants.java:339"$1$"	 * Exception thrown when the {@link Constants} class is asked for"
"Constants.java:340"$0$"	 * an invalid constant name."
"Constants.java:341"$0$"	 */"
"Constants.java:342"$0$"	@SuppressWarnings(""serial"")"
"Constants.java:343"$1$"	public static class ConstantException extends IllegalArgumentException {"
"Constants.java:344"$1$""
"Constants.java:345"$1$"		/**"
"Constants.java:346"$1$"		 * Thrown when an invalid constant name is requested."
"Constants.java:347"$1$"		 * @param className name of the class containing the constant definitions"
"Constants.java:348"$1$"		 * @param field invalid constant name"
"Constants.java:349"$1$"		 * @param message description of the problem"
"Constants.java:350"$1$"		 */"
"Constants.java:351"$1$"		public ConstantException(String className, String field, String message) {"
"Constants.java:352"$1$"			super(""Field '"" + field + ""' "" + message + "" in class ["" + className + ""]"");"
"Constants.java:353"$1$"		}"
"Constants.java:354"$0$""
"Constants.java:355"$0$"		/**"
"Constants.java:356"$0$"		 * Thrown when an invalid constant value is looked up."
"Constants.java:357"$0$"		 * @param className name of the class containing the constant definitions"
"Constants.java:358"$0$"		 * @param namePrefix prefix of the searched constant names"
"Constants.java:359"$0$"		 * @param value the looked up constant value"
"Constants.java:360"$0$"		 */"
"Constants.java:361"$1$"		public ConstantException(String className, String namePrefix, Object value) {"
"Constants.java:362"$1$"			super(""No '"" + namePrefix + ""' field with value '"" + value + ""' found in class ["" + className + ""]"");"
"Constants.java:363"$1$"		}"
"Constants.java:364"$0$"	}"
"Constants.java:365"$0$""
"Constants.java:366"$0$"}"
"StandardEnvironment.java:1"$0$"/*"
"StandardEnvironment.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"StandardEnvironment.java:3"$0$" *"
"StandardEnvironment.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StandardEnvironment.java:5"$0$" * you may not use this file except in compliance with the License."
"StandardEnvironment.java:6"$0$" * You may obtain a copy of the License at"
"StandardEnvironment.java:7"$0$" *"
"StandardEnvironment.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StandardEnvironment.java:9"$0$" *"
"StandardEnvironment.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StandardEnvironment.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StandardEnvironment.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StandardEnvironment.java:13"$0$" * See the License for the specific language governing permissions and"
"StandardEnvironment.java:14"$0$" * limitations under the License."
"StandardEnvironment.java:15"$0$" */"
"StandardEnvironment.java:16"$0$""
"StandardEnvironment.java:17"$0$"package org.springframework.core.env;"
"StandardEnvironment.java:18"$0$""
"StandardEnvironment.java:19"$0$"/**"
"StandardEnvironment.java:20"$1$" * {@link Environment} implementation suitable for use in 'standard' (i.e. non-web)"
"StandardEnvironment.java:21"$0$" * applications."
"StandardEnvironment.java:22"$0$" *"
"StandardEnvironment.java:23"$1$" * <p>In addition to the usual functions of a {@link ConfigurableEnvironment} such as"
"StandardEnvironment.java:24"$0$" * property resolution and profile-related operations, this implementation configures two"
"StandardEnvironment.java:25"$0$" * default property sources, to be searched in the following order:"
"StandardEnvironment.java:26"$0$" * <ul>"
"StandardEnvironment.java:27"$1$" * <li>{@linkplain AbstractEnvironment#getSystemProperties() system properties}"
"StandardEnvironment.java:28"$1$" * <li>{@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables}"
"StandardEnvironment.java:29"$0$" * </ul>"
"StandardEnvironment.java:30"$0$" *"
"StandardEnvironment.java:31"$0$" * That is, if the key ""xyz"" is present both in the JVM system properties as well as in"
"StandardEnvironment.java:32"$0$" * the set of environment variables for the current process, the value of key ""xyz"" from"
"StandardEnvironment.java:33"$1$" * system properties will return from a call to {@code environment.getProperty(""xyz"")}."
"StandardEnvironment.java:34"$0$" * This ordering is chosen by default because system properties are per-JVM, while"
"StandardEnvironment.java:35"$0$" * environment variables may be the same across many JVMs on a given system.  Giving"
"StandardEnvironment.java:36"$0$" * system properties precedence allows for overriding of environment variables on a"
"StandardEnvironment.java:37"$0$" * per-JVM basis."
"StandardEnvironment.java:38"$0$" *"
"StandardEnvironment.java:39"$0$" * <p>These default property sources may be removed, reordered, or replaced; and"
"StandardEnvironment.java:40"$1$" * additional property sources may be added using the {@link MutablePropertySources}"
"StandardEnvironment.java:41"$1$" * instance available from {@link #getPropertySources()}. See"
"StandardEnvironment.java:42"$1$" * {@link ConfigurableEnvironment} Javadoc for usage examples."
"StandardEnvironment.java:43"$0$" *"
"StandardEnvironment.java:44"$1$" * <p>See {@link SystemEnvironmentPropertySource} javadoc for details on special handling"
"StandardEnvironment.java:45"$0$" * of property names in shell environments (e.g. Bash) that disallow period characters in"
"StandardEnvironment.java:46"$0$" * variable names."
"StandardEnvironment.java:47"$0$" *"
"StandardEnvironment.java:48"$0$" * @author Chris Beams"
"StandardEnvironment.java:49"$0$" * @since 3.1"
"StandardEnvironment.java:50"$0$" * @see ConfigurableEnvironment"
"StandardEnvironment.java:51"$0$" * @see SystemEnvironmentPropertySource"
"StandardEnvironment.java:52"$0$" * @see org.springframework.web.context.support.StandardServletEnvironment"
"StandardEnvironment.java:53"$0$" */"
"StandardEnvironment.java:54"$1$"public class StandardEnvironment extends AbstractEnvironment {"
"StandardEnvironment.java:55"$1$""
"StandardEnvironment.java:56"$1$"	/** System environment property source name: {@value}. */"
"StandardEnvironment.java:57"$1$"	public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = ""systemEnvironment"";"
"StandardEnvironment.java:58"$1$""
"StandardEnvironment.java:59"$1$"	/** JVM system properties property source name: {@value}. */"
"StandardEnvironment.java:60"$1$"	public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = ""systemProperties"";"
"StandardEnvironment.java:61"$1$""
"StandardEnvironment.java:62"$1$""
"StandardEnvironment.java:63"$1$"	/**"
"StandardEnvironment.java:64"$1$"	 * Customize the set of property sources with those appropriate for any standard"
"StandardEnvironment.java:65"$1$"	 * Java environment:"
"StandardEnvironment.java:66"$1$"	 * <ul>"
"StandardEnvironment.java:67"$1$"	 * <li>{@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME}"
"StandardEnvironment.java:68"$1$"	 * <li>{@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}"
"StandardEnvironment.java:69"$1$"	 * </ul>"
"StandardEnvironment.java:70"$1$"	 * <p>Properties present in {@value #SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME} will"
"StandardEnvironment.java:71"$1$"	 * take precedence over those in {@value #SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME}."
"StandardEnvironment.java:72"$1$"	 * @see AbstractEnvironment#customizePropertySources(MutablePropertySources)"
"StandardEnvironment.java:73"$1$"	 * @see #getSystemProperties()"
"StandardEnvironment.java:74"$1$"	 * @see #getSystemEnvironment()"
"StandardEnvironment.java:75"$1$"	 */"
"StandardEnvironment.java:76"$1$"	@Override"
"StandardEnvironment.java:77"$1$"	protected void customizePropertySources(MutablePropertySources propertySources) {"
"StandardEnvironment.java:78"$1$"		propertySources.addLast("
"StandardEnvironment.java:79"$1$"				new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));"
"StandardEnvironment.java:80"$1$"		propertySources.addLast("
"StandardEnvironment.java:81"$1$"				new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));"
"StandardEnvironment.java:82"$1$"	}"
"StandardEnvironment.java:83"$0$""
"StandardEnvironment.java:84"$0$"}"
"DataBufferUtils.java:1"$0$"/*"
"DataBufferUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DataBufferUtils.java:3"$0$" *"
"DataBufferUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DataBufferUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"DataBufferUtils.java:6"$0$" * You may obtain a copy of the License at"
"DataBufferUtils.java:7"$0$" *"
"DataBufferUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DataBufferUtils.java:9"$0$" *"
"DataBufferUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DataBufferUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DataBufferUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DataBufferUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"DataBufferUtils.java:14"$0$" * limitations under the License."
"DataBufferUtils.java:15"$0$" */"
"DataBufferUtils.java:16"$0$""
"DataBufferUtils.java:17"$0$"package org.springframework.core.io.buffer;"
"DataBufferUtils.java:18"$0$""
"DataBufferUtils.java:19"$0$"import java.io.File;"
"DataBufferUtils.java:20"$0$"import java.io.IOException;"
"DataBufferUtils.java:21"$0$"import java.io.InputStream;"
"DataBufferUtils.java:22"$0$"import java.io.OutputStream;"
"DataBufferUtils.java:23"$0$"import java.nio.ByteBuffer;"
"DataBufferUtils.java:24"$0$"import java.nio.channels.AsynchronousFileChannel;"
"DataBufferUtils.java:25"$0$"import java.nio.channels.Channel;"
"DataBufferUtils.java:26"$0$"import java.nio.channels.Channels;"
"DataBufferUtils.java:27"$0$"import java.nio.channels.CompletionHandler;"
"DataBufferUtils.java:28"$0$"import java.nio.channels.ReadableByteChannel;"
"DataBufferUtils.java:29"$0$"import java.nio.channels.WritableByteChannel;"
"DataBufferUtils.java:30"$0$"import java.nio.file.OpenOption;"
"DataBufferUtils.java:31"$0$"import java.nio.file.Path;"
"DataBufferUtils.java:32"$0$"import java.nio.file.StandardOpenOption;"
"DataBufferUtils.java:33"$0$"import java.util.Arrays;"
"DataBufferUtils.java:34"$0$"import java.util.HashSet;"
"DataBufferUtils.java:35"$0$"import java.util.Set;"
"DataBufferUtils.java:36"$0$"import java.util.concurrent.Callable;"
"DataBufferUtils.java:37"$0$"import java.util.concurrent.atomic.AtomicBoolean;"
"DataBufferUtils.java:38"$0$"import java.util.concurrent.atomic.AtomicLong;"
"DataBufferUtils.java:39"$0$"import java.util.concurrent.atomic.AtomicReference;"
"DataBufferUtils.java:40"$0$"import java.util.function.Consumer;"
"DataBufferUtils.java:41"$0$""
"DataBufferUtils.java:42"$0$"import org.reactivestreams.Publisher;"
"DataBufferUtils.java:43"$0$"import org.reactivestreams.Subscription;"
"DataBufferUtils.java:44"$0$"import reactor.core.publisher.BaseSubscriber;"
"DataBufferUtils.java:45"$0$"import reactor.core.publisher.Flux;"
"DataBufferUtils.java:46"$0$"import reactor.core.publisher.FluxSink;"
"DataBufferUtils.java:47"$0$"import reactor.core.publisher.Mono;"
"DataBufferUtils.java:48"$0$"import reactor.core.publisher.SynchronousSink;"
"DataBufferUtils.java:49"$0$""
"DataBufferUtils.java:50"$0$"import org.springframework.core.io.Resource;"
"DataBufferUtils.java:51"$0$"import org.springframework.lang.Nullable;"
"DataBufferUtils.java:52"$0$"import org.springframework.util.Assert;"
"DataBufferUtils.java:53"$0$""
"DataBufferUtils.java:54"$0$"/**"
"DataBufferUtils.java:55"$1$" * Utility class for working with {@link DataBuffer DataBuffers}."
"DataBufferUtils.java:56"$0$" *"
"DataBufferUtils.java:57"$0$" * @author Arjen Poutsma"
"DataBufferUtils.java:58"$0$" * @author Brian Clozel"
"DataBufferUtils.java:59"$0$" * @since 5.0"
"DataBufferUtils.java:60"$0$" */"
"DataBufferUtils.java:61"$1$"public abstract class DataBufferUtils {"
"DataBufferUtils.java:62"$1$""
"DataBufferUtils.java:63"$1$"	private static final Consumer<DataBuffer> RELEASE_CONSUMER = DataBufferUtils::release;"
"DataBufferUtils.java:64"$1$""
"DataBufferUtils.java:65"$1$""
"DataBufferUtils.java:66"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:67"$0$"	// Reading"
"DataBufferUtils.java:68"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:69"$1$""
"DataBufferUtils.java:70"$1$"	/**"
"DataBufferUtils.java:71"$1$"	 * Obtain a {@link InputStream} from the given supplier, and read it into a"
"DataBufferUtils.java:72"$1$"	 * {@code Flux} of {@code DataBuffer}s. Closes the input stream when the"
"DataBufferUtils.java:73"$1$"	 * Flux is terminated."
"DataBufferUtils.java:74"$1$"	 * @param inputStreamSupplier the supplier for the input stream to read from"
"DataBufferUtils.java:75"$1$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:76"$1$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:77"$1$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:78"$1$"	 */"
"DataBufferUtils.java:79"$1$"	public static Flux<DataBuffer> readInputStream("
"DataBufferUtils.java:80"$1$"			Callable<InputStream> inputStreamSupplier, DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:81"$1$""
"DataBufferUtils.java:82"$1$"		Assert.notNull(inputStreamSupplier, ""'inputStreamSupplier' must not be null"");"
"DataBufferUtils.java:83"$1$"		return readByteChannel(() -> Channels.newChannel(inputStreamSupplier.call()), bufferFactory, bufferSize);"
"DataBufferUtils.java:84"$1$"	}"
"DataBufferUtils.java:85"$0$""
"DataBufferUtils.java:86"$0$"	/**"
"DataBufferUtils.java:87"$1$"	 * Obtain a {@link ReadableByteChannel} from the given supplier, and read"
"DataBufferUtils.java:88"$1$"	 * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when"
"DataBufferUtils.java:89"$0$"	 * the Flux is terminated."
"DataBufferUtils.java:90"$0$"	 * @param channelSupplier the supplier for the channel to read from"
"DataBufferUtils.java:91"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:92"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:93"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:94"$0$"	 */"
"DataBufferUtils.java:95"$0$"	public static Flux<DataBuffer> readByteChannel("
"DataBufferUtils.java:96"$1$"			Callable<ReadableByteChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:97"$1$""
"DataBufferUtils.java:98"$1$"		Assert.notNull(channelSupplier, ""'channelSupplier' must not be null"");"
"DataBufferUtils.java:99"$1$"		Assert.notNull(bufferFactory, ""'dataBufferFactory' must not be null"");"
"DataBufferUtils.java:100"$1$"		Assert.isTrue(bufferSize > 0, ""'bufferSize' must be > 0"");"
"DataBufferUtils.java:101"$1$""
"DataBufferUtils.java:102"$1$"		return Flux.using(channelSupplier,"
"DataBufferUtils.java:103"$1$"				channel -> Flux.generate(new ReadableByteChannelGenerator(channel, bufferFactory, bufferSize)),"
"DataBufferUtils.java:104"$1$"				DataBufferUtils::closeChannel);"
"DataBufferUtils.java:105"$1$""
"DataBufferUtils.java:106"$0$"		// No doOnDiscard as operators used do not cache"
"DataBufferUtils.java:107"$1$"	}"
"DataBufferUtils.java:108"$0$""
"DataBufferUtils.java:109"$0$"	/**"
"DataBufferUtils.java:110"$1$"	 * Obtain a {@code AsynchronousFileChannel} from the given supplier, and read"
"DataBufferUtils.java:111"$1$"	 * it into a {@code Flux} of {@code DataBuffer}s. Closes the channel when"
"DataBufferUtils.java:112"$0$"	 * the Flux is terminated."
"DataBufferUtils.java:113"$0$"	 * @param channelSupplier the supplier for the channel to read from"
"DataBufferUtils.java:114"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:115"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:116"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:117"$0$"	 */"
"DataBufferUtils.java:118"$0$"	public static Flux<DataBuffer> readAsynchronousFileChannel("
"DataBufferUtils.java:119"$1$"			Callable<AsynchronousFileChannel> channelSupplier, DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:120"$1$""
"DataBufferUtils.java:121"$1$"		return readAsynchronousFileChannel(channelSupplier, 0, bufferFactory, bufferSize);"
"DataBufferUtils.java:122"$1$"	}"
"DataBufferUtils.java:123"$0$""
"DataBufferUtils.java:124"$0$"	/**"
"DataBufferUtils.java:125"$1$"	 * Obtain a {@code AsynchronousFileChannel} from the given supplier, and"
"DataBufferUtils.java:126"$1$"	 * read it into a {@code Flux} of {@code DataBuffer}s, starting at the given"
"DataBufferUtils.java:127"$0$"	 * position. Closes the channel when the Flux is terminated."
"DataBufferUtils.java:128"$0$"	 * @param channelSupplier the supplier for the channel to read from"
"DataBufferUtils.java:129"$0$"	 * @param position the position to start reading from"
"DataBufferUtils.java:130"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:131"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:132"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:133"$0$"	 */"
"DataBufferUtils.java:134"$0$"	public static Flux<DataBuffer> readAsynchronousFileChannel("
"DataBufferUtils.java:135"$0$"			Callable<AsynchronousFileChannel> channelSupplier, long position,"
"DataBufferUtils.java:136"$1$"			DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:137"$1$""
"DataBufferUtils.java:138"$1$"		Assert.notNull(channelSupplier, ""'channelSupplier' must not be null"");"
"DataBufferUtils.java:139"$1$"		Assert.notNull(bufferFactory, ""'dataBufferFactory' must not be null"");"
"DataBufferUtils.java:140"$1$"		Assert.isTrue(position >= 0, ""'position' must be >= 0"");"
"DataBufferUtils.java:141"$1$"		Assert.isTrue(bufferSize > 0, ""'bufferSize' must be > 0"");"
"DataBufferUtils.java:142"$1$""
"DataBufferUtils.java:143"$1$"		Flux<DataBuffer> flux = Flux.using(channelSupplier,"
"DataBufferUtils.java:144"$1$"				channel -> Flux.create(sink -> {"
"DataBufferUtils.java:145"$1$"					ReadCompletionHandler handler ="
"DataBufferUtils.java:146"$1$"							new ReadCompletionHandler(channel, sink, position, bufferFactory, bufferSize);"
"DataBufferUtils.java:147"$1$"					sink.onCancel(handler::cancel);"
"DataBufferUtils.java:148"$1$"					sink.onRequest(handler::request);"
"DataBufferUtils.java:149"$1$"				}),"
"DataBufferUtils.java:150"$1$"				channel -> {"
"DataBufferUtils.java:151"$0$"					// Do not close channel from here, rather wait for the current read callback"
"DataBufferUtils.java:152"$0$"					// and then complete after releasing the DataBuffer."
"DataBufferUtils.java:153"$1$"				});"
"DataBufferUtils.java:154"$0$""
"DataBufferUtils.java:155"$0$"		return flux.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);"
"DataBufferUtils.java:156"$0$"	}"
"DataBufferUtils.java:157"$0$""
"DataBufferUtils.java:158"$0$"	/**"
"DataBufferUtils.java:159"$1$"	 * Read bytes from the given file {@code Path} into a {@code Flux} of {@code DataBuffer}s."
"DataBufferUtils.java:160"$0$"	 * The method ensures that the file is closed when the flux is terminated."
"DataBufferUtils.java:161"$0$"	 * @param path the path to read bytes from"
"DataBufferUtils.java:162"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:163"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:164"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:165"$0$"	 * @since 5.2"
"DataBufferUtils.java:166"$0$"	 */"
"DataBufferUtils.java:167"$0$"	public static Flux<DataBuffer> read("
"DataBufferUtils.java:168"$1$"			Path path, DataBufferFactory bufferFactory, int bufferSize, OpenOption... options) {"
"DataBufferUtils.java:169"$1$""
"DataBufferUtils.java:170"$1$"		Assert.notNull(path, ""Path must not be null"");"
"DataBufferUtils.java:171"$1$"		Assert.notNull(bufferFactory, ""BufferFactory must not be null"");"
"DataBufferUtils.java:172"$1$"		Assert.isTrue(bufferSize > 0, ""'bufferSize' must be > 0"");"
"DataBufferUtils.java:173"$1$"		if (options.length > 0) {"
"DataBufferUtils.java:174"$1$"			for (OpenOption option : options) {"
"DataBufferUtils.java:175"$1$"				Assert.isTrue(!(option == StandardOpenOption.APPEND || option == StandardOpenOption.WRITE),"
"DataBufferUtils.java:176"$1$"						""'"" + option + ""' not allowed"");"
"DataBufferUtils.java:177"$1$"			}"
"DataBufferUtils.java:178"$0$"		}"
"DataBufferUtils.java:179"$0$""
"DataBufferUtils.java:180"$0$"		return readAsynchronousFileChannel(() -> AsynchronousFileChannel.open(path, options),"
"DataBufferUtils.java:181"$0$"				bufferFactory, bufferSize);"
"DataBufferUtils.java:182"$0$"	}"
"DataBufferUtils.java:183"$0$""
"DataBufferUtils.java:184"$0$"	/**"
"DataBufferUtils.java:185"$1$"	 * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s."
"DataBufferUtils.java:186"$0$"	 * <p>If the resource is a file, it is read into an"
"DataBufferUtils.java:187"$1$"	 * {@code AsynchronousFileChannel} and turned to {@code Flux} via"
"DataBufferUtils.java:188"$1$"	 * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else"
"DataBufferUtils.java:189"$1$"	 * fall back to {@link #readByteChannel(Callable, DataBufferFactory, int)}."
"DataBufferUtils.java:190"$0$"	 * Closes the channel when the flux is terminated."
"DataBufferUtils.java:191"$0$"	 * @param resource the resource to read from"
"DataBufferUtils.java:192"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:193"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:194"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:195"$0$"	 */"
"DataBufferUtils.java:196"$1$"	public static Flux<DataBuffer> read(Resource resource, DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:197"$1$"		return read(resource, 0, bufferFactory, bufferSize);"
"DataBufferUtils.java:198"$1$"	}"
"DataBufferUtils.java:199"$0$""
"DataBufferUtils.java:200"$0$"	/**"
"DataBufferUtils.java:201"$1$"	 * Read the given {@code Resource} into a {@code Flux} of {@code DataBuffer}s"
"DataBufferUtils.java:202"$0$"	 * starting at the given position."
"DataBufferUtils.java:203"$0$"	 * <p>If the resource is a file, it is read into an"
"DataBufferUtils.java:204"$1$"	 * {@code AsynchronousFileChannel} and turned to {@code Flux} via"
"DataBufferUtils.java:205"$1$"	 * {@link #readAsynchronousFileChannel(Callable, DataBufferFactory, int)} or else"
"DataBufferUtils.java:206"$1$"	 * fall back on {@link #readByteChannel(Callable, DataBufferFactory, int)}."
"DataBufferUtils.java:207"$0$"	 * Closes the channel when the flux is terminated."
"DataBufferUtils.java:208"$0$"	 * @param resource the resource to read from"
"DataBufferUtils.java:209"$0$"	 * @param position the position to start reading from"
"DataBufferUtils.java:210"$0$"	 * @param bufferFactory the factory to create data buffers with"
"DataBufferUtils.java:211"$0$"	 * @param bufferSize the maximum size of the data buffers"
"DataBufferUtils.java:212"$0$"	 * @return a Flux of data buffers read from the given channel"
"DataBufferUtils.java:213"$0$"	 */"
"DataBufferUtils.java:214"$0$"	public static Flux<DataBuffer> read("
"DataBufferUtils.java:215"$1$"			Resource resource, long position, DataBufferFactory bufferFactory, int bufferSize) {"
"DataBufferUtils.java:216"$1$""
"DataBufferUtils.java:217"$1$"		try {"
"DataBufferUtils.java:218"$1$"			if (resource.isFile()) {"
"DataBufferUtils.java:219"$1$"				File file = resource.getFile();"
"DataBufferUtils.java:220"$1$"				return readAsynchronousFileChannel("
"DataBufferUtils.java:221"$1$"						() -> AsynchronousFileChannel.open(file.toPath(), StandardOpenOption.READ),"
"DataBufferUtils.java:222"$1$"						position, bufferFactory, bufferSize);"
"DataBufferUtils.java:223"$1$"			}"
"DataBufferUtils.java:224"$0$"		}"
"DataBufferUtils.java:225"$1$"		catch (IOException ignore) {"
"DataBufferUtils.java:226"$0$"			// fallback to resource.readableChannel(), below"
"DataBufferUtils.java:227"$1$"		}"
"DataBufferUtils.java:228"$0$"		Flux<DataBuffer> result = readByteChannel(resource::readableChannel, bufferFactory, bufferSize);"
"DataBufferUtils.java:229"$0$"		return position == 0 ? result : skipUntilByteCount(result, position);"
"DataBufferUtils.java:230"$0$"	}"
"DataBufferUtils.java:231"$0$""
"DataBufferUtils.java:232"$0$""
"DataBufferUtils.java:233"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:234"$0$"	// Writing"
"DataBufferUtils.java:235"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:236"$0$""
"DataBufferUtils.java:237"$0$"	/**"
"DataBufferUtils.java:238"$1$"	 * Write the given stream of {@link DataBuffer DataBuffers} to the given"
"DataBufferUtils.java:239"$1$"	 * {@code OutputStream}. Does <strong>not</strong> close the output stream"
"DataBufferUtils.java:240"$0$"	 * when the flux is terminated, and does <strong>not</strong>"
"DataBufferUtils.java:241"$1$"	 * {@linkplain #release(DataBuffer) release} the data buffers in the source."
"DataBufferUtils.java:242"$1$"	 * If releasing is required, then subscribe to the returned {@code Flux}"
"DataBufferUtils.java:243"$1$"	 * with a {@link #releaseConsumer()}."
"DataBufferUtils.java:244"$0$"	 * <p>Note that the writing process does not start until the returned"
"DataBufferUtils.java:245"$1$"	 * {@code Flux} is subscribed to."
"DataBufferUtils.java:246"$0$"	 * @param source the stream of data buffers to be written"
"DataBufferUtils.java:247"$0$"	 * @param outputStream the output stream to write to"
"DataBufferUtils.java:248"$1$"	 * @return a Flux containing the same buffers as in {@code source}, that"
"DataBufferUtils.java:249"$0$"	 * starts the writing process when subscribed to, and that publishes any"
"DataBufferUtils.java:250"$0$"	 * writing errors and the completion signal"
"DataBufferUtils.java:251"$0$"	 */"
"DataBufferUtils.java:252"$1$"	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, OutputStream outputStream) {"
"DataBufferUtils.java:253"$1$"		Assert.notNull(source, ""'source' must not be null"");"
"DataBufferUtils.java:254"$1$"		Assert.notNull(outputStream, ""'outputStream' must not be null"");"
"DataBufferUtils.java:255"$1$""
"DataBufferUtils.java:256"$1$"		WritableByteChannel channel = Channels.newChannel(outputStream);"
"DataBufferUtils.java:257"$1$"		return write(source, channel);"
"DataBufferUtils.java:258"$1$"	}"
"DataBufferUtils.java:259"$0$""
"DataBufferUtils.java:260"$0$"	/**"
"DataBufferUtils.java:261"$1$"	 * Write the given stream of {@link DataBuffer DataBuffers} to the given"
"DataBufferUtils.java:262"$1$"	 * {@code WritableByteChannel}. Does <strong>not</strong> close the channel"
"DataBufferUtils.java:263"$0$"	 * when the flux is terminated, and does <strong>not</strong>"
"DataBufferUtils.java:264"$1$"	 * {@linkplain #release(DataBuffer) release} the data buffers in the source."
"DataBufferUtils.java:265"$1$"	 * If releasing is required, then subscribe to the returned {@code Flux}"
"DataBufferUtils.java:266"$1$"	 * with a {@link #releaseConsumer()}."
"DataBufferUtils.java:267"$0$"	 * <p>Note that the writing process does not start until the returned"
"DataBufferUtils.java:268"$1$"	 * {@code Flux} is subscribed to."
"DataBufferUtils.java:269"$0$"	 * @param source the stream of data buffers to be written"
"DataBufferUtils.java:270"$0$"	 * @param channel the channel to write to"
"DataBufferUtils.java:271"$1$"	 * @return a Flux containing the same buffers as in {@code source}, that"
"DataBufferUtils.java:272"$0$"	 * starts the writing process when subscribed to, and that publishes any"
"DataBufferUtils.java:273"$0$"	 * writing errors and the completion signal"
"DataBufferUtils.java:274"$0$"	 */"
"DataBufferUtils.java:275"$1$"	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, WritableByteChannel channel) {"
"DataBufferUtils.java:276"$1$"		Assert.notNull(source, ""'source' must not be null"");"
"DataBufferUtils.java:277"$1$"		Assert.notNull(channel, ""'channel' must not be null"");"
"DataBufferUtils.java:278"$1$""
"DataBufferUtils.java:279"$1$"		Flux<DataBuffer> flux = Flux.from(source);"
"DataBufferUtils.java:280"$1$"		return Flux.create(sink -> {"
"DataBufferUtils.java:281"$1$"			WritableByteChannelSubscriber subscriber = new WritableByteChannelSubscriber(sink, channel);"
"DataBufferUtils.java:282"$1$"			sink.onDispose(subscriber);"
"DataBufferUtils.java:283"$1$"			flux.subscribe(subscriber);"
"DataBufferUtils.java:284"$1$"		});"
"DataBufferUtils.java:285"$0$"	}"
"DataBufferUtils.java:286"$0$""
"DataBufferUtils.java:287"$0$"	/**"
"DataBufferUtils.java:288"$1$"	 * Write the given stream of {@link DataBuffer DataBuffers} to the given"
"DataBufferUtils.java:289"$1$"	 * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the"
"DataBufferUtils.java:290"$0$"	 * channel when the flux is terminated, and does <strong>not</strong>"
"DataBufferUtils.java:291"$1$"	 * {@linkplain #release(DataBuffer) release} the data buffers in the source."
"DataBufferUtils.java:292"$1$"	 * If releasing is required, then subscribe to the returned {@code Flux}"
"DataBufferUtils.java:293"$1$"	 * with a {@link #releaseConsumer()}."
"DataBufferUtils.java:294"$0$"	 * <p>Note that the writing process does not start until the returned"
"DataBufferUtils.java:295"$1$"	 * {@code Flux} is subscribed to."
"DataBufferUtils.java:296"$0$"	 * @param source the stream of data buffers to be written"
"DataBufferUtils.java:297"$0$"	 * @param channel the channel to write to"
"DataBufferUtils.java:298"$1$"	 * @return a Flux containing the same buffers as in {@code source}, that"
"DataBufferUtils.java:299"$0$"	 * starts the writing process when subscribed to, and that publishes any"
"DataBufferUtils.java:300"$0$"	 * writing errors and the completion signal"
"DataBufferUtils.java:301"$0$"	 * @since 5.0.10"
"DataBufferUtils.java:302"$0$"	 */"
"DataBufferUtils.java:303"$1$"	public static Flux<DataBuffer> write(Publisher<DataBuffer> source, AsynchronousFileChannel channel) {"
"DataBufferUtils.java:304"$1$"		return write(source, channel, 0);"
"DataBufferUtils.java:305"$1$"	}"
"DataBufferUtils.java:306"$0$""
"DataBufferUtils.java:307"$0$"	/**"
"DataBufferUtils.java:308"$1$"	 * Write the given stream of {@link DataBuffer DataBuffers} to the given"
"DataBufferUtils.java:309"$1$"	 * {@code AsynchronousFileChannel}. Does <strong>not</strong> close the channel"
"DataBufferUtils.java:310"$0$"	 * when the flux is terminated, and does <strong>not</strong>"
"DataBufferUtils.java:311"$1$"	 * {@linkplain #release(DataBuffer) release} the data buffers in the source."
"DataBufferUtils.java:312"$1$"	 * If releasing is required, then subscribe to the returned {@code Flux} with a"
"DataBufferUtils.java:313"$1$"	 * {@link #releaseConsumer()}."
"DataBufferUtils.java:314"$0$"	 * <p>Note that the writing process does not start until the returned"
"DataBufferUtils.java:315"$1$"	 * {@code Flux} is subscribed to."
"DataBufferUtils.java:316"$0$"	 * @param source the stream of data buffers to be written"
"DataBufferUtils.java:317"$0$"	 * @param channel the channel to write to"
"DataBufferUtils.java:318"$0$"	 * @param position the file position where writing is to begin; must be non-negative"
"DataBufferUtils.java:319"$1$"	 * @return a flux containing the same buffers as in {@code source}, that"
"DataBufferUtils.java:320"$0$"	 * starts the writing process when subscribed to, and that publishes any"
"DataBufferUtils.java:321"$0$"	 * writing errors and the completion signal"
"DataBufferUtils.java:322"$0$"	 */"
"DataBufferUtils.java:323"$0$"	public static Flux<DataBuffer> write("
"DataBufferUtils.java:324"$1$"			Publisher<? extends DataBuffer> source, AsynchronousFileChannel channel, long position) {"
"DataBufferUtils.java:325"$1$""
"DataBufferUtils.java:326"$1$"		Assert.notNull(source, ""'source' must not be null"");"
"DataBufferUtils.java:327"$1$"		Assert.notNull(channel, ""'channel' must not be null"");"
"DataBufferUtils.java:328"$1$"		Assert.isTrue(position >= 0, ""'position' must be >= 0"");"
"DataBufferUtils.java:329"$1$""
"DataBufferUtils.java:330"$1$"		Flux<DataBuffer> flux = Flux.from(source);"
"DataBufferUtils.java:331"$1$"		return Flux.create(sink -> {"
"DataBufferUtils.java:332"$1$"			WriteCompletionHandler handler = new WriteCompletionHandler(sink, channel, position);"
"DataBufferUtils.java:333"$1$"			sink.onDispose(handler);"
"DataBufferUtils.java:334"$1$"			flux.subscribe(handler);"
"DataBufferUtils.java:335"$1$"		});"
"DataBufferUtils.java:336"$0$""
"DataBufferUtils.java:337"$0$""
"DataBufferUtils.java:338"$0$"	}"
"DataBufferUtils.java:339"$0$""
"DataBufferUtils.java:340"$0$"	/**"
"DataBufferUtils.java:341"$1$"	 * Write the given stream of {@link DataBuffer DataBuffers} to the given"
"DataBufferUtils.java:342"$1$"	 * file {@link Path}. The optional {@code options} parameter specifies"
"DataBufferUtils.java:343"$0$"	 * how the file is created or opened (defaults to"
"DataBufferUtils.java:344"$1$"	 * {@link StandardOpenOption#CREATE CREATE},"
"DataBufferUtils.java:345"$1$"	 * {@link StandardOpenOption#TRUNCATE_EXISTING TRUNCATE_EXISTING}, and"
"DataBufferUtils.java:346"$1$"	 * {@link StandardOpenOption#WRITE WRITE})."
"DataBufferUtils.java:347"$0$"	 * @param source the stream of data buffers to be written"
"DataBufferUtils.java:348"$0$"	 * @param destination the path to the file"
"DataBufferUtils.java:349"$0$"	 * @param options the options specifying how the file is opened"
"DataBufferUtils.java:350"$1$"	 * @return a {@link Mono} that indicates completion or error"
"DataBufferUtils.java:351"$0$"	 * @since 5.2"
"DataBufferUtils.java:352"$0$"	 */"
"DataBufferUtils.java:353"$1$"	public static Mono<Void> write(Publisher<DataBuffer> source, Path destination, OpenOption... options) {"
"DataBufferUtils.java:354"$1$"		Assert.notNull(source, ""Source must not be null"");"
"DataBufferUtils.java:355"$1$"		Assert.notNull(destination, ""Destination must not be null"");"
"DataBufferUtils.java:356"$1$""
"DataBufferUtils.java:357"$1$"		Set<OpenOption> optionSet = checkWriteOptions(options);"
"DataBufferUtils.java:358"$1$""
"DataBufferUtils.java:359"$1$"		return Mono.create(sink -> {"
"DataBufferUtils.java:360"$1$"			try {"
"DataBufferUtils.java:361"$1$"				AsynchronousFileChannel channel = AsynchronousFileChannel.open(destination, optionSet, null);"
"DataBufferUtils.java:362"$1$"				sink.onDispose(() -> closeChannel(channel));"
"DataBufferUtils.java:363"$1$"				write(source, channel).subscribe(DataBufferUtils::release,"
"DataBufferUtils.java:364"$1$"						sink::error,"
"DataBufferUtils.java:365"$1$"						sink::success);"
"DataBufferUtils.java:366"$1$"			}"
"DataBufferUtils.java:367"$1$"			catch (IOException ex) {"
"DataBufferUtils.java:368"$1$"				sink.error(ex);"
"DataBufferUtils.java:369"$1$"			}"
"DataBufferUtils.java:370"$0$"		});"
"DataBufferUtils.java:371"$0$"	}"
"DataBufferUtils.java:372"$0$""
"DataBufferUtils.java:373"$1$"	private static Set<OpenOption> checkWriteOptions(OpenOption[] options) {"
"DataBufferUtils.java:374"$1$"		int length = options.length;"
"DataBufferUtils.java:375"$1$"		Set<OpenOption> result = new HashSet<>(length + 3);"
"DataBufferUtils.java:376"$1$"		if (length == 0) {"
"DataBufferUtils.java:377"$1$"			result.add(StandardOpenOption.CREATE);"
"DataBufferUtils.java:378"$1$"			result.add(StandardOpenOption.TRUNCATE_EXISTING);"
"DataBufferUtils.java:379"$1$"		}"
"DataBufferUtils.java:380"$1$"		else {"
"DataBufferUtils.java:381"$1$"			for (OpenOption opt : options) {"
"DataBufferUtils.java:382"$1$"				if (opt == StandardOpenOption.READ) {"
"DataBufferUtils.java:383"$1$"					throw new IllegalArgumentException(""READ not allowed"");"
"DataBufferUtils.java:384"$1$"				}"
"DataBufferUtils.java:385"$0$"				result.add(opt);"
"DataBufferUtils.java:386"$0$"			}"
"DataBufferUtils.java:387"$0$"		}"
"DataBufferUtils.java:388"$0$"		result.add(StandardOpenOption.WRITE);"
"DataBufferUtils.java:389"$0$"		return result;"
"DataBufferUtils.java:390"$0$"	}"
"DataBufferUtils.java:391"$0$""
"DataBufferUtils.java:392"$1$"	static void closeChannel(@Nullable Channel channel) {"
"DataBufferUtils.java:393"$1$"		if (channel != null && channel.isOpen()) {"
"DataBufferUtils.java:394"$1$"			try {"
"DataBufferUtils.java:395"$1$"				channel.close();"
"DataBufferUtils.java:396"$1$"			}"
"DataBufferUtils.java:397"$1$"			catch (IOException ignored) {"
"DataBufferUtils.java:398"$1$"			}"
"DataBufferUtils.java:399"$0$"		}"
"DataBufferUtils.java:400"$0$"	}"
"DataBufferUtils.java:401"$0$""
"DataBufferUtils.java:402"$0$""
"DataBufferUtils.java:403"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:404"$0$"	// Various"
"DataBufferUtils.java:405"$0$"	//---------------------------------------------------------------------"
"DataBufferUtils.java:406"$0$""
"DataBufferUtils.java:407"$0$"	/**"
"DataBufferUtils.java:408"$1$"	 * Relay buffers from the given {@link Publisher} until the total"
"DataBufferUtils.java:409"$1$"	 * {@linkplain DataBuffer#readableByteCount() byte count} reaches"
"DataBufferUtils.java:410"$0$"	 * the given maximum byte count, or until the publisher is complete."
"DataBufferUtils.java:411"$0$"	 * @param publisher the publisher to filter"
"DataBufferUtils.java:412"$0$"	 * @param maxByteCount the maximum byte count"
"DataBufferUtils.java:413"$1$"	 * @return a flux whose maximum byte count is {@code maxByteCount}"
"DataBufferUtils.java:414"$0$"	 */"
"DataBufferUtils.java:415"$1$"	public static Flux<DataBuffer> takeUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount) {"
"DataBufferUtils.java:416"$1$"		Assert.notNull(publisher, ""Publisher must not be null"");"
"DataBufferUtils.java:417"$1$"		Assert.isTrue(maxByteCount >= 0, ""'maxByteCount' must be a positive number"");"
"DataBufferUtils.java:418"$1$""
"DataBufferUtils.java:419"$1$"		return Flux.defer(() -> {"
"DataBufferUtils.java:420"$1$"			AtomicLong countDown = new AtomicLong(maxByteCount);"
"DataBufferUtils.java:421"$1$"			return Flux.from(publisher)"
"DataBufferUtils.java:422"$1$"					.map(buffer -> {"
"DataBufferUtils.java:423"$1$"						long remainder = countDown.addAndGet(-buffer.readableByteCount());"
"DataBufferUtils.java:424"$1$"						if (remainder < 0) {"
"DataBufferUtils.java:425"$1$"							int length = buffer.readableByteCount() + (int) remainder;"
"DataBufferUtils.java:426"$1$"							return buffer.slice(0, length);"
"DataBufferUtils.java:427"$1$"						}"
"DataBufferUtils.java:428"$1$"						else {"
"DataBufferUtils.java:429"$1$"							return buffer;"
"DataBufferUtils.java:430"$1$"						}"
"DataBufferUtils.java:431"$0$"					})"
"DataBufferUtils.java:432"$0$"					.takeUntil(buffer -> countDown.get() <= 0);"
"DataBufferUtils.java:433"$0$"		});"
"DataBufferUtils.java:434"$0$""
"DataBufferUtils.java:435"$0$"		// No doOnDiscard as operators used do not cache (and drop) buffers"
"DataBufferUtils.java:436"$0$"	}"
"DataBufferUtils.java:437"$0$""
"DataBufferUtils.java:438"$0$"	/**"
"DataBufferUtils.java:439"$1$"	 * Skip buffers from the given {@link Publisher} until the total"
"DataBufferUtils.java:440"$1$"	 * {@linkplain DataBuffer#readableByteCount() byte count} reaches"
"DataBufferUtils.java:441"$0$"	 * the given maximum byte count, or until the publisher is complete."
"DataBufferUtils.java:442"$0$"	 * @param publisher the publisher to filter"
"DataBufferUtils.java:443"$0$"	 * @param maxByteCount the maximum byte count"
"DataBufferUtils.java:444"$0$"	 * @return a flux with the remaining part of the given publisher"
"DataBufferUtils.java:445"$0$"	 */"
"DataBufferUtils.java:446"$1$"	public static Flux<DataBuffer> skipUntilByteCount(Publisher<? extends DataBuffer> publisher, long maxByteCount) {"
"DataBufferUtils.java:447"$1$"		Assert.notNull(publisher, ""Publisher must not be null"");"
"DataBufferUtils.java:448"$1$"		Assert.isTrue(maxByteCount >= 0, ""'maxByteCount' must be a positive number"");"
"DataBufferUtils.java:449"$1$""
"DataBufferUtils.java:450"$1$"		return Flux.defer(() -> {"
"DataBufferUtils.java:451"$1$"			AtomicLong countDown = new AtomicLong(maxByteCount);"
"DataBufferUtils.java:452"$1$"			return Flux.from(publisher)"
"DataBufferUtils.java:453"$1$"					.skipUntil(buffer -> {"
"DataBufferUtils.java:454"$1$"						long remainder = countDown.addAndGet(-buffer.readableByteCount());"
"DataBufferUtils.java:455"$1$"						return remainder < 0;"
"DataBufferUtils.java:456"$1$"					})"
"DataBufferUtils.java:457"$1$"					.map(buffer -> {"
"DataBufferUtils.java:458"$1$"						long remainder = countDown.get();"
"DataBufferUtils.java:459"$1$"						if (remainder < 0) {"
"DataBufferUtils.java:460"$1$"							countDown.set(0);"
"DataBufferUtils.java:461"$1$"							int start = buffer.readableByteCount() + (int)remainder;"
"DataBufferUtils.java:462"$1$"							int length = (int) -remainder;"
"DataBufferUtils.java:463"$1$"							return buffer.slice(start, length);"
"DataBufferUtils.java:464"$1$"						}"
"DataBufferUtils.java:465"$1$"						else {"
"DataBufferUtils.java:466"$1$"							return buffer;"
"DataBufferUtils.java:467"$1$"						}"
"DataBufferUtils.java:468"$0$"					});"
"DataBufferUtils.java:469"$0$"		}).doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);"
"DataBufferUtils.java:470"$0$"	}"
"DataBufferUtils.java:471"$0$""
"DataBufferUtils.java:472"$0$"	/**"
"DataBufferUtils.java:473"$1$"	 * Retain the given data buffer, if it is a {@link PooledDataBuffer}."
"DataBufferUtils.java:474"$0$"	 * @param dataBuffer the data buffer to retain"
"DataBufferUtils.java:475"$0$"	 * @return the retained buffer"
"DataBufferUtils.java:476"$0$"	 */"
"DataBufferUtils.java:477"$0$"	@SuppressWarnings(""unchecked"")"
"DataBufferUtils.java:478"$1$"	public static <T extends DataBuffer> T retain(T dataBuffer) {"
"DataBufferUtils.java:479"$1$"		if (dataBuffer instanceof PooledDataBuffer) {"
"DataBufferUtils.java:480"$1$"			return (T) ((PooledDataBuffer) dataBuffer).retain();"
"DataBufferUtils.java:481"$1$"		}"
"DataBufferUtils.java:482"$1$"		else {"
"DataBufferUtils.java:483"$1$"			return dataBuffer;"
"DataBufferUtils.java:484"$1$"		}"
"DataBufferUtils.java:485"$0$"	}"
"DataBufferUtils.java:486"$0$""
"DataBufferUtils.java:487"$0$"	/**"
"DataBufferUtils.java:488"$1$"	 * Release the given data buffer, if it is a {@link PooledDataBuffer} and"
"DataBufferUtils.java:489"$1$"	 * has been {@linkplain PooledDataBuffer#isAllocated() allocated}."
"DataBufferUtils.java:490"$0$"	 * @param dataBuffer the data buffer to release"
"DataBufferUtils.java:491"$1$"	 * @return {@code true} if the buffer was released; {@code false} otherwise."
"DataBufferUtils.java:492"$0$"	 */"
"DataBufferUtils.java:493"$1$"	public static boolean release(@Nullable DataBuffer dataBuffer) {"
"DataBufferUtils.java:494"$1$"		if (dataBuffer instanceof PooledDataBuffer) {"
"DataBufferUtils.java:495"$1$"			PooledDataBuffer pooledDataBuffer = (PooledDataBuffer) dataBuffer;"
"DataBufferUtils.java:496"$1$"			if (pooledDataBuffer.isAllocated()) {"
"DataBufferUtils.java:497"$1$"				return pooledDataBuffer.release();"
"DataBufferUtils.java:498"$1$"			}"
"DataBufferUtils.java:499"$0$"		}"
"DataBufferUtils.java:500"$0$"		return false;"
"DataBufferUtils.java:501"$0$"	}"
"DataBufferUtils.java:502"$0$""
"DataBufferUtils.java:503"$0$"	/**"
"DataBufferUtils.java:504"$1$"	 * Return a consumer that calls {@link #release(DataBuffer)} on all"
"DataBufferUtils.java:505"$0$"	 * passed data buffers."
"DataBufferUtils.java:506"$0$"	 */"
"DataBufferUtils.java:507"$1$"	public static Consumer<DataBuffer> releaseConsumer() {"
"DataBufferUtils.java:508"$1$"		return RELEASE_CONSUMER;"
"DataBufferUtils.java:509"$1$"	}"
"DataBufferUtils.java:510"$0$""
"DataBufferUtils.java:511"$0$"	/**"
"DataBufferUtils.java:512"$1$"	 * Return a new {@code DataBuffer} composed from joining together the given"
"DataBufferUtils.java:513"$1$"	 * {@code dataBuffers} elements. Depending on the {@link DataBuffer} type,"
"DataBufferUtils.java:514"$0$"	 * the returned buffer may be a single buffer containing all data of the"
"DataBufferUtils.java:515"$0$"	 * provided buffers, or it may be a zero-copy, composite with references to"
"DataBufferUtils.java:516"$0$"	 * the given buffers."
"DataBufferUtils.java:517"$1$"	 * <p>If {@code dataBuffers} produces an error or if there is a cancel"
"DataBufferUtils.java:518"$0$"	 * signal, then all accumulated buffers will be"
"DataBufferUtils.java:519"$1$"	 * {@linkplain #release(DataBuffer) released}."
"DataBufferUtils.java:520"$0$"	 * <p>Note that the given data buffers do <strong>not</strong> have to be"
"DataBufferUtils.java:521"$0$"	 * released. They will be released as part of the returned composite."
"DataBufferUtils.java:522"$0$"	 * @param dataBuffers the data buffers that are to be composed"
"DataBufferUtils.java:523"$1$"	 * @return a buffer that is composed from the {@code dataBuffers} argument"
"DataBufferUtils.java:524"$0$"	 * @since 5.0.3"
"DataBufferUtils.java:525"$0$"	 */"
"DataBufferUtils.java:526"$0$"	@SuppressWarnings(""unchecked"")"
"DataBufferUtils.java:527"$1$"	public static Mono<DataBuffer> join(Publisher<? extends DataBuffer> dataBuffers) {"
"DataBufferUtils.java:528"$1$"		return join(dataBuffers, -1);"
"DataBufferUtils.java:529"$1$"	}"
"DataBufferUtils.java:530"$0$""
"DataBufferUtils.java:531"$0$"	/**"
"DataBufferUtils.java:532"$1$"	 * Variant of {@link #join(Publisher)} that behaves the same way up until"
"DataBufferUtils.java:533"$0$"	 * the specified max number of bytes to buffer. Once the limit is exceeded,"
"DataBufferUtils.java:534"$1$"	 * {@link DataBufferLimitException} is raised."
"DataBufferUtils.java:535"$0$"	 * @param buffers the data buffers that are to be composed"
"DataBufferUtils.java:536"$0$"	 * @param maxByteCount the max number of bytes to buffer, or -1 for unlimited"
"DataBufferUtils.java:537"$0$"	 * @return a buffer with the aggregated content, possibly an empty Mono if"
"DataBufferUtils.java:538"$0$"	 * the max number of bytes to buffer is exceeded."
"DataBufferUtils.java:539"$0$"	 * @throws DataBufferLimitException if maxByteCount is exceeded"
"DataBufferUtils.java:540"$0$"	 * @since 5.1.11"
"DataBufferUtils.java:541"$0$"	 */"
"DataBufferUtils.java:542"$0$"	@SuppressWarnings(""unchecked"")"
"DataBufferUtils.java:543"$1$"	public static Mono<DataBuffer> join(Publisher<? extends DataBuffer> buffers, int maxByteCount) {"
"DataBufferUtils.java:544"$1$"		Assert.notNull(buffers, ""'dataBuffers' must not be null"");"
"DataBufferUtils.java:545"$1$""
"DataBufferUtils.java:546"$1$"		if (buffers instanceof Mono) {"
"DataBufferUtils.java:547"$1$"			return (Mono<DataBuffer>) buffers;"
"DataBufferUtils.java:548"$1$"		}"
"DataBufferUtils.java:549"$0$""
"DataBufferUtils.java:550"$0$"		return Flux.from(buffers)"
"DataBufferUtils.java:551"$0$"				.collect(() -> new LimitedDataBufferList(maxByteCount), LimitedDataBufferList::add)"
"DataBufferUtils.java:552"$0$"				.filter(list -> !list.isEmpty())"
"DataBufferUtils.java:553"$0$"				.map(list -> list.get(0).factory().join(list))"
"DataBufferUtils.java:554"$0$"				.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);"
"DataBufferUtils.java:555"$0$"	}"
"DataBufferUtils.java:556"$0$""
"DataBufferUtils.java:557"$0$"	/**"
"DataBufferUtils.java:558"$1$"	 * Return a {@link Matcher} for the given delimiter."
"DataBufferUtils.java:559"$0$"	 * The matcher can be used to find the delimiters in data buffers."
"DataBufferUtils.java:560"$0$"	 * @param delimiter the delimiter bytes to find"
"DataBufferUtils.java:561"$0$"	 * @return the matcher"
"DataBufferUtils.java:562"$0$"	 * @since 5.2"
"DataBufferUtils.java:563"$0$"	 */"
"DataBufferUtils.java:564"$1$"	public static Matcher matcher(byte[] delimiter) {"
"DataBufferUtils.java:565"$1$"		Assert.isTrue(delimiter.length > 0, ""Delimiter must not be empty"");"
"DataBufferUtils.java:566"$1$"		return new KnuthMorrisPrattMatcher(delimiter);"
"DataBufferUtils.java:567"$1$"	}"
"DataBufferUtils.java:568"$0$""
"DataBufferUtils.java:569"$1$"	/** Return a {@link Matcher} for the given delimiters."
"DataBufferUtils.java:570"$0$"	 * The matcher can be used to find the delimiters in data buffers."
"DataBufferUtils.java:571"$0$"	 * @param delimiters the delimiters bytes to find"
"DataBufferUtils.java:572"$0$"	 * @return the matcher"
"DataBufferUtils.java:573"$0$"	 * @since 5.2"
"DataBufferUtils.java:574"$0$"	 */"
"DataBufferUtils.java:575"$1$"	public static Matcher matcher(byte[]... delimiters) {"
"DataBufferUtils.java:576"$1$"		Assert.isTrue(delimiters.length > 0, ""Delimiters must not be empty"");"
"DataBufferUtils.java:577"$1$"		if (delimiters.length == 1) {"
"DataBufferUtils.java:578"$1$"			return matcher(delimiters[0]);"
"DataBufferUtils.java:579"$1$"		}"
"DataBufferUtils.java:580"$1$"		else {"
"DataBufferUtils.java:581"$1$"			Matcher[] matchers = new Matcher[delimiters.length];"
"DataBufferUtils.java:582"$1$"			for (int i = 0; i < delimiters.length; i++) {"
"DataBufferUtils.java:583"$1$"				matchers[i] = matcher(delimiters[i]);"
"DataBufferUtils.java:584"$1$"			}"
"DataBufferUtils.java:585"$0$"			return new CompositeMatcher(matchers);"
"DataBufferUtils.java:586"$0$"		}"
"DataBufferUtils.java:587"$0$"	}"
"DataBufferUtils.java:588"$0$""
"DataBufferUtils.java:589"$0$""
"DataBufferUtils.java:590"$0$"	/**"
"DataBufferUtils.java:591"$0$"	 * Defines an object that matches a data buffer against a delimiter."
"DataBufferUtils.java:592"$0$"	 * @since 5.2"
"DataBufferUtils.java:593"$0$"	 * @see #match(DataBuffer)"
"DataBufferUtils.java:594"$0$"	 */"
"DataBufferUtils.java:595"$1$"	public interface Matcher {"
"DataBufferUtils.java:596"$1$""
"DataBufferUtils.java:597"$1$"		/**"
"DataBufferUtils.java:598"$1$"		 * Returns the position of the final matching delimiter byte that matches the given buffer,"
"DataBufferUtils.java:599"$1$"		 * or {@code -1} if not found."
"DataBufferUtils.java:600"$1$"		 * @param dataBuffer the buffer in which to search for the delimiter"
"DataBufferUtils.java:601"$1$"		 * @return the position of the final matching delimiter, or {@code -1} if not found."
"DataBufferUtils.java:602"$1$"		 */"
"DataBufferUtils.java:603"$1$"		int match(DataBuffer dataBuffer);"
"DataBufferUtils.java:604"$1$""
"DataBufferUtils.java:605"$1$"		/**"
"DataBufferUtils.java:606"$1$"		 * Return the delimiter used for this matcher."
"DataBufferUtils.java:607"$1$"		 * @return the delimiter"
"DataBufferUtils.java:608"$1$"		 */"
"DataBufferUtils.java:609"$1$"		byte[] delimiter();"
"DataBufferUtils.java:610"$1$""
"DataBufferUtils.java:611"$1$"		/**"
"DataBufferUtils.java:612"$1$"		 * Resets the state of this matcher."
"DataBufferUtils.java:613"$1$"		 */"
"DataBufferUtils.java:614"$1$"		void reset();"
"DataBufferUtils.java:615"$1$"	}"
"DataBufferUtils.java:616"$0$""
"DataBufferUtils.java:617"$0$""
"DataBufferUtils.java:618"$1$"	private static class ReadableByteChannelGenerator implements Consumer<SynchronousSink<DataBuffer>> {"
"DataBufferUtils.java:619"$1$""
"DataBufferUtils.java:620"$1$"		private final ReadableByteChannel channel;"
"DataBufferUtils.java:621"$1$""
"DataBufferUtils.java:622"$1$"		private final DataBufferFactory dataBufferFactory;"
"DataBufferUtils.java:623"$1$""
"DataBufferUtils.java:624"$1$"		private final int bufferSize;"
"DataBufferUtils.java:625"$1$""
"DataBufferUtils.java:626"$1$"		public ReadableByteChannelGenerator("
"DataBufferUtils.java:627"$1$"				ReadableByteChannel channel, DataBufferFactory dataBufferFactory, int bufferSize) {"
"DataBufferUtils.java:628"$1$""
"DataBufferUtils.java:629"$1$"			this.channel = channel;"
"DataBufferUtils.java:630"$1$"			this.dataBufferFactory = dataBufferFactory;"
"DataBufferUtils.java:631"$1$"			this.bufferSize = bufferSize;"
"DataBufferUtils.java:632"$1$"		}"
"DataBufferUtils.java:633"$0$""
"DataBufferUtils.java:634"$0$"		@Override"
"DataBufferUtils.java:635"$1$"		public void accept(SynchronousSink<DataBuffer> sink) {"
"DataBufferUtils.java:636"$1$"			boolean release = true;"
"DataBufferUtils.java:637"$1$"			DataBuffer dataBuffer = this.dataBufferFactory.allocateBuffer(this.bufferSize);"
"DataBufferUtils.java:638"$1$"			try {"
"DataBufferUtils.java:639"$1$"				int read;"
"DataBufferUtils.java:640"$1$"				ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, dataBuffer.capacity());"
"DataBufferUtils.java:641"$1$"				if ((read = this.channel.read(byteBuffer)) >= 0) {"
"DataBufferUtils.java:642"$1$"					dataBuffer.writePosition(read);"
"DataBufferUtils.java:643"$1$"					release = false;"
"DataBufferUtils.java:644"$1$"					sink.next(dataBuffer);"
"DataBufferUtils.java:645"$1$"				}"
"DataBufferUtils.java:646"$1$"				else {"
"DataBufferUtils.java:647"$1$"					sink.complete();"
"DataBufferUtils.java:648"$1$"				}"
"DataBufferUtils.java:649"$0$"			}"
"DataBufferUtils.java:650"$1$"			catch (IOException ex) {"
"DataBufferUtils.java:651"$1$"				sink.error(ex);"
"DataBufferUtils.java:652"$1$"			}"
"DataBufferUtils.java:653"$1$"			finally {"
"DataBufferUtils.java:654"$1$"				if (release) {"
"DataBufferUtils.java:655"$1$"					release(dataBuffer);"
"DataBufferUtils.java:656"$1$"				}"
"DataBufferUtils.java:657"$0$"			}"
"DataBufferUtils.java:658"$0$"		}"
"DataBufferUtils.java:659"$0$"	}"
"DataBufferUtils.java:660"$0$""
"DataBufferUtils.java:661"$0$""
"DataBufferUtils.java:662"$1$"	private static class ReadCompletionHandler implements CompletionHandler<Integer, DataBuffer> {"
"DataBufferUtils.java:663"$1$""
"DataBufferUtils.java:664"$1$"		private final AsynchronousFileChannel channel;"
"DataBufferUtils.java:665"$1$""
"DataBufferUtils.java:666"$1$"		private final FluxSink<DataBuffer> sink;"
"DataBufferUtils.java:667"$1$""
"DataBufferUtils.java:668"$1$"		private final DataBufferFactory dataBufferFactory;"
"DataBufferUtils.java:669"$1$""
"DataBufferUtils.java:670"$1$"		private final int bufferSize;"
"DataBufferUtils.java:671"$1$""
"DataBufferUtils.java:672"$1$"		private final AtomicLong position;"
"DataBufferUtils.java:673"$1$""
"DataBufferUtils.java:674"$1$"		private final AtomicBoolean reading = new AtomicBoolean();"
"DataBufferUtils.java:675"$1$""
"DataBufferUtils.java:676"$1$"		private final AtomicBoolean disposed = new AtomicBoolean();"
"DataBufferUtils.java:677"$1$""
"DataBufferUtils.java:678"$1$"		public ReadCompletionHandler(AsynchronousFileChannel channel,"
"DataBufferUtils.java:679"$1$"				FluxSink<DataBuffer> sink, long position, DataBufferFactory dataBufferFactory, int bufferSize) {"
"DataBufferUtils.java:680"$1$""
"DataBufferUtils.java:681"$1$"			this.channel = channel;"
"DataBufferUtils.java:682"$1$"			this.sink = sink;"
"DataBufferUtils.java:683"$1$"			this.position = new AtomicLong(position);"
"DataBufferUtils.java:684"$1$"			this.dataBufferFactory = dataBufferFactory;"
"DataBufferUtils.java:685"$1$"			this.bufferSize = bufferSize;"
"DataBufferUtils.java:686"$1$"		}"
"DataBufferUtils.java:687"$0$""
"DataBufferUtils.java:688"$1$"		public void read() {"
"DataBufferUtils.java:689"$1$"			if (this.sink.requestedFromDownstream() > 0 &&"
"DataBufferUtils.java:690"$1$"					isNotDisposed() &&"
"DataBufferUtils.java:691"$1$"					this.reading.compareAndSet(false, true)) {"
"DataBufferUtils.java:692"$1$"				DataBuffer dataBuffer = this.dataBufferFactory.allocateBuffer(this.bufferSize);"
"DataBufferUtils.java:693"$1$"				ByteBuffer byteBuffer = dataBuffer.asByteBuffer(0, this.bufferSize);"
"DataBufferUtils.java:694"$1$"				this.channel.read(byteBuffer, this.position.get(), dataBuffer, this);"
"DataBufferUtils.java:695"$1$"			}"
"DataBufferUtils.java:696"$0$"		}"
"DataBufferUtils.java:697"$0$""
"DataBufferUtils.java:698"$0$"		@Override"
"DataBufferUtils.java:699"$1$"		public void completed(Integer read, DataBuffer dataBuffer) {"
"DataBufferUtils.java:700"$1$"			if (isNotDisposed()) {"
"DataBufferUtils.java:701"$1$"				if (read != -1) {"
"DataBufferUtils.java:702"$1$"					this.position.addAndGet(read);"
"DataBufferUtils.java:703"$1$"					dataBuffer.writePosition(read);"
"DataBufferUtils.java:704"$1$"					this.sink.next(dataBuffer);"
"DataBufferUtils.java:705"$1$"					this.reading.set(false);"
"DataBufferUtils.java:706"$1$"					read();"
"DataBufferUtils.java:707"$1$"				}"
"DataBufferUtils.java:708"$1$"				else {"
"DataBufferUtils.java:709"$1$"					release(dataBuffer);"
"DataBufferUtils.java:710"$1$"					closeChannel(this.channel);"
"DataBufferUtils.java:711"$1$"					if (this.disposed.compareAndSet(false, true)) {"
"DataBufferUtils.java:712"$1$"						this.sink.complete();"
"DataBufferUtils.java:713"$1$"					}"
"DataBufferUtils.java:714"$0$"					this.reading.set(false);"
"DataBufferUtils.java:715"$0$"				}"
"DataBufferUtils.java:716"$0$"			}"
"DataBufferUtils.java:717"$1$"			else {"
"DataBufferUtils.java:718"$1$"				release(dataBuffer);"
"DataBufferUtils.java:719"$1$"				closeChannel(this.channel);"
"DataBufferUtils.java:720"$1$"				this.reading.set(false);"
"DataBufferUtils.java:721"$1$"			}"
"DataBufferUtils.java:722"$0$"		}"
"DataBufferUtils.java:723"$0$""
"DataBufferUtils.java:724"$0$"		@Override"
"DataBufferUtils.java:725"$1$"		public void failed(Throwable exc, DataBuffer dataBuffer) {"
"DataBufferUtils.java:726"$1$"			release(dataBuffer);"
"DataBufferUtils.java:727"$1$"			closeChannel(this.channel);"
"DataBufferUtils.java:728"$1$"			if (this.disposed.compareAndSet(false, true)) {"
"DataBufferUtils.java:729"$1$"				this.sink.error(exc);"
"DataBufferUtils.java:730"$1$"			}"
"DataBufferUtils.java:731"$0$"			this.reading.set(false);"
"DataBufferUtils.java:732"$0$"		}"
"DataBufferUtils.java:733"$0$""
"DataBufferUtils.java:734"$1$"		public void request(long n) {"
"DataBufferUtils.java:735"$1$"			read();"
"DataBufferUtils.java:736"$1$"		}"
"DataBufferUtils.java:737"$0$""
"DataBufferUtils.java:738"$1$"		public void cancel() {"
"DataBufferUtils.java:739"$1$"			if (this.disposed.compareAndSet(false, true)) {"
"DataBufferUtils.java:740"$1$"				if (!this.reading.get()) {"
"DataBufferUtils.java:741"$1$"					closeChannel(this.channel);"
"DataBufferUtils.java:742"$1$"				}"
"DataBufferUtils.java:743"$0$"			}"
"DataBufferUtils.java:744"$0$"		}"
"DataBufferUtils.java:745"$0$""
"DataBufferUtils.java:746"$1$"		private boolean isNotDisposed() {"
"DataBufferUtils.java:747"$1$"			return !this.disposed.get();"
"DataBufferUtils.java:748"$1$"		}"
"DataBufferUtils.java:749"$0$"	}"
"DataBufferUtils.java:750"$0$""
"DataBufferUtils.java:751"$0$""
"DataBufferUtils.java:752"$1$"	private static class WritableByteChannelSubscriber extends BaseSubscriber<DataBuffer> {"
"DataBufferUtils.java:753"$1$""
"DataBufferUtils.java:754"$1$"		private final FluxSink<DataBuffer> sink;"
"DataBufferUtils.java:755"$1$""
"DataBufferUtils.java:756"$1$"		private final WritableByteChannel channel;"
"DataBufferUtils.java:757"$1$""
"DataBufferUtils.java:758"$1$"		public WritableByteChannelSubscriber(FluxSink<DataBuffer> sink, WritableByteChannel channel) {"
"DataBufferUtils.java:759"$1$"			this.sink = sink;"
"DataBufferUtils.java:760"$1$"			this.channel = channel;"
"DataBufferUtils.java:761"$1$"		}"
"DataBufferUtils.java:762"$0$""
"DataBufferUtils.java:763"$0$"		@Override"
"DataBufferUtils.java:764"$1$"		protected void hookOnSubscribe(Subscription subscription) {"
"DataBufferUtils.java:765"$1$"			request(1);"
"DataBufferUtils.java:766"$1$"		}"
"DataBufferUtils.java:767"$0$""
"DataBufferUtils.java:768"$0$"		@Override"
"DataBufferUtils.java:769"$1$"		protected void hookOnNext(DataBuffer dataBuffer) {"
"DataBufferUtils.java:770"$1$"			try {"
"DataBufferUtils.java:771"$1$"				ByteBuffer byteBuffer = dataBuffer.asByteBuffer();"
"DataBufferUtils.java:772"$1$"				while (byteBuffer.hasRemaining()) {"
"DataBufferUtils.java:773"$1$"					this.channel.write(byteBuffer);"
"DataBufferUtils.java:774"$1$"				}"
"DataBufferUtils.java:775"$0$"				this.sink.next(dataBuffer);"
"DataBufferUtils.java:776"$0$"				request(1);"
"DataBufferUtils.java:777"$0$"			}"
"DataBufferUtils.java:778"$1$"			catch (IOException ex) {"
"DataBufferUtils.java:779"$1$"				this.sink.next(dataBuffer);"
"DataBufferUtils.java:780"$1$"				this.sink.error(ex);"
"DataBufferUtils.java:781"$1$"			}"
"DataBufferUtils.java:782"$0$"		}"
"DataBufferUtils.java:783"$0$""
"DataBufferUtils.java:784"$0$"		@Override"
"DataBufferUtils.java:785"$1$"		protected void hookOnError(Throwable throwable) {"
"DataBufferUtils.java:786"$1$"			this.sink.error(throwable);"
"DataBufferUtils.java:787"$1$"		}"
"DataBufferUtils.java:788"$0$""
"DataBufferUtils.java:789"$0$"		@Override"
"DataBufferUtils.java:790"$1$"		protected void hookOnComplete() {"
"DataBufferUtils.java:791"$1$"			this.sink.complete();"
"DataBufferUtils.java:792"$1$"		}"
"DataBufferUtils.java:793"$0$"	}"
"DataBufferUtils.java:794"$0$""
"DataBufferUtils.java:795"$0$""
"DataBufferUtils.java:796"$0$"	private static class WriteCompletionHandler extends BaseSubscriber<DataBuffer>"
"DataBufferUtils.java:797"$1$"			implements CompletionHandler<Integer, ByteBuffer> {"
"DataBufferUtils.java:798"$1$""
"DataBufferUtils.java:799"$1$"		private final FluxSink<DataBuffer> sink;"
"DataBufferUtils.java:800"$1$""
"DataBufferUtils.java:801"$1$"		private final AsynchronousFileChannel channel;"
"DataBufferUtils.java:802"$1$""
"DataBufferUtils.java:803"$1$"		private final AtomicBoolean completed = new AtomicBoolean();"
"DataBufferUtils.java:804"$1$""
"DataBufferUtils.java:805"$1$"		private final AtomicReference<Throwable> error = new AtomicReference<>();"
"DataBufferUtils.java:806"$1$""
"DataBufferUtils.java:807"$1$"		private final AtomicLong position;"
"DataBufferUtils.java:808"$1$""
"DataBufferUtils.java:809"$1$"		private final AtomicReference<DataBuffer> dataBuffer = new AtomicReference<>();"
"DataBufferUtils.java:810"$1$""
"DataBufferUtils.java:811"$1$"		public WriteCompletionHandler("
"DataBufferUtils.java:812"$1$"				FluxSink<DataBuffer> sink, AsynchronousFileChannel channel, long position) {"
"DataBufferUtils.java:813"$1$""
"DataBufferUtils.java:814"$1$"			this.sink = sink;"
"DataBufferUtils.java:815"$1$"			this.channel = channel;"
"DataBufferUtils.java:816"$1$"			this.position = new AtomicLong(position);"
"DataBufferUtils.java:817"$1$"		}"
"DataBufferUtils.java:818"$0$""
"DataBufferUtils.java:819"$0$"		@Override"
"DataBufferUtils.java:820"$1$"		protected void hookOnSubscribe(Subscription subscription) {"
"DataBufferUtils.java:821"$1$"			request(1);"
"DataBufferUtils.java:822"$1$"		}"
"DataBufferUtils.java:823"$0$""
"DataBufferUtils.java:824"$0$"		@Override"
"DataBufferUtils.java:825"$1$"		protected void hookOnNext(DataBuffer value) {"
"DataBufferUtils.java:826"$1$"			if (!this.dataBuffer.compareAndSet(null, value)) {"
"DataBufferUtils.java:827"$1$"				throw new IllegalStateException();"
"DataBufferUtils.java:828"$1$"			}"
"DataBufferUtils.java:829"$0$"			ByteBuffer byteBuffer = value.asByteBuffer();"
"DataBufferUtils.java:830"$0$"			this.channel.write(byteBuffer, this.position.get(), byteBuffer, this);"
"DataBufferUtils.java:831"$0$"		}"
"DataBufferUtils.java:832"$0$""
"DataBufferUtils.java:833"$0$"		@Override"
"DataBufferUtils.java:834"$1$"		protected void hookOnError(Throwable throwable) {"
"DataBufferUtils.java:835"$1$"			this.error.set(throwable);"
"DataBufferUtils.java:836"$1$""
"DataBufferUtils.java:837"$1$"			if (this.dataBuffer.get() == null) {"
"DataBufferUtils.java:838"$1$"				this.sink.error(throwable);"
"DataBufferUtils.java:839"$1$"			}"
"DataBufferUtils.java:840"$0$"		}"
"DataBufferUtils.java:841"$0$""
"DataBufferUtils.java:842"$0$"		@Override"
"DataBufferUtils.java:843"$1$"		protected void hookOnComplete() {"
"DataBufferUtils.java:844"$1$"			this.completed.set(true);"
"DataBufferUtils.java:845"$1$""
"DataBufferUtils.java:846"$1$"			if (this.dataBuffer.get() == null) {"
"DataBufferUtils.java:847"$1$"				this.sink.complete();"
"DataBufferUtils.java:848"$1$"			}"
"DataBufferUtils.java:849"$0$"		}"
"DataBufferUtils.java:850"$0$""
"DataBufferUtils.java:851"$0$"		@Override"
"DataBufferUtils.java:852"$1$"		public void completed(Integer written, ByteBuffer byteBuffer) {"
"DataBufferUtils.java:853"$1$"			long pos = this.position.addAndGet(written);"
"DataBufferUtils.java:854"$1$"			if (byteBuffer.hasRemaining()) {"
"DataBufferUtils.java:855"$1$"				this.channel.write(byteBuffer, pos, byteBuffer, this);"
"DataBufferUtils.java:856"$1$"				return;"
"DataBufferUtils.java:857"$1$"			}"
"DataBufferUtils.java:858"$0$"			sinkDataBuffer();"
"DataBufferUtils.java:859"$0$""
"DataBufferUtils.java:860"$0$"			Throwable throwable = this.error.get();"
"DataBufferUtils.java:861"$1$"			if (throwable != null) {"
"DataBufferUtils.java:862"$1$"				this.sink.error(throwable);"
"DataBufferUtils.java:863"$1$"			}"
"DataBufferUtils.java:864"$1$"			else if (this.completed.get()) {"
"DataBufferUtils.java:865"$1$"				this.sink.complete();"
"DataBufferUtils.java:866"$1$"			}"
"DataBufferUtils.java:867"$1$"			else {"
"DataBufferUtils.java:868"$1$"				request(1);"
"DataBufferUtils.java:869"$1$"			}"
"DataBufferUtils.java:870"$0$"		}"
"DataBufferUtils.java:871"$0$""
"DataBufferUtils.java:872"$0$"		@Override"
"DataBufferUtils.java:873"$1$"		public void failed(Throwable exc, ByteBuffer byteBuffer) {"
"DataBufferUtils.java:874"$1$"			sinkDataBuffer();"
"DataBufferUtils.java:875"$1$"			this.sink.error(exc);"
"DataBufferUtils.java:876"$1$"		}"
"DataBufferUtils.java:877"$0$""
"DataBufferUtils.java:878"$1$"		private void sinkDataBuffer() {"
"DataBufferUtils.java:879"$1$"			DataBuffer dataBuffer = this.dataBuffer.get();"
"DataBufferUtils.java:880"$1$"			Assert.state(dataBuffer != null, ""DataBuffer should not be null"");"
"DataBufferUtils.java:881"$1$"			this.sink.next(dataBuffer);"
"DataBufferUtils.java:882"$1$"			this.dataBuffer.set(null);"
"DataBufferUtils.java:883"$1$"		}"
"DataBufferUtils.java:884"$0$"	}"
"DataBufferUtils.java:885"$0$""
"DataBufferUtils.java:886"$0$""
"DataBufferUtils.java:887"$0$"	/**"
"DataBufferUtils.java:888"$1$"	 * Implementation of {@link Matcher} that uses the Knuth-Morris-Pratt algorithm."
"DataBufferUtils.java:889"$0$"	 * @see <a href=""https://www.nayuki.io/page/knuth-morris-pratt-string-matching"">Knuth-Morris-Pratt string matching</a>"
"DataBufferUtils.java:890"$0$"	 */"
"DataBufferUtils.java:891"$1$"	private static class KnuthMorrisPrattMatcher implements Matcher {"
"DataBufferUtils.java:892"$1$""
"DataBufferUtils.java:893"$1$"		private final byte[] delimiter;"
"DataBufferUtils.java:894"$1$""
"DataBufferUtils.java:895"$1$"		private final int[] table;"
"DataBufferUtils.java:896"$1$""
"DataBufferUtils.java:897"$1$"		private int matches = 0;"
"DataBufferUtils.java:898"$1$""
"DataBufferUtils.java:899"$1$"		public KnuthMorrisPrattMatcher(byte[] delimiter) {"
"DataBufferUtils.java:900"$1$"			this.delimiter = Arrays.copyOf(delimiter, delimiter.length);"
"DataBufferUtils.java:901"$1$"			this.table = longestSuffixPrefixTable(delimiter);"
"DataBufferUtils.java:902"$1$"		}"
"DataBufferUtils.java:903"$0$""
"DataBufferUtils.java:904"$1$"		private static int[] longestSuffixPrefixTable(byte[] delimiter) {"
"DataBufferUtils.java:905"$1$"			int[] result = new int[delimiter.length];"
"DataBufferUtils.java:906"$1$"			result[0] = 0;"
"DataBufferUtils.java:907"$1$"			for (int i = 1; i < delimiter.length; i++) {"
"DataBufferUtils.java:908"$1$"				int j = result[i - 1];"
"DataBufferUtils.java:909"$1$"				while (j > 0 && delimiter[i] != delimiter[j]) {"
"DataBufferUtils.java:910"$1$"					j = result[j - 1];"
"DataBufferUtils.java:911"$1$"				}"
"DataBufferUtils.java:912"$1$"				if (delimiter[i] == delimiter[j]) {"
"DataBufferUtils.java:913"$1$"					j++;"
"DataBufferUtils.java:914"$1$"				}"
"DataBufferUtils.java:915"$0$"				result[i] = j;"
"DataBufferUtils.java:916"$0$"			}"
"DataBufferUtils.java:917"$0$"			return result;"
"DataBufferUtils.java:918"$0$"		}"
"DataBufferUtils.java:919"$0$""
"DataBufferUtils.java:920"$0$"		@Override"
"DataBufferUtils.java:921"$1$"		public int match(DataBuffer dataBuffer) {"
"DataBufferUtils.java:922"$1$"			for (int i = dataBuffer.readPosition(); i < dataBuffer.writePosition(); i++) {"
"DataBufferUtils.java:923"$1$"				byte b = dataBuffer.getByte(i);"
"DataBufferUtils.java:924"$1$""
"DataBufferUtils.java:925"$1$"				while (this.matches > 0 && b != this.delimiter[this.matches]) {"
"DataBufferUtils.java:926"$1$"					this.matches = this.table[this.matches - 1];"
"DataBufferUtils.java:927"$1$"				}"
"DataBufferUtils.java:928"$0$""
"DataBufferUtils.java:929"$1$"				if (b == this.delimiter[this.matches]) {"
"DataBufferUtils.java:930"$1$"					this.matches++;"
"DataBufferUtils.java:931"$1$"					if (this.matches == this.delimiter.length) {"
"DataBufferUtils.java:932"$1$"						reset();"
"DataBufferUtils.java:933"$1$"						return i;"
"DataBufferUtils.java:934"$1$"					}"
"DataBufferUtils.java:935"$0$"				}"
"DataBufferUtils.java:936"$0$"			}"
"DataBufferUtils.java:937"$0$"			return -1;"
"DataBufferUtils.java:938"$0$"		}"
"DataBufferUtils.java:939"$0$""
"DataBufferUtils.java:940"$0$"		@Override"
"DataBufferUtils.java:941"$1$"		public byte[] delimiter() {"
"DataBufferUtils.java:942"$1$"			return Arrays.copyOf(this.delimiter, this.delimiter.length);"
"DataBufferUtils.java:943"$1$"		}"
"DataBufferUtils.java:944"$0$""
"DataBufferUtils.java:945"$0$"		@Override"
"DataBufferUtils.java:946"$1$"		public void reset() {"
"DataBufferUtils.java:947"$1$"			this.matches = 0;"
"DataBufferUtils.java:948"$1$"		}"
"DataBufferUtils.java:949"$0$"	}"
"DataBufferUtils.java:950"$0$""
"DataBufferUtils.java:951"$0$""
"DataBufferUtils.java:952"$0$"	/**"
"DataBufferUtils.java:953"$1$"	 * Implementation of {@link Matcher} that wraps several other matchers."
"DataBufferUtils.java:954"$0$"	 */"
"DataBufferUtils.java:955"$1$"	private static class CompositeMatcher implements Matcher {"
"DataBufferUtils.java:956"$1$""
"DataBufferUtils.java:957"$1$"		private static final byte[] NO_DELIMITER = new byte[0];"
"DataBufferUtils.java:958"$1$""
"DataBufferUtils.java:959"$1$"		private final Matcher[] matchers;"
"DataBufferUtils.java:960"$1$""
"DataBufferUtils.java:961"$1$"		byte[] longestDelimiter = NO_DELIMITER;"
"DataBufferUtils.java:962"$1$""
"DataBufferUtils.java:963"$1$"		public CompositeMatcher(Matcher[] matchers) {"
"DataBufferUtils.java:964"$1$"			this.matchers = matchers;"
"DataBufferUtils.java:965"$1$"		}"
"DataBufferUtils.java:966"$0$""
"DataBufferUtils.java:967"$0$"		@Override"
"DataBufferUtils.java:968"$1$"		public int match(DataBuffer dataBuffer) {"
"DataBufferUtils.java:969"$1$"			this.longestDelimiter = NO_DELIMITER;"
"DataBufferUtils.java:970"$1$"			int bestEndIdx = Integer.MAX_VALUE;"
"DataBufferUtils.java:971"$1$""
"DataBufferUtils.java:972"$1$""
"DataBufferUtils.java:973"$1$"			for (Matcher matcher : this.matchers) {"
"DataBufferUtils.java:974"$1$"				int endIdx = matcher.match(dataBuffer);"
"DataBufferUtils.java:975"$1$"				if (endIdx != -1 &&"
"DataBufferUtils.java:976"$1$"						endIdx <= bestEndIdx &&"
"DataBufferUtils.java:977"$1$"						matcher.delimiter().length > this.longestDelimiter.length) {"
"DataBufferUtils.java:978"$1$"					bestEndIdx = endIdx;"
"DataBufferUtils.java:979"$1$"					this.longestDelimiter = matcher.delimiter();"
"DataBufferUtils.java:980"$1$"				}"
"DataBufferUtils.java:981"$0$"			}"
"DataBufferUtils.java:982"$1$"			if (bestEndIdx == Integer.MAX_VALUE) {"
"DataBufferUtils.java:983"$1$"				this.longestDelimiter = NO_DELIMITER;"
"DataBufferUtils.java:984"$1$"				return -1;"
"DataBufferUtils.java:985"$1$"			}"
"DataBufferUtils.java:986"$1$"			else {"
"DataBufferUtils.java:987"$1$"				reset();"
"DataBufferUtils.java:988"$1$"				return bestEndIdx;"
"DataBufferUtils.java:989"$1$"			}"
"DataBufferUtils.java:990"$0$"		}"
"DataBufferUtils.java:991"$0$""
"DataBufferUtils.java:992"$0$"		@Override"
"DataBufferUtils.java:993"$1$"		public byte[] delimiter() {"
"DataBufferUtils.java:994"$1$"			Assert.state(this.longestDelimiter != NO_DELIMITER, ""Illegal state!"");"
"DataBufferUtils.java:995"$1$"			return this.longestDelimiter;"
"DataBufferUtils.java:996"$1$"		}"
"DataBufferUtils.java:997"$0$""
"DataBufferUtils.java:998"$0$"		@Override"
"DataBufferUtils.java:999"$1$"		public void reset() {"
"DataBufferUtils.java:1000"$1$"			for (Matcher matcher : this.matchers) {"
"DataBufferUtils.java:1001"$1$"				matcher.reset();"
"DataBufferUtils.java:1002"$1$"			}"
"DataBufferUtils.java:1003"$0$"		}"
"DataBufferUtils.java:1004"$0$"	}"
"DataBufferUtils.java:1005"$0$""
"DataBufferUtils.java:1006"$0$"}"
"ListenableFutureTask.java:1"$0$"/*"
"ListenableFutureTask.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ListenableFutureTask.java:3"$0$" *"
"ListenableFutureTask.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ListenableFutureTask.java:5"$0$" * you may not use this file except in compliance with the License."
"ListenableFutureTask.java:6"$0$" * You may obtain a copy of the License at"
"ListenableFutureTask.java:7"$0$" *"
"ListenableFutureTask.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ListenableFutureTask.java:9"$0$" *"
"ListenableFutureTask.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ListenableFutureTask.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ListenableFutureTask.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ListenableFutureTask.java:13"$0$" * See the License for the specific language governing permissions and"
"ListenableFutureTask.java:14"$0$" * limitations under the License."
"ListenableFutureTask.java:15"$0$" */"
"ListenableFutureTask.java:16"$0$""
"ListenableFutureTask.java:17"$0$"package org.springframework.util.concurrent;"
"ListenableFutureTask.java:18"$0$""
"ListenableFutureTask.java:19"$0$"import java.util.concurrent.Callable;"
"ListenableFutureTask.java:20"$0$"import java.util.concurrent.CompletableFuture;"
"ListenableFutureTask.java:21"$0$"import java.util.concurrent.ExecutionException;"
"ListenableFutureTask.java:22"$0$"import java.util.concurrent.FutureTask;"
"ListenableFutureTask.java:23"$0$""
"ListenableFutureTask.java:24"$0$"import org.springframework.lang.Nullable;"
"ListenableFutureTask.java:25"$0$""
"ListenableFutureTask.java:26"$0$"/**"
"ListenableFutureTask.java:27"$1$" * Extension of {@link FutureTask} that implements {@link ListenableFuture}."
"ListenableFutureTask.java:28"$0$" *"
"ListenableFutureTask.java:29"$0$" * @author Arjen Poutsma"
"ListenableFutureTask.java:30"$0$" * @since 4.0"
"ListenableFutureTask.java:31"$1$" * @param <T> the result type returned by this Future's {@code get} method"
"ListenableFutureTask.java:32"$0$" */"
"ListenableFutureTask.java:33"$1$"public class ListenableFutureTask<T> extends FutureTask<T> implements ListenableFuture<T> {"
"ListenableFutureTask.java:34"$1$""
"ListenableFutureTask.java:35"$1$"	private final ListenableFutureCallbackRegistry<T> callbacks = new ListenableFutureCallbackRegistry<>();"
"ListenableFutureTask.java:36"$1$""
"ListenableFutureTask.java:37"$1$""
"ListenableFutureTask.java:38"$1$"	/**"
"ListenableFutureTask.java:39"$1$"	 * Create a new {@code ListenableFutureTask} that will, upon running,"
"ListenableFutureTask.java:40"$1$"	 * execute the given {@link Callable}."
"ListenableFutureTask.java:41"$1$"	 * @param callable the callable task"
"ListenableFutureTask.java:42"$1$"	 */"
"ListenableFutureTask.java:43"$1$"	public ListenableFutureTask(Callable<T> callable) {"
"ListenableFutureTask.java:44"$1$"		super(callable);"
"ListenableFutureTask.java:45"$1$"	}"
"ListenableFutureTask.java:46"$0$""
"ListenableFutureTask.java:47"$0$"	/**"
"ListenableFutureTask.java:48"$1$"	 * Create a {@code ListenableFutureTask} that will, upon running,"
"ListenableFutureTask.java:49"$1$"	 * execute the given {@link Runnable}, and arrange that {@link #get()}"
"ListenableFutureTask.java:50"$0$"	 * will return the given result on successful completion."
"ListenableFutureTask.java:51"$0$"	 * @param runnable the runnable task"
"ListenableFutureTask.java:52"$0$"	 * @param result the result to return on successful completion"
"ListenableFutureTask.java:53"$0$"	 */"
"ListenableFutureTask.java:54"$1$"	public ListenableFutureTask(Runnable runnable, @Nullable T result) {"
"ListenableFutureTask.java:55"$1$"		super(runnable, result);"
"ListenableFutureTask.java:56"$1$"	}"
"ListenableFutureTask.java:57"$0$""
"ListenableFutureTask.java:58"$0$""
"ListenableFutureTask.java:59"$0$"	@Override"
"ListenableFutureTask.java:60"$1$"	public void addCallback(ListenableFutureCallback<? super T> callback) {"
"ListenableFutureTask.java:61"$1$"		this.callbacks.addCallback(callback);"
"ListenableFutureTask.java:62"$1$"	}"
"ListenableFutureTask.java:63"$0$""
"ListenableFutureTask.java:64"$0$"	@Override"
"ListenableFutureTask.java:65"$1$"	public void addCallback(SuccessCallback<? super T> successCallback, FailureCallback failureCallback) {"
"ListenableFutureTask.java:66"$1$"		this.callbacks.addSuccessCallback(successCallback);"
"ListenableFutureTask.java:67"$1$"		this.callbacks.addFailureCallback(failureCallback);"
"ListenableFutureTask.java:68"$1$"	}"
"ListenableFutureTask.java:69"$0$""
"ListenableFutureTask.java:70"$0$"	@Override"
"ListenableFutureTask.java:71"$1$"	public CompletableFuture<T> completable() {"
"ListenableFutureTask.java:72"$1$"		CompletableFuture<T> completable = new DelegatingCompletableFuture<>(this);"
"ListenableFutureTask.java:73"$1$"		this.callbacks.addSuccessCallback(completable::complete);"
"ListenableFutureTask.java:74"$1$"		this.callbacks.addFailureCallback(completable::completeExceptionally);"
"ListenableFutureTask.java:75"$1$"		return completable;"
"ListenableFutureTask.java:76"$1$"	}"
"ListenableFutureTask.java:77"$0$""
"ListenableFutureTask.java:78"$0$""
"ListenableFutureTask.java:79"$0$"	@Override"
"ListenableFutureTask.java:80"$1$"	protected void done() {"
"ListenableFutureTask.java:81"$1$"		Throwable cause;"
"ListenableFutureTask.java:82"$1$"		try {"
"ListenableFutureTask.java:83"$1$"			T result = get();"
"ListenableFutureTask.java:84"$1$"			this.callbacks.success(result);"
"ListenableFutureTask.java:85"$1$"			return;"
"ListenableFutureTask.java:86"$1$"		}"
"ListenableFutureTask.java:87"$1$"		catch (InterruptedException ex) {"
"ListenableFutureTask.java:88"$1$"			Thread.currentThread().interrupt();"
"ListenableFutureTask.java:89"$1$"			return;"
"ListenableFutureTask.java:90"$1$"		}"
"ListenableFutureTask.java:91"$1$"		catch (ExecutionException ex) {"
"ListenableFutureTask.java:92"$1$"			cause = ex.getCause();"
"ListenableFutureTask.java:93"$1$"			if (cause == null) {"
"ListenableFutureTask.java:94"$1$"				cause = ex;"
"ListenableFutureTask.java:95"$1$"			}"
"ListenableFutureTask.java:96"$0$"		}"
"ListenableFutureTask.java:97"$1$"		catch (Throwable ex) {"
"ListenableFutureTask.java:98"$1$"			cause = ex;"
"ListenableFutureTask.java:99"$1$"		}"
"ListenableFutureTask.java:100"$0$"		this.callbacks.failure(cause);"
"ListenableFutureTask.java:101"$0$"	}"
"ListenableFutureTask.java:102"$0$""
"ListenableFutureTask.java:103"$0$"}"
"ByteBufferConverter.java:1"$0$"/*"
"ByteBufferConverter.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ByteBufferConverter.java:3"$0$" *"
"ByteBufferConverter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ByteBufferConverter.java:5"$0$" * you may not use this file except in compliance with the License."
"ByteBufferConverter.java:6"$0$" * You may obtain a copy of the License at"
"ByteBufferConverter.java:7"$0$" *"
"ByteBufferConverter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ByteBufferConverter.java:9"$0$" *"
"ByteBufferConverter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ByteBufferConverter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ByteBufferConverter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ByteBufferConverter.java:13"$0$" * See the License for the specific language governing permissions and"
"ByteBufferConverter.java:14"$0$" * limitations under the License."
"ByteBufferConverter.java:15"$0$" */"
"ByteBufferConverter.java:16"$0$""
"ByteBufferConverter.java:17"$0$"package org.springframework.core.convert.support;"
"ByteBufferConverter.java:18"$0$""
"ByteBufferConverter.java:19"$0$"import java.nio.Buffer;"
"ByteBufferConverter.java:20"$0$"import java.nio.ByteBuffer;"
"ByteBufferConverter.java:21"$0$"import java.util.Collections;"
"ByteBufferConverter.java:22"$0$"import java.util.HashSet;"
"ByteBufferConverter.java:23"$0$"import java.util.Set;"
"ByteBufferConverter.java:24"$0$""
"ByteBufferConverter.java:25"$0$"import org.springframework.core.convert.ConversionService;"
"ByteBufferConverter.java:26"$0$"import org.springframework.core.convert.TypeDescriptor;"
"ByteBufferConverter.java:27"$0$"import org.springframework.core.convert.converter.ConditionalGenericConverter;"
"ByteBufferConverter.java:28"$0$"import org.springframework.lang.Nullable;"
"ByteBufferConverter.java:29"$0$""
"ByteBufferConverter.java:30"$0$"/**"
"ByteBufferConverter.java:31"$1$" * Converts a {@link ByteBuffer} directly to and from {@code byte[] ByteBuffer} directly to and from {@code byte[]s} and indirectly"
"ByteBufferConverter.java:32"$1$" * to any type that the {@link ConversionService} support via {@code byte[]}."
"ByteBufferConverter.java:33"$0$" *"
"ByteBufferConverter.java:34"$0$" * @author Phillip Webb"
"ByteBufferConverter.java:35"$0$" * @author Juergen Hoeller"
"ByteBufferConverter.java:36"$0$" * @since 4.0"
"ByteBufferConverter.java:37"$0$" */"
"ByteBufferConverter.java:38"$1$"final class ByteBufferConverter implements ConditionalGenericConverter {"
"ByteBufferConverter.java:39"$1$""
"ByteBufferConverter.java:40"$1$"	private static final TypeDescriptor BYTE_BUFFER_TYPE = TypeDescriptor.valueOf(ByteBuffer.class);"
"ByteBufferConverter.java:41"$1$""
"ByteBufferConverter.java:42"$1$"	private static final TypeDescriptor BYTE_ARRAY_TYPE = TypeDescriptor.valueOf(byte[].class);"
"ByteBufferConverter.java:43"$1$""
"ByteBufferConverter.java:44"$1$"	private static final Set<ConvertiblePair> CONVERTIBLE_PAIRS;"
"ByteBufferConverter.java:45"$1$""
"ByteBufferConverter.java:46"$1$"	static {"
"ByteBufferConverter.java:47"$1$"		Set<ConvertiblePair> convertiblePairs = new HashSet<>(4);"
"ByteBufferConverter.java:48"$1$"		convertiblePairs.add(new ConvertiblePair(ByteBuffer.class, byte[].class));"
"ByteBufferConverter.java:49"$1$"		convertiblePairs.add(new ConvertiblePair(byte[].class, ByteBuffer.class));"
"ByteBufferConverter.java:50"$1$"		convertiblePairs.add(new ConvertiblePair(ByteBuffer.class, Object.class));"
"ByteBufferConverter.java:51"$1$"		convertiblePairs.add(new ConvertiblePair(Object.class, ByteBuffer.class));"
"ByteBufferConverter.java:52"$1$"		CONVERTIBLE_PAIRS = Collections.unmodifiableSet(convertiblePairs);"
"ByteBufferConverter.java:53"$1$"	}"
"ByteBufferConverter.java:54"$0$""
"ByteBufferConverter.java:55"$0$""
"ByteBufferConverter.java:56"$0$"	private final ConversionService conversionService;"
"ByteBufferConverter.java:57"$0$""
"ByteBufferConverter.java:58"$0$""
"ByteBufferConverter.java:59"$1$"	public ByteBufferConverter(ConversionService conversionService) {"
"ByteBufferConverter.java:60"$1$"		this.conversionService = conversionService;"
"ByteBufferConverter.java:61"$1$"	}"
"ByteBufferConverter.java:62"$0$""
"ByteBufferConverter.java:63"$0$""
"ByteBufferConverter.java:64"$0$"	@Override"
"ByteBufferConverter.java:65"$1$"	public Set<ConvertiblePair> getConvertibleTypes() {"
"ByteBufferConverter.java:66"$1$"		return CONVERTIBLE_PAIRS;"
"ByteBufferConverter.java:67"$1$"	}"
"ByteBufferConverter.java:68"$0$""
"ByteBufferConverter.java:69"$0$"	@Override"
"ByteBufferConverter.java:70"$1$"	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"ByteBufferConverter.java:71"$1$"		boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);"
"ByteBufferConverter.java:72"$1$"		if (sourceType.isAssignableTo(BYTE_BUFFER_TYPE)) {"
"ByteBufferConverter.java:73"$1$"			return (byteBufferTarget || matchesFromByteBuffer(targetType));"
"ByteBufferConverter.java:74"$1$"		}"
"ByteBufferConverter.java:75"$0$"		return (byteBufferTarget && matchesToByteBuffer(sourceType));"
"ByteBufferConverter.java:76"$0$"	}"
"ByteBufferConverter.java:77"$0$""
"ByteBufferConverter.java:78"$1$"	private boolean matchesFromByteBuffer(TypeDescriptor targetType) {"
"ByteBufferConverter.java:79"$1$"		return (targetType.isAssignableTo(BYTE_ARRAY_TYPE) ||"
"ByteBufferConverter.java:80"$1$"				this.conversionService.canConvert(BYTE_ARRAY_TYPE, targetType));"
"ByteBufferConverter.java:81"$1$"	}"
"ByteBufferConverter.java:82"$0$""
"ByteBufferConverter.java:83"$1$"	private boolean matchesToByteBuffer(TypeDescriptor sourceType) {"
"ByteBufferConverter.java:84"$1$"		return (sourceType.isAssignableTo(BYTE_ARRAY_TYPE) ||"
"ByteBufferConverter.java:85"$1$"				this.conversionService.canConvert(sourceType, BYTE_ARRAY_TYPE));"
"ByteBufferConverter.java:86"$1$"	}"
"ByteBufferConverter.java:87"$0$""
"ByteBufferConverter.java:88"$0$"	@Override"
"ByteBufferConverter.java:89"$0$"	@Nullable"
"ByteBufferConverter.java:90"$1$"	public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"ByteBufferConverter.java:91"$1$"		boolean byteBufferTarget = targetType.isAssignableTo(BYTE_BUFFER_TYPE);"
"ByteBufferConverter.java:92"$1$"		if (source instanceof ByteBuffer) {"
"ByteBufferConverter.java:93"$1$"			ByteBuffer buffer = (ByteBuffer) source;"
"ByteBufferConverter.java:94"$1$"			return (byteBufferTarget ? buffer.duplicate() : convertFromByteBuffer(buffer, targetType));"
"ByteBufferConverter.java:95"$1$"		}"
"ByteBufferConverter.java:96"$1$"		if (byteBufferTarget) {"
"ByteBufferConverter.java:97"$1$"			return convertToByteBuffer(source, sourceType);"
"ByteBufferConverter.java:98"$1$"		}"
"ByteBufferConverter.java:99"$0$"		// Should not happen"
"ByteBufferConverter.java:100"$0$"		throw new IllegalStateException(""Unexpected source/target types"");"
"ByteBufferConverter.java:101"$0$"	}"
"ByteBufferConverter.java:102"$0$""
"ByteBufferConverter.java:103"$0$"	@Nullable"
"ByteBufferConverter.java:104"$1$"	private Object convertFromByteBuffer(ByteBuffer source, TypeDescriptor targetType) {"
"ByteBufferConverter.java:105"$1$"		byte[] bytes = new byte[source.remaining()];"
"ByteBufferConverter.java:106"$1$"		source.get(bytes);"
"ByteBufferConverter.java:107"$1$""
"ByteBufferConverter.java:108"$1$"		if (targetType.isAssignableTo(BYTE_ARRAY_TYPE)) {"
"ByteBufferConverter.java:109"$1$"			return bytes;"
"ByteBufferConverter.java:110"$1$"		}"
"ByteBufferConverter.java:111"$0$"		return this.conversionService.convert(bytes, BYTE_ARRAY_TYPE, targetType);"
"ByteBufferConverter.java:112"$0$"	}"
"ByteBufferConverter.java:113"$0$""
"ByteBufferConverter.java:114"$1$"	private Object convertToByteBuffer(@Nullable Object source, TypeDescriptor sourceType) {"
"ByteBufferConverter.java:115"$1$"		byte[] bytes = (byte[]) (source instanceof byte[] ? source :"
"ByteBufferConverter.java:116"$1$"				this.conversionService.convert(source, sourceType, BYTE_ARRAY_TYPE));"
"ByteBufferConverter.java:117"$1$""
"ByteBufferConverter.java:118"$1$"		if (bytes == null) {"
"ByteBufferConverter.java:119"$1$"			return ByteBuffer.wrap(new byte[0]);"
"ByteBufferConverter.java:120"$1$"		}"
"ByteBufferConverter.java:121"$0$""
"ByteBufferConverter.java:122"$0$"		ByteBuffer byteBuffer = ByteBuffer.allocate(bytes.length);"
"ByteBufferConverter.java:123"$0$"		byteBuffer.put(bytes);"
"ByteBufferConverter.java:124"$0$""
"ByteBufferConverter.java:125"$0$"		// Extra cast necessary for compiling on JDK 9 plus running on JDK 8, since"
"ByteBufferConverter.java:126"$0$"		// otherwise the overridden ByteBuffer-returning rewind method would be chosen"
"ByteBufferConverter.java:127"$0$"		// which isn't available on JDK 8."
"ByteBufferConverter.java:128"$0$"		return ((Buffer) byteBuffer).rewind();"
"ByteBufferConverter.java:129"$0$"	}"
"ByteBufferConverter.java:130"$0$""
"ByteBufferConverter.java:131"$0$"}"
"StreamConverter.java:1"$0$"/*"
"StreamConverter.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"StreamConverter.java:3"$0$" *"
"StreamConverter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StreamConverter.java:5"$0$" * you may not use this file except in compliance with the License."
"StreamConverter.java:6"$0$" * You may obtain a copy of the License at"
"StreamConverter.java:7"$0$" *"
"StreamConverter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StreamConverter.java:9"$0$" *"
"StreamConverter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StreamConverter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StreamConverter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StreamConverter.java:13"$0$" * See the License for the specific language governing permissions and"
"StreamConverter.java:14"$0$" * limitations under the License."
"StreamConverter.java:15"$0$" */"
"StreamConverter.java:16"$0$""
"StreamConverter.java:17"$0$"package org.springframework.core.convert.support;"
"StreamConverter.java:18"$0$""
"StreamConverter.java:19"$0$"import java.util.Collection;"
"StreamConverter.java:20"$0$"import java.util.Collections;"
"StreamConverter.java:21"$0$"import java.util.HashSet;"
"StreamConverter.java:22"$0$"import java.util.List;"
"StreamConverter.java:23"$0$"import java.util.Set;"
"StreamConverter.java:24"$0$"import java.util.stream.Collectors;"
"StreamConverter.java:25"$0$"import java.util.stream.Stream;"
"StreamConverter.java:26"$0$""
"StreamConverter.java:27"$0$"import org.springframework.core.convert.ConversionService;"
"StreamConverter.java:28"$0$"import org.springframework.core.convert.TypeDescriptor;"
"StreamConverter.java:29"$0$"import org.springframework.core.convert.converter.ConditionalGenericConverter;"
"StreamConverter.java:30"$0$"import org.springframework.lang.Nullable;"
"StreamConverter.java:31"$0$""
"StreamConverter.java:32"$0$"/**"
"StreamConverter.java:33"$1$" * Converts a {@link Stream} to and from a collection or array, converting the"
"StreamConverter.java:34"$0$" * element type if necessary."
"StreamConverter.java:35"$0$" *"
"StreamConverter.java:36"$0$" * @author Stephane Nicoll"
"StreamConverter.java:37"$0$" * @since 4.2"
"StreamConverter.java:38"$0$" */"
"StreamConverter.java:39"$1$"class StreamConverter implements ConditionalGenericConverter {"
"StreamConverter.java:40"$1$""
"StreamConverter.java:41"$1$"	private static final TypeDescriptor STREAM_TYPE = TypeDescriptor.valueOf(Stream.class);"
"StreamConverter.java:42"$1$""
"StreamConverter.java:43"$1$"	private static final Set<ConvertiblePair> CONVERTIBLE_TYPES = createConvertibleTypes();"
"StreamConverter.java:44"$1$""
"StreamConverter.java:45"$1$"	private final ConversionService conversionService;"
"StreamConverter.java:46"$1$""
"StreamConverter.java:47"$1$""
"StreamConverter.java:48"$1$"	public StreamConverter(ConversionService conversionService) {"
"StreamConverter.java:49"$1$"		this.conversionService = conversionService;"
"StreamConverter.java:50"$1$"	}"
"StreamConverter.java:51"$0$""
"StreamConverter.java:52"$0$""
"StreamConverter.java:53"$0$"	@Override"
"StreamConverter.java:54"$1$"	public Set<ConvertiblePair> getConvertibleTypes() {"
"StreamConverter.java:55"$1$"		return CONVERTIBLE_TYPES;"
"StreamConverter.java:56"$1$"	}"
"StreamConverter.java:57"$0$""
"StreamConverter.java:58"$0$"	@Override"
"StreamConverter.java:59"$1$"	public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {"
"StreamConverter.java:60"$1$"		if (sourceType.isAssignableTo(STREAM_TYPE)) {"
"StreamConverter.java:61"$1$"			return matchesFromStream(sourceType.getElementTypeDescriptor(), targetType);"
"StreamConverter.java:62"$1$"		}"
"StreamConverter.java:63"$1$"		if (targetType.isAssignableTo(STREAM_TYPE)) {"
"StreamConverter.java:64"$1$"			return matchesToStream(targetType.getElementTypeDescriptor(), sourceType);"
"StreamConverter.java:65"$1$"		}"
"StreamConverter.java:66"$0$"		return false;"
"StreamConverter.java:67"$0$"	}"
"StreamConverter.java:68"$0$""
"StreamConverter.java:69"$0$"	/**"
"StreamConverter.java:70"$1$"	 * Validate that a {@link Collection} of the elements held within the stream can be"
"StreamConverter.java:71"$1$"	 * converted to the specified {@code targetType}."
"StreamConverter.java:72"$0$"	 * @param elementType the type of the stream elements"
"StreamConverter.java:73"$0$"	 * @param targetType the type to convert to"
"StreamConverter.java:74"$0$"	 */"
"StreamConverter.java:75"$1$"	public boolean matchesFromStream(@Nullable TypeDescriptor elementType, TypeDescriptor targetType) {"
"StreamConverter.java:76"$1$"		TypeDescriptor collectionOfElement = TypeDescriptor.collection(Collection.class, elementType);"
"StreamConverter.java:77"$1$"		return this.conversionService.canConvert(collectionOfElement, targetType);"
"StreamConverter.java:78"$1$"	}"
"StreamConverter.java:79"$0$""
"StreamConverter.java:80"$0$"	/**"
"StreamConverter.java:81"$1$"	 * Validate that the specified {@code sourceType} can be converted to a {@link Collection} of"
"StreamConverter.java:82"$0$"	 * the type of the stream elements."
"StreamConverter.java:83"$0$"	 * @param elementType the type of the stream elements"
"StreamConverter.java:84"$0$"	 * @param sourceType the type to convert from"
"StreamConverter.java:85"$0$"	 */"
"StreamConverter.java:86"$1$"	public boolean matchesToStream(@Nullable TypeDescriptor elementType, TypeDescriptor sourceType) {"
"StreamConverter.java:87"$1$"		TypeDescriptor collectionOfElement = TypeDescriptor.collection(Collection.class, elementType);"
"StreamConverter.java:88"$1$"		return this.conversionService.canConvert(sourceType, collectionOfElement);"
"StreamConverter.java:89"$1$"	}"
"StreamConverter.java:90"$0$""
"StreamConverter.java:91"$0$"	@Override"
"StreamConverter.java:92"$0$"	@Nullable"
"StreamConverter.java:93"$1$"	public Object convert(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {"
"StreamConverter.java:94"$1$"		if (sourceType.isAssignableTo(STREAM_TYPE)) {"
"StreamConverter.java:95"$1$"			return convertFromStream((Stream<?>) source, sourceType, targetType);"
"StreamConverter.java:96"$1$"		}"
"StreamConverter.java:97"$1$"		if (targetType.isAssignableTo(STREAM_TYPE)) {"
"StreamConverter.java:98"$1$"			return convertToStream(source, sourceType, targetType);"
"StreamConverter.java:99"$1$"		}"
"StreamConverter.java:100"$0$"		// Should not happen"
"StreamConverter.java:101"$0$"		throw new IllegalStateException(""Unexpected source/target types"");"
"StreamConverter.java:102"$0$"	}"
"StreamConverter.java:103"$0$""
"StreamConverter.java:104"$0$"	@Nullable"
"StreamConverter.java:105"$1$"	private Object convertFromStream(@Nullable Stream<?> source, TypeDescriptor streamType, TypeDescriptor targetType) {"
"StreamConverter.java:106"$1$"		List<Object> content = (source != null ? source.collect(Collectors.<Object>toList()) : Collections.emptyList());"
"StreamConverter.java:107"$1$"		TypeDescriptor listType = TypeDescriptor.collection(List.class, streamType.getElementTypeDescriptor());"
"StreamConverter.java:108"$1$"		return this.conversionService.convert(content, listType, targetType);"
"StreamConverter.java:109"$1$"	}"
"StreamConverter.java:110"$0$""
"StreamConverter.java:111"$1$"	private Object convertToStream(@Nullable Object source, TypeDescriptor sourceType, TypeDescriptor streamType) {"
"StreamConverter.java:112"$1$"		TypeDescriptor targetCollection = TypeDescriptor.collection(List.class, streamType.getElementTypeDescriptor());"
"StreamConverter.java:113"$1$"		List<?> target = (List<?>) this.conversionService.convert(source, sourceType, targetCollection);"
"StreamConverter.java:114"$1$"		if (target == null) {"
"StreamConverter.java:115"$1$"			target = Collections.emptyList();"
"StreamConverter.java:116"$1$"		}"
"StreamConverter.java:117"$0$"		return target.stream();"
"StreamConverter.java:118"$0$"	}"
"StreamConverter.java:119"$0$""
"StreamConverter.java:120"$0$""
"StreamConverter.java:121"$1$"	private static Set<ConvertiblePair> createConvertibleTypes() {"
"StreamConverter.java:122"$1$"		Set<ConvertiblePair> convertiblePairs = new HashSet<>();"
"StreamConverter.java:123"$1$"		convertiblePairs.add(new ConvertiblePair(Stream.class, Collection.class));"
"StreamConverter.java:124"$1$"		convertiblePairs.add(new ConvertiblePair(Stream.class, Object[].class));"
"StreamConverter.java:125"$1$"		convertiblePairs.add(new ConvertiblePair(Collection.class, Stream.class));"
"StreamConverter.java:126"$1$"		convertiblePairs.add(new ConvertiblePair(Object[].class, Stream.class));"
"StreamConverter.java:127"$1$"		return convertiblePairs;"
"StreamConverter.java:128"$1$"	}"
"StreamConverter.java:129"$0$""
"StreamConverter.java:130"$0$"}"
"AnnotationAttributes.java:1"$0$"/*"
"AnnotationAttributes.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotationAttributes.java:3"$0$" *"
"AnnotationAttributes.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationAttributes.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationAttributes.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationAttributes.java:7"$0$" *"
"AnnotationAttributes.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationAttributes.java:9"$0$" *"
"AnnotationAttributes.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationAttributes.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationAttributes.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationAttributes.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationAttributes.java:14"$0$" * limitations under the License."
"AnnotationAttributes.java:15"$0$" */"
"AnnotationAttributes.java:16"$0$""
"AnnotationAttributes.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationAttributes.java:18"$0$""
"AnnotationAttributes.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotationAttributes.java:20"$0$"import java.lang.reflect.Array;"
"AnnotationAttributes.java:21"$0$"import java.util.Iterator;"
"AnnotationAttributes.java:22"$0$"import java.util.LinkedHashMap;"
"AnnotationAttributes.java:23"$0$"import java.util.Map;"
"AnnotationAttributes.java:24"$0$""
"AnnotationAttributes.java:25"$0$"import org.springframework.lang.Nullable;"
"AnnotationAttributes.java:26"$0$"import org.springframework.util.Assert;"
"AnnotationAttributes.java:27"$0$"import org.springframework.util.StringUtils;"
"AnnotationAttributes.java:28"$0$""
"AnnotationAttributes.java:29"$0$"/**"
"AnnotationAttributes.java:30"$1$" * {@link LinkedHashMap} subclass representing annotation attribute"
"AnnotationAttributes.java:31"$1$" * <em>key-value</em> pairs as read by {@link AnnotationUtils},"
"AnnotationAttributes.java:32"$1$" * {@link AnnotatedElementUtils}, and Spring's reflection- and ASM-based"
"AnnotationAttributes.java:33"$1$" * {@link org.springframework.core.type.AnnotationMetadata} implementations."
"AnnotationAttributes.java:34"$0$" *"
"AnnotationAttributes.java:35"$0$" * <p>Provides 'pseudo-reification' to avoid noisy Map generics in the calling"
"AnnotationAttributes.java:36"$0$" * code as well as convenience methods for looking up annotation attributes"
"AnnotationAttributes.java:37"$0$" * in a type-safe fashion."
"AnnotationAttributes.java:38"$0$" *"
"AnnotationAttributes.java:39"$0$" * @author Chris Beams"
"AnnotationAttributes.java:40"$0$" * @author Sam Brannen"
"AnnotationAttributes.java:41"$0$" * @author Juergen Hoeller"
"AnnotationAttributes.java:42"$0$" * @since 3.1.1"
"AnnotationAttributes.java:43"$0$" * @see AnnotationUtils#getAnnotationAttributes"
"AnnotationAttributes.java:44"$0$" * @see AnnotatedElementUtils"
"AnnotationAttributes.java:45"$0$" */"
"AnnotationAttributes.java:46"$0$"SuppressWarnings(""serial"")"
"AnnotationAttributes.java:47"$1$"public class AnnotationAttributes extends LinkedHashMap<String, Object> {"
"AnnotationAttributes.java:48"$1$""
"AnnotationAttributes.java:49"$1$"	private static final String UNKNOWN = ""unknown"";"
"AnnotationAttributes.java:50"$1$""
"AnnotationAttributes.java:51"$1$"	@Nullable"
"AnnotationAttributes.java:52"$1$"	private final Class<? extends Annotation> annotationType;"
"AnnotationAttributes.java:53"$1$""
"AnnotationAttributes.java:54"$1$"	final String displayName;"
"AnnotationAttributes.java:55"$1$""
"AnnotationAttributes.java:56"$1$"	boolean validated = false;"
"AnnotationAttributes.java:57"$1$""
"AnnotationAttributes.java:58"$1$""
"AnnotationAttributes.java:59"$1$"	/**"
"AnnotationAttributes.java:60"$1$"	 * Create a new, empty {@link AnnotationAttributes} instance."
"AnnotationAttributes.java:61"$1$"	 */"
"AnnotationAttributes.java:62"$1$"	public AnnotationAttributes() {"
"AnnotationAttributes.java:63"$1$"		this.annotationType = null;"
"AnnotationAttributes.java:64"$1$"		this.displayName = UNKNOWN;"
"AnnotationAttributes.java:65"$1$"	}"
"AnnotationAttributes.java:66"$0$""
"AnnotationAttributes.java:67"$0$"	/**"
"AnnotationAttributes.java:68"$1$"	 * Create a new, empty {@link AnnotationAttributes} instance with the"
"AnnotationAttributes.java:69"$0$"	 * given initial capacity to optimize performance."
"AnnotationAttributes.java:70"$0$"	 * @param initialCapacity initial size of the underlying map"
"AnnotationAttributes.java:71"$0$"	 */"
"AnnotationAttributes.java:72"$1$"	public AnnotationAttributes(int initialCapacity) {"
"AnnotationAttributes.java:73"$1$"		super(initialCapacity);"
"AnnotationAttributes.java:74"$1$"		this.annotationType = null;"
"AnnotationAttributes.java:75"$1$"		this.displayName = UNKNOWN;"
"AnnotationAttributes.java:76"$1$"	}"
"AnnotationAttributes.java:77"$0$""
"AnnotationAttributes.java:78"$0$"	/**"
"AnnotationAttributes.java:79"$1$"	 * Create a new {@link AnnotationAttributes} instance, wrapping the provided"
"AnnotationAttributes.java:80"$0$"	 * map and all its <em>key-value</em> pairs."
"AnnotationAttributes.java:81"$0$"	 * @param map original source of annotation attribute <em>key-value</em> pairs"
"AnnotationAttributes.java:82"$0$"	 * @see #fromMap(Map)"
"AnnotationAttributes.java:83"$0$"	 */"
"AnnotationAttributes.java:84"$1$"	public AnnotationAttributes(Map<String, Object> map) {"
"AnnotationAttributes.java:85"$1$"		super(map);"
"AnnotationAttributes.java:86"$1$"		this.annotationType = null;"
"AnnotationAttributes.java:87"$1$"		this.displayName = UNKNOWN;"
"AnnotationAttributes.java:88"$1$"	}"
"AnnotationAttributes.java:89"$0$""
"AnnotationAttributes.java:90"$0$"	/**"
"AnnotationAttributes.java:91"$1$"	 * Create a new {@link AnnotationAttributes} instance, wrapping the provided"
"AnnotationAttributes.java:92"$0$"	 * map and all its <em>key-value</em> pairs."
"AnnotationAttributes.java:93"$0$"	 * @param other original source of annotation attribute <em>key-value</em> pairs"
"AnnotationAttributes.java:94"$0$"	 * @see #fromMap(Map)"
"AnnotationAttributes.java:95"$0$"	 */"
"AnnotationAttributes.java:96"$1$"	public AnnotationAttributes(AnnotationAttributes other) {"
"AnnotationAttributes.java:97"$1$"		super(other);"
"AnnotationAttributes.java:98"$1$"		this.annotationType = other.annotationType;"
"AnnotationAttributes.java:99"$1$"		this.displayName = other.displayName;"
"AnnotationAttributes.java:100"$1$"		this.validated = other.validated;"
"AnnotationAttributes.java:101"$1$"	}"
"AnnotationAttributes.java:102"$0$""
"AnnotationAttributes.java:103"$0$"	/**"
"AnnotationAttributes.java:104"$1$"	 * Create a new, empty {@link AnnotationAttributes} instance for the"
"AnnotationAttributes.java:105"$1$"	 * specified {@code annotationType}."
"AnnotationAttributes.java:106"$0$"	 * @param annotationType the type of annotation represented by this"
"AnnotationAttributes.java:107"$1$"	 * {@code AnnotationAttributes} instance; never {@code null}"
"AnnotationAttributes.java:108"$0$"	 * @since 4.2"
"AnnotationAttributes.java:109"$0$"	 */"
"AnnotationAttributes.java:110"$1$"	public AnnotationAttributes(Class<? extends Annotation> annotationType) {"
"AnnotationAttributes.java:111"$1$"		Assert.notNull(annotationType, ""'annotationType' must not be null"");"
"AnnotationAttributes.java:112"$1$"		this.annotationType = annotationType;"
"AnnotationAttributes.java:113"$1$"		this.displayName = annotationType.getName();"
"AnnotationAttributes.java:114"$1$"	}"
"AnnotationAttributes.java:115"$0$""
"AnnotationAttributes.java:116"$0$"	/**"
"AnnotationAttributes.java:117"$0$"	 * Create a possibly already validated new, empty"
"AnnotationAttributes.java:118"$1$"	 * {@link AnnotationAttributes} instance for the specified"
"AnnotationAttributes.java:119"$1$"	 * {@code annotationType}."
"AnnotationAttributes.java:120"$0$"	 * @param annotationType the type of annotation represented by this"
"AnnotationAttributes.java:121"$1$"	 * {@code AnnotationAttributes} instance; never {@code null}"
"AnnotationAttributes.java:122"$0$"	 * @param validated if the attributes are considered already validated"
"AnnotationAttributes.java:123"$0$"	 * @since 5.2"
"AnnotationAttributes.java:124"$0$"	 */"
"AnnotationAttributes.java:125"$1$"	AnnotationAttributes(Class<? extends Annotation> annotationType, boolean validated) {"
"AnnotationAttributes.java:126"$1$"		Assert.notNull(annotationType, ""'annotationType' must not be null"");"
"AnnotationAttributes.java:127"$1$"		this.annotationType = annotationType;"
"AnnotationAttributes.java:128"$1$"		this.displayName = annotationType.getName();"
"AnnotationAttributes.java:129"$1$"		this.validated = validated;"
"AnnotationAttributes.java:130"$1$"	}"
"AnnotationAttributes.java:131"$0$""
"AnnotationAttributes.java:132"$0$"	/**"
"AnnotationAttributes.java:133"$1$"	 * Create a new, empty {@link AnnotationAttributes} instance for the"
"AnnotationAttributes.java:134"$1$"	 * specified {@code annotationType}."
"AnnotationAttributes.java:135"$0$"	 * @param annotationType the annotation type name represented by this"
"AnnotationAttributes.java:136"$1$"	 * {@code AnnotationAttributes} instance; never {@code null}"
"AnnotationAttributes.java:137"$0$"	 * @param classLoader the ClassLoader to try to load the annotation type on,"
"AnnotationAttributes.java:138"$1$"	 * or {@code null} to just store the annotation type name"
"AnnotationAttributes.java:139"$0$"	 * @since 4.3.2"
"AnnotationAttributes.java:140"$0$"	 */"
"AnnotationAttributes.java:141"$1$"	public AnnotationAttributes(String annotationType, @Nullable ClassLoader classLoader) {"
"AnnotationAttributes.java:142"$1$"		Assert.notNull(annotationType, ""'annotationType' must not be null"");"
"AnnotationAttributes.java:143"$1$"		this.annotationType = getAnnotationType(annotationType, classLoader);"
"AnnotationAttributes.java:144"$1$"		this.displayName = annotationType;"
"AnnotationAttributes.java:145"$1$"	}"
"AnnotationAttributes.java:146"$0$""
"AnnotationAttributes.java:147"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:148"$0$"	@Nullable"
"AnnotationAttributes.java:149"$1$"	private static Class<? extends Annotation> getAnnotationType(String annotationType, @Nullable ClassLoader classLoader) {"
"AnnotationAttributes.java:150"$1$"		if (classLoader != null) {"
"AnnotationAttributes.java:151"$1$"			try {"
"AnnotationAttributes.java:152"$1$"				return (Class<? extends Annotation>) classLoader.loadClass(annotationType);"
"AnnotationAttributes.java:153"$1$"			}"
"AnnotationAttributes.java:154"$1$"			catch (ClassNotFoundException ex) {"
"AnnotationAttributes.java:155"$0$"				// Annotation Class not resolvable"
"AnnotationAttributes.java:156"$1$"			}"
"AnnotationAttributes.java:157"$0$"		}"
"AnnotationAttributes.java:158"$0$"		return null;"
"AnnotationAttributes.java:159"$0$"	}"
"AnnotationAttributes.java:160"$0$""
"AnnotationAttributes.java:161"$0$""
"AnnotationAttributes.java:162"$0$"	/**"
"AnnotationAttributes.java:163"$1$"	 * Get the type of annotation represented by this {@code AnnotationAttributes}."
"AnnotationAttributes.java:164"$1$"	 * @return the annotation type, or {@code null} if unknown"
"AnnotationAttributes.java:165"$0$"	 * @since 4.2"
"AnnotationAttributes.java:166"$0$"	 */"
"AnnotationAttributes.java:167"$0$"	@Nullable"
"AnnotationAttributes.java:168"$1$"	public Class<? extends Annotation> annotationType() {"
"AnnotationAttributes.java:169"$1$"		return this.annotationType;"
"AnnotationAttributes.java:170"$1$"	}"
"AnnotationAttributes.java:171"$0$""
"AnnotationAttributes.java:172"$0$"	/**"
"AnnotationAttributes.java:173"$1$"	 * Get the value stored under the specified {@code attributeName} as a string."
"AnnotationAttributes.java:174"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:175"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:176"$0$"	 * @return the value"
"AnnotationAttributes.java:177"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:178"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:179"$0$"	 */"
"AnnotationAttributes.java:180"$1$"	public String getString(String attributeName) {"
"AnnotationAttributes.java:181"$1$"		return getRequiredAttribute(attributeName, String.class);"
"AnnotationAttributes.java:182"$1$"	}"
"AnnotationAttributes.java:183"$0$""
"AnnotationAttributes.java:184"$0$"	/**"
"AnnotationAttributes.java:185"$1$"	 * Get the value stored under the specified {@code attributeName} as an"
"AnnotationAttributes.java:186"$0$"	 * array of strings."
"AnnotationAttributes.java:187"$1$"	 * <p>If the value stored under the specified {@code attributeName} is"
"AnnotationAttributes.java:188"$0$"	 * a string, it will be wrapped in a single-element array before"
"AnnotationAttributes.java:189"$0$"	 * returning it."
"AnnotationAttributes.java:190"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:191"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:192"$0$"	 * @return the value"
"AnnotationAttributes.java:193"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:194"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:195"$0$"	 */"
"AnnotationAttributes.java:196"$1$"	public String[] getStringArray(String attributeName) {"
"AnnotationAttributes.java:197"$1$"		return getRequiredAttribute(attributeName, String[].class);"
"AnnotationAttributes.java:198"$1$"	}"
"AnnotationAttributes.java:199"$0$""
"AnnotationAttributes.java:200"$0$"	/**"
"AnnotationAttributes.java:201"$1$"	 * Get the value stored under the specified {@code attributeName} as a boolean."
"AnnotationAttributes.java:202"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:203"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:204"$0$"	 * @return the value"
"AnnotationAttributes.java:205"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:206"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:207"$0$"	 */"
"AnnotationAttributes.java:208"$1$"	public boolean getBoolean(String attributeName) {"
"AnnotationAttributes.java:209"$1$"		return getRequiredAttribute(attributeName, Boolean.class);"
"AnnotationAttributes.java:210"$1$"	}"
"AnnotationAttributes.java:211"$0$""
"AnnotationAttributes.java:212"$0$"	/**"
"AnnotationAttributes.java:213"$1$"	 * Get the value stored under the specified {@code attributeName} as a number."
"AnnotationAttributes.java:214"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:215"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:216"$0$"	 * @return the value"
"AnnotationAttributes.java:217"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:218"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:219"$0$"	 */"
"AnnotationAttributes.java:220"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:221"$1$"	public <N extends Number> N getNumber(String attributeName) {"
"AnnotationAttributes.java:222"$1$"		return (N) getRequiredAttribute(attributeName, Number.class);"
"AnnotationAttributes.java:223"$1$"	}"
"AnnotationAttributes.java:224"$0$""
"AnnotationAttributes.java:225"$0$"	/**"
"AnnotationAttributes.java:226"$1$"	 * Get the value stored under the specified {@code attributeName} as an enum."
"AnnotationAttributes.java:227"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:228"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:229"$0$"	 * @return the value"
"AnnotationAttributes.java:230"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:231"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:232"$0$"	 */"
"AnnotationAttributes.java:233"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:234"$1$"	public <E extends Enum<?>> E getEnum(String attributeName) {"
"AnnotationAttributes.java:235"$1$"		return (E) getRequiredAttribute(attributeName, Enum.class);"
"AnnotationAttributes.java:236"$1$"	}"
"AnnotationAttributes.java:237"$0$""
"AnnotationAttributes.java:238"$0$"	/**"
"AnnotationAttributes.java:239"$1$"	 * Get the value stored under the specified {@code attributeName} as a class."
"AnnotationAttributes.java:240"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:241"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:242"$0$"	 * @return the value"
"AnnotationAttributes.java:243"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:244"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:245"$0$"	 */"
"AnnotationAttributes.java:246"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:247"$1$"	public <T> Class<? extends T> getClass(String attributeName) {"
"AnnotationAttributes.java:248"$1$"		return getRequiredAttribute(attributeName, Class.class);"
"AnnotationAttributes.java:249"$1$"	}"
"AnnotationAttributes.java:250"$0$""
"AnnotationAttributes.java:251"$0$"	/**"
"AnnotationAttributes.java:252"$1$"	 * Get the value stored under the specified {@code attributeName} as an"
"AnnotationAttributes.java:253"$0$"	 * array of classes."
"AnnotationAttributes.java:254"$1$"	 * <p>If the value stored under the specified {@code attributeName} is a class,"
"AnnotationAttributes.java:255"$0$"	 * it will be wrapped in a single-element array before returning it."
"AnnotationAttributes.java:256"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:257"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:258"$0$"	 * @return the value"
"AnnotationAttributes.java:259"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:260"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:261"$0$"	 */"
"AnnotationAttributes.java:262"$1$"	public Class<?>[] getClassArray(String attributeName) {"
"AnnotationAttributes.java:263"$1$"		return getRequiredAttribute(attributeName, Class[].class);"
"AnnotationAttributes.java:264"$1$"	}"
"AnnotationAttributes.java:265"$0$""
"AnnotationAttributes.java:266"$0$"	/**"
"AnnotationAttributes.java:267"$1$"	 * Get the {@link AnnotationAttributes} stored under the specified"
"AnnotationAttributes.java:268"$1$"	 * {@code attributeName}."
"AnnotationAttributes.java:269"$0$"	 * <p>Note: if you expect an actual annotation, invoke"
"AnnotationAttributes.java:270"$1$"	 * {@link #getAnnotation(String, Class)} instead."
"AnnotationAttributes.java:271"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:272"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:273"$1$"	 * @return the {@code AnnotationAttributes}"
"AnnotationAttributes.java:274"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:275"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:276"$0$"	 */"
"AnnotationAttributes.java:277"$1$"	public AnnotationAttributes getAnnotation(String attributeName) {"
"AnnotationAttributes.java:278"$1$"		return getRequiredAttribute(attributeName, AnnotationAttributes.class);"
"AnnotationAttributes.java:279"$1$"	}"
"AnnotationAttributes.java:280"$0$""
"AnnotationAttributes.java:281"$0$"	/**"
"AnnotationAttributes.java:282"$1$"	 * Get the annotation of type {@code annotationType} stored under the"
"AnnotationAttributes.java:283"$1$"	 * specified {@code attributeName}."
"AnnotationAttributes.java:284"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:285"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:286"$1$"	 * @param annotationType the expected annotation type; never {@code null}"
"AnnotationAttributes.java:287"$0$"	 * @return the annotation"
"AnnotationAttributes.java:288"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:289"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:290"$0$"	 * @since 4.2"
"AnnotationAttributes.java:291"$0$"	 */"
"AnnotationAttributes.java:292"$1$"	public <A extends Annotation> A getAnnotation(String attributeName, Class<A> annotationType) {"
"AnnotationAttributes.java:293"$1$"		return getRequiredAttribute(attributeName, annotationType);"
"AnnotationAttributes.java:294"$1$"	}"
"AnnotationAttributes.java:295"$0$""
"AnnotationAttributes.java:296"$0$"	/**"
"AnnotationAttributes.java:297"$1$"	 * Get the array of {@link AnnotationAttributes} stored under the specified"
"AnnotationAttributes.java:298"$1$"	 * {@code attributeName}."
"AnnotationAttributes.java:299"$1$"	 * <p>If the value stored under the specified {@code attributeName} is"
"AnnotationAttributes.java:300"$1$"	 * an instance of {@code AnnotationAttributes}, it will be wrapped in"
"AnnotationAttributes.java:301"$0$"	 * a single-element array before returning it."
"AnnotationAttributes.java:302"$0$"	 * <p>Note: if you expect an actual array of annotations, invoke"
"AnnotationAttributes.java:303"$1$"	 * {@link #getAnnotationArray(String, Class)} instead."
"AnnotationAttributes.java:304"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:305"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:306"$1$"	 * @return the array of {@code AnnotationAttributes}"
"AnnotationAttributes.java:307"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:308"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:309"$0$"	 */"
"AnnotationAttributes.java:310"$1$"	public AnnotationAttributes[] getAnnotationArray(String attributeName) {"
"AnnotationAttributes.java:311"$1$"		return getRequiredAttribute(attributeName, AnnotationAttributes[].class);"
"AnnotationAttributes.java:312"$1$"	}"
"AnnotationAttributes.java:313"$0$""
"AnnotationAttributes.java:314"$0$"	/**"
"AnnotationAttributes.java:315"$1$"	 * Get the array of type {@code annotationType} stored under the specified"
"AnnotationAttributes.java:316"$1$"	 * {@code attributeName}."
"AnnotationAttributes.java:317"$1$"	 * <p>If the value stored under the specified {@code attributeName} is"
"AnnotationAttributes.java:318"$1$"	 * an {@code Annotation}, it will be wrapped in a single-element array"
"AnnotationAttributes.java:319"$0$"	 * before returning it."
"AnnotationAttributes.java:320"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:321"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:322"$1$"	 * @param annotationType the expected annotation type; never {@code null}"
"AnnotationAttributes.java:323"$0$"	 * @return the annotation array"
"AnnotationAttributes.java:324"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:325"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:326"$0$"	 * @since 4.2"
"AnnotationAttributes.java:327"$0$"	 */"
"AnnotationAttributes.java:328"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:329"$1$"	public <A extends Annotation> A[] getAnnotationArray(String attributeName, Class<A> annotationType) {"
"AnnotationAttributes.java:330"$1$"		Object array = Array.newInstance(annotationType, 0);"
"AnnotationAttributes.java:331"$1$"		return (A[]) getRequiredAttribute(attributeName, array.getClass());"
"AnnotationAttributes.java:332"$1$"	}"
"AnnotationAttributes.java:333"$0$""
"AnnotationAttributes.java:334"$0$"	/**"
"AnnotationAttributes.java:335"$1$"	 * Get the value stored under the specified {@code attributeName},"
"AnnotationAttributes.java:336"$1$"	 * ensuring that the value is of the {@code expectedType}."
"AnnotationAttributes.java:337"$1$"	 * <p>If the {@code expectedType} is an array and the value stored"
"AnnotationAttributes.java:338"$1$"	 * under the specified {@code attributeName} is a single element of the"
"AnnotationAttributes.java:339"$0$"	 * component type of the expected array type, the single element will be"
"AnnotationAttributes.java:340"$0$"	 * wrapped in a single-element array of the appropriate type before"
"AnnotationAttributes.java:341"$0$"	 * returning it."
"AnnotationAttributes.java:342"$0$"	 * @param attributeName the name of the attribute to get;"
"AnnotationAttributes.java:343"$1$"	 * never {@code null} or empty"
"AnnotationAttributes.java:344"$1$"	 * @param expectedType the expected type; never {@code null}"
"AnnotationAttributes.java:345"$0$"	 * @return the value"
"AnnotationAttributes.java:346"$0$"	 * @throws IllegalArgumentException if the attribute does not exist or"
"AnnotationAttributes.java:347"$0$"	 * if it is not of the expected type"
"AnnotationAttributes.java:348"$0$"	 */"
"AnnotationAttributes.java:349"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationAttributes.java:350"$1$"	private <T> T getRequiredAttribute(String attributeName, Class<T> expectedType) {"
"AnnotationAttributes.java:351"$1$"		Assert.hasText(attributeName, ""'attributeName' must not be null or empty"");"
"AnnotationAttributes.java:352"$1$"		Object value = get(attributeName);"
"AnnotationAttributes.java:353"$1$"		assertAttributePresence(attributeName, value);"
"AnnotationAttributes.java:354"$1$"		assertNotException(attributeName, value);"
"AnnotationAttributes.java:355"$1$"		if (!expectedType.isInstance(value) && expectedType.isArray() &&"
"AnnotationAttributes.java:356"$1$"				expectedType.getComponentType().isInstance(value)) {"
"AnnotationAttributes.java:357"$1$"			Object array = Array.newInstance(expectedType.getComponentType(), 1);"
"AnnotationAttributes.java:358"$1$"			Array.set(array, 0, value);"
"AnnotationAttributes.java:359"$1$"			value = array;"
"AnnotationAttributes.java:360"$1$"		}"
"AnnotationAttributes.java:361"$0$"		assertAttributeType(attributeName, value, expectedType);"
"AnnotationAttributes.java:362"$0$"		return (T) value;"
"AnnotationAttributes.java:363"$0$"	}"
"AnnotationAttributes.java:364"$0$""
"AnnotationAttributes.java:365"$1$"	private void assertAttributePresence(String attributeName, Object attributeValue) {"
"AnnotationAttributes.java:366"$1$"		Assert.notNull(attributeValue, () -> String.format("
"AnnotationAttributes.java:367"$1$"				""Attribute '%s' not found in attributes for annotation [%s]"","
"AnnotationAttributes.java:368"$1$"				attributeName, this.displayName));"
"AnnotationAttributes.java:369"$1$"	}"
"AnnotationAttributes.java:370"$0$""
"AnnotationAttributes.java:371"$1$"	private void assertNotException(String attributeName, Object attributeValue) {"
"AnnotationAttributes.java:372"$1$"		if (attributeValue instanceof Throwable) {"
"AnnotationAttributes.java:373"$1$"			throw new IllegalArgumentException(String.format("
"AnnotationAttributes.java:374"$1$"					""Attribute '%s' for annotation [%s] was not resolvable due to exception [%s]"","
"AnnotationAttributes.java:375"$1$"					attributeName, this.displayName, attributeValue), (Throwable) attributeValue);"
"AnnotationAttributes.java:376"$1$"		}"
"AnnotationAttributes.java:377"$0$"	}"
"AnnotationAttributes.java:378"$0$""
"AnnotationAttributes.java:379"$1$"	private void assertAttributeType(String attributeName, Object attributeValue, Class<?> expectedType) {"
"AnnotationAttributes.java:380"$1$"		if (!expectedType.isInstance(attributeValue)) {"
"AnnotationAttributes.java:381"$1$"			throw new IllegalArgumentException(String.format("
"AnnotationAttributes.java:382"$1$"					""Attribute '%s' is of type %s, but %s was expected in attributes for annotation [%s]"","
"AnnotationAttributes.java:383"$1$"					attributeName, attributeValue.getClass().getSimpleName(), expectedType.getSimpleName(),"
"AnnotationAttributes.java:384"$1$"					this.displayName));"
"AnnotationAttributes.java:385"$1$"		}"
"AnnotationAttributes.java:386"$0$"	}"
"AnnotationAttributes.java:387"$0$""
"AnnotationAttributes.java:388"$0$"	@Override"
"AnnotationAttributes.java:389"$1$"	public String toString() {"
"AnnotationAttributes.java:390"$1$"		Iterator<Map.Entry<String, Object>> entries = entrySet().iterator();"
"AnnotationAttributes.java:391"$1$"		StringBuilder sb = new StringBuilder(""{"");"
"AnnotationAttributes.java:392"$1$"		while (entries.hasNext()) {"
"AnnotationAttributes.java:393"$1$"			Map.Entry<String, Object> entry = entries.next();"
"AnnotationAttributes.java:394"$1$"			sb.append(entry.getKey());"
"AnnotationAttributes.java:395"$1$"			sb.append('=');"
"AnnotationAttributes.java:396"$1$"			sb.append(valueToString(entry.getValue()));"
"AnnotationAttributes.java:397"$1$"			sb.append(entries.hasNext() ? "", "" : """");"
"AnnotationAttributes.java:398"$1$"		}"
"AnnotationAttributes.java:399"$0$"		sb.append(""}"");"
"AnnotationAttributes.java:400"$0$"		return sb.toString();"
"AnnotationAttributes.java:401"$0$"	}"
"AnnotationAttributes.java:402"$0$""
"AnnotationAttributes.java:403"$1$"	private String valueToString(Object value) {"
"AnnotationAttributes.java:404"$1$"		if (value == this) {"
"AnnotationAttributes.java:405"$1$"			return ""(this Map)"";"
"AnnotationAttributes.java:406"$1$"		}"
"AnnotationAttributes.java:407"$1$"		if (value instanceof Object[]) {"
"AnnotationAttributes.java:408"$1$"			return ""["" + StringUtils.arrayToDelimitedString((Object[]) value, "", "") + ""]"";"
"AnnotationAttributes.java:409"$1$"		}"
"AnnotationAttributes.java:410"$0$"		return String.valueOf(value);"
"AnnotationAttributes.java:411"$0$"	}"
"AnnotationAttributes.java:412"$0$""
"AnnotationAttributes.java:413"$0$""
"AnnotationAttributes.java:414"$0$"	/**"
"AnnotationAttributes.java:415"$1$"	 * Return an {@link AnnotationAttributes} instance based on the given map."
"AnnotationAttributes.java:416"$1$"	 * <p>If the map is already an {@code AnnotationAttributes} instance, it"
"AnnotationAttributes.java:417"$0$"	 * will be cast and returned immediately without creating a new instance."
"AnnotationAttributes.java:418"$0$"	 * Otherwise a new instance will be created by passing the supplied map"
"AnnotationAttributes.java:419"$1$"	 * to the {@link #AnnotationAttributes(Map)} constructor."
"AnnotationAttributes.java:420"$0$"	 * @param map original source of annotation attribute <em>key-value</em> pairs"
"AnnotationAttributes.java:421"$0$"	 */"
"AnnotationAttributes.java:422"$0$"	@Nullable"
"AnnotationAttributes.java:423"$1$"	public static AnnotationAttributes fromMap(@Nullable Map<String, Object> map) {"
"AnnotationAttributes.java:424"$1$"		if (map == null) {"
"AnnotationAttributes.java:425"$1$"			return null;"
"AnnotationAttributes.java:426"$1$"		}"
"AnnotationAttributes.java:427"$1$"		if (map instanceof AnnotationAttributes) {"
"AnnotationAttributes.java:428"$1$"			return (AnnotationAttributes) map;"
"AnnotationAttributes.java:429"$1$"		}"
"AnnotationAttributes.java:430"$0$"		return new AnnotationAttributes(map);"
"AnnotationAttributes.java:431"$0$"	}"
"AnnotationAttributes.java:432"$0$""
"AnnotationAttributes.java:433"$0$"}"
"Base64Utils.java:1"$0$"/*"
"Base64Utils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"Base64Utils.java:3"$0$" *"
"Base64Utils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Base64Utils.java:5"$0$" * you may not use this file except in compliance with the License."
"Base64Utils.java:6"$0$" * You may obtain a copy of the License at"
"Base64Utils.java:7"$0$" *"
"Base64Utils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Base64Utils.java:9"$0$" *"
"Base64Utils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Base64Utils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Base64Utils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Base64Utils.java:13"$0$" * See the License for the specific language governing permissions and"
"Base64Utils.java:14"$0$" * limitations under the License."
"Base64Utils.java:15"$0$" */"
"Base64Utils.java:16"$0$""
"Base64Utils.java:17"$0$"package org.springframework.util;"
"Base64Utils.java:18"$0$""
"Base64Utils.java:19"$0$"import java.nio.charset.Charset;"
"Base64Utils.java:20"$0$"import java.nio.charset.StandardCharsets;"
"Base64Utils.java:21"$0$"import java.util.Base64;"
"Base64Utils.java:22"$0$""
"Base64Utils.java:23"$0$"/**"
"Base64Utils.java:24"$0$" * A simple utility class for Base64 encoding and decoding."
"Base64Utils.java:25"$0$" *"
"Base64Utils.java:26"$1$" * <p>Adapts to Java 8's {@link java.util.Base64} in a convenience fashion."
"Base64Utils.java:27"$0$" *"
"Base64Utils.java:28"$0$" * @author Juergen Hoeller"
"Base64Utils.java:29"$0$" * @author Gary Russell"
"Base64Utils.java:30"$0$" * @since 4.1"
"Base64Utils.java:31"$0$" * @see java.util.Base64"
"Base64Utils.java:32"$0$" */"
"Base64Utils.java:33"$1$"public abstract class Base64Utils {"
"Base64Utils.java:34"$1$""
"Base64Utils.java:35"$1$"	private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;"
"Base64Utils.java:36"$1$""
"Base64Utils.java:37"$1$""
"Base64Utils.java:38"$1$"	/**"
"Base64Utils.java:39"$1$"	 * Base64-encode the given byte array."
"Base64Utils.java:40"$1$"	 * @param src the original byte array"
"Base64Utils.java:41"$1$"	 * @return the encoded byte array"
"Base64Utils.java:42"$1$"	 */"
"Base64Utils.java:43"$1$"	public static byte[] encode(byte[] src) {"
"Base64Utils.java:44"$1$"		if (src.length == 0) {"
"Base64Utils.java:45"$1$"			return src;"
"Base64Utils.java:46"$1$"		}"
"Base64Utils.java:47"$0$"		return Base64.getEncoder().encode(src);"
"Base64Utils.java:48"$0$"	}"
"Base64Utils.java:49"$0$""
"Base64Utils.java:50"$0$"	/**"
"Base64Utils.java:51"$0$"	 * Base64-decode the given byte array."
"Base64Utils.java:52"$0$"	 * @param src the encoded byte array"
"Base64Utils.java:53"$0$"	 * @return the original byte array"
"Base64Utils.java:54"$0$"	 */"
"Base64Utils.java:55"$1$"	public static byte[] decode(byte[] src) {"
"Base64Utils.java:56"$1$"		if (src.length == 0) {"
"Base64Utils.java:57"$1$"			return src;"
"Base64Utils.java:58"$1$"		}"
"Base64Utils.java:59"$0$"		return Base64.getDecoder().decode(src);"
"Base64Utils.java:60"$0$"	}"
"Base64Utils.java:61"$0$""
"Base64Utils.java:62"$0$"	/**"
"Base64Utils.java:63"$0$"	 * Base64-encode the given byte array using the RFC 4648"
"Base64Utils.java:64"$0$"	 * ""URL and Filename Safe Alphabet""."
"Base64Utils.java:65"$0$"	 * @param src the original byte array"
"Base64Utils.java:66"$0$"	 * @return the encoded byte array"
"Base64Utils.java:67"$0$"	 * @since 4.2.4"
"Base64Utils.java:68"$0$"	 */"
"Base64Utils.java:69"$1$"	public static byte[] encodeUrlSafe(byte[] src) {"
"Base64Utils.java:70"$1$"		if (src.length == 0) {"
"Base64Utils.java:71"$1$"			return src;"
"Base64Utils.java:72"$1$"		}"
"Base64Utils.java:73"$0$"		return Base64.getUrlEncoder().encode(src);"
"Base64Utils.java:74"$0$"	}"
"Base64Utils.java:75"$0$""
"Base64Utils.java:76"$0$"	/**"
"Base64Utils.java:77"$0$"	 * Base64-decode the given byte array using the RFC 4648"
"Base64Utils.java:78"$0$"	 * ""URL and Filename Safe Alphabet""."
"Base64Utils.java:79"$0$"	 * @param src the encoded byte array"
"Base64Utils.java:80"$0$"	 * @return the original byte array"
"Base64Utils.java:81"$0$"	 * @since 4.2.4"
"Base64Utils.java:82"$0$"	 */"
"Base64Utils.java:83"$1$"	public static byte[] decodeUrlSafe(byte[] src) {"
"Base64Utils.java:84"$1$"		if (src.length == 0) {"
"Base64Utils.java:85"$1$"			return src;"
"Base64Utils.java:86"$1$"		}"
"Base64Utils.java:87"$0$"		return Base64.getUrlDecoder().decode(src);"
"Base64Utils.java:88"$0$"	}"
"Base64Utils.java:89"$0$""
"Base64Utils.java:90"$0$"	/**"
"Base64Utils.java:91"$0$"	 * Base64-encode the given byte array to a String."
"Base64Utils.java:92"$0$"	 * @param src the original byte array"
"Base64Utils.java:93"$0$"	 * @return the encoded byte array as a UTF-8 String"
"Base64Utils.java:94"$0$"	 */"
"Base64Utils.java:95"$1$"	public static String encodeToString(byte[] src) {"
"Base64Utils.java:96"$1$"		if (src.length == 0) {"
"Base64Utils.java:97"$1$"			return """";"
"Base64Utils.java:98"$1$"		}"
"Base64Utils.java:99"$0$"		return new String(encode(src), DEFAULT_CHARSET);"
"Base64Utils.java:100"$0$"	}"
"Base64Utils.java:101"$0$""
"Base64Utils.java:102"$0$"	/**"
"Base64Utils.java:103"$0$"	 * Base64-decode the given byte array from an UTF-8 String."
"Base64Utils.java:104"$0$"	 * @param src the encoded UTF-8 String"
"Base64Utils.java:105"$0$"	 * @return the original byte array"
"Base64Utils.java:106"$0$"	 */"
"Base64Utils.java:107"$1$"	public static byte[] decodeFromString(String src) {"
"Base64Utils.java:108"$1$"		if (src.isEmpty()) {"
"Base64Utils.java:109"$1$"			return new byte[0];"
"Base64Utils.java:110"$1$"		}"
"Base64Utils.java:111"$0$"		return decode(src.getBytes(DEFAULT_CHARSET));"
"Base64Utils.java:112"$0$"	}"
"Base64Utils.java:113"$0$""
"Base64Utils.java:114"$0$"	/**"
"Base64Utils.java:115"$0$"	 * Base64-encode the given byte array to a String using the RFC 4648"
"Base64Utils.java:116"$0$"	 * ""URL and Filename Safe Alphabet""."
"Base64Utils.java:117"$0$"	 * @param src the original byte array"
"Base64Utils.java:118"$0$"	 * @return the encoded byte array as a UTF-8 String"
"Base64Utils.java:119"$0$"	 */"
"Base64Utils.java:120"$1$"	public static String encodeToUrlSafeString(byte[] src) {"
"Base64Utils.java:121"$1$"		return new String(encodeUrlSafe(src), DEFAULT_CHARSET);"
"Base64Utils.java:122"$1$"	}"
"Base64Utils.java:123"$0$""
"Base64Utils.java:124"$0$"	/**"
"Base64Utils.java:125"$0$"	 * Base64-decode the given byte array from an UTF-8 String using the RFC 4648"
"Base64Utils.java:126"$0$"	 * ""URL and Filename Safe Alphabet""."
"Base64Utils.java:127"$0$"	 * @param src the encoded UTF-8 String"
"Base64Utils.java:128"$0$"	 * @return the original byte array"
"Base64Utils.java:129"$0$"	 */"
"Base64Utils.java:130"$1$"	public static byte[] decodeFromUrlSafeString(String src) {"
"Base64Utils.java:131"$1$"		return decodeUrlSafe(src.getBytes(DEFAULT_CHARSET));"
"Base64Utils.java:132"$1$"	}"
"Base64Utils.java:133"$0$""
"Base64Utils.java:134"$0$"}"
"AnnotationsScanner.java:1"$0$"/*"
"AnnotationsScanner.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotationsScanner.java:3"$0$" *"
"AnnotationsScanner.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationsScanner.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationsScanner.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationsScanner.java:7"$0$" *"
"AnnotationsScanner.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationsScanner.java:9"$0$" *"
"AnnotationsScanner.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationsScanner.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationsScanner.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationsScanner.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationsScanner.java:14"$0$" * limitations under the License."
"AnnotationsScanner.java:15"$0$" */"
"AnnotationsScanner.java:16"$0$""
"AnnotationsScanner.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationsScanner.java:18"$0$""
"AnnotationsScanner.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotationsScanner.java:20"$0$"import java.lang.reflect.AnnotatedElement;"
"AnnotationsScanner.java:21"$0$"import java.lang.reflect.Member;"
"AnnotationsScanner.java:22"$0$"import java.lang.reflect.Method;"
"AnnotationsScanner.java:23"$0$"import java.lang.reflect.Modifier;"
"AnnotationsScanner.java:24"$0$"import java.util.Arrays;"
"AnnotationsScanner.java:25"$0$"import java.util.Map;"
"AnnotationsScanner.java:26"$0$"import java.util.function.BiPredicate;"
"AnnotationsScanner.java:27"$0$""
"AnnotationsScanner.java:28"$0$"import org.springframework.core.BridgeMethodResolver;"
"AnnotationsScanner.java:29"$0$"import org.springframework.core.Ordered;"
"AnnotationsScanner.java:30"$0$"import org.springframework.core.ResolvableType;"
"AnnotationsScanner.java:31"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"AnnotationsScanner.java:32"$0$"import org.springframework.lang.Nullable;"
"AnnotationsScanner.java:33"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"AnnotationsScanner.java:34"$0$"import org.springframework.util.ObjectUtils;"
"AnnotationsScanner.java:35"$0$"import org.springframework.util.ReflectionUtils;"
"AnnotationsScanner.java:36"$0$""
"AnnotationsScanner.java:37"$0$"/**"
"AnnotationsScanner.java:38"$0$" * Scanner to search for relevant annotations in the annotation hierarchy of an"
"AnnotationsScanner.java:39"$1$" * {@link AnnotatedElement}."
"AnnotationsScanner.java:40"$0$" *"
"AnnotationsScanner.java:41"$0$" * @author Phillip Webb"
"AnnotationsScanner.java:42"$0$" * @author Sam Brannen"
"AnnotationsScanner.java:43"$0$" * @since 5.2"
"AnnotationsScanner.java:44"$0$" * @see AnnotationsProcessor"
"AnnotationsScanner.java:45"$0$" */"
"AnnotationsScanner.java:46"$1$"abstract class AnnotationsScanner {"
"AnnotationsScanner.java:47"$1$""
"AnnotationsScanner.java:48"$1$"	private static final Annotation[] NO_ANNOTATIONS = {};"
"AnnotationsScanner.java:49"$1$""
"AnnotationsScanner.java:50"$1$"	private static final Method[] NO_METHODS = {};"
"AnnotationsScanner.java:51"$1$""
"AnnotationsScanner.java:52"$1$""
"AnnotationsScanner.java:53"$1$"	private static final Map<AnnotatedElement, Annotation[]> declaredAnnotationCache ="
"AnnotationsScanner.java:54"$1$"			new ConcurrentReferenceHashMap<>(256);"
"AnnotationsScanner.java:55"$1$""
"AnnotationsScanner.java:56"$1$"	private static final Map<Class<?>, Method[]> baseTypeMethodsCache ="
"AnnotationsScanner.java:57"$1$"			new ConcurrentReferenceHashMap<>(256);"
"AnnotationsScanner.java:58"$1$""
"AnnotationsScanner.java:59"$1$""
"AnnotationsScanner.java:60"$1$"	private AnnotationsScanner() {"
"AnnotationsScanner.java:61"$1$"	}"
"AnnotationsScanner.java:62"$0$""
"AnnotationsScanner.java:63"$0$""
"AnnotationsScanner.java:64"$0$"	/**"
"AnnotationsScanner.java:65"$0$"	 * Scan the hierarchy of the specified element for relevant annotations and"
"AnnotationsScanner.java:66"$0$"	 * call the processor as required."
"AnnotationsScanner.java:67"$0$"	 * @param context an optional context object that will be passed back to the"
"AnnotationsScanner.java:68"$0$"	 * processor"
"AnnotationsScanner.java:69"$0$"	 * @param source the source element to scan"
"AnnotationsScanner.java:70"$0$"	 * @param searchStrategy the search strategy to use"
"AnnotationsScanner.java:71"$0$"	 * @param processor the processor that receives the annotations"
"AnnotationsScanner.java:72"$1$"	 * @return the result of {@link AnnotationsProcessor#finish(Object)}"
"AnnotationsScanner.java:73"$0$"	 */"
"AnnotationsScanner.java:74"$0$"	@Nullable"
"AnnotationsScanner.java:75"$0$"	static <C, R> R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,"
"AnnotationsScanner.java:76"$1$"			AnnotationsProcessor<C, R> processor) {"
"AnnotationsScanner.java:77"$1$""
"AnnotationsScanner.java:78"$1$"		return scan(context, source, searchStrategy, processor, null);"
"AnnotationsScanner.java:79"$1$"	}"
"AnnotationsScanner.java:80"$0$""
"AnnotationsScanner.java:81"$0$"	/**"
"AnnotationsScanner.java:82"$0$"	 * Scan the hierarchy of the specified element for relevant annotations and"
"AnnotationsScanner.java:83"$0$"	 * call the processor as required."
"AnnotationsScanner.java:84"$0$"	 * @param context an optional context object that will be passed back to the"
"AnnotationsScanner.java:85"$0$"	 * processor"
"AnnotationsScanner.java:86"$0$"	 * @param source the source element to scan"
"AnnotationsScanner.java:87"$0$"	 * @param searchStrategy the search strategy to use"
"AnnotationsScanner.java:88"$0$"	 * @param processor the processor that receives the annotations"
"AnnotationsScanner.java:89"$0$"	 * @param classFilter an optional filter that can be used to entirely filter"
"AnnotationsScanner.java:90"$0$"	 * out a specific class from the hierarchy"
"AnnotationsScanner.java:91"$1$"	 * @return the result of {@link AnnotationsProcessor#finish(Object)}"
"AnnotationsScanner.java:92"$0$"	 */"
"AnnotationsScanner.java:93"$0$"	@Nullable"
"AnnotationsScanner.java:94"$0$"	static <C, R> R scan(C context, AnnotatedElement source, SearchStrategy searchStrategy,"
"AnnotationsScanner.java:95"$1$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:96"$1$""
"AnnotationsScanner.java:97"$1$"		R result = process(context, source, searchStrategy, processor, classFilter);"
"AnnotationsScanner.java:98"$1$"		return processor.finish(result);"
"AnnotationsScanner.java:99"$1$"	}"
"AnnotationsScanner.java:100"$0$""
"AnnotationsScanner.java:101"$0$"	@Nullable"
"AnnotationsScanner.java:102"$0$"	private static <C, R> R process(C context, AnnotatedElement source,"
"AnnotationsScanner.java:103"$0$"			SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor,"
"AnnotationsScanner.java:104"$1$"			@Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:105"$1$""
"AnnotationsScanner.java:106"$1$"		if (source instanceof Class) {"
"AnnotationsScanner.java:107"$1$"			return processClass(context, (Class<?>) source, searchStrategy, processor, classFilter);"
"AnnotationsScanner.java:108"$1$"		}"
"AnnotationsScanner.java:109"$1$"		if (source instanceof Method) {"
"AnnotationsScanner.java:110"$1$"			return processMethod(context, (Method) source, searchStrategy, processor, classFilter);"
"AnnotationsScanner.java:111"$1$"		}"
"AnnotationsScanner.java:112"$0$"		return processElement(context, source, processor, classFilter);"
"AnnotationsScanner.java:113"$0$"	}"
"AnnotationsScanner.java:114"$0$""
"AnnotationsScanner.java:115"$0$"	@Nullable"
"AnnotationsScanner.java:116"$0$"	private static <C, R> R processClass(C context, Class<?> source,"
"AnnotationsScanner.java:117"$0$"			SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor,"
"AnnotationsScanner.java:118"$1$"			@Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:119"$1$""
"AnnotationsScanner.java:120"$1$"		switch (searchStrategy) {"
"AnnotationsScanner.java:121"$1$"			case DIRECT:"
"AnnotationsScanner.java:122"$1$"				return processElement(context, source, processor, classFilter);"
"AnnotationsScanner.java:123"$1$"			case INHERITED_ANNOTATIONS:"
"AnnotationsScanner.java:124"$1$"				return processClassInheritedAnnotations(context, source, searchStrategy, processor, classFilter);"
"AnnotationsScanner.java:125"$1$"			case SUPERCLASS:"
"AnnotationsScanner.java:126"$1$"				return processClassHierarchy(context, source, processor, classFilter, false, false);"
"AnnotationsScanner.java:127"$1$"			case TYPE_HIERARCHY:"
"AnnotationsScanner.java:128"$1$"				return processClassHierarchy(context, source, processor, classFilter, true, false);"
"AnnotationsScanner.java:129"$1$"			case TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:"
"AnnotationsScanner.java:130"$1$"				return processClassHierarchy(context, source, processor, classFilter, true, true);"
"AnnotationsScanner.java:131"$1$"		}"
"AnnotationsScanner.java:132"$0$"		throw new IllegalStateException(""Unsupported search strategy "" + searchStrategy);"
"AnnotationsScanner.java:133"$0$"	}"
"AnnotationsScanner.java:134"$0$""
"AnnotationsScanner.java:135"$0$"	@Nullable"
"AnnotationsScanner.java:136"$0$"	private static <C, R> R processClassInheritedAnnotations(C context, Class<?> source,"
"AnnotationsScanner.java:137"$1$"			SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:138"$1$""
"AnnotationsScanner.java:139"$1$"		try {"
"AnnotationsScanner.java:140"$1$"			if (isWithoutHierarchy(source, searchStrategy)) {"
"AnnotationsScanner.java:141"$1$"				return processElement(context, source, processor, classFilter);"
"AnnotationsScanner.java:142"$1$"			}"
"AnnotationsScanner.java:143"$0$"			Annotation[] relevant = null;"
"AnnotationsScanner.java:144"$0$"			int remaining = Integer.MAX_VALUE;"
"AnnotationsScanner.java:145"$0$"			int aggregateIndex = 0;"
"AnnotationsScanner.java:146"$0$"			Class<?> root = source;"
"AnnotationsScanner.java:147"$0$"			while (source != null && source != Object.class && remaining > 0 &&"
"AnnotationsScanner.java:148"$1$"					!hasPlainJavaAnnotationsOnly(source)) {"
"AnnotationsScanner.java:149"$1$"				R result = processor.doWithAggregate(context, aggregateIndex);"
"AnnotationsScanner.java:150"$1$"				if (result != null) {"
"AnnotationsScanner.java:151"$1$"					return result;"
"AnnotationsScanner.java:152"$1$"				}"
"AnnotationsScanner.java:153"$1$"				if (isFiltered(source, context, classFilter)) {"
"AnnotationsScanner.java:154"$1$"					continue;"
"AnnotationsScanner.java:155"$1$"				}"
"AnnotationsScanner.java:156"$0$"				Annotation[] declaredAnnotations ="
"AnnotationsScanner.java:157"$0$"						getDeclaredAnnotations(context, source, classFilter, true);"
"AnnotationsScanner.java:158"$1$"				if (relevant == null && declaredAnnotations.length > 0) {"
"AnnotationsScanner.java:159"$1$"					relevant = root.getAnnotations();"
"AnnotationsScanner.java:160"$1$"					remaining = relevant.length;"
"AnnotationsScanner.java:161"$1$"				}"
"AnnotationsScanner.java:162"$1$"				for (int i = 0; i < declaredAnnotations.length; i++) {"
"AnnotationsScanner.java:163"$1$"					if (declaredAnnotations[i] != null) {"
"AnnotationsScanner.java:164"$1$"						boolean isRelevant = false;"
"AnnotationsScanner.java:165"$1$"						for (int relevantIndex = 0; relevantIndex < relevant.length; relevantIndex++) {"
"AnnotationsScanner.java:166"$1$"							if (relevant[relevantIndex] != null &&"
"AnnotationsScanner.java:167"$1$"									declaredAnnotations[i].annotationType() == relevant[relevantIndex].annotationType()) {"
"AnnotationsScanner.java:168"$1$"								isRelevant = true;"
"AnnotationsScanner.java:169"$1$"								relevant[relevantIndex] = null;"
"AnnotationsScanner.java:170"$1$"								remaining--;"
"AnnotationsScanner.java:171"$1$"								break;"
"AnnotationsScanner.java:172"$1$"							}"
"AnnotationsScanner.java:173"$0$"						}"
"AnnotationsScanner.java:174"$1$"						if (!isRelevant) {"
"AnnotationsScanner.java:175"$1$"							declaredAnnotations[i] = null;"
"AnnotationsScanner.java:176"$1$"						}"
"AnnotationsScanner.java:177"$0$"					}"
"AnnotationsScanner.java:178"$0$"				}"
"AnnotationsScanner.java:179"$0$"				result = processor.doWithAnnotations(context, aggregateIndex, source, declaredAnnotations);"
"AnnotationsScanner.java:180"$1$"				if (result != null) {"
"AnnotationsScanner.java:181"$1$"					return result;"
"AnnotationsScanner.java:182"$1$"				}"
"AnnotationsScanner.java:183"$0$"				source = source.getSuperclass();"
"AnnotationsScanner.java:184"$0$"				aggregateIndex++;"
"AnnotationsScanner.java:185"$0$"			}"
"AnnotationsScanner.java:186"$0$"		}"
"AnnotationsScanner.java:187"$1$"		catch (Throwable ex) {"
"AnnotationsScanner.java:188"$1$"			AnnotationUtils.handleIntrospectionFailure(source, ex);"
"AnnotationsScanner.java:189"$1$"		}"
"AnnotationsScanner.java:190"$0$"		return null;"
"AnnotationsScanner.java:191"$0$"	}"
"AnnotationsScanner.java:192"$0$""
"AnnotationsScanner.java:193"$0$"	@Nullable"
"AnnotationsScanner.java:194"$0$"	private static <C, R> R processClassHierarchy(C context, Class<?> source,"
"AnnotationsScanner.java:195"$0$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter,"
"AnnotationsScanner.java:196"$1$"			boolean includeInterfaces, boolean includeEnclosing) {"
"AnnotationsScanner.java:197"$1$""
"AnnotationsScanner.java:198"$1$"		return processClassHierarchy(context, new int[] {0}, source, processor,"
"AnnotationsScanner.java:199"$1$"				classFilter, includeInterfaces, includeEnclosing);"
"AnnotationsScanner.java:200"$1$"	}"
"AnnotationsScanner.java:201"$0$""
"AnnotationsScanner.java:202"$0$"	@Nullable"
"AnnotationsScanner.java:203"$0$"	private static <C, R> R processClassHierarchy(C context, int[] aggregateIndex, Class<?> source,"
"AnnotationsScanner.java:204"$0$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter,"
"AnnotationsScanner.java:205"$1$"			boolean includeInterfaces, boolean includeEnclosing) {"
"AnnotationsScanner.java:206"$1$""
"AnnotationsScanner.java:207"$1$"		try {"
"AnnotationsScanner.java:208"$1$"			R result = processor.doWithAggregate(context, aggregateIndex[0]);"
"AnnotationsScanner.java:209"$1$"			if (result != null) {"
"AnnotationsScanner.java:210"$1$"				return result;"
"AnnotationsScanner.java:211"$1$"			}"
"AnnotationsScanner.java:212"$1$"			if (hasPlainJavaAnnotationsOnly(source)) {"
"AnnotationsScanner.java:213"$1$"				return null;"
"AnnotationsScanner.java:214"$1$"			}"
"AnnotationsScanner.java:215"$0$"			Annotation[] annotations = getDeclaredAnnotations(context, source, classFilter, false);"
"AnnotationsScanner.java:216"$0$"			result = processor.doWithAnnotations(context, aggregateIndex[0], source, annotations);"
"AnnotationsScanner.java:217"$1$"			if (result != null) {"
"AnnotationsScanner.java:218"$1$"				return result;"
"AnnotationsScanner.java:219"$1$"			}"
"AnnotationsScanner.java:220"$0$"			aggregateIndex[0]++;"
"AnnotationsScanner.java:221"$1$"			if (includeInterfaces) {"
"AnnotationsScanner.java:222"$1$"				for (Class<?> interfaceType : source.getInterfaces()) {"
"AnnotationsScanner.java:223"$1$"					R interfacesResult = processClassHierarchy(context, aggregateIndex,"
"AnnotationsScanner.java:224"$1$"						interfaceType, processor, classFilter, true, includeEnclosing);"
"AnnotationsScanner.java:225"$1$"					if (interfacesResult != null) {"
"AnnotationsScanner.java:226"$1$"						return interfacesResult;"
"AnnotationsScanner.java:227"$1$"					}"
"AnnotationsScanner.java:228"$0$"				}"
"AnnotationsScanner.java:229"$0$"			}"
"AnnotationsScanner.java:230"$0$"			Class<?> superclass = source.getSuperclass();"
"AnnotationsScanner.java:231"$1$"			if (superclass != Object.class && superclass != null) {"
"AnnotationsScanner.java:232"$1$"				R superclassResult = processClassHierarchy(context, aggregateIndex,"
"AnnotationsScanner.java:233"$1$"					superclass, processor, classFilter, includeInterfaces, includeEnclosing);"
"AnnotationsScanner.java:234"$1$"				if (superclassResult != null) {"
"AnnotationsScanner.java:235"$1$"					return superclassResult;"
"AnnotationsScanner.java:236"$1$"				}"
"AnnotationsScanner.java:237"$0$"			}"
"AnnotationsScanner.java:238"$1$"			if (includeEnclosing) {"
"AnnotationsScanner.java:239"$0$"				// Since merely attempting to load the enclosing class may result in"
"AnnotationsScanner.java:240"$0$"				// automatic loading of sibling nested classes that in turn results"
"AnnotationsScanner.java:241"$0$"				// in an exception such as NoClassDefFoundError, we wrap the following"
"AnnotationsScanner.java:242"$0$"				// in its own dedicated try-catch block in order not to preemptively"
"AnnotationsScanner.java:243"$0$"				// halt the annotation scanning process."
"AnnotationsScanner.java:244"$1$"				try {"
"AnnotationsScanner.java:245"$1$"					Class<?> enclosingClass = source.getEnclosingClass();"
"AnnotationsScanner.java:246"$1$"					if (enclosingClass != null) {"
"AnnotationsScanner.java:247"$1$"						R enclosingResult = processClassHierarchy(context, aggregateIndex,"
"AnnotationsScanner.java:248"$1$"							enclosingClass, processor, classFilter, includeInterfaces, true);"
"AnnotationsScanner.java:249"$1$"						if (enclosingResult != null) {"
"AnnotationsScanner.java:250"$1$"							return enclosingResult;"
"AnnotationsScanner.java:251"$1$"						}"
"AnnotationsScanner.java:252"$0$"					}"
"AnnotationsScanner.java:253"$0$"				}"
"AnnotationsScanner.java:254"$1$"				catch (Throwable ex) {"
"AnnotationsScanner.java:255"$1$"					AnnotationUtils.handleIntrospectionFailure(source, ex);"
"AnnotationsScanner.java:256"$1$"				}"
"AnnotationsScanner.java:257"$0$"			}"
"AnnotationsScanner.java:258"$0$"		}"
"AnnotationsScanner.java:259"$1$"		catch (Throwable ex) {"
"AnnotationsScanner.java:260"$1$"			AnnotationUtils.handleIntrospectionFailure(source, ex);"
"AnnotationsScanner.java:261"$1$"		}"
"AnnotationsScanner.java:262"$0$"		return null;"
"AnnotationsScanner.java:263"$0$"	}"
"AnnotationsScanner.java:264"$0$""
"AnnotationsScanner.java:265"$0$"	@Nullable"
"AnnotationsScanner.java:266"$0$"	private static <C, R> R processMethod(C context, Method source,"
"AnnotationsScanner.java:267"$0$"			SearchStrategy searchStrategy, AnnotationsProcessor<C, R> processor,"
"AnnotationsScanner.java:268"$1$"			@Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:269"$1$""
"AnnotationsScanner.java:270"$1$"		switch (searchStrategy) {"
"AnnotationsScanner.java:271"$1$"			case DIRECT:"
"AnnotationsScanner.java:272"$1$"			case INHERITED_ANNOTATIONS:"
"AnnotationsScanner.java:273"$1$"				return processMethodInheritedAnnotations(context, source, processor, classFilter);"
"AnnotationsScanner.java:274"$1$"			case SUPERCLASS:"
"AnnotationsScanner.java:275"$1$"				return processMethodHierarchy(context, new int[] {0}, source.getDeclaringClass(),"
"AnnotationsScanner.java:276"$1$"						processor, classFilter, source, false);"
"AnnotationsScanner.java:277"$1$"			case TYPE_HIERARCHY:"
"AnnotationsScanner.java:278"$1$"			case TYPE_HIERARCHY_AND_ENCLOSING_CLASSES:"
"AnnotationsScanner.java:279"$1$"				return processMethodHierarchy(context, new int[] {0}, source.getDeclaringClass(),"
"AnnotationsScanner.java:280"$1$"						processor, classFilter, source, true);"
"AnnotationsScanner.java:281"$1$"		}"
"AnnotationsScanner.java:282"$0$"		throw new IllegalStateException(""Unsupported search strategy "" + searchStrategy);"
"AnnotationsScanner.java:283"$0$"	}"
"AnnotationsScanner.java:284"$0$""
"AnnotationsScanner.java:285"$0$"	@Nullable"
"AnnotationsScanner.java:286"$0$"	private static <C, R> R processMethodInheritedAnnotations(C context, Method source,"
"AnnotationsScanner.java:287"$1$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:288"$1$""
"AnnotationsScanner.java:289"$1$"		try {"
"AnnotationsScanner.java:290"$1$"			R result = processor.doWithAggregate(context, 0);"
"AnnotationsScanner.java:291"$1$"			return (result != null ? result :"
"AnnotationsScanner.java:292"$1$"				processMethodAnnotations(context, 0, source, processor, classFilter));"
"AnnotationsScanner.java:293"$1$"		}"
"AnnotationsScanner.java:294"$1$"		catch (Throwable ex) {"
"AnnotationsScanner.java:295"$1$"			AnnotationUtils.handleIntrospectionFailure(source, ex);"
"AnnotationsScanner.java:296"$1$"		}"
"AnnotationsScanner.java:297"$0$"		return null;"
"AnnotationsScanner.java:298"$0$"	}"
"AnnotationsScanner.java:299"$0$""
"AnnotationsScanner.java:300"$0$"	@Nullable"
"AnnotationsScanner.java:301"$0$"	private static <C, R> R processMethodHierarchy(C context, int[] aggregateIndex,"
"AnnotationsScanner.java:302"$0$"			Class<?> sourceClass, AnnotationsProcessor<C, R> processor,"
"AnnotationsScanner.java:303"$0$"			@Nullable BiPredicate<C, Class<?>> classFilter, Method rootMethod,"
"AnnotationsScanner.java:304"$1$"			boolean includeInterfaces) {"
"AnnotationsScanner.java:305"$1$""
"AnnotationsScanner.java:306"$1$"		try {"
"AnnotationsScanner.java:307"$1$"			R result = processor.doWithAggregate(context, aggregateIndex[0]);"
"AnnotationsScanner.java:308"$1$"			if (result != null) {"
"AnnotationsScanner.java:309"$1$"				return result;"
"AnnotationsScanner.java:310"$1$"			}"
"AnnotationsScanner.java:311"$1$"			if (hasPlainJavaAnnotationsOnly(sourceClass)) {"
"AnnotationsScanner.java:312"$1$"				return null;"
"AnnotationsScanner.java:313"$1$"			}"
"AnnotationsScanner.java:314"$0$"			boolean calledProcessor = false;"
"AnnotationsScanner.java:315"$1$"			if (sourceClass == rootMethod.getDeclaringClass()) {"
"AnnotationsScanner.java:316"$1$"				result = processMethodAnnotations(context, aggregateIndex[0],"
"AnnotationsScanner.java:317"$1$"					rootMethod, processor, classFilter);"
"AnnotationsScanner.java:318"$1$"				calledProcessor = true;"
"AnnotationsScanner.java:319"$1$"				if (result != null) {"
"AnnotationsScanner.java:320"$1$"					return result;"
"AnnotationsScanner.java:321"$1$"				}"
"AnnotationsScanner.java:322"$0$"			}"
"AnnotationsScanner.java:323"$1$"			else {"
"AnnotationsScanner.java:324"$1$"				for (Method candidateMethod : getBaseTypeMethods(context, sourceClass, classFilter)) {"
"AnnotationsScanner.java:325"$1$"					if (candidateMethod != null && isOverride(rootMethod, candidateMethod)) {"
"AnnotationsScanner.java:326"$1$"						result = processMethodAnnotations(context, aggregateIndex[0],"
"AnnotationsScanner.java:327"$1$"							candidateMethod, processor, classFilter);"
"AnnotationsScanner.java:328"$1$"						calledProcessor = true;"
"AnnotationsScanner.java:329"$1$"						if (result != null) {"
"AnnotationsScanner.java:330"$1$"							return result;"
"AnnotationsScanner.java:331"$1$"						}"
"AnnotationsScanner.java:332"$0$"					}"
"AnnotationsScanner.java:333"$0$"				}"
"AnnotationsScanner.java:334"$0$"			}"
"AnnotationsScanner.java:335"$1$"			if (Modifier.isPrivate(rootMethod.getModifiers())) {"
"AnnotationsScanner.java:336"$1$"				return null;"
"AnnotationsScanner.java:337"$1$"			}"
"AnnotationsScanner.java:338"$1$"			if (calledProcessor) {"
"AnnotationsScanner.java:339"$1$"				aggregateIndex[0]++;"
"AnnotationsScanner.java:340"$1$"			}"
"AnnotationsScanner.java:341"$1$"			if (includeInterfaces) {"
"AnnotationsScanner.java:342"$1$"				for (Class<?> interfaceType : sourceClass.getInterfaces()) {"
"AnnotationsScanner.java:343"$1$"					R interfacesResult = processMethodHierarchy(context, aggregateIndex,"
"AnnotationsScanner.java:344"$1$"						interfaceType, processor, classFilter, rootMethod, true);"
"AnnotationsScanner.java:345"$1$"					if (interfacesResult != null) {"
"AnnotationsScanner.java:346"$1$"						return interfacesResult;"
"AnnotationsScanner.java:347"$1$"					}"
"AnnotationsScanner.java:348"$0$"				}"
"AnnotationsScanner.java:349"$0$"			}"
"AnnotationsScanner.java:350"$0$"			Class<?> superclass = sourceClass.getSuperclass();"
"AnnotationsScanner.java:351"$1$"			if (superclass != Object.class && superclass != null) {"
"AnnotationsScanner.java:352"$1$"				R superclassResult = processMethodHierarchy(context, aggregateIndex,"
"AnnotationsScanner.java:353"$1$"					superclass, processor, classFilter, rootMethod, includeInterfaces);"
"AnnotationsScanner.java:354"$1$"				if (superclassResult != null) {"
"AnnotationsScanner.java:355"$1$"					return superclassResult;"
"AnnotationsScanner.java:356"$1$"				}"
"AnnotationsScanner.java:357"$0$"			}"
"AnnotationsScanner.java:358"$0$"		}"
"AnnotationsScanner.java:359"$1$"		catch (Throwable ex) {"
"AnnotationsScanner.java:360"$1$"			AnnotationUtils.handleIntrospectionFailure(rootMethod, ex);"
"AnnotationsScanner.java:361"$1$"		}"
"AnnotationsScanner.java:362"$0$"		return null;"
"AnnotationsScanner.java:363"$0$"	}"
"AnnotationsScanner.java:364"$0$""
"AnnotationsScanner.java:365"$0$"	private static <C> Method[] getBaseTypeMethods("
"AnnotationsScanner.java:366"$1$"			C context, Class<?> baseType, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:367"$1$""
"AnnotationsScanner.java:368"$1$"		if (baseType == Object.class || hasPlainJavaAnnotationsOnly(baseType) ||"
"AnnotationsScanner.java:369"$1$"				isFiltered(baseType, context, classFilter)) {"
"AnnotationsScanner.java:370"$1$"			return NO_METHODS;"
"AnnotationsScanner.java:371"$1$"		}"
"AnnotationsScanner.java:372"$0$""
"AnnotationsScanner.java:373"$0$"		Method[] methods = baseTypeMethodsCache.get(baseType);"
"AnnotationsScanner.java:374"$1$"		if (methods == null) {"
"AnnotationsScanner.java:375"$1$"			boolean isInterface = baseType.isInterface();"
"AnnotationsScanner.java:376"$1$"			methods = isInterface ? baseType.getMethods() : ReflectionUtils.getDeclaredMethods(baseType);"
"AnnotationsScanner.java:377"$1$"			int cleared = 0;"
"AnnotationsScanner.java:378"$1$"			for (int i = 0; i < methods.length; i++) {"
"AnnotationsScanner.java:379"$1$"				if ((!isInterface && Modifier.isPrivate(methods[i].getModifiers())) ||"
"AnnotationsScanner.java:380"$1$"						hasPlainJavaAnnotationsOnly(methods[i]) ||"
"AnnotationsScanner.java:381"$1$"						getDeclaredAnnotations(methods[i], false).length == 0) {"
"AnnotationsScanner.java:382"$1$"					methods[i] = null;"
"AnnotationsScanner.java:383"$1$"					cleared++;"
"AnnotationsScanner.java:384"$1$"				}"
"AnnotationsScanner.java:385"$0$"			}"
"AnnotationsScanner.java:386"$1$"			if (cleared == methods.length) {"
"AnnotationsScanner.java:387"$1$"				methods = NO_METHODS;"
"AnnotationsScanner.java:388"$1$"			}"
"AnnotationsScanner.java:389"$0$"			baseTypeMethodsCache.put(baseType, methods);"
"AnnotationsScanner.java:390"$0$"		}"
"AnnotationsScanner.java:391"$0$"		return methods;"
"AnnotationsScanner.java:392"$0$"	}"
"AnnotationsScanner.java:393"$0$""
"AnnotationsScanner.java:394"$1$"	private static boolean isOverride(Method rootMethod, Method candidateMethod) {"
"AnnotationsScanner.java:395"$1$"		return (!Modifier.isPrivate(candidateMethod.getModifiers()) &&"
"AnnotationsScanner.java:396"$1$"				candidateMethod.getName().equals(rootMethod.getName()) &&"
"AnnotationsScanner.java:397"$1$"				hasSameParameterTypes(rootMethod, candidateMethod));"
"AnnotationsScanner.java:398"$1$"	}"
"AnnotationsScanner.java:399"$0$""
"AnnotationsScanner.java:400"$1$"	private static boolean hasSameParameterTypes(Method rootMethod, Method candidateMethod) {"
"AnnotationsScanner.java:401"$1$"		if (candidateMethod.getParameterCount() != rootMethod.getParameterCount()) {"
"AnnotationsScanner.java:402"$1$"			return false;"
"AnnotationsScanner.java:403"$1$"		}"
"AnnotationsScanner.java:404"$0$"		Class<?>[] rootParameterTypes = rootMethod.getParameterTypes();"
"AnnotationsScanner.java:405"$0$"		Class<?>[] candidateParameterTypes = candidateMethod.getParameterTypes();"
"AnnotationsScanner.java:406"$1$"		if (Arrays.equals(candidateParameterTypes, rootParameterTypes)) {"
"AnnotationsScanner.java:407"$1$"			return true;"
"AnnotationsScanner.java:408"$1$"		}"
"AnnotationsScanner.java:409"$0$"		return hasSameGenericTypeParameters(rootMethod, candidateMethod,"
"AnnotationsScanner.java:410"$0$"				rootParameterTypes);"
"AnnotationsScanner.java:411"$0$"	}"
"AnnotationsScanner.java:412"$0$""
"AnnotationsScanner.java:413"$0$"	private static boolean hasSameGenericTypeParameters("
"AnnotationsScanner.java:414"$1$"			Method rootMethod, Method candidateMethod, Class<?>[] rootParameterTypes) {"
"AnnotationsScanner.java:415"$1$""
"AnnotationsScanner.java:416"$1$"		Class<?> sourceDeclaringClass = rootMethod.getDeclaringClass();"
"AnnotationsScanner.java:417"$1$"		Class<?> candidateDeclaringClass = candidateMethod.getDeclaringClass();"
"AnnotationsScanner.java:418"$1$"		if (!candidateDeclaringClass.isAssignableFrom(sourceDeclaringClass)) {"
"AnnotationsScanner.java:419"$1$"			return false;"
"AnnotationsScanner.java:420"$1$"		}"
"AnnotationsScanner.java:421"$1$"		for (int i = 0; i < rootParameterTypes.length; i++) {"
"AnnotationsScanner.java:422"$1$"			Class<?> resolvedParameterType = ResolvableType.forMethodParameter("
"AnnotationsScanner.java:423"$1$"					candidateMethod, i, sourceDeclaringClass).resolve();"
"AnnotationsScanner.java:424"$1$"			if (rootParameterTypes[i] != resolvedParameterType) {"
"AnnotationsScanner.java:425"$1$"				return false;"
"AnnotationsScanner.java:426"$1$"			}"
"AnnotationsScanner.java:427"$0$"		}"
"AnnotationsScanner.java:428"$0$"		return true;"
"AnnotationsScanner.java:429"$0$"	}"
"AnnotationsScanner.java:430"$0$""
"AnnotationsScanner.java:431"$0$"	@Nullable"
"AnnotationsScanner.java:432"$0$"	private static <C, R> R processMethodAnnotations(C context, int aggregateIndex, Method source,"
"AnnotationsScanner.java:433"$1$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:434"$1$""
"AnnotationsScanner.java:435"$1$"		Annotation[] annotations = getDeclaredAnnotations(context, source, classFilter, false);"
"AnnotationsScanner.java:436"$1$"		R result = processor.doWithAnnotations(context, aggregateIndex, source, annotations);"
"AnnotationsScanner.java:437"$1$"		if (result != null) {"
"AnnotationsScanner.java:438"$1$"			return result;"
"AnnotationsScanner.java:439"$1$"		}"
"AnnotationsScanner.java:440"$0$"		Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(source);"
"AnnotationsScanner.java:441"$1$"		if (bridgedMethod != source) {"
"AnnotationsScanner.java:442"$1$"			Annotation[] bridgedAnnotations = getDeclaredAnnotations(context, bridgedMethod, classFilter, true);"
"AnnotationsScanner.java:443"$1$"			for (int i = 0; i < bridgedAnnotations.length; i++) {"
"AnnotationsScanner.java:444"$1$"				if (ObjectUtils.containsElement(annotations, bridgedAnnotations[i])) {"
"AnnotationsScanner.java:445"$1$"					bridgedAnnotations[i] = null;"
"AnnotationsScanner.java:446"$1$"				}"
"AnnotationsScanner.java:447"$0$"			}"
"AnnotationsScanner.java:448"$0$"			return processor.doWithAnnotations(context, aggregateIndex, source, bridgedAnnotations);"
"AnnotationsScanner.java:449"$0$"		}"
"AnnotationsScanner.java:450"$0$"		return null;"
"AnnotationsScanner.java:451"$0$"	}"
"AnnotationsScanner.java:452"$0$""
"AnnotationsScanner.java:453"$0$"	@Nullable"
"AnnotationsScanner.java:454"$0$"	private static <C, R> R processElement(C context, AnnotatedElement source,"
"AnnotationsScanner.java:455"$1$"			AnnotationsProcessor<C, R> processor, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:456"$1$""
"AnnotationsScanner.java:457"$1$"		try {"
"AnnotationsScanner.java:458"$1$"			R result = processor.doWithAggregate(context, 0);"
"AnnotationsScanner.java:459"$1$"			return (result != null ? result : processor.doWithAnnotations("
"AnnotationsScanner.java:460"$1$"				context, 0, source, getDeclaredAnnotations(context, source, classFilter, false)));"
"AnnotationsScanner.java:461"$1$"		}"
"AnnotationsScanner.java:462"$1$"		catch (Throwable ex) {"
"AnnotationsScanner.java:463"$1$"			AnnotationUtils.handleIntrospectionFailure(source, ex);"
"AnnotationsScanner.java:464"$1$"		}"
"AnnotationsScanner.java:465"$0$"		return null;"
"AnnotationsScanner.java:466"$0$"	}"
"AnnotationsScanner.java:467"$0$""
"AnnotationsScanner.java:468"$0$"	private static <C, R> Annotation[] getDeclaredAnnotations(C context,"
"AnnotationsScanner.java:469"$1$"			AnnotatedElement source, @Nullable BiPredicate<C, Class<?>> classFilter, boolean copy) {"
"AnnotationsScanner.java:470"$1$""
"AnnotationsScanner.java:471"$1$"		if (source instanceof Class && isFiltered((Class<?>) source, context, classFilter)) {"
"AnnotationsScanner.java:472"$1$"			return NO_ANNOTATIONS;"
"AnnotationsScanner.java:473"$1$"		}"
"AnnotationsScanner.java:474"$1$"		if (source instanceof Method && isFiltered(((Method) source).getDeclaringClass(), context, classFilter)) {"
"AnnotationsScanner.java:475"$1$"			return NO_ANNOTATIONS;"
"AnnotationsScanner.java:476"$1$"		}"
"AnnotationsScanner.java:477"$0$"		return getDeclaredAnnotations(source, copy);"
"AnnotationsScanner.java:478"$0$"	}"
"AnnotationsScanner.java:479"$0$""
"AnnotationsScanner.java:480"$0$"	@SuppressWarnings(""unchecked"")"
"AnnotationsScanner.java:481"$0$"	@Nullable"
"AnnotationsScanner.java:482"$1$"	static <A extends Annotation> A getDeclaredAnnotation(AnnotatedElement source, Class<A> annotationType) {"
"AnnotationsScanner.java:483"$1$"		Annotation[] annotations = getDeclaredAnnotations(source, false);"
"AnnotationsScanner.java:484"$1$"		for (Annotation annotation : annotations) {"
"AnnotationsScanner.java:485"$1$"			if (annotation != null && annotationType == annotation.annotationType()) {"
"AnnotationsScanner.java:486"$1$"				return (A) annotation;"
"AnnotationsScanner.java:487"$1$"			}"
"AnnotationsScanner.java:488"$0$"		}"
"AnnotationsScanner.java:489"$0$"		return null;"
"AnnotationsScanner.java:490"$0$"	}"
"AnnotationsScanner.java:491"$0$""
"AnnotationsScanner.java:492"$1$"	static Annotation[] getDeclaredAnnotations(AnnotatedElement source, boolean defensive) {"
"AnnotationsScanner.java:493"$1$"		boolean cached = false;"
"AnnotationsScanner.java:494"$1$"		Annotation[] annotations = declaredAnnotationCache.get(source);"
"AnnotationsScanner.java:495"$1$"		if (annotations != null) {"
"AnnotationsScanner.java:496"$1$"			cached = true;"
"AnnotationsScanner.java:497"$1$"		}"
"AnnotationsScanner.java:498"$1$"		else {"
"AnnotationsScanner.java:499"$1$"			annotations = source.getDeclaredAnnotations();"
"AnnotationsScanner.java:500"$1$"			if (annotations.length != 0) {"
"AnnotationsScanner.java:501"$1$"				boolean allIgnored = true;"
"AnnotationsScanner.java:502"$1$"				for (int i = 0; i < annotations.length; i++) {"
"AnnotationsScanner.java:503"$1$"					Annotation annotation = annotations[i];"
"AnnotationsScanner.java:504"$1$"					if (isIgnorable(annotation.annotationType()) ||"
"AnnotationsScanner.java:505"$1$"							!AttributeMethods.forAnnotationType(annotation.annotationType()).isValid(annotation)) {"
"AnnotationsScanner.java:506"$1$"						annotations[i] = null;"
"AnnotationsScanner.java:507"$1$"					}"
"AnnotationsScanner.java:508"$1$"					else {"
"AnnotationsScanner.java:509"$1$"						allIgnored = false;"
"AnnotationsScanner.java:510"$1$"					}"
"AnnotationsScanner.java:511"$0$"				}"
"AnnotationsScanner.java:512"$0$"				annotations = (allIgnored ? NO_ANNOTATIONS : annotations);"
"AnnotationsScanner.java:513"$1$"				if (source instanceof Class || source instanceof Member) {"
"AnnotationsScanner.java:514"$1$"					declaredAnnotationCache.put(source, annotations);"
"AnnotationsScanner.java:515"$1$"					cached = true;"
"AnnotationsScanner.java:516"$1$"				}"
"AnnotationsScanner.java:517"$0$"			}"
"AnnotationsScanner.java:518"$0$"		}"
"AnnotationsScanner.java:519"$1$"		if (!defensive || annotations.length == 0 || !cached) {"
"AnnotationsScanner.java:520"$1$"			return annotations;"
"AnnotationsScanner.java:521"$1$"		}"
"AnnotationsScanner.java:522"$0$"		return annotations.clone();"
"AnnotationsScanner.java:523"$0$"	}"
"AnnotationsScanner.java:524"$0$""
"AnnotationsScanner.java:525"$0$"	private static <C> boolean isFiltered("
"AnnotationsScanner.java:526"$1$"			Class<?> sourceClass, C context, @Nullable BiPredicate<C, Class<?>> classFilter) {"
"AnnotationsScanner.java:527"$1$""
"AnnotationsScanner.java:528"$1$"		return (classFilter != null && classFilter.test(context, sourceClass));"
"AnnotationsScanner.java:529"$1$"	}"
"AnnotationsScanner.java:530"$0$""
"AnnotationsScanner.java:531"$1$"	private static boolean isIgnorable(Class<?> annotationType) {"
"AnnotationsScanner.java:532"$1$"		return AnnotationFilter.PLAIN.matches(annotationType);"
"AnnotationsScanner.java:533"$1$"	}"
"AnnotationsScanner.java:534"$0$""
"AnnotationsScanner.java:535"$1$"	static boolean isKnownEmpty(AnnotatedElement source, SearchStrategy searchStrategy) {"
"AnnotationsScanner.java:536"$1$"		if (hasPlainJavaAnnotationsOnly(source)) {"
"AnnotationsScanner.java:537"$1$"			return true;"
"AnnotationsScanner.java:538"$1$"		}"
"AnnotationsScanner.java:539"$1$"		if (searchStrategy == SearchStrategy.DIRECT || isWithoutHierarchy(source, searchStrategy)) {"
"AnnotationsScanner.java:540"$1$"			if (source instanceof Method && ((Method) source).isBridge()) {"
"AnnotationsScanner.java:541"$1$"				return false;"
"AnnotationsScanner.java:542"$1$"			}"
"AnnotationsScanner.java:543"$0$"			return getDeclaredAnnotations(source, false).length == 0;"
"AnnotationsScanner.java:544"$0$"		}"
"AnnotationsScanner.java:545"$0$"		return false;"
"AnnotationsScanner.java:546"$0$"	}"
"AnnotationsScanner.java:547"$0$""
"AnnotationsScanner.java:548"$1$"	static boolean hasPlainJavaAnnotationsOnly(@Nullable Object annotatedElement) {"
"AnnotationsScanner.java:549"$1$"		if (annotatedElement instanceof Class) {"
"AnnotationsScanner.java:550"$1$"			return hasPlainJavaAnnotationsOnly((Class<?>) annotatedElement);"
"AnnotationsScanner.java:551"$1$"		}"
"AnnotationsScanner.java:552"$1$"		else if (annotatedElement instanceof Member) {"
"AnnotationsScanner.java:553"$1$"			return hasPlainJavaAnnotationsOnly(((Member) annotatedElement).getDeclaringClass());"
"AnnotationsScanner.java:554"$1$"		}"
"AnnotationsScanner.java:555"$1$"		else {"
"AnnotationsScanner.java:556"$1$"			return false;"
"AnnotationsScanner.java:557"$1$"		}"
"AnnotationsScanner.java:558"$0$"	}"
"AnnotationsScanner.java:559"$0$""
"AnnotationsScanner.java:560"$1$"	static boolean hasPlainJavaAnnotationsOnly(Class<?> type) {"
"AnnotationsScanner.java:561"$1$"		return (type.getName().startsWith(""java."") || type == Ordered.class);"
"AnnotationsScanner.java:562"$1$"	}"
"AnnotationsScanner.java:563"$0$""
"AnnotationsScanner.java:564"$1$"	private static boolean isWithoutHierarchy(AnnotatedElement source, SearchStrategy searchStrategy) {"
"AnnotationsScanner.java:565"$1$"		if (source == Object.class) {"
"AnnotationsScanner.java:566"$1$"			return true;"
"AnnotationsScanner.java:567"$1$"		}"
"AnnotationsScanner.java:568"$1$"		if (source instanceof Class) {"
"AnnotationsScanner.java:569"$1$"			Class<?> sourceClass = (Class<?>) source;"
"AnnotationsScanner.java:570"$1$"			boolean noSuperTypes = (sourceClass.getSuperclass() == Object.class &&"
"AnnotationsScanner.java:571"$1$"					sourceClass.getInterfaces().length == 0);"
"AnnotationsScanner.java:572"$1$"			return (searchStrategy == SearchStrategy.TYPE_HIERARCHY_AND_ENCLOSING_CLASSES ? noSuperTypes &&"
"AnnotationsScanner.java:573"$1$"					sourceClass.getEnclosingClass() == null : noSuperTypes);"
"AnnotationsScanner.java:574"$1$"		}"
"AnnotationsScanner.java:575"$1$"		if (source instanceof Method) {"
"AnnotationsScanner.java:576"$1$"			Method sourceMethod = (Method) source;"
"AnnotationsScanner.java:577"$1$"			return (Modifier.isPrivate(sourceMethod.getModifiers()) ||"
"AnnotationsScanner.java:578"$1$"					isWithoutHierarchy(sourceMethod.getDeclaringClass(), searchStrategy));"
"AnnotationsScanner.java:579"$1$"		}"
"AnnotationsScanner.java:580"$0$"		return true;"
"AnnotationsScanner.java:581"$0$"	}"
"AnnotationsScanner.java:582"$0$""
"AnnotationsScanner.java:583"$1$"	static void clearCache() {"
"AnnotationsScanner.java:584"$1$"		declaredAnnotationCache.clear();"
"AnnotationsScanner.java:585"$1$"		baseTypeMethodsCache.clear();"
"AnnotationsScanner.java:586"$1$"	}"
"AnnotationsScanner.java:587"$0$""
"AnnotationsScanner.java:588"$0$"}"
"SerializableTypeWrapper.java:1"$0$"/*"
"SerializableTypeWrapper.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SerializableTypeWrapper.java:3"$0$" *"
"SerializableTypeWrapper.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SerializableTypeWrapper.java:5"$0$" * you may not use this file except in compliance with the License."
"SerializableTypeWrapper.java:6"$0$" * You may obtain a copy of the License at"
"SerializableTypeWrapper.java:7"$0$" *"
"SerializableTypeWrapper.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SerializableTypeWrapper.java:9"$0$" *"
"SerializableTypeWrapper.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SerializableTypeWrapper.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SerializableTypeWrapper.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SerializableTypeWrapper.java:13"$0$" * See the License for the specific language governing permissions and"
"SerializableTypeWrapper.java:14"$0$" * limitations under the License."
"SerializableTypeWrapper.java:15"$0$" */"
"SerializableTypeWrapper.java:16"$0$""
"SerializableTypeWrapper.java:17"$0$"package org.springframework.core;"
"SerializableTypeWrapper.java:18"$0$""
"SerializableTypeWrapper.java:19"$0$"import java.io.IOException;"
"SerializableTypeWrapper.java:20"$0$"import java.io.ObjectInputStream;"
"SerializableTypeWrapper.java:21"$0$"import java.io.Serializable;"
"SerializableTypeWrapper.java:22"$0$"import java.lang.reflect.Field;"
"SerializableTypeWrapper.java:23"$0$"import java.lang.reflect.GenericArrayType;"
"SerializableTypeWrapper.java:24"$0$"import java.lang.reflect.InvocationHandler;"
"SerializableTypeWrapper.java:25"$0$"import java.lang.reflect.InvocationTargetException;"
"SerializableTypeWrapper.java:26"$0$"import java.lang.reflect.Method;"
"SerializableTypeWrapper.java:27"$0$"import java.lang.reflect.ParameterizedType;"
"SerializableTypeWrapper.java:28"$0$"import java.lang.reflect.Proxy;"
"SerializableTypeWrapper.java:29"$0$"import java.lang.reflect.Type;"
"SerializableTypeWrapper.java:30"$0$"import java.lang.reflect.TypeVariable;"
"SerializableTypeWrapper.java:31"$0$"import java.lang.reflect.WildcardType;"
"SerializableTypeWrapper.java:32"$0$""
"SerializableTypeWrapper.java:33"$0$"import org.springframework.lang.Nullable;"
"SerializableTypeWrapper.java:34"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"SerializableTypeWrapper.java:35"$0$"import org.springframework.util.ObjectUtils;"
"SerializableTypeWrapper.java:36"$0$"import org.springframework.util.ReflectionUtils;"
"SerializableTypeWrapper.java:37"$0$""
"SerializableTypeWrapper.java:38"$0$"/**"
"SerializableTypeWrapper.java:39"$1$" * Internal utility class that can be used to obtain wrapped {@link Serializable}"
"SerializableTypeWrapper.java:40"$1$" * variants of {@link java.lang.reflect.Type java.lang.reflect.Types}."
"SerializableTypeWrapper.java:41"$0$" *"
"SerializableTypeWrapper.java:42"$1$" * <p>{@link #forField(Field) Fields} or {@link #forMethodParameter(MethodParameter)"
"SerializableTypeWrapper.java:43"$0$" * MethodParameters} can be used as the root source for a serializable type."
"SerializableTypeWrapper.java:44"$1$" * Alternatively, a regular {@link Class} can also be used as source."
"SerializableTypeWrapper.java:45"$0$" *"
"SerializableTypeWrapper.java:46"$1$" * <p>The returned type will either be a {@link Class} or a serializable proxy of"
"SerializableTypeWrapper.java:47"$1$" * {@link GenericArrayType}, {@link ParameterizedType}, {@link TypeVariable} or"
"SerializableTypeWrapper.java:48"$1$" * {@link WildcardType}. With the exception of {@link Class} (which is final) calls"
"SerializableTypeWrapper.java:49"$1$" * to methods that return further {@link Type Types} (for example"
"SerializableTypeWrapper.java:50"$1$" * {@link GenericArrayType#getGenericComponentType()}) will be automatically wrapped."
"SerializableTypeWrapper.java:51"$0$" *"
"SerializableTypeWrapper.java:52"$0$" * @author Phillip Webb"
"SerializableTypeWrapper.java:53"$0$" * @author Juergen Hoeller"
"SerializableTypeWrapper.java:54"$0$" * @author Sam Brannen"
"SerializableTypeWrapper.java:55"$0$" * @since 4.0"
"SerializableTypeWrapper.java:56"$0$" */"
"SerializableTypeWrapper.java:57"$1$"final class SerializableTypeWrapper {"
"SerializableTypeWrapper.java:58"$1$""
"SerializableTypeWrapper.java:59"$1$"	private static final Class<?>[] SUPPORTED_SERIALIZABLE_TYPES = {"
"SerializableTypeWrapper.java:60"$1$"			GenericArrayType.class, ParameterizedType.class, TypeVariable.class, WildcardType.class};"
"SerializableTypeWrapper.java:61"$0$""
"SerializableTypeWrapper.java:62"$0$"	static final ConcurrentReferenceHashMap<Type, Type> cache = new ConcurrentReferenceHashMap<>(256);"
"SerializableTypeWrapper.java:63"$0$""
"SerializableTypeWrapper.java:64"$0$""
"SerializableTypeWrapper.java:65"$1$"	private SerializableTypeWrapper() {"
"SerializableTypeWrapper.java:66"$1$"	}"
"SerializableTypeWrapper.java:67"$0$""
"SerializableTypeWrapper.java:68"$0$""
"SerializableTypeWrapper.java:69"$0$"	/**"
"SerializableTypeWrapper.java:70"$1$"	 * Return a {@link Serializable} variant of {@link Field#getGenericType()}."
"SerializableTypeWrapper.java:71"$0$"	 */"
"SerializableTypeWrapper.java:72"$0$"	@Nullable"
"SerializableTypeWrapper.java:73"$1$"	public static Type forField(Field field) {"
"SerializableTypeWrapper.java:74"$1$"		return forTypeProvider(new FieldTypeProvider(field));"
"SerializableTypeWrapper.java:75"$1$"	}"
"SerializableTypeWrapper.java:76"$0$""
"SerializableTypeWrapper.java:77"$0$"	/**"
"SerializableTypeWrapper.java:78"$1$"	 * Return a {@link Serializable} variant of"
"SerializableTypeWrapper.java:79"$1$"	 * {@link MethodParameter#getGenericParameterType()}."
"SerializableTypeWrapper.java:80"$0$"	 */"
"SerializableTypeWrapper.java:81"$0$"	@Nullable"
"SerializableTypeWrapper.java:82"$1$"	public static Type forMethodParameter(MethodParameter methodParameter) {"
"SerializableTypeWrapper.java:83"$1$"		return forTypeProvider(new MethodParameterTypeProvider(methodParameter));"
"SerializableTypeWrapper.java:84"$1$"	}"
"SerializableTypeWrapper.java:85"$0$""
"SerializableTypeWrapper.java:86"$0$"	/**"
"SerializableTypeWrapper.java:87"$0$"	 * Unwrap the given type, effectively returning the original non-serializable type."
"SerializableTypeWrapper.java:88"$0$"	 * @param type the type to unwrap"
"SerializableTypeWrapper.java:89"$0$"	 * @return the original non-serializable type"
"SerializableTypeWrapper.java:90"$0$"	 */"
"SerializableTypeWrapper.java:91"$0$"	@SuppressWarnings(""unchecked"")"
"SerializableTypeWrapper.java:92"$1$"	public static <T extends Type> T unwrap(T type) {"
"SerializableTypeWrapper.java:93"$1$"		Type unwrapped = null;"
"SerializableTypeWrapper.java:94"$1$"		if (type instanceof SerializableTypeProxy) {"
"SerializableTypeWrapper.java:95"$1$"			unwrapped = ((SerializableTypeProxy) type).getTypeProvider().getType();"
"SerializableTypeWrapper.java:96"$1$"		}"
"SerializableTypeWrapper.java:97"$0$"		return (unwrapped != null ? (T) unwrapped : type);"
"SerializableTypeWrapper.java:98"$0$"	}"
"SerializableTypeWrapper.java:99"$0$""
"SerializableTypeWrapper.java:100"$0$"	/**"
"SerializableTypeWrapper.java:101"$1$"	 * Return a {@link Serializable} {@link Type} backed by a {@link TypeProvider} ."
"SerializableTypeWrapper.java:102"$0$"	 * <p>If type artifacts are generally not serializable in the current runtime"
"SerializableTypeWrapper.java:103"$1$"	 * environment, this delegate will simply return the original {@code Type} as-is."
"SerializableTypeWrapper.java:104"$0$"	 */"
"SerializableTypeWrapper.java:105"$0$"	@Nullable"
"SerializableTypeWrapper.java:106"$1$"	static Type forTypeProvider(TypeProvider provider) {"
"SerializableTypeWrapper.java:107"$1$"		Type providedType = provider.getType();"
"SerializableTypeWrapper.java:108"$1$"		if (providedType == null || providedType instanceof Serializable) {"
"SerializableTypeWrapper.java:109"$0$"			// No serializable type wrapping necessary (e.g. for java.lang.Class)"
"SerializableTypeWrapper.java:110"$1$"			return providedType;"
"SerializableTypeWrapper.java:111"$1$"		}"
"SerializableTypeWrapper.java:112"$1$"		if (GraalDetector.inImageCode() || !Serializable.class.isAssignableFrom(Class.class)) {"
"SerializableTypeWrapper.java:113"$0$"			// Let's skip any wrapping attempts if types are generally not serializable in"
"SerializableTypeWrapper.java:114"$0$"			// the current runtime environment (even java.lang.Class itself, e.g. on Graal)"
"SerializableTypeWrapper.java:115"$1$"			return providedType;"
"SerializableTypeWrapper.java:116"$1$"		}"
"SerializableTypeWrapper.java:117"$0$""
"SerializableTypeWrapper.java:118"$0$"		// Obtain a serializable type proxy for the given provider..."
"SerializableTypeWrapper.java:119"$0$"		Type cached = cache.get(providedType);"
"SerializableTypeWrapper.java:120"$1$"		if (cached != null) {"
"SerializableTypeWrapper.java:121"$1$"			return cached;"
"SerializableTypeWrapper.java:122"$1$"		}"
"SerializableTypeWrapper.java:123"$1$"		for (Class<?> type : SUPPORTED_SERIALIZABLE_TYPES) {"
"SerializableTypeWrapper.java:124"$1$"			if (type.isInstance(providedType)) {"
"SerializableTypeWrapper.java:125"$1$"				ClassLoader classLoader = provider.getClass().getClassLoader();"
"SerializableTypeWrapper.java:126"$1$"				Class<?>[] interfaces = new Class<?>[] {type, SerializableTypeProxy.class, Serializable.class};"
"SerializableTypeWrapper.java:127"$1$"				InvocationHandler handler = new TypeProxyInvocationHandler(provider);"
"SerializableTypeWrapper.java:128"$1$"				cached = (Type) Proxy.newProxyInstance(classLoader, interfaces, handler);"
"SerializableTypeWrapper.java:129"$1$"				cache.put(providedType, cached);"
"SerializableTypeWrapper.java:130"$1$"				return cached;"
"SerializableTypeWrapper.java:131"$1$"			}"
"SerializableTypeWrapper.java:132"$0$"		}"
"SerializableTypeWrapper.java:133"$0$"		throw new IllegalArgumentException(""Unsupported Type class: "" + providedType.getClass().getName());"
"SerializableTypeWrapper.java:134"$0$"	}"
"SerializableTypeWrapper.java:135"$0$""
"SerializableTypeWrapper.java:136"$0$""
"SerializableTypeWrapper.java:137"$0$"	/**"
"SerializableTypeWrapper.java:138"$0$"	 * Additional interface implemented by the type proxy."
"SerializableTypeWrapper.java:139"$0$"	 */"
"SerializableTypeWrapper.java:140"$1$"	interface SerializableTypeProxy {"
"SerializableTypeWrapper.java:141"$1$""
"SerializableTypeWrapper.java:142"$1$"		/**"
"SerializableTypeWrapper.java:143"$1$"		 * Return the underlying type provider."
"SerializableTypeWrapper.java:144"$1$"		 */"
"SerializableTypeWrapper.java:145"$1$"		TypeProvider getTypeProvider();"
"SerializableTypeWrapper.java:146"$1$"	}"
"SerializableTypeWrapper.java:147"$0$""
"SerializableTypeWrapper.java:148"$0$""
"SerializableTypeWrapper.java:149"$0$"	/**"
"SerializableTypeWrapper.java:150"$1$"	 * A {@link Serializable} interface providing access to a {@link Type}."
"SerializableTypeWrapper.java:151"$0$"	 */"
"SerializableTypeWrapper.java:152"$0$"	@SuppressWarnings(""serial"")"
"SerializableTypeWrapper.java:153"$1$"	interface TypeProvider extends Serializable {"
"SerializableTypeWrapper.java:154"$1$""
"SerializableTypeWrapper.java:155"$1$"		/**"
"SerializableTypeWrapper.java:156"$1$"		 * Return the (possibly non {@link Serializable}) {@link Type}."
"SerializableTypeWrapper.java:157"$1$"		 */"
"SerializableTypeWrapper.java:158"$1$"		@Nullable"
"SerializableTypeWrapper.java:159"$1$"		Type getType();"
"SerializableTypeWrapper.java:160"$1$""
"SerializableTypeWrapper.java:161"$1$"		/**"
"SerializableTypeWrapper.java:162"$1$"		 * Return the source of the type, or {@code null} if not known."
"SerializableTypeWrapper.java:163"$1$"		 * <p>The default implementations returns {@code null}."
"SerializableTypeWrapper.java:164"$1$"		 */"
"SerializableTypeWrapper.java:165"$1$"		@Nullable"
"SerializableTypeWrapper.java:166"$1$"		default Object getSource() {"
"SerializableTypeWrapper.java:167"$1$"			return null;"
"SerializableTypeWrapper.java:168"$1$"		}"
"SerializableTypeWrapper.java:169"$0$"	}"
"SerializableTypeWrapper.java:170"$0$""
"SerializableTypeWrapper.java:171"$0$""
"SerializableTypeWrapper.java:172"$0$"	/**"
"SerializableTypeWrapper.java:173"$1$"	 * {@link Serializable} {@link InvocationHandler} used by the proxied {@link Type}."
"SerializableTypeWrapper.java:174"$1$"	 * Provides serialization support and enhances any methods that return {@code Type}"
"SerializableTypeWrapper.java:175"$1$"	 * or {@code Type[]}."
"SerializableTypeWrapper.java:176"$0$"	 */"
"SerializableTypeWrapper.java:177"$0$"	@SuppressWarnings(""serial"")"
"SerializableTypeWrapper.java:178"$1$"	private static class TypeProxyInvocationHandler implements InvocationHandler, Serializable {"
"SerializableTypeWrapper.java:179"$1$""
"SerializableTypeWrapper.java:180"$1$"		private final TypeProvider provider;"
"SerializableTypeWrapper.java:181"$1$""
"SerializableTypeWrapper.java:182"$1$"		public TypeProxyInvocationHandler(TypeProvider provider) {"
"SerializableTypeWrapper.java:183"$1$"			this.provider = provider;"
"SerializableTypeWrapper.java:184"$1$"		}"
"SerializableTypeWrapper.java:185"$0$""
"SerializableTypeWrapper.java:186"$0$"		@Override"
"SerializableTypeWrapper.java:187"$0$"		@Nullable"
"SerializableTypeWrapper.java:188"$1$"		public Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable {"
"SerializableTypeWrapper.java:189"$1$"			if (method.getName().equals(""equals"") && args != null) {"
"SerializableTypeWrapper.java:190"$1$"				Object other = args[0];"
"SerializableTypeWrapper.java:191"$0$"				// Unwrap proxies for speed"
"SerializableTypeWrapper.java:192"$1$"				if (other instanceof Type) {"
"SerializableTypeWrapper.java:193"$1$"					other = unwrap((Type) other);"
"SerializableTypeWrapper.java:194"$1$"				}"
"SerializableTypeWrapper.java:195"$0$"				return ObjectUtils.nullSafeEquals(this.provider.getType(), other);"
"SerializableTypeWrapper.java:196"$0$"			}"
"SerializableTypeWrapper.java:197"$1$"			else if (method.getName().equals(""hashCode"")) {"
"SerializableTypeWrapper.java:198"$1$"				return ObjectUtils.nullSafeHashCode(this.provider.getType());"
"SerializableTypeWrapper.java:199"$1$"			}"
"SerializableTypeWrapper.java:200"$1$"			else if (method.getName().equals(""getTypeProvider"")) {"
"SerializableTypeWrapper.java:201"$1$"				return this.provider;"
"SerializableTypeWrapper.java:202"$1$"			}"
"SerializableTypeWrapper.java:203"$0$""
"SerializableTypeWrapper.java:204"$1$"			if (Type.class == method.getReturnType() && args == null) {"
"SerializableTypeWrapper.java:205"$1$"				return forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, -1));"
"SerializableTypeWrapper.java:206"$1$"			}"
"SerializableTypeWrapper.java:207"$1$"			else if (Type[].class == method.getReturnType() && args == null) {"
"SerializableTypeWrapper.java:208"$1$"				Type[] result = new Type[((Type[]) method.invoke(this.provider.getType())).length];"
"SerializableTypeWrapper.java:209"$1$"				for (int i = 0; i < result.length; i++) {"
"SerializableTypeWrapper.java:210"$1$"					result[i] = forTypeProvider(new MethodInvokeTypeProvider(this.provider, method, i));"
"SerializableTypeWrapper.java:211"$1$"				}"
"SerializableTypeWrapper.java:212"$0$"				return result;"
"SerializableTypeWrapper.java:213"$0$"			}"
"SerializableTypeWrapper.java:214"$0$""
"SerializableTypeWrapper.java:215"$1$"			try {"
"SerializableTypeWrapper.java:216"$1$"				return method.invoke(this.provider.getType(), args);"
"SerializableTypeWrapper.java:217"$1$"			}"
"SerializableTypeWrapper.java:218"$1$"			catch (InvocationTargetException ex) {"
"SerializableTypeWrapper.java:219"$1$"				throw ex.getTargetException();"
"SerializableTypeWrapper.java:220"$1$"			}"
"SerializableTypeWrapper.java:221"$0$"		}"
"SerializableTypeWrapper.java:222"$0$"	}"
"SerializableTypeWrapper.java:223"$0$""
"SerializableTypeWrapper.java:224"$0$""
"SerializableTypeWrapper.java:225"$0$"	/**"
"SerializableTypeWrapper.java:226"$1$"	 * {@link TypeProvider} for {@link Type Types} obtained from a {@link Field}."
"SerializableTypeWrapper.java:227"$0$"	 */"
"SerializableTypeWrapper.java:228"$0$"	@SuppressWarnings(""serial"")"
"SerializableTypeWrapper.java:229"$1$"	static class FieldTypeProvider implements TypeProvider {"
"SerializableTypeWrapper.java:230"$1$""
"SerializableTypeWrapper.java:231"$1$"		private final String fieldName;"
"SerializableTypeWrapper.java:232"$1$""
"SerializableTypeWrapper.java:233"$1$"		private final Class<?> declaringClass;"
"SerializableTypeWrapper.java:234"$1$""
"SerializableTypeWrapper.java:235"$1$"		private transient Field field;"
"SerializableTypeWrapper.java:236"$1$""
"SerializableTypeWrapper.java:237"$1$"		public FieldTypeProvider(Field field) {"
"SerializableTypeWrapper.java:238"$1$"			this.fieldName = field.getName();"
"SerializableTypeWrapper.java:239"$1$"			this.declaringClass = field.getDeclaringClass();"
"SerializableTypeWrapper.java:240"$1$"			this.field = field;"
"SerializableTypeWrapper.java:241"$1$"		}"
"SerializableTypeWrapper.java:242"$0$""
"SerializableTypeWrapper.java:243"$0$"		@Override"
"SerializableTypeWrapper.java:244"$1$"		public Type getType() {"
"SerializableTypeWrapper.java:245"$1$"			return this.field.getGenericType();"
"SerializableTypeWrapper.java:246"$1$"		}"
"SerializableTypeWrapper.java:247"$0$""
"SerializableTypeWrapper.java:248"$0$"		@Override"
"SerializableTypeWrapper.java:249"$1$"		public Object getSource() {"
"SerializableTypeWrapper.java:250"$1$"			return this.field;"
"SerializableTypeWrapper.java:251"$1$"		}"
"SerializableTypeWrapper.java:252"$0$""
"SerializableTypeWrapper.java:253"$1$"		private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {"
"SerializableTypeWrapper.java:254"$1$"			inputStream.defaultReadObject();"
"SerializableTypeWrapper.java:255"$1$"			try {"
"SerializableTypeWrapper.java:256"$1$"				this.field = this.declaringClass.getDeclaredField(this.fieldName);"
"SerializableTypeWrapper.java:257"$1$"			}"
"SerializableTypeWrapper.java:258"$1$"			catch (Throwable ex) {"
"SerializableTypeWrapper.java:259"$1$"				throw new IllegalStateException(""Could not find original class structure"", ex);"
"SerializableTypeWrapper.java:260"$1$"			}"
"SerializableTypeWrapper.java:261"$0$"		}"
"SerializableTypeWrapper.java:262"$0$"	}"
"SerializableTypeWrapper.java:263"$0$""
"SerializableTypeWrapper.java:264"$0$""
"SerializableTypeWrapper.java:265"$0$"	/**"
"SerializableTypeWrapper.java:266"$1$"	 * {@link TypeProvider} for {@link Type Types} obtained from a {@link MethodParameter}."
"SerializableTypeWrapper.java:267"$0$"	 */"
"SerializableTypeWrapper.java:268"$0$"	@SuppressWarnings(""serial"")"
"SerializableTypeWrapper.java:269"$1$"	static class MethodParameterTypeProvider implements TypeProvider {"
"SerializableTypeWrapper.java:270"$1$""
"SerializableTypeWrapper.java:271"$1$"		@Nullable"
"SerializableTypeWrapper.java:272"$1$"		private final String methodName;"
"SerializableTypeWrapper.java:273"$1$""
"SerializableTypeWrapper.java:274"$1$"		private final Class<?>[] parameterTypes;"
"SerializableTypeWrapper.java:275"$1$""
"SerializableTypeWrapper.java:276"$1$"		private final Class<?> declaringClass;"
"SerializableTypeWrapper.java:277"$1$""
"SerializableTypeWrapper.java:278"$1$"		private final int parameterIndex;"
"SerializableTypeWrapper.java:279"$1$""
"SerializableTypeWrapper.java:280"$1$"		private transient MethodParameter methodParameter;"
"SerializableTypeWrapper.java:281"$1$""
"SerializableTypeWrapper.java:282"$1$"		public MethodParameterTypeProvider(MethodParameter methodParameter) {"
"SerializableTypeWrapper.java:283"$1$"			this.methodName = (methodParameter.getMethod() != null ? methodParameter.getMethod().getName() : null);"
"SerializableTypeWrapper.java:284"$1$"			this.parameterTypes = methodParameter.getExecutable().getParameterTypes();"
"SerializableTypeWrapper.java:285"$1$"			this.declaringClass = methodParameter.getDeclaringClass();"
"SerializableTypeWrapper.java:286"$1$"			this.parameterIndex = methodParameter.getParameterIndex();"
"SerializableTypeWrapper.java:287"$1$"			this.methodParameter = methodParameter;"
"SerializableTypeWrapper.java:288"$1$"		}"
"SerializableTypeWrapper.java:289"$0$""
"SerializableTypeWrapper.java:290"$0$"		@Override"
"SerializableTypeWrapper.java:291"$1$"		public Type getType() {"
"SerializableTypeWrapper.java:292"$1$"			return this.methodParameter.getGenericParameterType();"
"SerializableTypeWrapper.java:293"$1$"		}"
"SerializableTypeWrapper.java:294"$0$""
"SerializableTypeWrapper.java:295"$0$"		@Override"
"SerializableTypeWrapper.java:296"$1$"		public Object getSource() {"
"SerializableTypeWrapper.java:297"$1$"			return this.methodParameter;"
"SerializableTypeWrapper.java:298"$1$"		}"
"SerializableTypeWrapper.java:299"$0$""
"SerializableTypeWrapper.java:300"$1$"		private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {"
"SerializableTypeWrapper.java:301"$1$"			inputStream.defaultReadObject();"
"SerializableTypeWrapper.java:302"$1$"			try {"
"SerializableTypeWrapper.java:303"$1$"				if (this.methodName != null) {"
"SerializableTypeWrapper.java:304"$1$"					this.methodParameter = new MethodParameter("
"SerializableTypeWrapper.java:305"$1$"							this.declaringClass.getDeclaredMethod(this.methodName, this.parameterTypes), this.parameterIndex);"
"SerializableTypeWrapper.java:306"$1$"				}"
"SerializableTypeWrapper.java:307"$1$"				else {"
"SerializableTypeWrapper.java:308"$1$"					this.methodParameter = new MethodParameter("
"SerializableTypeWrapper.java:309"$1$"							this.declaringClass.getDeclaredConstructor(this.parameterTypes), this.parameterIndex);"
"SerializableTypeWrapper.java:310"$1$"				}"
"SerializableTypeWrapper.java:311"$0$"			}"
"SerializableTypeWrapper.java:312"$1$"			catch (Throwable ex) {"
"SerializableTypeWrapper.java:313"$1$"				throw new IllegalStateException(""Could not find original class structure"", ex);"
"SerializableTypeWrapper.java:314"$1$"			}"
"SerializableTypeWrapper.java:315"$0$"		}"
"SerializableTypeWrapper.java:316"$0$"	}"
"SerializableTypeWrapper.java:317"$0$""
"SerializableTypeWrapper.java:318"$0$""
"SerializableTypeWrapper.java:319"$0$"	/**"
"SerializableTypeWrapper.java:320"$1$"	 * {@link TypeProvider} for {@link Type Types} obtained by invoking a no-arg method."
"SerializableTypeWrapper.java:321"$0$"	 */"
"SerializableTypeWrapper.java:322"$0$"	@SuppressWarnings(""serial"")"
"SerializableTypeWrapper.java:323"$1$"	static class MethodInvokeTypeProvider implements TypeProvider {"
"SerializableTypeWrapper.java:324"$1$""
"SerializableTypeWrapper.java:325"$1$"		private final TypeProvider provider;"
"SerializableTypeWrapper.java:326"$1$""
"SerializableTypeWrapper.java:327"$1$"		private final String methodName;"
"SerializableTypeWrapper.java:328"$1$""
"SerializableTypeWrapper.java:329"$1$"		private final Class<?> declaringClass;"
"SerializableTypeWrapper.java:330"$1$""
"SerializableTypeWrapper.java:331"$1$"		private final int index;"
"SerializableTypeWrapper.java:332"$1$""
"SerializableTypeWrapper.java:333"$1$"		private transient Method method;"
"SerializableTypeWrapper.java:334"$1$""
"SerializableTypeWrapper.java:335"$1$"		@Nullable"
"SerializableTypeWrapper.java:336"$1$"		private transient volatile Object result;"
"SerializableTypeWrapper.java:337"$1$""
"SerializableTypeWrapper.java:338"$1$"		public MethodInvokeTypeProvider(TypeProvider provider, Method method, int index) {"
"SerializableTypeWrapper.java:339"$1$"			this.provider = provider;"
"SerializableTypeWrapper.java:340"$1$"			this.methodName = method.getName();"
"SerializableTypeWrapper.java:341"$1$"			this.declaringClass = method.getDeclaringClass();"
"SerializableTypeWrapper.java:342"$1$"			this.index = index;"
"SerializableTypeWrapper.java:343"$1$"			this.method = method;"
"SerializableTypeWrapper.java:344"$1$"		}"
"SerializableTypeWrapper.java:345"$0$""
"SerializableTypeWrapper.java:346"$0$"		@Override"
"SerializableTypeWrapper.java:347"$0$"		@Nullable"
"SerializableTypeWrapper.java:348"$1$"		public Type getType() {"
"SerializableTypeWrapper.java:349"$1$"			Object result = this.result;"
"SerializableTypeWrapper.java:350"$1$"			if (result == null) {"
"SerializableTypeWrapper.java:351"$0$"				// Lazy invocation of the target method on the provided type"
"SerializableTypeWrapper.java:352"$1$"				result = ReflectionUtils.invokeMethod(this.method, this.provider.getType());"
"SerializableTypeWrapper.java:353"$0$"				// Cache the result for further calls to getType()"
"SerializableTypeWrapper.java:354"$1$"				this.result = result;"
"SerializableTypeWrapper.java:355"$1$"			}"
"SerializableTypeWrapper.java:356"$0$"			return (result instanceof Type[] ? ((Type[]) result)[this.index] : (Type) result);"
"SerializableTypeWrapper.java:357"$0$"		}"
"SerializableTypeWrapper.java:358"$0$""
"SerializableTypeWrapper.java:359"$0$"		@Override"
"SerializableTypeWrapper.java:360"$0$"		@Nullable"
"SerializableTypeWrapper.java:361"$1$"		public Object getSource() {"
"SerializableTypeWrapper.java:362"$1$"			return null;"
"SerializableTypeWrapper.java:363"$1$"		}"
"SerializableTypeWrapper.java:364"$0$""
"SerializableTypeWrapper.java:365"$1$"		private void readObject(ObjectInputStream inputStream) throws IOException, ClassNotFoundException {"
"SerializableTypeWrapper.java:366"$1$"			inputStream.defaultReadObject();"
"SerializableTypeWrapper.java:367"$1$"			Method method = ReflectionUtils.findMethod(this.declaringClass, this.methodName);"
"SerializableTypeWrapper.java:368"$1$"			if (method == null) {"
"SerializableTypeWrapper.java:369"$1$"				throw new IllegalStateException(""Cannot find method on deserialization: "" + this.methodName);"
"SerializableTypeWrapper.java:370"$1$"			}"
"SerializableTypeWrapper.java:371"$1$"			if (method.getReturnType() != Type.class && method.getReturnType() != Type[].class) {"
"SerializableTypeWrapper.java:372"$1$"				throw new IllegalStateException("
"SerializableTypeWrapper.java:373"$1$"						""Invalid return type on deserialized method - needs to be Type or Type[]: "" + method);"
"SerializableTypeWrapper.java:374"$1$"			}"
"SerializableTypeWrapper.java:375"$0$"			this.method = method;"
"SerializableTypeWrapper.java:376"$0$"		}"
"SerializableTypeWrapper.java:377"$0$"	}"
"SerializableTypeWrapper.java:378"$0$""
"SerializableTypeWrapper.java:379"$0$"}"
"RepeatableContainers.java:1"$0$"/*"
"RepeatableContainers.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"RepeatableContainers.java:3"$0$" *"
"RepeatableContainers.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"RepeatableContainers.java:5"$0$" * you may not use this file except in compliance with the License."
"RepeatableContainers.java:6"$0$" * You may obtain a copy of the License at"
"RepeatableContainers.java:7"$0$" *"
"RepeatableContainers.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"RepeatableContainers.java:9"$0$" *"
"RepeatableContainers.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"RepeatableContainers.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"RepeatableContainers.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"RepeatableContainers.java:13"$0$" * See the License for the specific language governing permissions and"
"RepeatableContainers.java:14"$0$" * limitations under the License."
"RepeatableContainers.java:15"$0$" */"
"RepeatableContainers.java:16"$0$""
"RepeatableContainers.java:17"$0$"package org.springframework.core.annotation;"
"RepeatableContainers.java:18"$0$""
"RepeatableContainers.java:19"$0$"import java.lang.annotation.Annotation;"
"RepeatableContainers.java:20"$0$"import java.lang.annotation.Repeatable;"
"RepeatableContainers.java:21"$0$"import java.lang.reflect.Method;"
"RepeatableContainers.java:22"$0$"import java.util.Map;"
"RepeatableContainers.java:23"$0$""
"RepeatableContainers.java:24"$0$"import org.springframework.lang.Nullable;"
"RepeatableContainers.java:25"$0$"import org.springframework.util.Assert;"
"RepeatableContainers.java:26"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"RepeatableContainers.java:27"$0$"import org.springframework.util.ObjectUtils;"
"RepeatableContainers.java:28"$0$"import org.springframework.util.ReflectionUtils;"
"RepeatableContainers.java:29"$0$""
"RepeatableContainers.java:30"$0$"/**"
"RepeatableContainers.java:31"$0$" * Strategy used to determine annotations that act as containers for other"
"RepeatableContainers.java:32"$1$" * annotations. The {@link #standardRepeatables()} method provides a default"
"RepeatableContainers.java:33"$1$" * strategy that respects Java's {@link Repeatable @Repeatable} support and"
"RepeatableContainers.java:34"$0$" * should be suitable for most situations."
"RepeatableContainers.java:35"$0$" *"
"RepeatableContainers.java:36"$1$" * <p>The {@link #of} method can be used to register relationships for"
"RepeatableContainers.java:37"$1$" * annotations that do not wish to use {@link Repeatable @Repeatable}."
"RepeatableContainers.java:38"$0$" *"
"RepeatableContainers.java:39"$1$" * <p>To completely disable repeatable support use {@link #none()}."
"RepeatableContainers.java:40"$0$" *"
"RepeatableContainers.java:41"$0$" * @author Phillip Webb"
"RepeatableContainers.java:42"$0$" * @since 5.2"
"RepeatableContainers.java:43"$0$" */"
"RepeatableContainers.java:44"$1$"public abstract class RepeatableContainers {"
"RepeatableContainers.java:45"$1$""
"RepeatableContainers.java:46"$1$"	@Nullable"
"RepeatableContainers.java:47"$1$"	private final RepeatableContainers parent;"
"RepeatableContainers.java:48"$1$""
"RepeatableContainers.java:49"$1$""
"RepeatableContainers.java:50"$1$"	private RepeatableContainers(@Nullable RepeatableContainers parent) {"
"RepeatableContainers.java:51"$1$"		this.parent = parent;"
"RepeatableContainers.java:52"$1$"	}"
"RepeatableContainers.java:53"$0$""
"RepeatableContainers.java:54"$0$""
"RepeatableContainers.java:55"$0$"	/**"
"RepeatableContainers.java:56"$0$"	 * Add an additional explicit relationship between a contained and"
"RepeatableContainers.java:57"$0$"	 * repeatable annotation."
"RepeatableContainers.java:58"$0$"	 * @param container the container type"
"RepeatableContainers.java:59"$0$"	 * @param repeatable the contained repeatable type"
"RepeatableContainers.java:60"$1$"	 * @return a new {@link RepeatableContainers} instance"
"RepeatableContainers.java:61"$0$"	 */"
"RepeatableContainers.java:62"$0$"	public RepeatableContainers and(Class<? extends Annotation> container,"
"RepeatableContainers.java:63"$1$"			Class<? extends Annotation> repeatable) {"
"RepeatableContainers.java:64"$1$""
"RepeatableContainers.java:65"$1$"		return new ExplicitRepeatableContainer(this, repeatable, container);"
"RepeatableContainers.java:66"$1$"	}"
"RepeatableContainers.java:67"$0$""
"RepeatableContainers.java:68"$0$"	@Nullable"
"RepeatableContainers.java:69"$1$"	Annotation[] findRepeatedAnnotations(Annotation annotation) {"
"RepeatableContainers.java:70"$1$"		if (this.parent == null) {"
"RepeatableContainers.java:71"$1$"			return null;"
"RepeatableContainers.java:72"$1$"		}"
"RepeatableContainers.java:73"$0$"		return this.parent.findRepeatedAnnotations(annotation);"
"RepeatableContainers.java:74"$0$"	}"
"RepeatableContainers.java:75"$0$""
"RepeatableContainers.java:76"$0$""
"RepeatableContainers.java:77"$0$"	@Override"
"RepeatableContainers.java:78"$1$"	public boolean equals(@Nullable Object other) {"
"RepeatableContainers.java:79"$1$"		if (other == this) {"
"RepeatableContainers.java:80"$1$"			return true;"
"RepeatableContainers.java:81"$1$"		}"
"RepeatableContainers.java:82"$1$"		if (other == null || getClass() != other.getClass()) {"
"RepeatableContainers.java:83"$1$"			return false;"
"RepeatableContainers.java:84"$1$"		}"
"RepeatableContainers.java:85"$0$"		return ObjectUtils.nullSafeEquals(this.parent, ((RepeatableContainers) other).parent);"
"RepeatableContainers.java:86"$0$"	}"
"RepeatableContainers.java:87"$0$""
"RepeatableContainers.java:88"$0$"	@Override"
"RepeatableContainers.java:89"$1$"	public int hashCode() {"
"RepeatableContainers.java:90"$1$"		return ObjectUtils.nullSafeHashCode(this.parent);"
"RepeatableContainers.java:91"$1$"	}"
"RepeatableContainers.java:92"$0$""
"RepeatableContainers.java:93"$0$""
"RepeatableContainers.java:94"$0$"	/**"
"RepeatableContainers.java:95"$1$"	 * Create a {@link RepeatableContainers} instance that searches using Java's"
"RepeatableContainers.java:96"$1$"	 * {@link Repeatable @Repeatable} annotation."
"RepeatableContainers.java:97"$1$"	 * @return a {@link RepeatableContainers} instance"
"RepeatableContainers.java:98"$0$"	 */"
"RepeatableContainers.java:99"$1$"	public static RepeatableContainers standardRepeatables() {"
"RepeatableContainers.java:100"$1$"		return StandardRepeatableContainers.INSTANCE;"
"RepeatableContainers.java:101"$1$"	}"
"RepeatableContainers.java:102"$0$""
"RepeatableContainers.java:103"$0$"	/**"
"RepeatableContainers.java:104"$1$"	 * Create a {@link RepeatableContainers} instance that uses a defined"
"RepeatableContainers.java:105"$0$"	 * container and repeatable type."
"RepeatableContainers.java:106"$0$"	 * @param repeatable the contained repeatable annotation"
"RepeatableContainers.java:107"$1$"	 * @param container the container annotation or {@code null}. If specified,"
"RepeatableContainers.java:108"$1$"	 * this annotation must declare a {@code value} attribute returning an array"
"RepeatableContainers.java:109"$0$"	 * of repeatable annotations. If not specified, the container will be"
"RepeatableContainers.java:110"$1$"	 * deduced by inspecting the {@code @Repeatable} annotation on"
"RepeatableContainers.java:111"$1$"	 * {@code repeatable}."
"RepeatableContainers.java:112"$1$"	 * @return a {@link RepeatableContainers} instance"
"RepeatableContainers.java:113"$0$"	 */"
"RepeatableContainers.java:114"$0$"	public static RepeatableContainers of("
"RepeatableContainers.java:115"$1$"			Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {"
"RepeatableContainers.java:116"$1$""
"RepeatableContainers.java:117"$1$"		return new ExplicitRepeatableContainer(null, repeatable, container);"
"RepeatableContainers.java:118"$1$"	}"
"RepeatableContainers.java:119"$0$""
"RepeatableContainers.java:120"$0$"	/**"
"RepeatableContainers.java:121"$1$"	 * Create a {@link RepeatableContainers} instance that does not expand any"
"RepeatableContainers.java:122"$0$"	 * repeatable annotations."
"RepeatableContainers.java:123"$1$"	 * @return a {@link RepeatableContainers} instance"
"RepeatableContainers.java:124"$0$"	 */"
"RepeatableContainers.java:125"$1$"	public static RepeatableContainers none() {"
"RepeatableContainers.java:126"$1$"		return NoRepeatableContainers.INSTANCE;"
"RepeatableContainers.java:127"$1$"	}"
"RepeatableContainers.java:128"$0$""
"RepeatableContainers.java:129"$0$""
"RepeatableContainers.java:130"$0$"	/**"
"RepeatableContainers.java:131"$1$"	 * Standard {@link RepeatableContainers} implementation that searches using"
"RepeatableContainers.java:132"$1$"	 * Java's {@link Repeatable @Repeatable} annotation."
"RepeatableContainers.java:133"$0$"	 */"
"RepeatableContainers.java:134"$1$"	private static class StandardRepeatableContainers extends RepeatableContainers {"
"RepeatableContainers.java:135"$1$""
"RepeatableContainers.java:136"$1$"		private static final Map<Class<? extends Annotation>, Object> cache = new ConcurrentReferenceHashMap<>();"
"RepeatableContainers.java:137"$1$""
"RepeatableContainers.java:138"$1$"		private static final Object NONE = new Object();"
"RepeatableContainers.java:139"$1$""
"RepeatableContainers.java:140"$1$"		private static StandardRepeatableContainers INSTANCE = new StandardRepeatableContainers();"
"RepeatableContainers.java:141"$1$""
"RepeatableContainers.java:142"$1$"		StandardRepeatableContainers() {"
"RepeatableContainers.java:143"$1$"			super(null);"
"RepeatableContainers.java:144"$1$"		}"
"RepeatableContainers.java:145"$0$""
"RepeatableContainers.java:146"$0$"		@Override"
"RepeatableContainers.java:147"$0$"		@Nullable"
"RepeatableContainers.java:148"$1$"		Annotation[] findRepeatedAnnotations(Annotation annotation) {"
"RepeatableContainers.java:149"$1$"			Method method = getRepeatedAnnotationsMethod(annotation.annotationType());"
"RepeatableContainers.java:150"$1$"			if (method != null) {"
"RepeatableContainers.java:151"$1$"				return (Annotation[]) ReflectionUtils.invokeMethod(method, annotation);"
"RepeatableContainers.java:152"$1$"			}"
"RepeatableContainers.java:153"$0$"			return super.findRepeatedAnnotations(annotation);"
"RepeatableContainers.java:154"$0$"		}"
"RepeatableContainers.java:155"$0$""
"RepeatableContainers.java:156"$0$"		@Nullable"
"RepeatableContainers.java:157"$1$"		private static Method getRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {"
"RepeatableContainers.java:158"$1$"			Object result = cache.computeIfAbsent(annotationType,"
"RepeatableContainers.java:159"$1$"					StandardRepeatableContainers::computeRepeatedAnnotationsMethod);"
"RepeatableContainers.java:160"$1$"			return (result != NONE ? (Method) result : null);"
"RepeatableContainers.java:161"$1$"		}"
"RepeatableContainers.java:162"$0$""
"RepeatableContainers.java:163"$1$"		private static Object computeRepeatedAnnotationsMethod(Class<? extends Annotation> annotationType) {"
"RepeatableContainers.java:164"$1$"			AttributeMethods methods = AttributeMethods.forAnnotationType(annotationType);"
"RepeatableContainers.java:165"$1$"			if (methods.hasOnlyValueAttribute()) {"
"RepeatableContainers.java:166"$1$"				Method method = methods.get(0);"
"RepeatableContainers.java:167"$1$"				Class<?> returnType = method.getReturnType();"
"RepeatableContainers.java:168"$1$"				if (returnType.isArray()) {"
"RepeatableContainers.java:169"$1$"					Class<?> componentType = returnType.getComponentType();"
"RepeatableContainers.java:170"$1$"					if (Annotation.class.isAssignableFrom(componentType) &&"
"RepeatableContainers.java:171"$1$"							componentType.isAnnotationPresent(Repeatable.class)) {"
"RepeatableContainers.java:172"$1$"						return method;"
"RepeatableContainers.java:173"$1$"					}"
"RepeatableContainers.java:174"$0$"				}"
"RepeatableContainers.java:175"$0$"			}"
"RepeatableContainers.java:176"$0$"			return NONE;"
"RepeatableContainers.java:177"$0$"		}"
"RepeatableContainers.java:178"$0$"	}"
"RepeatableContainers.java:179"$0$""
"RepeatableContainers.java:180"$0$""
"RepeatableContainers.java:181"$0$"	/**"
"RepeatableContainers.java:182"$0$"	 * A single explicit mapping."
"RepeatableContainers.java:183"$0$"	 */"
"RepeatableContainers.java:184"$1$"	private static class ExplicitRepeatableContainer extends RepeatableContainers {"
"RepeatableContainers.java:185"$1$""
"RepeatableContainers.java:186"$1$"		private final Class<? extends Annotation> repeatable;"
"RepeatableContainers.java:187"$1$""
"RepeatableContainers.java:188"$1$"		private final Class<? extends Annotation> container;"
"RepeatableContainers.java:189"$1$""
"RepeatableContainers.java:190"$1$"		private final Method valueMethod;"
"RepeatableContainers.java:191"$1$""
"RepeatableContainers.java:192"$1$"		ExplicitRepeatableContainer(@Nullable RepeatableContainers parent,"
"RepeatableContainers.java:193"$1$"				Class<? extends Annotation> repeatable, @Nullable Class<? extends Annotation> container) {"
"RepeatableContainers.java:194"$1$""
"RepeatableContainers.java:195"$1$"			super(parent);"
"RepeatableContainers.java:196"$1$"			Assert.notNull(repeatable, ""Repeatable must not be null"");"
"RepeatableContainers.java:197"$1$"			if (container == null) {"
"RepeatableContainers.java:198"$1$"				container = deduceContainer(repeatable);"
"RepeatableContainers.java:199"$1$"			}"
"RepeatableContainers.java:200"$0$"			Method valueMethod = AttributeMethods.forAnnotationType(container).get(MergedAnnotation.VALUE);"
"RepeatableContainers.java:201"$1$"			try {"
"RepeatableContainers.java:202"$1$"				if (valueMethod == null) {"
"RepeatableContainers.java:203"$1$"					throw new NoSuchMethodException(""No value method found"");"
"RepeatableContainers.java:204"$1$"				}"
"RepeatableContainers.java:205"$0$"				Class<?> returnType = valueMethod.getReturnType();"
"RepeatableContainers.java:206"$1$"				if (!returnType.isArray() || returnType.getComponentType() != repeatable) {"
"RepeatableContainers.java:207"$1$"					throw new AnnotationConfigurationException(""Container type ["" +"
"RepeatableContainers.java:208"$1$"							container.getName() +"
"RepeatableContainers.java:209"$1$"							""] must declare a 'value' attribute for an array of type ["" +"
"RepeatableContainers.java:210"$1$"							repeatable.getName() + ""]"");"
"RepeatableContainers.java:211"$1$"				}"
"RepeatableContainers.java:212"$0$"			}"
"RepeatableContainers.java:213"$1$"			catch (AnnotationConfigurationException ex) {"
"RepeatableContainers.java:214"$1$"				throw ex;"
"RepeatableContainers.java:215"$1$"			}"
"RepeatableContainers.java:216"$1$"			catch (Throwable ex) {"
"RepeatableContainers.java:217"$1$"				throw new AnnotationConfigurationException("
"RepeatableContainers.java:218"$1$"						""Invalid declaration of container type ["" + container.getName() +"
"RepeatableContainers.java:219"$1$"								""] for repeatable annotation ["" + repeatable.getName() + ""]"","
"RepeatableContainers.java:220"$1$"						ex);"
"RepeatableContainers.java:221"$1$"			}"
"RepeatableContainers.java:222"$0$"			this.repeatable = repeatable;"
"RepeatableContainers.java:223"$0$"			this.container = container;"
"RepeatableContainers.java:224"$0$"			this.valueMethod = valueMethod;"
"RepeatableContainers.java:225"$0$"		}"
"RepeatableContainers.java:226"$0$""
"RepeatableContainers.java:227"$1$"		private Class<? extends Annotation> deduceContainer(Class<? extends Annotation> repeatable) {"
"RepeatableContainers.java:228"$1$"			Repeatable annotation = repeatable.getAnnotation(Repeatable.class);"
"RepeatableContainers.java:229"$1$"			Assert.notNull(annotation, () -> ""Annotation type must be a repeatable annotation: "" +"
"RepeatableContainers.java:230"$1$"						""failed to resolve container type for "" + repeatable.getName());"
"RepeatableContainers.java:231"$1$"			return annotation.value();"
"RepeatableContainers.java:232"$1$"		}"
"RepeatableContainers.java:233"$0$""
"RepeatableContainers.java:234"$0$"		@Override"
"RepeatableContainers.java:235"$0$"		@Nullable"
"RepeatableContainers.java:236"$1$"		Annotation[] findRepeatedAnnotations(Annotation annotation) {"
"RepeatableContainers.java:237"$1$"			if (this.container.isAssignableFrom(annotation.annotationType())) {"
"RepeatableContainers.java:238"$1$"				return (Annotation[]) ReflectionUtils.invokeMethod(this.valueMethod, annotation);"
"RepeatableContainers.java:239"$1$"			}"
"RepeatableContainers.java:240"$0$"			return super.findRepeatedAnnotations(annotation);"
"RepeatableContainers.java:241"$0$"		}"
"RepeatableContainers.java:242"$0$""
"RepeatableContainers.java:243"$0$"		@Override"
"RepeatableContainers.java:244"$1$"		public boolean equals(@Nullable Object other) {"
"RepeatableContainers.java:245"$1$"			if (!super.equals(other)) {"
"RepeatableContainers.java:246"$1$"				return false;"
"RepeatableContainers.java:247"$1$"			}"
"RepeatableContainers.java:248"$0$"			ExplicitRepeatableContainer otherErc = (ExplicitRepeatableContainer) other;"
"RepeatableContainers.java:249"$0$"			return (this.container.equals(otherErc.container) && this.repeatable.equals(otherErc.repeatable));"
"RepeatableContainers.java:250"$0$"		}"
"RepeatableContainers.java:251"$0$""
"RepeatableContainers.java:252"$0$"		@Override"
"RepeatableContainers.java:253"$1$"		public int hashCode() {"
"RepeatableContainers.java:254"$1$"			int hashCode = super.hashCode();"
"RepeatableContainers.java:255"$1$"			hashCode = 31 * hashCode + this.container.hashCode();"
"RepeatableContainers.java:256"$1$"			hashCode = 31 * hashCode + this.repeatable.hashCode();"
"RepeatableContainers.java:257"$1$"			return hashCode;"
"RepeatableContainers.java:258"$1$"		}"
"RepeatableContainers.java:259"$0$"	}"
"RepeatableContainers.java:260"$0$""
"RepeatableContainers.java:261"$0$""
"RepeatableContainers.java:262"$0$"	/**"
"RepeatableContainers.java:263"$0$"	 * No repeatable containers."
"RepeatableContainers.java:264"$0$"	 */"
"RepeatableContainers.java:265"$1$"	private static class NoRepeatableContainers extends RepeatableContainers {"
"RepeatableContainers.java:266"$1$""
"RepeatableContainers.java:267"$1$"		private static NoRepeatableContainers INSTANCE = new NoRepeatableContainers();"
"RepeatableContainers.java:268"$1$""
"RepeatableContainers.java:269"$1$"		NoRepeatableContainers() {"
"RepeatableContainers.java:270"$1$"			super(null);"
"RepeatableContainers.java:271"$1$"		}"
"RepeatableContainers.java:272"$0$"	}"
"RepeatableContainers.java:273"$0$""
"RepeatableContainers.java:274"$0$"}"
"DataBufferDecoder.java:1"$0$"/*"
"DataBufferDecoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DataBufferDecoder.java:3"$0$" *"
"DataBufferDecoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DataBufferDecoder.java:5"$0$" * you may not use this file except in compliance with the License."
"DataBufferDecoder.java:6"$0$" * You may obtain a copy of the License at"
"DataBufferDecoder.java:7"$0$" *"
"DataBufferDecoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DataBufferDecoder.java:9"$0$" *"
"DataBufferDecoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DataBufferDecoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DataBufferDecoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DataBufferDecoder.java:13"$0$" * See the License for the specific language governing permissions and"
"DataBufferDecoder.java:14"$0$" * limitations under the License."
"DataBufferDecoder.java:15"$0$" */"
"DataBufferDecoder.java:16"$0$""
"DataBufferDecoder.java:17"$0$"package org.springframework.core.codec;"
"DataBufferDecoder.java:18"$0$""
"DataBufferDecoder.java:19"$0$"import java.util.Map;"
"DataBufferDecoder.java:20"$0$""
"DataBufferDecoder.java:21"$0$"import org.reactivestreams.Publisher;"
"DataBufferDecoder.java:22"$0$"import reactor.core.publisher.Flux;"
"DataBufferDecoder.java:23"$0$""
"DataBufferDecoder.java:24"$0$"import org.springframework.core.ResolvableType;"
"DataBufferDecoder.java:25"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"DataBufferDecoder.java:26"$0$"import org.springframework.lang.Nullable;"
"DataBufferDecoder.java:27"$0$"import org.springframework.util.MimeType;"
"DataBufferDecoder.java:28"$0$"import org.springframework.util.MimeTypeUtils;"
"DataBufferDecoder.java:29"$0$""
"DataBufferDecoder.java:30"$0$"/**"
"DataBufferDecoder.java:31"$1$" * Simple pass-through decoder for {@link DataBuffer DataBuffers}."
"DataBufferDecoder.java:32"$0$" *"
"DataBufferDecoder.java:33"$0$" * <p><strong>Note:</strong> The data buffers should be released via"
"DataBufferDecoder.java:34"$1$" * {@link org.springframework.core.io.buffer.DataBufferUtils#release(DataBuffer)}"
"DataBufferDecoder.java:35"$1$" * after they have been consumed. In addition, if using {@code Flux} or"
"DataBufferDecoder.java:36"$1$" * {@code Mono} operators such as flatMap, reduce, and others that prefetch,"
"DataBufferDecoder.java:37"$0$" * cache, and skip or filter out data items internally, please add"
"DataBufferDecoder.java:38"$1$" * {@code doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release)} to the"
"DataBufferDecoder.java:39"$0$" * composition chain to ensure cached data buffers are released prior to an"
"DataBufferDecoder.java:40"$0$" * error or cancellation signal."
"DataBufferDecoder.java:41"$0$" *"
"DataBufferDecoder.java:42"$0$" * @author Arjen Poutsma"
"DataBufferDecoder.java:43"$0$" * @author Rossen Stoyanchev"
"DataBufferDecoder.java:44"$0$" * @since 5.0"
"DataBufferDecoder.java:45"$0$" */"
"DataBufferDecoder.java:46"$1$"public class DataBufferDecoder extends AbstractDataBufferDecoder<DataBuffer> {"
"DataBufferDecoder.java:47"$1$""
"DataBufferDecoder.java:48"$1$"	public DataBufferDecoder() {"
"DataBufferDecoder.java:49"$1$"		super(MimeTypeUtils.ALL);"
"DataBufferDecoder.java:50"$1$"	}"
"DataBufferDecoder.java:51"$0$""
"DataBufferDecoder.java:52"$0$""
"DataBufferDecoder.java:53"$0$"	@Override"
"DataBufferDecoder.java:54"$1$"	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"DataBufferDecoder.java:55"$1$"		return (DataBuffer.class.isAssignableFrom(elementType.toClass()) &&"
"DataBufferDecoder.java:56"$1$"				super.canDecode(elementType, mimeType));"
"DataBufferDecoder.java:57"$1$"	}"
"DataBufferDecoder.java:58"$0$""
"DataBufferDecoder.java:59"$0$"	@Override"
"DataBufferDecoder.java:60"$0$"	public Flux<DataBuffer> decode(Publisher<DataBuffer> input, ResolvableType elementType,"
"DataBufferDecoder.java:61"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"DataBufferDecoder.java:62"$1$""
"DataBufferDecoder.java:63"$1$"		return Flux.from(input);"
"DataBufferDecoder.java:64"$1$"	}"
"DataBufferDecoder.java:65"$0$""
"DataBufferDecoder.java:66"$0$"	@Override"
"DataBufferDecoder.java:67"$0$"	public DataBuffer decode(DataBuffer buffer, ResolvableType elementType,"
"DataBufferDecoder.java:68"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"DataBufferDecoder.java:69"$1$""
"DataBufferDecoder.java:70"$1$"		if (logger.isDebugEnabled()) {"
"DataBufferDecoder.java:71"$1$"			logger.debug(Hints.getLogPrefix(hints) + ""Read "" + buffer.readableByteCount() + "" bytes"");"
"DataBufferDecoder.java:72"$1$"		}"
"DataBufferDecoder.java:73"$0$"		return buffer;"
"DataBufferDecoder.java:74"$0$"	}"
"DataBufferDecoder.java:75"$0$""
"DataBufferDecoder.java:76"$0$"}"
"SimpleAnnotationMetadata.java:1"$0$"/*"
"SimpleAnnotationMetadata.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SimpleAnnotationMetadata.java:3"$0$" *"
"SimpleAnnotationMetadata.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleAnnotationMetadata.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleAnnotationMetadata.java:6"$0$" * You may obtain a copy of the License at"
"SimpleAnnotationMetadata.java:7"$0$" *"
"SimpleAnnotationMetadata.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleAnnotationMetadata.java:9"$0$" *"
"SimpleAnnotationMetadata.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleAnnotationMetadata.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleAnnotationMetadata.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleAnnotationMetadata.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleAnnotationMetadata.java:14"$0$" * limitations under the License."
"SimpleAnnotationMetadata.java:15"$0$" */"
"SimpleAnnotationMetadata.java:16"$0$""
"SimpleAnnotationMetadata.java:17"$0$"package org.springframework.core.type.classreading;"
"SimpleAnnotationMetadata.java:18"$0$""
"SimpleAnnotationMetadata.java:19"$0$"import java.util.Collections;"
"SimpleAnnotationMetadata.java:20"$0$"import java.util.LinkedHashSet;"
"SimpleAnnotationMetadata.java:21"$0$"import java.util.Set;"
"SimpleAnnotationMetadata.java:22"$0$""
"SimpleAnnotationMetadata.java:23"$0$"import org.springframework.asm.Opcodes;"
"SimpleAnnotationMetadata.java:24"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"SimpleAnnotationMetadata.java:25"$0$"import org.springframework.core.type.AnnotationMetadata;"
"SimpleAnnotationMetadata.java:26"$0$"import org.springframework.core.type.MethodMetadata;"
"SimpleAnnotationMetadata.java:27"$0$"import org.springframework.lang.Nullable;"
"SimpleAnnotationMetadata.java:28"$0$""
"SimpleAnnotationMetadata.java:29"$0$"/**"
"SimpleAnnotationMetadata.java:30"$1$" * {@link AnnotationMetadata} created from a"
"SimpleAnnotationMetadata.java:31"$1$" * {@link SimpleAnnotationMetadataReadingVisitor}."
"SimpleAnnotationMetadata.java:32"$0$" *"
"SimpleAnnotationMetadata.java:33"$0$" * @author Phillip Webb"
"SimpleAnnotationMetadata.java:34"$0$" * @since 5.2"
"SimpleAnnotationMetadata.java:35"$0$" */"
"SimpleAnnotationMetadata.java:36"$1$"final class SimpleAnnotationMetadata implements AnnotationMetadata {"
"SimpleAnnotationMetadata.java:37"$1$""
"SimpleAnnotationMetadata.java:38"$1$"	private final String className;"
"SimpleAnnotationMetadata.java:39"$1$""
"SimpleAnnotationMetadata.java:40"$1$"	private final int access;"
"SimpleAnnotationMetadata.java:41"$1$""
"SimpleAnnotationMetadata.java:42"$1$"	@Nullable"
"SimpleAnnotationMetadata.java:43"$1$"	private final String enclosingClassName;"
"SimpleAnnotationMetadata.java:44"$1$""
"SimpleAnnotationMetadata.java:45"$1$"	@Nullable"
"SimpleAnnotationMetadata.java:46"$1$"	private final String superClassName;"
"SimpleAnnotationMetadata.java:47"$1$""
"SimpleAnnotationMetadata.java:48"$1$"	private final boolean independentInnerClass;"
"SimpleAnnotationMetadata.java:49"$1$""
"SimpleAnnotationMetadata.java:50"$1$"	private final String[] interfaceNames;"
"SimpleAnnotationMetadata.java:51"$1$""
"SimpleAnnotationMetadata.java:52"$1$"	private final String[] memberClassNames;"
"SimpleAnnotationMetadata.java:53"$1$""
"SimpleAnnotationMetadata.java:54"$1$"	private final MethodMetadata[] annotatedMethods;"
"SimpleAnnotationMetadata.java:55"$1$""
"SimpleAnnotationMetadata.java:56"$1$"	private final MergedAnnotations annotations;"
"SimpleAnnotationMetadata.java:57"$1$""
"SimpleAnnotationMetadata.java:58"$1$"	@Nullable"
"SimpleAnnotationMetadata.java:59"$1$"	private Set<String> annotationTypes;"
"SimpleAnnotationMetadata.java:60"$1$""
"SimpleAnnotationMetadata.java:61"$1$""
"SimpleAnnotationMetadata.java:62"$1$"	SimpleAnnotationMetadata(String className, int access, @Nullable String enclosingClassName,"
"SimpleAnnotationMetadata.java:63"$1$"			@Nullable String superClassName, boolean independentInnerClass, String[] interfaceNames,"
"SimpleAnnotationMetadata.java:64"$1$"			String[] memberClassNames, MethodMetadata[] annotatedMethods, MergedAnnotations annotations) {"
"SimpleAnnotationMetadata.java:65"$1$""
"SimpleAnnotationMetadata.java:66"$1$"		this.className = className;"
"SimpleAnnotationMetadata.java:67"$1$"		this.access = access;"
"SimpleAnnotationMetadata.java:68"$1$"		this.enclosingClassName = enclosingClassName;"
"SimpleAnnotationMetadata.java:69"$1$"		this.superClassName = superClassName;"
"SimpleAnnotationMetadata.java:70"$1$"		this.independentInnerClass = independentInnerClass;"
"SimpleAnnotationMetadata.java:71"$1$"		this.interfaceNames = interfaceNames;"
"SimpleAnnotationMetadata.java:72"$1$"		this.memberClassNames = memberClassNames;"
"SimpleAnnotationMetadata.java:73"$1$"		this.annotatedMethods = annotatedMethods;"
"SimpleAnnotationMetadata.java:74"$1$"		this.annotations = annotations;"
"SimpleAnnotationMetadata.java:75"$1$"	}"
"SimpleAnnotationMetadata.java:76"$0$""
"SimpleAnnotationMetadata.java:77"$0$"	@Override"
"SimpleAnnotationMetadata.java:78"$1$"	public String getClassName() {"
"SimpleAnnotationMetadata.java:79"$1$"		return this.className;"
"SimpleAnnotationMetadata.java:80"$1$"	}"
"SimpleAnnotationMetadata.java:81"$0$""
"SimpleAnnotationMetadata.java:82"$0$"	@Override"
"SimpleAnnotationMetadata.java:83"$1$"	public boolean isInterface() {"
"SimpleAnnotationMetadata.java:84"$1$"		return (this.access & Opcodes.ACC_INTERFACE) != 0;"
"SimpleAnnotationMetadata.java:85"$1$"	}"
"SimpleAnnotationMetadata.java:86"$0$""
"SimpleAnnotationMetadata.java:87"$0$"	@Override"
"SimpleAnnotationMetadata.java:88"$1$"	public boolean isAnnotation() {"
"SimpleAnnotationMetadata.java:89"$1$"		return (this.access & Opcodes.ACC_ANNOTATION) != 0;"
"SimpleAnnotationMetadata.java:90"$1$"	}"
"SimpleAnnotationMetadata.java:91"$0$""
"SimpleAnnotationMetadata.java:92"$0$"	@Override"
"SimpleAnnotationMetadata.java:93"$1$"	public boolean isAbstract() {"
"SimpleAnnotationMetadata.java:94"$1$"		return (this.access & Opcodes.ACC_ABSTRACT) != 0;"
"SimpleAnnotationMetadata.java:95"$1$"	}"
"SimpleAnnotationMetadata.java:96"$0$""
"SimpleAnnotationMetadata.java:97"$0$"	@Override"
"SimpleAnnotationMetadata.java:98"$1$"	public boolean isFinal() {"
"SimpleAnnotationMetadata.java:99"$1$"		return (this.access & Opcodes.ACC_FINAL) != 0;"
"SimpleAnnotationMetadata.java:100"$1$"	}"
"SimpleAnnotationMetadata.java:101"$0$""
"SimpleAnnotationMetadata.java:102"$0$"	@Override"
"SimpleAnnotationMetadata.java:103"$1$"	public boolean isIndependent() {"
"SimpleAnnotationMetadata.java:104"$1$"		return (this.enclosingClassName == null || this.independentInnerClass);"
"SimpleAnnotationMetadata.java:105"$1$"	}"
"SimpleAnnotationMetadata.java:106"$0$""
"SimpleAnnotationMetadata.java:107"$0$"	@Override"
"SimpleAnnotationMetadata.java:108"$0$"	@Nullable"
"SimpleAnnotationMetadata.java:109"$1$"	public String getEnclosingClassName() {"
"SimpleAnnotationMetadata.java:110"$1$"		return this.enclosingClassName;"
"SimpleAnnotationMetadata.java:111"$1$"	}"
"SimpleAnnotationMetadata.java:112"$0$""
"SimpleAnnotationMetadata.java:113"$0$"	@Override"
"SimpleAnnotationMetadata.java:114"$0$"	@Nullable"
"SimpleAnnotationMetadata.java:115"$1$"	public String getSuperClassName() {"
"SimpleAnnotationMetadata.java:116"$1$"		return this.superClassName;"
"SimpleAnnotationMetadata.java:117"$1$"	}"
"SimpleAnnotationMetadata.java:118"$0$""
"SimpleAnnotationMetadata.java:119"$0$"	@Override"
"SimpleAnnotationMetadata.java:120"$1$"	public String[] getInterfaceNames() {"
"SimpleAnnotationMetadata.java:121"$1$"		return this.interfaceNames.clone();"
"SimpleAnnotationMetadata.java:122"$1$"	}"
"SimpleAnnotationMetadata.java:123"$0$""
"SimpleAnnotationMetadata.java:124"$0$"	@Override"
"SimpleAnnotationMetadata.java:125"$1$"	public String[] getMemberClassNames() {"
"SimpleAnnotationMetadata.java:126"$1$"		return this.memberClassNames.clone();"
"SimpleAnnotationMetadata.java:127"$1$"	}"
"SimpleAnnotationMetadata.java:128"$0$""
"SimpleAnnotationMetadata.java:129"$0$"	@Override"
"SimpleAnnotationMetadata.java:130"$1$"	public Set<String> getAnnotationTypes() {"
"SimpleAnnotationMetadata.java:131"$1$"		Set<String> annotationTypes = this.annotationTypes;"
"SimpleAnnotationMetadata.java:132"$1$"		if (annotationTypes == null) {"
"SimpleAnnotationMetadata.java:133"$1$"			annotationTypes = Collections.unmodifiableSet("
"SimpleAnnotationMetadata.java:134"$1$"					AnnotationMetadata.super.getAnnotationTypes());"
"SimpleAnnotationMetadata.java:135"$1$"			this.annotationTypes = annotationTypes;"
"SimpleAnnotationMetadata.java:136"$1$"		}"
"SimpleAnnotationMetadata.java:137"$0$"		return annotationTypes;"
"SimpleAnnotationMetadata.java:138"$0$"	}"
"SimpleAnnotationMetadata.java:139"$0$""
"SimpleAnnotationMetadata.java:140"$0$"	@Override"
"SimpleAnnotationMetadata.java:141"$1$"	public Set<MethodMetadata> getAnnotatedMethods(String annotationName) {"
"SimpleAnnotationMetadata.java:142"$1$"		Set<MethodMetadata> annotatedMethods = null;"
"SimpleAnnotationMetadata.java:143"$1$"		for (int i = 0; i < this.annotatedMethods.length; i++) {"
"SimpleAnnotationMetadata.java:144"$1$"			if (this.annotatedMethods[i].isAnnotated(annotationName)) {"
"SimpleAnnotationMetadata.java:145"$1$"				if (annotatedMethods == null) {"
"SimpleAnnotationMetadata.java:146"$1$"					annotatedMethods = new LinkedHashSet<>(4);"
"SimpleAnnotationMetadata.java:147"$1$"				}"
"SimpleAnnotationMetadata.java:148"$0$"				annotatedMethods.add(this.annotatedMethods[i]);"
"SimpleAnnotationMetadata.java:149"$0$"			}"
"SimpleAnnotationMetadata.java:150"$0$"		}"
"SimpleAnnotationMetadata.java:151"$0$"		return annotatedMethods != null ? annotatedMethods : Collections.emptySet();"
"SimpleAnnotationMetadata.java:152"$0$"	}"
"SimpleAnnotationMetadata.java:153"$0$""
"SimpleAnnotationMetadata.java:154"$0$"	@Override"
"SimpleAnnotationMetadata.java:155"$1$"	public MergedAnnotations getAnnotations() {"
"SimpleAnnotationMetadata.java:156"$1$"		return this.annotations;"
"SimpleAnnotationMetadata.java:157"$1$"	}"
"SimpleAnnotationMetadata.java:158"$0$""
"SimpleAnnotationMetadata.java:159"$0$"}"
"MissingMergedAnnotation.java:1"$0$"/*"
"MissingMergedAnnotation.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MissingMergedAnnotation.java:3"$0$" *"
"MissingMergedAnnotation.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MissingMergedAnnotation.java:5"$0$" * you may not use this file except in compliance with the License."
"MissingMergedAnnotation.java:6"$0$" * You may obtain a copy of the License at"
"MissingMergedAnnotation.java:7"$0$" *"
"MissingMergedAnnotation.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MissingMergedAnnotation.java:9"$0$" *"
"MissingMergedAnnotation.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MissingMergedAnnotation.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MissingMergedAnnotation.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MissingMergedAnnotation.java:13"$0$" * See the License for the specific language governing permissions and"
"MissingMergedAnnotation.java:14"$0$" * limitations under the License."
"MissingMergedAnnotation.java:15"$0$" */"
"MissingMergedAnnotation.java:16"$0$""
"MissingMergedAnnotation.java:17"$0$"package org.springframework.core.annotation;"
"MissingMergedAnnotation.java:18"$0$""
"MissingMergedAnnotation.java:19"$0$"import java.lang.annotation.Annotation;"
"MissingMergedAnnotation.java:20"$0$"import java.util.Collections;"
"MissingMergedAnnotation.java:21"$0$"import java.util.List;"
"MissingMergedAnnotation.java:22"$0$"import java.util.Map;"
"MissingMergedAnnotation.java:23"$0$"import java.util.NoSuchElementException;"
"MissingMergedAnnotation.java:24"$0$"import java.util.Optional;"
"MissingMergedAnnotation.java:25"$0$"import java.util.function.Function;"
"MissingMergedAnnotation.java:26"$0$"import java.util.function.Predicate;"
"MissingMergedAnnotation.java:27"$0$""
"MissingMergedAnnotation.java:28"$0$"import org.springframework.lang.Nullable;"
"MissingMergedAnnotation.java:29"$0$""
"MissingMergedAnnotation.java:30"$0$"/**"
"MissingMergedAnnotation.java:31"$1$" * An {@link AbstractMergedAnnotation} used as the implementation of"
"MissingMergedAnnotation.java:32"$1$" * {@link MergedAnnotation#missing()}."
"MissingMergedAnnotation.java:33"$0$" *"
"MissingMergedAnnotation.java:34"$0$" * @author Phillip Webb"
"MissingMergedAnnotation.java:35"$0$" * @author Juergen Hoeller"
"MissingMergedAnnotation.java:36"$0$" * @since 5.2"
"MissingMergedAnnotation.java:37"$0$" * @param <A> the annotation type"
"MissingMergedAnnotation.java:38"$0$" */"
"MissingMergedAnnotation.java:39"$1$"final class MissingMergedAnnotation<A extends Annotation> extends AbstractMergedAnnotation<A> {"
"MissingMergedAnnotation.java:40"$1$""
"MissingMergedAnnotation.java:41"$1$"	private static final MissingMergedAnnotation<?> INSTANCE = new MissingMergedAnnotation<>();"
"MissingMergedAnnotation.java:42"$1$""
"MissingMergedAnnotation.java:43"$1$""
"MissingMergedAnnotation.java:44"$1$"	private MissingMergedAnnotation() {"
"MissingMergedAnnotation.java:45"$1$"	}"
"MissingMergedAnnotation.java:46"$0$""
"MissingMergedAnnotation.java:47"$0$""
"MissingMergedAnnotation.java:48"$0$"	@Override"
"MissingMergedAnnotation.java:49"$1$"	public Class<A> getType() {"
"MissingMergedAnnotation.java:50"$1$"		throw new NoSuchElementException(""Unable to get type for missing annotation"");"
"MissingMergedAnnotation.java:51"$1$"	}"
"MissingMergedAnnotation.java:52"$0$""
"MissingMergedAnnotation.java:53"$0$"	@Override"
"MissingMergedAnnotation.java:54"$1$"	public boolean isPresent() {"
"MissingMergedAnnotation.java:55"$1$"		return false;"
"MissingMergedAnnotation.java:56"$1$"	}"
"MissingMergedAnnotation.java:57"$0$""
"MissingMergedAnnotation.java:58"$0$"	@Override"
"MissingMergedAnnotation.java:59"$0$"	@Nullable"
"MissingMergedAnnotation.java:60"$1$"	public Object getSource() {"
"MissingMergedAnnotation.java:61"$1$"		return null;"
"MissingMergedAnnotation.java:62"$1$"	}"
"MissingMergedAnnotation.java:63"$0$""
"MissingMergedAnnotation.java:64"$0$"	@Override"
"MissingMergedAnnotation.java:65"$0$"	@Nullable"
"MissingMergedAnnotation.java:66"$1$"	public MergedAnnotation<?> getMetaSource() {"
"MissingMergedAnnotation.java:67"$1$"		return null;"
"MissingMergedAnnotation.java:68"$1$"	}"
"MissingMergedAnnotation.java:69"$0$""
"MissingMergedAnnotation.java:70"$0$"	@Override"
"MissingMergedAnnotation.java:71"$1$"	public MergedAnnotation<?> getRoot() {"
"MissingMergedAnnotation.java:72"$1$"		return this;"
"MissingMergedAnnotation.java:73"$1$"	}"
"MissingMergedAnnotation.java:74"$0$""
"MissingMergedAnnotation.java:75"$0$"	@Override"
"MissingMergedAnnotation.java:76"$1$"	public List<Class<? extends Annotation>> getMetaTypes() {"
"MissingMergedAnnotation.java:77"$1$"		return Collections.emptyList();"
"MissingMergedAnnotation.java:78"$1$"	}"
"MissingMergedAnnotation.java:79"$0$""
"MissingMergedAnnotation.java:80"$0$"	@Override"
"MissingMergedAnnotation.java:81"$1$"	public int getDistance() {"
"MissingMergedAnnotation.java:82"$1$"		return -1;"
"MissingMergedAnnotation.java:83"$1$"	}"
"MissingMergedAnnotation.java:84"$0$""
"MissingMergedAnnotation.java:85"$0$"	@Override"
"MissingMergedAnnotation.java:86"$1$"	public int getAggregateIndex() {"
"MissingMergedAnnotation.java:87"$1$"		return -1;"
"MissingMergedAnnotation.java:88"$1$"	}"
"MissingMergedAnnotation.java:89"$0$""
"MissingMergedAnnotation.java:90"$0$"	@Override"
"MissingMergedAnnotation.java:91"$1$"	public boolean hasNonDefaultValue(String attributeName) {"
"MissingMergedAnnotation.java:92"$1$"		throw new NoSuchElementException("
"MissingMergedAnnotation.java:93"$1$"				""Unable to check non-default value for missing annotation"");"
"MissingMergedAnnotation.java:94"$1$"	}"
"MissingMergedAnnotation.java:95"$0$""
"MissingMergedAnnotation.java:96"$0$"	@Override"
"MissingMergedAnnotation.java:97"$1$"	public boolean hasDefaultValue(String attributeName) {"
"MissingMergedAnnotation.java:98"$1$"		throw new NoSuchElementException("
"MissingMergedAnnotation.java:99"$1$"				""Unable to check default value for missing annotation"");"
"MissingMergedAnnotation.java:100"$1$"	}"
"MissingMergedAnnotation.java:101"$0$""
"MissingMergedAnnotation.java:102"$0$"	@Override"
"MissingMergedAnnotation.java:103"$1$"	public <T> Optional<T> getValue(String attributeName, Class<T> type) {"
"MissingMergedAnnotation.java:104"$1$"		return Optional.empty();"
"MissingMergedAnnotation.java:105"$1$"	}"
"MissingMergedAnnotation.java:106"$0$""
"MissingMergedAnnotation.java:107"$0$"	@Override"
"MissingMergedAnnotation.java:108"$1$"	public <T> Optional<T> getDefaultValue(@Nullable String attributeName, Class<T> type) {"
"MissingMergedAnnotation.java:109"$1$"		return Optional.empty();"
"MissingMergedAnnotation.java:110"$1$"	}"
"MissingMergedAnnotation.java:111"$0$""
"MissingMergedAnnotation.java:112"$0$"	@Override"
"MissingMergedAnnotation.java:113"$1$"	public MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {"
"MissingMergedAnnotation.java:114"$1$"		return this;"
"MissingMergedAnnotation.java:115"$1$"	}"
"MissingMergedAnnotation.java:116"$0$""
"MissingMergedAnnotation.java:117"$0$"	@Override"
"MissingMergedAnnotation.java:118"$1$"	public MergedAnnotation<A> withNonMergedAttributes() {"
"MissingMergedAnnotation.java:119"$1$"		return this;"
"MissingMergedAnnotation.java:120"$1$"	}"
"MissingMergedAnnotation.java:121"$0$""
"MissingMergedAnnotation.java:122"$0$"	@Override"
"MissingMergedAnnotation.java:123"$1$"	public AnnotationAttributes asAnnotationAttributes(Adapt... adaptations) {"
"MissingMergedAnnotation.java:124"$1$"		return new AnnotationAttributes();"
"MissingMergedAnnotation.java:125"$1$"	}"
"MissingMergedAnnotation.java:126"$0$""
"MissingMergedAnnotation.java:127"$0$"	@Override"
"MissingMergedAnnotation.java:128"$1$"	public Map<String, Object> asMap(Adapt... adaptations) {"
"MissingMergedAnnotation.java:129"$1$"		return Collections.emptyMap();"
"MissingMergedAnnotation.java:130"$1$"	}"
"MissingMergedAnnotation.java:131"$0$""
"MissingMergedAnnotation.java:132"$0$"	@Override"
"MissingMergedAnnotation.java:133"$1$"	public <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {"
"MissingMergedAnnotation.java:134"$1$"		return factory.apply(this);"
"MissingMergedAnnotation.java:135"$1$"	}"
"MissingMergedAnnotation.java:136"$0$""
"MissingMergedAnnotation.java:137"$0$"	@Override"
"MissingMergedAnnotation.java:138"$1$"	public String toString() {"
"MissingMergedAnnotation.java:139"$1$"		return ""(missing)"";"
"MissingMergedAnnotation.java:140"$1$"	}"
"MissingMergedAnnotation.java:141"$0$""
"MissingMergedAnnotation.java:142"$0$"	@Override"
"MissingMergedAnnotation.java:143"$0$"	public <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName,"
"MissingMergedAnnotation.java:144"$1$"			Class<T> type) throws NoSuchElementException {"
"MissingMergedAnnotation.java:145"$1$""
"MissingMergedAnnotation.java:146"$1$"		throw new NoSuchElementException("
"MissingMergedAnnotation.java:147"$1$"				""Unable to get attribute value for missing annotation"");"
"MissingMergedAnnotation.java:148"$1$"	}"
"MissingMergedAnnotation.java:149"$0$""
"MissingMergedAnnotation.java:150"$0$"	@Override"
"MissingMergedAnnotation.java:151"$0$"	public <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray("
"MissingMergedAnnotation.java:152"$1$"			String attributeName, Class<T> type) throws NoSuchElementException {"
"MissingMergedAnnotation.java:153"$1$""
"MissingMergedAnnotation.java:154"$1$"		throw new NoSuchElementException("
"MissingMergedAnnotation.java:155"$1$"				""Unable to get attribute value for missing annotation"");"
"MissingMergedAnnotation.java:156"$1$"	}"
"MissingMergedAnnotation.java:157"$0$""
"MissingMergedAnnotation.java:158"$0$"	@Override"
"MissingMergedAnnotation.java:159"$1$"	protected <T> T getAttributeValue(String attributeName, Class<T> type) {"
"MissingMergedAnnotation.java:160"$1$"		throw new NoSuchElementException("
"MissingMergedAnnotation.java:161"$1$"				""Unable to get attribute value for missing annotation"");"
"MissingMergedAnnotation.java:162"$1$"	}"
"MissingMergedAnnotation.java:163"$0$""
"MissingMergedAnnotation.java:164"$0$"	@Override"
"MissingMergedAnnotation.java:165"$1$"	protected A createSynthesized() {"
"MissingMergedAnnotation.java:166"$1$"		throw new NoSuchElementException(""Unable to synthesize missing annotation"");"
"MissingMergedAnnotation.java:167"$1$"	}"
"MissingMergedAnnotation.java:168"$0$""
"MissingMergedAnnotation.java:169"$0$""
"MissingMergedAnnotation.java:170"$0$"	@SuppressWarnings(""unchecked"")"
"MissingMergedAnnotation.java:171"$1$"	static <A extends Annotation> MergedAnnotation<A> getInstance() {"
"MissingMergedAnnotation.java:172"$1$"		return (MergedAnnotation<A>) INSTANCE;"
"MissingMergedAnnotation.java:173"$1$"	}"
"MissingMergedAnnotation.java:174"$0$""
"MissingMergedAnnotation.java:175"$0$"}"
"PrioritizedParameterNameDiscoverer.java:1"$0$"/*"
"PrioritizedParameterNameDiscoverer.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"PrioritizedParameterNameDiscoverer.java:3"$0$" *"
"PrioritizedParameterNameDiscoverer.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PrioritizedParameterNameDiscoverer.java:5"$0$" * you may not use this file except in compliance with the License."
"PrioritizedParameterNameDiscoverer.java:6"$0$" * You may obtain a copy of the License at"
"PrioritizedParameterNameDiscoverer.java:7"$0$" *"
"PrioritizedParameterNameDiscoverer.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PrioritizedParameterNameDiscoverer.java:9"$0$" *"
"PrioritizedParameterNameDiscoverer.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PrioritizedParameterNameDiscoverer.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PrioritizedParameterNameDiscoverer.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PrioritizedParameterNameDiscoverer.java:13"$0$" * See the License for the specific language governing permissions and"
"PrioritizedParameterNameDiscoverer.java:14"$0$" * limitations under the License."
"PrioritizedParameterNameDiscoverer.java:15"$0$" */"
"PrioritizedParameterNameDiscoverer.java:16"$0$""
"PrioritizedParameterNameDiscoverer.java:17"$0$"package org.springframework.core;"
"PrioritizedParameterNameDiscoverer.java:18"$0$""
"PrioritizedParameterNameDiscoverer.java:19"$0$"import java.lang.reflect.Constructor;"
"PrioritizedParameterNameDiscoverer.java:20"$0$"import java.lang.reflect.Method;"
"PrioritizedParameterNameDiscoverer.java:21"$0$"import java.util.LinkedList;"
"PrioritizedParameterNameDiscoverer.java:22"$0$"import java.util.List;"
"PrioritizedParameterNameDiscoverer.java:23"$0$""
"PrioritizedParameterNameDiscoverer.java:24"$0$"import org.springframework.lang.Nullable;"
"PrioritizedParameterNameDiscoverer.java:25"$0$""
"PrioritizedParameterNameDiscoverer.java:26"$0$"/**"
"PrioritizedParameterNameDiscoverer.java:27"$1$" * {@link ParameterNameDiscoverer} implementation that tries several discoverer"
"PrioritizedParameterNameDiscoverer.java:28"$1$" * delegates in succession. Those added first in the {@code addDiscoverer} method"
"PrioritizedParameterNameDiscoverer.java:29"$1$" * have highest priority. If one returns {@code null}, the next will be tried."
"PrioritizedParameterNameDiscoverer.java:30"$0$" *"
"PrioritizedParameterNameDiscoverer.java:31"$1$" * <p>The default behavior is to return {@code null} if no discoverer matches."
"PrioritizedParameterNameDiscoverer.java:32"$0$" *"
"PrioritizedParameterNameDiscoverer.java:33"$0$" * @author Rod Johnson"
"PrioritizedParameterNameDiscoverer.java:34"$0$" * @author Juergen Hoeller"
"PrioritizedParameterNameDiscoverer.java:35"$0$" * @since 2.0"
"PrioritizedParameterNameDiscoverer.java:36"$0$" */"
"PrioritizedParameterNameDiscoverer.java:37"$1$"public class PrioritizedParameterNameDiscoverer implements ParameterNameDiscoverer {"
"PrioritizedParameterNameDiscoverer.java:38"$1$""
"PrioritizedParameterNameDiscoverer.java:39"$1$"	private final List<ParameterNameDiscoverer> parameterNameDiscoverers = new LinkedList<>();"
"PrioritizedParameterNameDiscoverer.java:40"$1$""
"PrioritizedParameterNameDiscoverer.java:41"$1$""
"PrioritizedParameterNameDiscoverer.java:42"$1$"	/**"
"PrioritizedParameterNameDiscoverer.java:43"$1$"	 * Add a further {@link ParameterNameDiscoverer} delegate to the list of"
"PrioritizedParameterNameDiscoverer.java:44"$1$"	 * discoverers that this {@code PrioritizedParameterNameDiscoverer} checks."
"PrioritizedParameterNameDiscoverer.java:45"$1$"	 */"
"PrioritizedParameterNameDiscoverer.java:46"$1$"	public void addDiscoverer(ParameterNameDiscoverer pnd) {"
"PrioritizedParameterNameDiscoverer.java:47"$1$"		this.parameterNameDiscoverers.add(pnd);"
"PrioritizedParameterNameDiscoverer.java:48"$1$"	}"
"PrioritizedParameterNameDiscoverer.java:49"$0$""
"PrioritizedParameterNameDiscoverer.java:50"$0$""
"PrioritizedParameterNameDiscoverer.java:51"$0$"	@Override"
"PrioritizedParameterNameDiscoverer.java:52"$0$"	@Nullable"
"PrioritizedParameterNameDiscoverer.java:53"$1$"	public String[] getParameterNames(Method method) {"
"PrioritizedParameterNameDiscoverer.java:54"$1$"		for (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {"
"PrioritizedParameterNameDiscoverer.java:55"$1$"			String[] result = pnd.getParameterNames(method);"
"PrioritizedParameterNameDiscoverer.java:56"$1$"			if (result != null) {"
"PrioritizedParameterNameDiscoverer.java:57"$1$"				return result;"
"PrioritizedParameterNameDiscoverer.java:58"$1$"			}"
"PrioritizedParameterNameDiscoverer.java:59"$0$"		}"
"PrioritizedParameterNameDiscoverer.java:60"$0$"		return null;"
"PrioritizedParameterNameDiscoverer.java:61"$0$"	}"
"PrioritizedParameterNameDiscoverer.java:62"$0$""
"PrioritizedParameterNameDiscoverer.java:63"$0$"	@Override"
"PrioritizedParameterNameDiscoverer.java:64"$0$"	@Nullable"
"PrioritizedParameterNameDiscoverer.java:65"$1$"	public String[] getParameterNames(Constructor<?> ctor) {"
"PrioritizedParameterNameDiscoverer.java:66"$1$"		for (ParameterNameDiscoverer pnd : this.parameterNameDiscoverers) {"
"PrioritizedParameterNameDiscoverer.java:67"$1$"			String[] result = pnd.getParameterNames(ctor);"
"PrioritizedParameterNameDiscoverer.java:68"$1$"			if (result != null) {"
"PrioritizedParameterNameDiscoverer.java:69"$1$"				return result;"
"PrioritizedParameterNameDiscoverer.java:70"$1$"			}"
"PrioritizedParameterNameDiscoverer.java:71"$0$"		}"
"PrioritizedParameterNameDiscoverer.java:72"$0$"		return null;"
"PrioritizedParameterNameDiscoverer.java:73"$0$"	}"
"PrioritizedParameterNameDiscoverer.java:74"$0$""
"PrioritizedParameterNameDiscoverer.java:75"$0$"}"
"MergedAnnotationPredicates.java:1"$0$"/*"
"MergedAnnotationPredicates.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MergedAnnotationPredicates.java:3"$0$" *"
"MergedAnnotationPredicates.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MergedAnnotationPredicates.java:5"$0$" * you may not use this file except in compliance with the License."
"MergedAnnotationPredicates.java:6"$0$" * You may obtain a copy of the License at"
"MergedAnnotationPredicates.java:7"$0$" *"
"MergedAnnotationPredicates.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MergedAnnotationPredicates.java:9"$0$" *"
"MergedAnnotationPredicates.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MergedAnnotationPredicates.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MergedAnnotationPredicates.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MergedAnnotationPredicates.java:13"$0$" * See the License for the specific language governing permissions and"
"MergedAnnotationPredicates.java:14"$0$" * limitations under the License."
"MergedAnnotationPredicates.java:15"$0$" */"
"MergedAnnotationPredicates.java:16"$0$""
"MergedAnnotationPredicates.java:17"$0$"package org.springframework.core.annotation;"
"MergedAnnotationPredicates.java:18"$0$""
"MergedAnnotationPredicates.java:19"$0$"import java.lang.annotation.Annotation;"
"MergedAnnotationPredicates.java:20"$0$"import java.util.Collection;"
"MergedAnnotationPredicates.java:21"$0$"import java.util.HashSet;"
"MergedAnnotationPredicates.java:22"$0$"import java.util.Set;"
"MergedAnnotationPredicates.java:23"$0$"import java.util.function.Function;"
"MergedAnnotationPredicates.java:24"$0$"import java.util.function.Predicate;"
"MergedAnnotationPredicates.java:25"$0$""
"MergedAnnotationPredicates.java:26"$0$"import org.springframework.lang.Nullable;"
"MergedAnnotationPredicates.java:27"$0$"import org.springframework.util.Assert;"
"MergedAnnotationPredicates.java:28"$0$"import org.springframework.util.ObjectUtils;"
"MergedAnnotationPredicates.java:29"$0$""
"MergedAnnotationPredicates.java:30"$0$"/**"
"MergedAnnotationPredicates.java:31"$0$" * Predicate implementations that provide various test operations for"
"MergedAnnotationPredicates.java:32"$1$" * {@link MergedAnnotation MergedAnnotations}."
"MergedAnnotationPredicates.java:33"$0$" *"
"MergedAnnotationPredicates.java:34"$0$" * @author Phillip Webb"
"MergedAnnotationPredicates.java:35"$0$" * @since 5.2"
"MergedAnnotationPredicates.java:36"$0$" */"
"MergedAnnotationPredicates.java:37"$1$"public abstract class MergedAnnotationPredicates {"
"MergedAnnotationPredicates.java:38"$1$""
"MergedAnnotationPredicates.java:39"$1$"	private MergedAnnotationPredicates() {"
"MergedAnnotationPredicates.java:40"$1$"	}"
"MergedAnnotationPredicates.java:41"$0$""
"MergedAnnotationPredicates.java:42"$0$""
"MergedAnnotationPredicates.java:43"$0$"	/**"
"MergedAnnotationPredicates.java:44"$1$"	 * Create a new {@link Predicate} that evaluates to {@code true} if the name of the"
"MergedAnnotationPredicates.java:45"$1$"	 * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in"
"MergedAnnotationPredicates.java:46"$0$"	 * the specified array."
"MergedAnnotationPredicates.java:47"$0$"	 * @param <A> the annotation type"
"MergedAnnotationPredicates.java:48"$0$"	 * @param typeNames the names that should be matched"
"MergedAnnotationPredicates.java:49"$1$"	 * @return a {@link Predicate} to test the annotation type"
"MergedAnnotationPredicates.java:50"$0$"	 */"
"MergedAnnotationPredicates.java:51"$1$"	public static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(String... typeNames) {"
"MergedAnnotationPredicates.java:52"$1$"		return annotation -> ObjectUtils.containsElement(typeNames, annotation.getType().getName());"
"MergedAnnotationPredicates.java:53"$1$"	}"
"MergedAnnotationPredicates.java:54"$0$""
"MergedAnnotationPredicates.java:55"$0$"	/**"
"MergedAnnotationPredicates.java:56"$1$"	 * Create a new {@link Predicate} that evaluates to {@code true} if the"
"MergedAnnotationPredicates.java:57"$1$"	 * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in"
"MergedAnnotationPredicates.java:58"$0$"	 * the specified array."
"MergedAnnotationPredicates.java:59"$0$"	 * @param <A> the annotation type"
"MergedAnnotationPredicates.java:60"$0$"	 * @param types the types that should be matched"
"MergedAnnotationPredicates.java:61"$1$"	 * @return a {@link Predicate} to test the annotation type"
"MergedAnnotationPredicates.java:62"$0$"	 */"
"MergedAnnotationPredicates.java:63"$1$"	public static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Class<?>... types) {"
"MergedAnnotationPredicates.java:64"$1$"		return annotation -> ObjectUtils.containsElement(types, annotation.getType());"
"MergedAnnotationPredicates.java:65"$1$"	}"
"MergedAnnotationPredicates.java:66"$0$""
"MergedAnnotationPredicates.java:67"$0$"	/**"
"MergedAnnotationPredicates.java:68"$1$"	 * Create a new {@link Predicate} that evaluates to {@code true} if the"
"MergedAnnotationPredicates.java:69"$1$"	 * {@linkplain MergedAnnotation#getType() merged annotation type} is contained in"
"MergedAnnotationPredicates.java:70"$0$"	 * the specified collection."
"MergedAnnotationPredicates.java:71"$0$"	 * @param <A> the annotation type"
"MergedAnnotationPredicates.java:72"$0$"	 * @param types the type names or classes that should be matched"
"MergedAnnotationPredicates.java:73"$1$"	 * @return a {@link Predicate} to test the annotation type"
"MergedAnnotationPredicates.java:74"$0$"	 */"
"MergedAnnotationPredicates.java:75"$1$"	public static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Collection<?> types) {"
"MergedAnnotationPredicates.java:76"$1$"		return annotation -> types.stream()"
"MergedAnnotationPredicates.java:77"$1$"				.map(type -> type instanceof Class ? ((Class<?>) type).getName() : type.toString())"
"MergedAnnotationPredicates.java:78"$1$"				.anyMatch(typeName -> typeName.equals(annotation.getType().getName()));"
"MergedAnnotationPredicates.java:79"$1$"	}"
"MergedAnnotationPredicates.java:80"$0$""
"MergedAnnotationPredicates.java:81"$0$"	/**"
"MergedAnnotationPredicates.java:82"$1$"	 * Create a new stateful, single use {@link Predicate} that matches only"
"MergedAnnotationPredicates.java:83"$0$"	 * the first run of an extracted value. For example,"
"MergedAnnotationPredicates.java:84"$1$"	 * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::distance)}"
"MergedAnnotationPredicates.java:85"$0$"	 * will match the first annotation, and any subsequent runs that have the"
"MergedAnnotationPredicates.java:86"$0$"	 * same distance."
"MergedAnnotationPredicates.java:87"$0$"	 * <p>NOTE: This predicate only matches the first run. Once the extracted"
"MergedAnnotationPredicates.java:88"$1$"	 * value changes, the predicate always returns {@code false}. For example,"
"MergedAnnotationPredicates.java:89"$1$"	 * if you have a set of annotations with distances {@code [1, 1, 2, 1]} then"
"MergedAnnotationPredicates.java:90"$0$"	 * only the first two will match."
"MergedAnnotationPredicates.java:91"$0$"	 * @param valueExtractor function used to extract the value to check"
"MergedAnnotationPredicates.java:92"$1$"	 * @return a {@link Predicate} that matches the first run of the extracted"
"MergedAnnotationPredicates.java:93"$0$"	 * values"
"MergedAnnotationPredicates.java:94"$0$"	 */"
"MergedAnnotationPredicates.java:95"$0$"	public static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf("
"MergedAnnotationPredicates.java:96"$1$"			Function<? super MergedAnnotation<A>, ?> valueExtractor) {"
"MergedAnnotationPredicates.java:97"$1$""
"MergedAnnotationPredicates.java:98"$1$"		return new FirstRunOfPredicate<>(valueExtractor);"
"MergedAnnotationPredicates.java:99"$1$"	}"
"MergedAnnotationPredicates.java:100"$0$""
"MergedAnnotationPredicates.java:101"$0$"	/**"
"MergedAnnotationPredicates.java:102"$1$"	 * Create a new stateful, single use {@link Predicate} that matches"
"MergedAnnotationPredicates.java:103"$0$"	 * annotations that are unique based on the extracted key. For example"
"MergedAnnotationPredicates.java:104"$1$"	 * {@code MergedAnnotationPredicates.unique(MergedAnnotation::getType)} will"
"MergedAnnotationPredicates.java:105"$0$"	 * match the first time a unique type is encountered."
"MergedAnnotationPredicates.java:106"$0$"	 * @param keyExtractor function used to extract the key used to test for"
"MergedAnnotationPredicates.java:107"$0$"	 * uniqueness"
"MergedAnnotationPredicates.java:108"$1$"	 * @return a {@link Predicate} that matches a unique annotation based on the"
"MergedAnnotationPredicates.java:109"$0$"	 * extracted key"
"MergedAnnotationPredicates.java:110"$0$"	 */"
"MergedAnnotationPredicates.java:111"$0$"	public static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique("
"MergedAnnotationPredicates.java:112"$1$"			Function<? super MergedAnnotation<A>, K> keyExtractor) {"
"MergedAnnotationPredicates.java:113"$1$""
"MergedAnnotationPredicates.java:114"$1$"		return new UniquePredicate<>(keyExtractor);"
"MergedAnnotationPredicates.java:115"$1$"	}"
"MergedAnnotationPredicates.java:116"$0$""
"MergedAnnotationPredicates.java:117"$0$""
"MergedAnnotationPredicates.java:118"$0$"	/**"
"MergedAnnotationPredicates.java:119"$1$"	 * {@link Predicate} implementation used for"
"MergedAnnotationPredicates.java:120"$1$"	 * {@link MergedAnnotationPredicates#firstRunOf(Function)}."
"MergedAnnotationPredicates.java:121"$0$"	 */"
"MergedAnnotationPredicates.java:122"$1$"	private static class FirstRunOfPredicate<A extends Annotation> implements Predicate<MergedAnnotation<A>> {"
"MergedAnnotationPredicates.java:123"$1$""
"MergedAnnotationPredicates.java:124"$1$"		private final Function<? super MergedAnnotation<A>, ?> valueExtractor;"
"MergedAnnotationPredicates.java:125"$1$""
"MergedAnnotationPredicates.java:126"$1$"		private boolean hasLastValue;"
"MergedAnnotationPredicates.java:127"$1$""
"MergedAnnotationPredicates.java:128"$1$"		@Nullable"
"MergedAnnotationPredicates.java:129"$1$"		private Object lastValue;"
"MergedAnnotationPredicates.java:130"$1$""
"MergedAnnotationPredicates.java:131"$1$"		FirstRunOfPredicate(Function<? super MergedAnnotation<A>, ?> valueExtractor) {"
"MergedAnnotationPredicates.java:132"$1$"			Assert.notNull(valueExtractor, ""Value extractor must not be null"");"
"MergedAnnotationPredicates.java:133"$1$"			this.valueExtractor = valueExtractor;"
"MergedAnnotationPredicates.java:134"$1$"		}"
"MergedAnnotationPredicates.java:135"$0$""
"MergedAnnotationPredicates.java:136"$0$"		@Override"
"MergedAnnotationPredicates.java:137"$1$"		public boolean test(@Nullable MergedAnnotation<A> annotation) {"
"MergedAnnotationPredicates.java:138"$1$"			if (!this.hasLastValue) {"
"MergedAnnotationPredicates.java:139"$1$"				this.hasLastValue = true;"
"MergedAnnotationPredicates.java:140"$1$"				this.lastValue = this.valueExtractor.apply(annotation);"
"MergedAnnotationPredicates.java:141"$1$"			}"
"MergedAnnotationPredicates.java:142"$0$"			Object value = this.valueExtractor.apply(annotation);"
"MergedAnnotationPredicates.java:143"$0$"			return ObjectUtils.nullSafeEquals(value, this.lastValue);"
"MergedAnnotationPredicates.java:144"$0$""
"MergedAnnotationPredicates.java:145"$0$"		}"
"MergedAnnotationPredicates.java:146"$0$"	}"
"MergedAnnotationPredicates.java:147"$0$""
"MergedAnnotationPredicates.java:148"$0$""
"MergedAnnotationPredicates.java:149"$0$"	/**"
"MergedAnnotationPredicates.java:150"$1$"	 * {@link Predicate} implementation used for"
"MergedAnnotationPredicates.java:151"$1$"	 * {@link MergedAnnotationPredicates#unique(Function)}."
"MergedAnnotationPredicates.java:152"$0$"	 */"
"MergedAnnotationPredicates.java:153"$1$"	private static class UniquePredicate<A extends Annotation, K> implements Predicate<MergedAnnotation<A>> {"
"MergedAnnotationPredicates.java:154"$1$""
"MergedAnnotationPredicates.java:155"$1$"		private final Function<? super MergedAnnotation<A>, K> keyExtractor;"
"MergedAnnotationPredicates.java:156"$1$""
"MergedAnnotationPredicates.java:157"$1$"		private final Set<K> seen = new HashSet<>();"
"MergedAnnotationPredicates.java:158"$1$""
"MergedAnnotationPredicates.java:159"$1$"		UniquePredicate(Function<? super MergedAnnotation<A>, K> keyExtractor) {"
"MergedAnnotationPredicates.java:160"$1$"			Assert.notNull(keyExtractor, ""Key extractor must not be null"");"
"MergedAnnotationPredicates.java:161"$1$"			this.keyExtractor = keyExtractor;"
"MergedAnnotationPredicates.java:162"$1$"		}"
"MergedAnnotationPredicates.java:163"$0$""
"MergedAnnotationPredicates.java:164"$0$"		@Override"
"MergedAnnotationPredicates.java:165"$1$"		public boolean test(@Nullable MergedAnnotation<A> annotation) {"
"MergedAnnotationPredicates.java:166"$1$"			K key = this.keyExtractor.apply(annotation);"
"MergedAnnotationPredicates.java:167"$1$"			return this.seen.add(key);"
"MergedAnnotationPredicates.java:168"$1$"		}"
"MergedAnnotationPredicates.java:169"$0$"	}"
"MergedAnnotationPredicates.java:170"$0$""
"MergedAnnotationPredicates.java:171"$0$"}"
"SimpleCommandLineArgsParser.java:1"$0$"/*"
"SimpleCommandLineArgsParser.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"SimpleCommandLineArgsParser.java:3"$0$" *"
"SimpleCommandLineArgsParser.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleCommandLineArgsParser.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleCommandLineArgsParser.java:6"$0$" * You may obtain a copy of the License at"
"SimpleCommandLineArgsParser.java:7"$0$" *"
"SimpleCommandLineArgsParser.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleCommandLineArgsParser.java:9"$0$" *"
"SimpleCommandLineArgsParser.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleCommandLineArgsParser.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleCommandLineArgsParser.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleCommandLineArgsParser.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleCommandLineArgsParser.java:14"$0$" * limitations under the License."
"SimpleCommandLineArgsParser.java:15"$0$" */"
"SimpleCommandLineArgsParser.java:16"$0$""
"SimpleCommandLineArgsParser.java:17"$0$"package org.springframework.core.env;"
"SimpleCommandLineArgsParser.java:18"$0$""
"SimpleCommandLineArgsParser.java:19"$0$"/**"
"SimpleCommandLineArgsParser.java:20"$1$" * Parses a {@code String[]} of command line arguments in order to populate a"
"SimpleCommandLineArgsParser.java:21"$1$" * {@link CommandLineArgs} object."
"SimpleCommandLineArgsParser.java:22"$0$" *"
"SimpleCommandLineArgsParser.java:23"$0$" * <h3>Working with option arguments</h3>"
"SimpleCommandLineArgsParser.java:24"$0$" * <p>Option arguments must adhere to the exact syntax:"
"SimpleCommandLineArgsParser.java:25"$0$" *"
"SimpleCommandLineArgsParser.java:26"$0$" * <pre class=""code"">--optName[=optValue]</pre>"
"SimpleCommandLineArgsParser.java:27"$0$" *"
"SimpleCommandLineArgsParser.java:28"$1$" * <p>That is, options must be prefixed with ""{@code --}"" and may or may not"
"SimpleCommandLineArgsParser.java:29"$0$" * specify a value. If a value is specified, the name and value must be separated"
"SimpleCommandLineArgsParser.java:30"$0$" * <em>without spaces</em> by an equals sign (""=""). The value may optionally be"
"SimpleCommandLineArgsParser.java:31"$0$" * an empty string."
"SimpleCommandLineArgsParser.java:32"$0$" *"
"SimpleCommandLineArgsParser.java:33"$0$" * <h4>Valid examples of option arguments</h4>"
"SimpleCommandLineArgsParser.java:34"$0$" * <pre class=""code"">"
"SimpleCommandLineArgsParser.java:35"$0$" * --foo"
"SimpleCommandLineArgsParser.java:36"$0$" * --foo="
"SimpleCommandLineArgsParser.java:37"$0$" * --foo="""""
"SimpleCommandLineArgsParser.java:38"$0$" * --foo=bar"
"SimpleCommandLineArgsParser.java:39"$0$" * --foo=""bar then baz"""
"SimpleCommandLineArgsParser.java:40"$0$" * --foo=bar,baz,biz</pre>"
"SimpleCommandLineArgsParser.java:41"$0$" *"
"SimpleCommandLineArgsParser.java:42"$0$" * <h4>Invalid examples of option arguments</h4>"
"SimpleCommandLineArgsParser.java:43"$0$" * <pre class=""code"">"
"SimpleCommandLineArgsParser.java:44"$0$" * -foo"
"SimpleCommandLineArgsParser.java:45"$0$" * --foo bar"
"SimpleCommandLineArgsParser.java:46"$0$" * --foo = bar"
"SimpleCommandLineArgsParser.java:47"$0$" * --foo=bar --foo=baz --foo=biz</pre>"
"SimpleCommandLineArgsParser.java:48"$0$" *"
"SimpleCommandLineArgsParser.java:49"$0$" * <h3>Working with non-option arguments</h3>"
"SimpleCommandLineArgsParser.java:50"$1$" * <p>Any and all arguments specified at the command line without the ""{@code --}"""
"SimpleCommandLineArgsParser.java:51"$0$" * option prefix will be considered as ""non-option arguments"" and made available"
"SimpleCommandLineArgsParser.java:52"$1$" * through the {@link CommandLineArgs#getNonOptionArgs()} method."
"SimpleCommandLineArgsParser.java:53"$0$" *"
"SimpleCommandLineArgsParser.java:54"$0$" * @author Chris Beams"
"SimpleCommandLineArgsParser.java:55"$0$" * @author Sam Brannen"
"SimpleCommandLineArgsParser.java:56"$0$" * @since 3.1"
"SimpleCommandLineArgsParser.java:57"$0$" */"
"SimpleCommandLineArgsParser.java:58"$1$"class SimpleCommandLineArgsParser {"
"SimpleCommandLineArgsParser.java:59"$1$""
"SimpleCommandLineArgsParser.java:60"$1$"	/**"
"SimpleCommandLineArgsParser.java:61"$1$"	 * Parse the given {@code String} array based on the rules described {@linkplain"
"SimpleCommandLineArgsParser.java:62"$1$"	 * SimpleCommandLineArgsParser above}, returning a fully-populated"
"SimpleCommandLineArgsParser.java:63"$1$"	 * {@link CommandLineArgs} object."
"SimpleCommandLineArgsParser.java:64"$1$"	 * @param args command line arguments, typically from a {@code main()} method"
"SimpleCommandLineArgsParser.java:65"$0$"	 */"
"SimpleCommandLineArgsParser.java:66"$1$"	public CommandLineArgs parse(String... args) {"
"SimpleCommandLineArgsParser.java:67"$1$"		CommandLineArgs commandLineArgs = new CommandLineArgs();"
"SimpleCommandLineArgsParser.java:68"$1$"		for (String arg : args) {"
"SimpleCommandLineArgsParser.java:69"$1$"			if (arg.startsWith(""--"")) {"
"SimpleCommandLineArgsParser.java:70"$1$"				String optionText = arg.substring(2);"
"SimpleCommandLineArgsParser.java:71"$1$"				String optionName;"
"SimpleCommandLineArgsParser.java:72"$1$"				String optionValue = null;"
"SimpleCommandLineArgsParser.java:73"$1$"				int indexOfEqualsSign = optionText.indexOf('=');"
"SimpleCommandLineArgsParser.java:74"$1$"				if (indexOfEqualsSign > -1) {"
"SimpleCommandLineArgsParser.java:75"$1$"					optionName = optionText.substring(0, indexOfEqualsSign);"
"SimpleCommandLineArgsParser.java:76"$1$"					optionValue = optionText.substring(indexOfEqualsSign + 1);"
"SimpleCommandLineArgsParser.java:77"$1$"				}"
"SimpleCommandLineArgsParser.java:78"$1$"				else {"
"SimpleCommandLineArgsParser.java:79"$1$"					optionName = optionText;"
"SimpleCommandLineArgsParser.java:80"$1$"				}"
"SimpleCommandLineArgsParser.java:81"$1$"				if (optionName.isEmpty()) {"
"SimpleCommandLineArgsParser.java:82"$1$"					throw new IllegalArgumentException(""Invalid argument syntax: "" + arg);"
"SimpleCommandLineArgsParser.java:83"$1$"				}"
"SimpleCommandLineArgsParser.java:84"$0$"				commandLineArgs.addOptionArg(optionName, optionValue);"
"SimpleCommandLineArgsParser.java:85"$0$"			}"
"SimpleCommandLineArgsParser.java:86"$1$"			else {"
"SimpleCommandLineArgsParser.java:87"$1$"				commandLineArgs.addNonOptionArg(arg);"
"SimpleCommandLineArgsParser.java:88"$1$"			}"
"SimpleCommandLineArgsParser.java:89"$0$"		}"
"SimpleCommandLineArgsParser.java:90"$0$"		return commandLineArgs;"
"SimpleCommandLineArgsParser.java:91"$0$"	}"
"SimpleCommandLineArgsParser.java:92"$0$""
"SimpleCommandLineArgsParser.java:93"$0$"}"
"StopWatch.java:1"$0$"/*"
"StopWatch.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"StopWatch.java:3"$0$" *"
"StopWatch.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StopWatch.java:5"$0$" * you may not use this file except in compliance with the License."
"StopWatch.java:6"$0$" * You may obtain a copy of the License at"
"StopWatch.java:7"$0$" *"
"StopWatch.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StopWatch.java:9"$0$" *"
"StopWatch.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StopWatch.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StopWatch.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StopWatch.java:13"$0$" * See the License for the specific language governing permissions and"
"StopWatch.java:14"$0$" * limitations under the License."
"StopWatch.java:15"$0$" */"
"StopWatch.java:16"$0$""
"StopWatch.java:17"$0$"package org.springframework.util;"
"StopWatch.java:18"$0$""
"StopWatch.java:19"$0$"import java.text.NumberFormat;"
"StopWatch.java:20"$0$"import java.util.LinkedList;"
"StopWatch.java:21"$0$"import java.util.List;"
"StopWatch.java:22"$0$"import java.util.concurrent.TimeUnit;"
"StopWatch.java:23"$0$""
"StopWatch.java:24"$0$"import org.springframework.lang.Nullable;"
"StopWatch.java:25"$0$""
"StopWatch.java:26"$0$"/**"
"StopWatch.java:27"$0$" * Simple stop watch, allowing for timing of a number of tasks, exposing total"
"StopWatch.java:28"$0$" * running time and running time for each named task."
"StopWatch.java:29"$0$" *"
"StopWatch.java:30"$1$" * <p>Conceals use of {@link System#nanoTime()}, improving the readability of"
"StopWatch.java:31"$0$" * application code and reducing the likelihood of calculation errors."
"StopWatch.java:32"$0$" *"
"StopWatch.java:33"$0$" * <p>Note that this object is not designed to be thread-safe and does not use"
"StopWatch.java:34"$0$" * synchronization."
"StopWatch.java:35"$0$" *"
"StopWatch.java:36"$0$" * <p>This class is normally used to verify performance during proof-of-concept"
"StopWatch.java:37"$0$" * work and in development, rather than as part of production applications."
"StopWatch.java:38"$0$" *"
"StopWatch.java:39"$0$" * <p>As of Spring Framework 5.2, running time is tracked and reported in"
"StopWatch.java:40"$0$" * nanoseconds."
"StopWatch.java:41"$0$" *"
"StopWatch.java:42"$0$" * @author Rod Johnson"
"StopWatch.java:43"$0$" * @author Juergen Hoeller"
"StopWatch.java:44"$0$" * @author Sam Brannen"
"StopWatch.java:45"$0$" * @since May 2, 2001"
"StopWatch.java:46"$0$" */"
"StopWatch.java:47"$1$"public class StopWatch {"
"StopWatch.java:48"$1$""
"StopWatch.java:49"$1$"	/**"
"StopWatch.java:50"$1$"	 * Identifier of this {@code StopWatch}."
"StopWatch.java:51"$1$"	 * <p>Handy when we have output from multiple stop watches and need to"
"StopWatch.java:52"$1$"	 * distinguish between them in log or console output."
"StopWatch.java:53"$1$"	 */"
"StopWatch.java:54"$1$"	private final String id;"
"StopWatch.java:55"$1$""
"StopWatch.java:56"$1$"	private boolean keepTaskList = true;"
"StopWatch.java:57"$1$""
"StopWatch.java:58"$1$"	private final List<TaskInfo> taskList = new LinkedList<>();"
"StopWatch.java:59"$1$""
"StopWatch.java:60"$1$"	/** Start time of the current task. */"
"StopWatch.java:61"$1$"	private long startTimeNanos;"
"StopWatch.java:62"$1$""
"StopWatch.java:63"$1$"	/** Name of the current task. */"
"StopWatch.java:64"$1$"	@Nullable"
"StopWatch.java:65"$1$"	private String currentTaskName;"
"StopWatch.java:66"$1$""
"StopWatch.java:67"$1$"	@Nullable"
"StopWatch.java:68"$1$"	private TaskInfo lastTaskInfo;"
"StopWatch.java:69"$1$""
"StopWatch.java:70"$1$"	private int taskCount;"
"StopWatch.java:71"$1$""
"StopWatch.java:72"$1$"	/** Total running time. */"
"StopWatch.java:73"$1$"	private long totalTimeNanos;"
"StopWatch.java:74"$1$""
"StopWatch.java:75"$1$""
"StopWatch.java:76"$1$"	/**"
"StopWatch.java:77"$1$"	 * Construct a new {@code StopWatch}."
"StopWatch.java:78"$1$"	 * <p>Does not start any task."
"StopWatch.java:79"$1$"	 */"
"StopWatch.java:80"$1$"	public StopWatch() {"
"StopWatch.java:81"$1$"		this("""");"
"StopWatch.java:82"$1$"	}"
"StopWatch.java:83"$0$""
"StopWatch.java:84"$0$"	/**"
"StopWatch.java:85"$1$"	 * Construct a new {@code StopWatch} with the given ID."
"StopWatch.java:86"$0$"	 * <p>The ID is handy when we have output from multiple stop watches and need"
"StopWatch.java:87"$0$"	 * to distinguish between them."
"StopWatch.java:88"$0$"	 * <p>Does not start any task."
"StopWatch.java:89"$0$"	 * @param id identifier for this stop watch"
"StopWatch.java:90"$0$"	 */"
"StopWatch.java:91"$1$"	public StopWatch(String id) {"
"StopWatch.java:92"$1$"		this.id = id;"
"StopWatch.java:93"$1$"	}"
"StopWatch.java:94"$0$""
"StopWatch.java:95"$0$""
"StopWatch.java:96"$0$"	/**"
"StopWatch.java:97"$1$"	 * Get the ID of this {@code StopWatch}, as specified on construction."
"StopWatch.java:98"$0$"	 * @return the ID (empty String by default)"
"StopWatch.java:99"$0$"	 * @since 4.2.2"
"StopWatch.java:100"$0$"	 * @see #StopWatch(String)"
"StopWatch.java:101"$0$"	 */"
"StopWatch.java:102"$1$"	public String getId() {"
"StopWatch.java:103"$1$"		return this.id;"
"StopWatch.java:104"$1$"	}"
"StopWatch.java:105"$0$""
"StopWatch.java:106"$0$"	/**"
"StopWatch.java:107"$1$"	 * Configure whether the {@link TaskInfo} array is built over time."
"StopWatch.java:108"$1$"	 * <p>Set this to {@code false} when using a {@code StopWatch} for millions"
"StopWatch.java:109"$1$"	 * of intervals; otherwise, the {@code TaskInfo} structure will consume"
"StopWatch.java:110"$0$"	 * excessive memory."
"StopWatch.java:111"$1$"	 * <p>Default is {@code true}."
"StopWatch.java:112"$0$"	 */"
"StopWatch.java:113"$1$"	public void setKeepTaskList(boolean keepTaskList) {"
"StopWatch.java:114"$1$"		this.keepTaskList = keepTaskList;"
"StopWatch.java:115"$1$"	}"
"StopWatch.java:116"$0$""
"StopWatch.java:117"$0$""
"StopWatch.java:118"$0$"	/**"
"StopWatch.java:119"$0$"	 * Start an unnamed task."
"StopWatch.java:120"$1$"	 * <p>The results are undefined if {@link #stop()} or timing methods are"
"StopWatch.java:121"$0$"	 * called without invoking this method first."
"StopWatch.java:122"$0$"	 * @see #start(String)"
"StopWatch.java:123"$0$"	 * @see #stop()"
"StopWatch.java:124"$0$"	 */"
"StopWatch.java:125"$1$"	public void start() throws IllegalStateException {"
"StopWatch.java:126"$1$"		start("""");"
"StopWatch.java:127"$1$"	}"
"StopWatch.java:128"$0$""
"StopWatch.java:129"$0$"	/**"
"StopWatch.java:130"$0$"	 * Start a named task."
"StopWatch.java:131"$1$"	 * <p>The results are undefined if {@link #stop()} or timing methods are"
"StopWatch.java:132"$0$"	 * called without invoking this method first."
"StopWatch.java:133"$0$"	 * @param taskName the name of the task to start"
"StopWatch.java:134"$0$"	 * @see #start()"
"StopWatch.java:135"$0$"	 * @see #stop()"
"StopWatch.java:136"$0$"	 */"
"StopWatch.java:137"$1$"	public void start(String taskName) throws IllegalStateException {"
"StopWatch.java:138"$1$"		if (this.currentTaskName != null) {"
"StopWatch.java:139"$1$"			throw new IllegalStateException(""Can't start StopWatch: it's already running"");"
"StopWatch.java:140"$1$"		}"
"StopWatch.java:141"$0$"		this.currentTaskName = taskName;"
"StopWatch.java:142"$0$"		this.startTimeNanos = System.nanoTime();"
"StopWatch.java:143"$0$"	}"
"StopWatch.java:144"$0$""
"StopWatch.java:145"$0$"	/**"
"StopWatch.java:146"$0$"	 * Stop the current task."
"StopWatch.java:147"$0$"	 * <p>The results are undefined if timing methods are called without invoking"
"StopWatch.java:148"$1$"	 * at least one pair of {@code start()} / {@code stop()} methods."
"StopWatch.java:149"$0$"	 * @see #start()"
"StopWatch.java:150"$0$"	 * @see #start(String)"
"StopWatch.java:151"$0$"	 */"
"StopWatch.java:152"$1$"	public void stop() throws IllegalStateException {"
"StopWatch.java:153"$1$"		if (this.currentTaskName == null) {"
"StopWatch.java:154"$1$"			throw new IllegalStateException(""Can't stop StopWatch: it's not running"");"
"StopWatch.java:155"$1$"		}"
"StopWatch.java:156"$0$"		long lastTime = System.nanoTime() - this.startTimeNanos;"
"StopWatch.java:157"$0$"		this.totalTimeNanos += lastTime;"
"StopWatch.java:158"$0$"		this.lastTaskInfo = new TaskInfo(this.currentTaskName, lastTime);"
"StopWatch.java:159"$1$"		if (this.keepTaskList) {"
"StopWatch.java:160"$1$"			this.taskList.add(this.lastTaskInfo);"
"StopWatch.java:161"$1$"		}"
"StopWatch.java:162"$0$"		++this.taskCount;"
"StopWatch.java:163"$0$"		this.currentTaskName = null;"
"StopWatch.java:164"$0$"	}"
"StopWatch.java:165"$0$""
"StopWatch.java:166"$0$"	/**"
"StopWatch.java:167"$1$"	 * Determine whether this {@code StopWatch} is currently running."
"StopWatch.java:168"$0$"	 * @see #currentTaskName()"
"StopWatch.java:169"$0$"	 */"
"StopWatch.java:170"$1$"	public boolean isRunning() {"
"StopWatch.java:171"$1$"		return (this.currentTaskName != null);"
"StopWatch.java:172"$1$"	}"
"StopWatch.java:173"$0$""
"StopWatch.java:174"$0$"	/**"
"StopWatch.java:175"$0$"	 * Get the name of the currently running task, if any."
"StopWatch.java:176"$0$"	 * @since 4.2.2"
"StopWatch.java:177"$0$"	 * @see #isRunning()"
"StopWatch.java:178"$0$"	 */"
"StopWatch.java:179"$0$"	@Nullable"
"StopWatch.java:180"$1$"	public String currentTaskName() {"
"StopWatch.java:181"$1$"		return this.currentTaskName;"
"StopWatch.java:182"$1$"	}"
"StopWatch.java:183"$0$""
"StopWatch.java:184"$0$"	/**"
"StopWatch.java:185"$0$"	 * Get the time taken by the last task in nanoseconds."
"StopWatch.java:186"$0$"	 * @since 5.2"
"StopWatch.java:187"$0$"	 * @see #getLastTaskTimeMillis()"
"StopWatch.java:188"$0$"	 */"
"StopWatch.java:189"$1$"	public long getLastTaskTimeNanos() throws IllegalStateException {"
"StopWatch.java:190"$1$"		if (this.lastTaskInfo == null) {"
"StopWatch.java:191"$1$"			throw new IllegalStateException(""No tasks run: can't get last task interval"");"
"StopWatch.java:192"$1$"		}"
"StopWatch.java:193"$0$"		return this.lastTaskInfo.getTimeNanos();"
"StopWatch.java:194"$0$"	}"
"StopWatch.java:195"$0$""
"StopWatch.java:196"$0$"	/**"
"StopWatch.java:197"$0$"	 * Get the time taken by the last task in milliseconds."
"StopWatch.java:198"$0$"	 * @see #getLastTaskTimeNanos()"
"StopWatch.java:199"$0$"	 */"
"StopWatch.java:200"$1$"	public long getLastTaskTimeMillis() throws IllegalStateException {"
"StopWatch.java:201"$1$"		if (this.lastTaskInfo == null) {"
"StopWatch.java:202"$1$"			throw new IllegalStateException(""No tasks run: can't get last task interval"");"
"StopWatch.java:203"$1$"		}"
"StopWatch.java:204"$0$"		return this.lastTaskInfo.getTimeMillis();"
"StopWatch.java:205"$0$"	}"
"StopWatch.java:206"$0$""
"StopWatch.java:207"$0$"	/**"
"StopWatch.java:208"$0$"	 * Get the name of the last task."
"StopWatch.java:209"$0$"	 */"
"StopWatch.java:210"$1$"	public String getLastTaskName() throws IllegalStateException {"
"StopWatch.java:211"$1$"		if (this.lastTaskInfo == null) {"
"StopWatch.java:212"$1$"			throw new IllegalStateException(""No tasks run: can't get last task name"");"
"StopWatch.java:213"$1$"		}"
"StopWatch.java:214"$0$"		return this.lastTaskInfo.getTaskName();"
"StopWatch.java:215"$0$"	}"
"StopWatch.java:216"$0$""
"StopWatch.java:217"$0$"	/**"
"StopWatch.java:218"$1$"	 * Get the last task as a {@link TaskInfo} object."
"StopWatch.java:219"$0$"	 */"
"StopWatch.java:220"$1$"	public TaskInfo getLastTaskInfo() throws IllegalStateException {"
"StopWatch.java:221"$1$"		if (this.lastTaskInfo == null) {"
"StopWatch.java:222"$1$"			throw new IllegalStateException(""No tasks run: can't get last task info"");"
"StopWatch.java:223"$1$"		}"
"StopWatch.java:224"$0$"		return this.lastTaskInfo;"
"StopWatch.java:225"$0$"	}"
"StopWatch.java:226"$0$""
"StopWatch.java:227"$0$""
"StopWatch.java:228"$0$"	/**"
"StopWatch.java:229"$0$"	 * Get the total time in nanoseconds for all tasks."
"StopWatch.java:230"$0$"	 * @since 5.2"
"StopWatch.java:231"$0$"	 * @see #getTotalTimeMillis()"
"StopWatch.java:232"$0$"	 * @see #getTotalTimeSeconds()"
"StopWatch.java:233"$0$"	 */"
"StopWatch.java:234"$1$"	public long getTotalTimeNanos() {"
"StopWatch.java:235"$1$"		return this.totalTimeNanos;"
"StopWatch.java:236"$1$"	}"
"StopWatch.java:237"$0$""
"StopWatch.java:238"$0$"	/**"
"StopWatch.java:239"$0$"	 * Get the total time in milliseconds for all tasks."
"StopWatch.java:240"$0$"	 * @see #getTotalTimeNanos()"
"StopWatch.java:241"$0$"	 * @see #getTotalTimeSeconds()"
"StopWatch.java:242"$0$"	 */"
"StopWatch.java:243"$1$"	public long getTotalTimeMillis() {"
"StopWatch.java:244"$1$"		return nanosToMillis(this.totalTimeNanos);"
"StopWatch.java:245"$1$"	}"
"StopWatch.java:246"$0$""
"StopWatch.java:247"$0$"	/**"
"StopWatch.java:248"$0$"	 * Get the total time in seconds for all tasks."
"StopWatch.java:249"$0$"	 * @see #getTotalTimeNanos()"
"StopWatch.java:250"$0$"	 * @see #getTotalTimeMillis()"
"StopWatch.java:251"$0$"	 */"
"StopWatch.java:252"$1$"	public double getTotalTimeSeconds() {"
"StopWatch.java:253"$1$"		return nanosToSeconds(this.totalTimeNanos);"
"StopWatch.java:254"$1$"	}"
"StopWatch.java:255"$0$""
"StopWatch.java:256"$0$"	/**"
"StopWatch.java:257"$0$"	 * Get the number of tasks timed."
"StopWatch.java:258"$0$"	 */"
"StopWatch.java:259"$1$"	public int getTaskCount() {"
"StopWatch.java:260"$1$"		return this.taskCount;"
"StopWatch.java:261"$1$"	}"
"StopWatch.java:262"$0$""
"StopWatch.java:263"$0$"	/**"
"StopWatch.java:264"$0$"	 * Get an array of the data for tasks performed."
"StopWatch.java:265"$0$"	 */"
"StopWatch.java:266"$1$"	public TaskInfo[] getTaskInfo() {"
"StopWatch.java:267"$1$"		if (!this.keepTaskList) {"
"StopWatch.java:268"$1$"			throw new UnsupportedOperationException(""Task info is not being kept!"");"
"StopWatch.java:269"$1$"		}"
"StopWatch.java:270"$0$"		return this.taskList.toArray(new TaskInfo[0]);"
"StopWatch.java:271"$0$"	}"
"StopWatch.java:272"$0$""
"StopWatch.java:273"$0$""
"StopWatch.java:274"$0$"	/**"
"StopWatch.java:275"$0$"	 * Get a short description of the total running time."
"StopWatch.java:276"$0$"	 */"
"StopWatch.java:277"$1$"	public String shortSummary() {"
"StopWatch.java:278"$1$"		return ""StopWatch '"" + getId() + ""': running time = "" + getTotalTimeNanos() + "" ns"";"
"StopWatch.java:279"$1$"	}"
"StopWatch.java:280"$0$""
"StopWatch.java:281"$0$"	/**"
"StopWatch.java:282"$0$"	 * Generate a string with a table describing all tasks performed."
"StopWatch.java:283"$1$"	 * <p>For custom reporting, call {@link #getTaskInfo()} and use the task info"
"StopWatch.java:284"$0$"	 * directly."
"StopWatch.java:285"$0$"	 */"
"StopWatch.java:286"$1$"	public String prettyPrint() {"
"StopWatch.java:287"$1$"		StringBuilder sb = new StringBuilder(shortSummary());"
"StopWatch.java:288"$1$"		sb.append('\n');"
"StopWatch.java:289"$1$"		if (!this.keepTaskList) {"
"StopWatch.java:290"$1$"			sb.append(""No task info kept"");"
"StopWatch.java:291"$1$"		}"
"StopWatch.java:292"$1$"		else {"
"StopWatch.java:293"$1$"			sb.append(""---------------------------------------------\n"");"
"StopWatch.java:294"$1$"			sb.append(""ns         %     Task name\n"");"
"StopWatch.java:295"$1$"			sb.append(""---------------------------------------------\n"");"
"StopWatch.java:296"$1$"			NumberFormat nf = NumberFormat.getNumberInstance();"
"StopWatch.java:297"$1$"			nf.setMinimumIntegerDigits(9);"
"StopWatch.java:298"$1$"			nf.setGroupingUsed(false);"
"StopWatch.java:299"$1$"			NumberFormat pf = NumberFormat.getPercentInstance();"
"StopWatch.java:300"$1$"			pf.setMinimumIntegerDigits(3);"
"StopWatch.java:301"$1$"			pf.setGroupingUsed(false);"
"StopWatch.java:302"$1$"			for (TaskInfo task : getTaskInfo()) {"
"StopWatch.java:303"$1$"				sb.append(nf.format(task.getTimeNanos())).append(""  "");"
"StopWatch.java:304"$1$"				sb.append(pf.format((double) task.getTimeNanos() / getTotalTimeNanos())).append(""  "");"
"StopWatch.java:305"$1$"				sb.append(task.getTaskName()).append(""\n"");"
"StopWatch.java:306"$1$"			}"
"StopWatch.java:307"$0$"		}"
"StopWatch.java:308"$0$"		return sb.toString();"
"StopWatch.java:309"$0$"	}"
"StopWatch.java:310"$0$""
"StopWatch.java:311"$0$"	/**"
"StopWatch.java:312"$0$"	 * Generate an informative string describing all tasks performed"
"StopWatch.java:313"$1$"	 * <p>For custom reporting, call {@link #getTaskInfo()} and use the task info"
"StopWatch.java:314"$0$"	 * directly."
"StopWatch.java:315"$0$"	 */"
"StopWatch.java:316"$0$"	@Override"
"StopWatch.java:317"$1$"	public String toString() {"
"StopWatch.java:318"$1$"		StringBuilder sb = new StringBuilder(shortSummary());"
"StopWatch.java:319"$1$"		if (this.keepTaskList) {"
"StopWatch.java:320"$1$"			for (TaskInfo task : getTaskInfo()) {"
"StopWatch.java:321"$1$"				sb.append(""; ["").append(task.getTaskName()).append(""] took "").append(task.getTimeNanos()).append("" ns"");"
"StopWatch.java:322"$1$"				long percent = Math.round(100.0 * task.getTimeNanos() / getTotalTimeNanos());"
"StopWatch.java:323"$1$"				sb.append("" = "").append(percent).append(""%"");"
"StopWatch.java:324"$1$"			}"
"StopWatch.java:325"$0$"		}"
"StopWatch.java:326"$1$"		else {"
"StopWatch.java:327"$1$"			sb.append(""; no task info kept"");"
"StopWatch.java:328"$1$"		}"
"StopWatch.java:329"$0$"		return sb.toString();"
"StopWatch.java:330"$0$"	}"
"StopWatch.java:331"$0$""
"StopWatch.java:332"$0$""
"StopWatch.java:333"$1$"	private static long nanosToMillis(long duration) {"
"StopWatch.java:334"$1$"		return TimeUnit.NANOSECONDS.toMillis(duration);"
"StopWatch.java:335"$1$"	}"
"StopWatch.java:336"$0$""
"StopWatch.java:337"$1$"	private static double nanosToSeconds(long duration) {"
"StopWatch.java:338"$1$"		return duration / 1_000_000_000.0;"
"StopWatch.java:339"$1$"	}"
"StopWatch.java:340"$0$""
"StopWatch.java:341"$0$""
"StopWatch.java:342"$0$"	/**"
"StopWatch.java:343"$1$"	 * Nested class to hold data about one task executed within the {@code StopWatch}."
"StopWatch.java:344"$0$"	 */"
"StopWatch.java:345"$1$"	public static final class TaskInfo {"
"StopWatch.java:346"$1$""
"StopWatch.java:347"$1$"		private final String taskName;"
"StopWatch.java:348"$1$""
"StopWatch.java:349"$1$"		private final long timeNanos;"
"StopWatch.java:350"$1$""
"StopWatch.java:351"$1$"		TaskInfo(String taskName, long timeNanos) {"
"StopWatch.java:352"$1$"			this.taskName = taskName;"
"StopWatch.java:353"$1$"			this.timeNanos = timeNanos;"
"StopWatch.java:354"$1$"		}"
"StopWatch.java:355"$0$""
"StopWatch.java:356"$0$"		/**"
"StopWatch.java:357"$0$"		 * Get the name of this task."
"StopWatch.java:358"$0$"		 */"
"StopWatch.java:359"$1$"		public String getTaskName() {"
"StopWatch.java:360"$1$"			return this.taskName;"
"StopWatch.java:361"$1$"		}"
"StopWatch.java:362"$0$""
"StopWatch.java:363"$0$"		/**"
"StopWatch.java:364"$0$"		 * Get the time in nanoseconds this task took."
"StopWatch.java:365"$0$"		 * @since 5.2"
"StopWatch.java:366"$0$"		 * @see #getTimeMillis()"
"StopWatch.java:367"$0$"		 * @see #getTimeSeconds()"
"StopWatch.java:368"$0$"		 */"
"StopWatch.java:369"$1$"		public long getTimeNanos() {"
"StopWatch.java:370"$1$"			return this.timeNanos;"
"StopWatch.java:371"$1$"		}"
"StopWatch.java:372"$0$""
"StopWatch.java:373"$0$"		/**"
"StopWatch.java:374"$0$"		 * Get the time in milliseconds this task took."
"StopWatch.java:375"$0$"		 * @see #getTimeNanos()"
"StopWatch.java:376"$0$"		 * @see #getTimeSeconds()"
"StopWatch.java:377"$0$"		 */"
"StopWatch.java:378"$1$"		public long getTimeMillis() {"
"StopWatch.java:379"$1$"			return nanosToMillis(this.timeNanos);"
"StopWatch.java:380"$1$"		}"
"StopWatch.java:381"$0$""
"StopWatch.java:382"$0$"		/**"
"StopWatch.java:383"$0$"		 * Get the time in seconds this task took."
"StopWatch.java:384"$0$"		 * @see #getTimeMillis()"
"StopWatch.java:385"$0$"		 * @see #getTimeNanos()"
"StopWatch.java:386"$0$"		 */"
"StopWatch.java:387"$1$"		public double getTimeSeconds() {"
"StopWatch.java:388"$1$"			return nanosToSeconds(this.timeNanos);"
"StopWatch.java:389"$1$"		}"
"StopWatch.java:390"$0$""
"StopWatch.java:391"$0$"	}"
"StopWatch.java:392"$0$""
"StopWatch.java:393"$0$"}"
"DataBuffer.java:1"$0$"/*"
"DataBuffer.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DataBuffer.java:3"$0$" *"
"DataBuffer.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DataBuffer.java:5"$0$" * you may not use this file except in compliance with the License."
"DataBuffer.java:6"$0$" * You may obtain a copy of the License at"
"DataBuffer.java:7"$0$" *"
"DataBuffer.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DataBuffer.java:9"$0$" *"
"DataBuffer.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DataBuffer.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DataBuffer.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DataBuffer.java:13"$0$" * See the License for the specific language governing permissions and"
"DataBuffer.java:14"$0$" * limitations under the License."
"DataBuffer.java:15"$0$" */"
"DataBuffer.java:16"$0$""
"DataBuffer.java:17"$0$"package org.springframework.core.io.buffer;"
"DataBuffer.java:18"$0$""
"DataBuffer.java:19"$0$"import java.io.InputStream;"
"DataBuffer.java:20"$0$"import java.io.OutputStream;"
"DataBuffer.java:21"$0$"import java.nio.ByteBuffer;"
"DataBuffer.java:22"$0$"import java.nio.CharBuffer;"
"DataBuffer.java:23"$0$"import java.nio.charset.Charset;"
"DataBuffer.java:24"$0$"import java.nio.charset.CharsetEncoder;"
"DataBuffer.java:25"$0$"import java.nio.charset.CoderResult;"
"DataBuffer.java:26"$0$"import java.nio.charset.CodingErrorAction;"
"DataBuffer.java:27"$0$"import java.util.function.IntPredicate;"
"DataBuffer.java:28"$0$""
"DataBuffer.java:29"$0$"import org.springframework.util.Assert;"
"DataBuffer.java:30"$0$""
"DataBuffer.java:31"$0$"/**"
"DataBuffer.java:32"$0$" * Basic abstraction over byte buffers."
"DataBuffer.java:33"$0$" *"
"DataBuffer.java:34"$1$" * <p>{@code DataBuffer}s has a separate {@linkplain #readPosition() read} and"
"DataBuffer.java:35"$1$" * {@linkplain #writePosition() write} position, as opposed to {@code ByteBuffer}'s"
"DataBuffer.java:36"$1$" * single {@linkplain ByteBuffer#position() position}. As such, the {@code DataBuffer}"
"DataBuffer.java:37"$1$" * does not require a {@linkplain ByteBuffer#flip() flip} to read after writing. In general,"
"DataBuffer.java:38"$0$" * the following invariant holds for the read and write positions, and the capacity:"
"DataBuffer.java:39"$0$" *"
"DataBuffer.java:40"$0$" * <blockquote>"
"DataBuffer.java:41"$0$" *     <tt>0</tt> <tt>&lt;=</tt>"
"DataBuffer.java:42"$0$" *     <i>readPosition</i> <tt>&lt;=</tt>"
"DataBuffer.java:43"$0$" *     <i>writePosition</i> <tt>&lt;=</tt>"
"DataBuffer.java:44"$0$" *     <i>capacity</i>"
"DataBuffer.java:45"$0$" * </blockquote>"
"DataBuffer.java:46"$0$" *"
"DataBuffer.java:47"$1$" * <p>The {@linkplain #capacity() capacity} of a {@code DataBuffer} is expanded on demand,"
"DataBuffer.java:48"$1$" * similar to {@code StringBuilder}."
"DataBuffer.java:49"$0$" *"
"DataBuffer.java:50"$1$" * <p>The main purpose of the {@code DataBuffer} abstraction is to provide a convenient wrapper"
"DataBuffer.java:51"$1$" * around {@link ByteBuffer} which is similar to Netty's {@link io.netty.buffer.ByteBuf} but"
"DataBuffer.java:52"$0$" * can also be used on non-Netty platforms (i.e. Servlet containers)."
"DataBuffer.java:53"$0$" *"
"DataBuffer.java:54"$0$" * @author Arjen Poutsma"
"DataBuffer.java:55"$0$" * @author Brian Clozel"
"DataBuffer.java:56"$0$" * @since 5.0"
"DataBuffer.java:57"$0$" * @see DataBufferFactory"
"DataBuffer.java:58"$0$" */"
"DataBuffer.java:59"$1$"public interface DataBuffer {"
"DataBuffer.java:60"$1$""
"DataBuffer.java:61"$1$"	/**"
"DataBuffer.java:62"$1$"	 * Return the {@link DataBufferFactory} that created this buffer."
"DataBuffer.java:63"$1$"	 * @return the creating buffer factory"
"DataBuffer.java:64"$1$"	 */"
"DataBuffer.java:65"$1$"	DataBufferFactory factory();"
"DataBuffer.java:66"$1$""
"DataBuffer.java:67"$1$"	/**"
"DataBuffer.java:68"$1$"	 * Return the index of the first byte in this buffer that matches"
"DataBuffer.java:69"$1$"	 * the given predicate."
"DataBuffer.java:70"$1$"	 * @param predicate the predicate to match"
"DataBuffer.java:71"$1$"	 * @param fromIndex the index to start the search from"
"DataBuffer.java:72"$1$"	 * @return the index of the first byte that matches {@code predicate};"
"DataBuffer.java:73"$1$"	 * or {@code -1} if none match"
"DataBuffer.java:74"$1$"	 */"
"DataBuffer.java:75"$1$"	int indexOf(IntPredicate predicate, int fromIndex);"
"DataBuffer.java:76"$1$""
"DataBuffer.java:77"$1$"	/**"
"DataBuffer.java:78"$1$"	 * Return the index of the last byte in this buffer that matches"
"DataBuffer.java:79"$1$"	 * the given predicate."
"DataBuffer.java:80"$1$"	 * @param predicate the predicate to match"
"DataBuffer.java:81"$1$"	 * @param fromIndex the index to start the search from"
"DataBuffer.java:82"$1$"	 * @return the index of the last byte that matches {@code predicate};"
"DataBuffer.java:83"$1$"	 * or {@code -1} if none match"
"DataBuffer.java:84"$1$"	 */"
"DataBuffer.java:85"$1$"	int lastIndexOf(IntPredicate predicate, int fromIndex);"
"DataBuffer.java:86"$1$""
"DataBuffer.java:87"$1$"	/**"
"DataBuffer.java:88"$1$"	 * Return the number of bytes that can be read from this data buffer."
"DataBuffer.java:89"$1$"	 * @return the readable byte count"
"DataBuffer.java:90"$1$"	 */"
"DataBuffer.java:91"$1$"	int readableByteCount();"
"DataBuffer.java:92"$1$""
"DataBuffer.java:93"$1$"	/**"
"DataBuffer.java:94"$1$"	 * Return the number of bytes that can be written to this data buffer."
"DataBuffer.java:95"$1$"	 * @return the writable byte count"
"DataBuffer.java:96"$1$"	 * @since 5.0.1"
"DataBuffer.java:97"$1$"	 */"
"DataBuffer.java:98"$1$"	int writableByteCount();"
"DataBuffer.java:99"$1$""
"DataBuffer.java:100"$1$"	/**"
"DataBuffer.java:101"$1$"	 * Return the number of bytes that this buffer can contain."
"DataBuffer.java:102"$1$"	 * @return the capacity"
"DataBuffer.java:103"$1$"	 * @since 5.0.1"
"DataBuffer.java:104"$1$"	 */"
"DataBuffer.java:105"$1$"	int capacity();"
"DataBuffer.java:106"$1$""
"DataBuffer.java:107"$1$"	/**"
"DataBuffer.java:108"$1$"	 * Set the number of bytes that this buffer can contain."
"DataBuffer.java:109"$1$"	 * <p>If the new capacity is lower than the current capacity, the contents"
"DataBuffer.java:110"$1$"	 * of this buffer will be truncated. If the new capacity is higher than"
"DataBuffer.java:111"$1$"	 * the current capacity, it will be expanded."
"DataBuffer.java:112"$1$"	 * @param capacity the new capacity"
"DataBuffer.java:113"$1$"	 * @return this buffer"
"DataBuffer.java:114"$1$"	 */"
"DataBuffer.java:115"$1$"	DataBuffer capacity(int capacity);"
"DataBuffer.java:116"$1$""
"DataBuffer.java:117"$1$"	/**"
"DataBuffer.java:118"$1$"	 * Ensure that the current buffer has enough {@link #writableByteCount()}"
"DataBuffer.java:119"$1$"	 * to write the amount of data given as an argument. If not, the missing"
"DataBuffer.java:120"$1$"	 * capacity will be added to the buffer."
"DataBuffer.java:121"$1$"	 * @param capacity the writable capacity to check for"
"DataBuffer.java:122"$1$"	 * @return this buffer"
"DataBuffer.java:123"$1$"	 * @since 5.1.4"
"DataBuffer.java:124"$1$"	 */"
"DataBuffer.java:125"$1$"	default DataBuffer ensureCapacity(int capacity) {"
"DataBuffer.java:126"$1$"		return this;"
"DataBuffer.java:127"$1$"	}"
"DataBuffer.java:128"$0$""
"DataBuffer.java:129"$0$"	/**"
"DataBuffer.java:130"$0$"	 * Return the position from which this buffer will read."
"DataBuffer.java:131"$0$"	 * @return the read position"
"DataBuffer.java:132"$0$"	 * @since 5.0.1"
"DataBuffer.java:133"$0$"	 */"
"DataBuffer.java:134"$0$"	int readPosition();"
"DataBuffer.java:135"$0$""
"DataBuffer.java:136"$0$"	/**"
"DataBuffer.java:137"$0$"	 * Set the position from which this buffer will read."
"DataBuffer.java:138"$0$"	 * @param readPosition the new read position"
"DataBuffer.java:139"$0$"	 * @return this buffer"
"DataBuffer.java:140"$1$"	 * @throws IndexOutOfBoundsException if {@code readPosition} is smaller than 0"
"DataBuffer.java:141"$1$"	 * or greater than {@link #writePosition()}"
"DataBuffer.java:142"$0$"	 * @since 5.0.1"
"DataBuffer.java:143"$0$"	 */"
"DataBuffer.java:144"$0$"	DataBuffer readPosition(int readPosition);"
"DataBuffer.java:145"$0$""
"DataBuffer.java:146"$0$"	/**"
"DataBuffer.java:147"$0$"	 * Return the position to which this buffer will write."
"DataBuffer.java:148"$0$"	 * @return the write position"
"DataBuffer.java:149"$0$"	 * @since 5.0.1"
"DataBuffer.java:150"$0$"	 */"
"DataBuffer.java:151"$0$"	int writePosition();"
"DataBuffer.java:152"$0$""
"DataBuffer.java:153"$0$"	/**"
"DataBuffer.java:154"$0$"	 * Set the position to which this buffer will write."
"DataBuffer.java:155"$0$"	 * @param writePosition the new write position"
"DataBuffer.java:156"$0$"	 * @return this buffer"
"DataBuffer.java:157"$1$"	 * @throws IndexOutOfBoundsException if {@code writePosition} is smaller than"
"DataBuffer.java:158"$1$"	 * {@link #readPosition()} or greater than {@link #capacity()}"
"DataBuffer.java:159"$0$"	 * @since 5.0.1"
"DataBuffer.java:160"$0$"	 */"
"DataBuffer.java:161"$0$"	DataBuffer writePosition(int writePosition);"
"DataBuffer.java:162"$0$""
"DataBuffer.java:163"$0$"	/**"
"DataBuffer.java:164"$0$"	 * Read a single byte at the given index from this data buffer."
"DataBuffer.java:165"$0$"	 * @param index the index at which the byte will be read"
"DataBuffer.java:166"$0$"	 * @return the byte at the given index"
"DataBuffer.java:167"$1$"	 * @throws IndexOutOfBoundsException when {@code index} is out of bounds"
"DataBuffer.java:168"$0$"	 * @since 5.0.4"
"DataBuffer.java:169"$0$"	 */"
"DataBuffer.java:170"$0$"	byte getByte(int index);"
"DataBuffer.java:171"$0$""
"DataBuffer.java:172"$0$"	/**"
"DataBuffer.java:173"$0$"	 * Read a single byte from the current reading position from this data buffer."
"DataBuffer.java:174"$0$"	 * @return the byte at this buffer's current reading position"
"DataBuffer.java:175"$0$"	 */"
"DataBuffer.java:176"$0$"	byte read();"
"DataBuffer.java:177"$0$""
"DataBuffer.java:178"$0$"	/**"
"DataBuffer.java:179"$0$"	 * Read this buffer's data into the specified destination, starting at the current"
"DataBuffer.java:180"$0$"	 * reading position of this buffer."
"DataBuffer.java:181"$0$"	 * @param destination the array into which the bytes are to be written"
"DataBuffer.java:182"$0$"	 * @return this buffer"
"DataBuffer.java:183"$0$"	 */"
"DataBuffer.java:184"$0$"	DataBuffer read(byte[] destination);"
"DataBuffer.java:185"$0$""
"DataBuffer.java:186"$0$"	/**"
"DataBuffer.java:187"$1$"	 * Read at most {@code length} bytes of this buffer into the specified destination,"
"DataBuffer.java:188"$0$"	 * starting at the current reading position of this buffer."
"DataBuffer.java:189"$0$"	 * @param destination the array into which the bytes are to be written"
"DataBuffer.java:190"$1$"	 * @param offset the index within {@code destination} of the first byte to be written"
"DataBuffer.java:191"$1$"	 * @param length the maximum number of bytes to be written in {@code destination}"
"DataBuffer.java:192"$0$"	 * @return this buffer"
"DataBuffer.java:193"$0$"	 */"
"DataBuffer.java:194"$0$"	DataBuffer read(byte[] destination, int offset, int length);"
"DataBuffer.java:195"$0$""
"DataBuffer.java:196"$0$"	/**"
"DataBuffer.java:197"$0$"	 * Write a single byte into this buffer at the current writing position."
"DataBuffer.java:198"$0$"	 * @param b the byte to be written"
"DataBuffer.java:199"$0$"	 * @return this buffer"
"DataBuffer.java:200"$0$"	 */"
"DataBuffer.java:201"$0$"	DataBuffer write(byte b);"
"DataBuffer.java:202"$0$""
"DataBuffer.java:203"$0$"	/**"
"DataBuffer.java:204"$0$"	 * Write the given source into this buffer, starting at the current writing position"
"DataBuffer.java:205"$0$"	 * of this buffer."
"DataBuffer.java:206"$0$"	 * @param source the bytes to be written into this buffer"
"DataBuffer.java:207"$0$"	 * @return this buffer"
"DataBuffer.java:208"$0$"	 */"
"DataBuffer.java:209"$0$"	DataBuffer write(byte[] source);"
"DataBuffer.java:210"$0$""
"DataBuffer.java:211"$0$"	/**"
"DataBuffer.java:212"$1$"	 * Write at most {@code length} bytes of the given source into this buffer, starting"
"DataBuffer.java:213"$0$"	 * at the current writing position of this buffer."
"DataBuffer.java:214"$0$"	 * @param source the bytes to be written into this buffer"
"DataBuffer.java:215"$1$"	 * @param offset the index within {@code source} to start writing from"
"DataBuffer.java:216"$1$"	 * @param length the maximum number of bytes to be written from {@code source}"
"DataBuffer.java:217"$0$"	 * @return this buffer"
"DataBuffer.java:218"$0$"	 */"
"DataBuffer.java:219"$0$"	DataBuffer write(byte[] source, int offset, int length);"
"DataBuffer.java:220"$0$""
"DataBuffer.java:221"$0$"	/**"
"DataBuffer.java:222"$1$"	 * Write one or more {@code DataBuffer}s to this buffer, starting at the current"
"DataBuffer.java:223"$0$"	 * writing position. It is the responsibility of the caller to"
"DataBuffer.java:224"$1$"	 * {@linkplain DataBufferUtils#release(DataBuffer) release} the given data buffers."
"DataBuffer.java:225"$0$"	 * @param buffers the byte buffers to write into this buffer"
"DataBuffer.java:226"$0$"	 * @return this buffer"
"DataBuffer.java:227"$0$"	 */"
"DataBuffer.java:228"$0$"	DataBuffer write(DataBuffer... buffers);"
"DataBuffer.java:229"$0$""
"DataBuffer.java:230"$0$"	/**"
"DataBuffer.java:231"$1$"	 * Write one or more {@link ByteBuffer} to this buffer, starting at the current"
"DataBuffer.java:232"$0$"	 * writing position."
"DataBuffer.java:233"$0$"	 * @param buffers the byte buffers to write into this buffer"
"DataBuffer.java:234"$0$"	 * @return this buffer"
"DataBuffer.java:235"$0$"	 */"
"DataBuffer.java:236"$0$"	DataBuffer write(ByteBuffer... buffers);"
"DataBuffer.java:237"$0$""
"DataBuffer.java:238"$0$"	/**"
"DataBuffer.java:239"$1$"	 * Write the given {@code CharSequence} using the given {@code Charset},"
"DataBuffer.java:240"$0$"	 * starting at the current writing position."
"DataBuffer.java:241"$0$"	 * @param charSequence the char sequence to write into this buffer"
"DataBuffer.java:242"$0$"	 * @param charset the charset to encode the char sequence with"
"DataBuffer.java:243"$0$"	 * @return this buffer"
"DataBuffer.java:244"$0$"	 * @since 5.1.4"
"DataBuffer.java:245"$0$"	 */"
"DataBuffer.java:246"$1$"	default DataBuffer write(CharSequence charSequence, Charset charset) {"
"DataBuffer.java:247"$1$"		Assert.notNull(charSequence, ""CharSequence must not be null"");"
"DataBuffer.java:248"$1$"		Assert.notNull(charset, ""Charset must not be null"");"
"DataBuffer.java:249"$1$"		if (charSequence.length() != 0) {"
"DataBuffer.java:250"$1$"			CharsetEncoder charsetEncoder = charset.newEncoder()"
"DataBuffer.java:251"$1$"					.onMalformedInput(CodingErrorAction.REPLACE)"
"DataBuffer.java:252"$1$"					.onUnmappableCharacter(CodingErrorAction.REPLACE);"
"DataBuffer.java:253"$1$"			CharBuffer inBuffer = CharBuffer.wrap(charSequence);"
"DataBuffer.java:254"$1$"			int estimatedSize = (int) (inBuffer.remaining() * charsetEncoder.averageBytesPerChar());"
"DataBuffer.java:255"$1$"			ByteBuffer outBuffer = ensureCapacity(estimatedSize)"
"DataBuffer.java:256"$1$"					.asByteBuffer(writePosition(), writableByteCount());"
"DataBuffer.java:257"$1$"			while (true) {"
"DataBuffer.java:258"$1$"				CoderResult cr = (inBuffer.hasRemaining() ?"
"DataBuffer.java:259"$1$"						charsetEncoder.encode(inBuffer, outBuffer, true) : CoderResult.UNDERFLOW);"
"DataBuffer.java:260"$1$"				if (cr.isUnderflow()) {"
"DataBuffer.java:261"$1$"					cr = charsetEncoder.flush(outBuffer);"
"DataBuffer.java:262"$1$"				}"
"DataBuffer.java:263"$1$"				if (cr.isUnderflow()) {"
"DataBuffer.java:264"$1$"					break;"
"DataBuffer.java:265"$1$"				}"
"DataBuffer.java:266"$1$"				if (cr.isOverflow()) {"
"DataBuffer.java:267"$1$"					writePosition(writePosition() + outBuffer.position());"
"DataBuffer.java:268"$1$"					int maximumSize = (int) (inBuffer.remaining() * charsetEncoder.maxBytesPerChar());"
"DataBuffer.java:269"$1$"					ensureCapacity(maximumSize);"
"DataBuffer.java:270"$1$"					outBuffer = asByteBuffer(writePosition(), writableByteCount());"
"DataBuffer.java:271"$1$"				}"
"DataBuffer.java:272"$0$"			}"
"DataBuffer.java:273"$0$"			writePosition(writePosition() + outBuffer.position());"
"DataBuffer.java:274"$0$"		}"
"DataBuffer.java:275"$0$"		return this;"
"DataBuffer.java:276"$0$"	}"
"DataBuffer.java:277"$0$""
"DataBuffer.java:278"$0$"	/**"
"DataBuffer.java:279"$1$"	 * Create a new {@code DataBuffer} whose contents is a shared subsequence of this"
"DataBuffer.java:280"$0$"	 * data buffer's content.  Data between this data buffer and the returned buffer is"
"DataBuffer.java:281"$0$"	 * shared; though changes in the returned buffer's position will not be reflected"
"DataBuffer.java:282"$0$"	 * in the reading nor writing position of this data buffer."
"DataBuffer.java:283"$0$"	 * <p><strong>Note</strong> that this method will <strong>not</strong> call"
"DataBuffer.java:284"$1$"	 * {@link DataBufferUtils#retain(DataBuffer)} on the resulting slice: the reference"
"DataBuffer.java:285"$0$"	 * count will not be increased."
"DataBuffer.java:286"$0$"	 * @param index the index at which to start the slice"
"DataBuffer.java:287"$0$"	 * @param length the length of the slice"
"DataBuffer.java:288"$0$"	 * @return the specified slice of this data buffer"
"DataBuffer.java:289"$0$"	 */"
"DataBuffer.java:290"$0$"	DataBuffer slice(int index, int length);"
"DataBuffer.java:291"$0$""
"DataBuffer.java:292"$0$"	/**"
"DataBuffer.java:293"$1$"	 * Create a new {@code DataBuffer} whose contents is a shared, retained subsequence of this"
"DataBuffer.java:294"$0$"	 * data buffer's content.  Data between this data buffer and the returned buffer is"
"DataBuffer.java:295"$0$"	 * shared; though changes in the returned buffer's position will not be reflected"
"DataBuffer.java:296"$0$"	 * in the reading nor writing position of this data buffer."
"DataBuffer.java:297"$1$"	 * <p><strong>Note</strong> that unlike {@link #slice(int, int)}, this method"
"DataBuffer.java:298"$1$"	 * <strong>will</strong> call {@link DataBufferUtils#retain(DataBuffer)} (or equivalent) on the"
"DataBuffer.java:299"$0$"	 * resulting slice."
"DataBuffer.java:300"$0$"	 * @param index the index at which to start the slice"
"DataBuffer.java:301"$0$"	 * @param length the length of the slice"
"DataBuffer.java:302"$0$"	 * @return the specified, retained slice of this data buffer"
"DataBuffer.java:303"$0$"	 * @since 5.2"
"DataBuffer.java:304"$0$"	 */"
"DataBuffer.java:305"$1$"	default DataBuffer retainedSlice(int index, int length) {"
"DataBuffer.java:306"$1$"		return DataBufferUtils.retain(slice(index, length));"
"DataBuffer.java:307"$1$"	}"
"DataBuffer.java:308"$0$""
"DataBuffer.java:309"$0$"	/**"
"DataBuffer.java:310"$1$"	 * Expose this buffer's bytes as a {@link ByteBuffer}. Data between this"
"DataBuffer.java:311"$1$"	 * {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though"
"DataBuffer.java:312"$1$"	 * changes in the returned buffer's {@linkplain ByteBuffer#position() position}"
"DataBuffer.java:313"$0$"	 * will not be reflected in the reading nor writing position of this data buffer."
"DataBuffer.java:314"$0$"	 * @return this data buffer as a byte buffer"
"DataBuffer.java:315"$0$"	 */"
"DataBuffer.java:316"$0$"	ByteBuffer asByteBuffer();"
"DataBuffer.java:317"$0$""
"DataBuffer.java:318"$0$"	/**"
"DataBuffer.java:319"$1$"	 * Expose a subsequence of this buffer's bytes as a {@link ByteBuffer}. Data between"
"DataBuffer.java:320"$1$"	 * this {@code DataBuffer} and the returned {@code ByteBuffer} is shared; though"
"DataBuffer.java:321"$1$"	 * changes in the returned buffer's {@linkplain ByteBuffer#position() position}"
"DataBuffer.java:322"$0$"	 * will not be reflected in the reading nor writing position of this data buffer."
"DataBuffer.java:323"$0$"	 * @param index the index at which to start the byte buffer"
"DataBuffer.java:324"$0$"	 * @param length the length of the returned byte buffer"
"DataBuffer.java:325"$0$"	 * @return this data buffer as a byte buffer"
"DataBuffer.java:326"$0$"	 * @since 5.0.1"
"DataBuffer.java:327"$0$"	 */"
"DataBuffer.java:328"$0$"	ByteBuffer asByteBuffer(int index, int length);"
"DataBuffer.java:329"$0$""
"DataBuffer.java:330"$0$"	/**"
"DataBuffer.java:331"$1$"	 * Expose this buffer's data as an {@link InputStream}. Both data and read position are"
"DataBuffer.java:332"$0$"	 * shared between the returned stream and this data buffer. The underlying buffer will"
"DataBuffer.java:333"$1$"	 * <strong>not</strong> be {@linkplain DataBufferUtils#release(DataBuffer) released}"
"DataBuffer.java:334"$1$"	 * when the input stream is {@linkplain InputStream#close() closed}."
"DataBuffer.java:335"$0$"	 * @return this data buffer as an input stream"
"DataBuffer.java:336"$0$"	 * @see #asInputStream(boolean)"
"DataBuffer.java:337"$0$"	 */"
"DataBuffer.java:338"$0$"	InputStream asInputStream();"
"DataBuffer.java:339"$0$""
"DataBuffer.java:340"$0$"	/**"
"DataBuffer.java:341"$1$"	 * Expose this buffer's data as an {@link InputStream}. Both data and read position are"
"DataBuffer.java:342"$0$"	 * shared between the returned stream and this data buffer."
"DataBuffer.java:343"$0$"	 * @param releaseOnClose whether the underlying buffer will be"
"DataBuffer.java:344"$1$"	 * {@linkplain DataBufferUtils#release(DataBuffer) released} when the input stream is"
"DataBuffer.java:345"$1$"	 * {@linkplain InputStream#close() closed}."
"DataBuffer.java:346"$0$"	 * @return this data buffer as an input stream"
"DataBuffer.java:347"$0$"	 * @since 5.0.4"
"DataBuffer.java:348"$0$"	 */"
"DataBuffer.java:349"$0$"	InputStream asInputStream(boolean releaseOnClose);"
"DataBuffer.java:350"$0$""
"DataBuffer.java:351"$0$"	/**"
"DataBuffer.java:352"$1$"	 * Expose this buffer's data as an {@link OutputStream}. Both data and write position are"
"DataBuffer.java:353"$0$"	 * shared between the returned stream and this data buffer."
"DataBuffer.java:354"$0$"	 * @return this data buffer as an output stream"
"DataBuffer.java:355"$0$"	 */"
"DataBuffer.java:356"$0$"	OutputStream asOutputStream();"
"DataBuffer.java:357"$0$""
"DataBuffer.java:358"$0$"	/**"
"DataBuffer.java:359"$0$"	 * Return this buffer's data a String using the specified charset. Default implementation"
"DataBuffer.java:360"$1$"	 * delegates to {@code toString(readPosition(), readableByteCount(), charset)}."
"DataBuffer.java:361"$0$"	 * @param charset the character set to use"
"DataBuffer.java:362"$0$"	 * @return a string representation of all this buffers data"
"DataBuffer.java:363"$0$"	 * @since 5.2"
"DataBuffer.java:364"$0$"	 */"
"DataBuffer.java:365"$1$"	default String toString(Charset charset) {"
"DataBuffer.java:366"$1$"		Assert.notNull(charset, ""Charset must not be null"");"
"DataBuffer.java:367"$1$"		return toString(readPosition(), readableByteCount(), charset);"
"DataBuffer.java:368"$1$"	}"
"DataBuffer.java:369"$0$""
"DataBuffer.java:370"$0$"	/**"
"DataBuffer.java:371"$0$"	 * Return a part of this buffer's data as a String using the specified charset."
"DataBuffer.java:372"$0$"	 * @param index the index at which to start the string"
"DataBuffer.java:373"$0$"	 * @param length the number of bytes to use for the string"
"DataBuffer.java:374"$0$"	 * @param charset the charset to use"
"DataBuffer.java:375"$0$"	 * @return a string representation of a part of this buffers data"
"DataBuffer.java:376"$0$"	 * @since 5.2"
"DataBuffer.java:377"$0$"	 */"
"DataBuffer.java:378"$0$"	String toString(int index, int length, Charset charset);"
"DataBuffer.java:379"$0$""
"DataBuffer.java:380"$0$"}"
"TypeDescriptor.java:1"$0$"/*"
"TypeDescriptor.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"TypeDescriptor.java:3"$0$" *"
"TypeDescriptor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"TypeDescriptor.java:5"$0$" * you may not use this file except in compliance with the License."
"TypeDescriptor.java:6"$0$" * You may obtain a copy of the License at"
"TypeDescriptor.java:7"$0$" *"
"TypeDescriptor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"TypeDescriptor.java:9"$0$" *"
"TypeDescriptor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"TypeDescriptor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"TypeDescriptor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"TypeDescriptor.java:13"$0$" * See the License for the specific language governing permissions and"
"TypeDescriptor.java:14"$0$" * limitations under the License."
"TypeDescriptor.java:15"$0$" */"
"TypeDescriptor.java:16"$0$""
"TypeDescriptor.java:17"$0$"package org.springframework.core.convert;"
"TypeDescriptor.java:18"$0$""
"TypeDescriptor.java:19"$0$"import java.io.Serializable;"
"TypeDescriptor.java:20"$0$"import java.lang.annotation.Annotation;"
"TypeDescriptor.java:21"$0$"import java.lang.reflect.AnnotatedElement;"
"TypeDescriptor.java:22"$0$"import java.lang.reflect.Field;"
"TypeDescriptor.java:23"$0$"import java.lang.reflect.Type;"
"TypeDescriptor.java:24"$0$"import java.util.Arrays;"
"TypeDescriptor.java:25"$0$"import java.util.Collection;"
"TypeDescriptor.java:26"$0$"import java.util.HashMap;"
"TypeDescriptor.java:27"$0$"import java.util.Map;"
"TypeDescriptor.java:28"$0$"import java.util.stream.Stream;"
"TypeDescriptor.java:29"$0$""
"TypeDescriptor.java:30"$0$"import org.springframework.core.MethodParameter;"
"TypeDescriptor.java:31"$0$"import org.springframework.core.ResolvableType;"
"TypeDescriptor.java:32"$0$"import org.springframework.core.annotation.AnnotatedElementUtils;"
"TypeDescriptor.java:33"$0$"import org.springframework.lang.Nullable;"
"TypeDescriptor.java:34"$0$"import org.springframework.util.Assert;"
"TypeDescriptor.java:35"$0$"import org.springframework.util.ClassUtils;"
"TypeDescriptor.java:36"$0$"import org.springframework.util.ObjectUtils;"
"TypeDescriptor.java:37"$0$""
"TypeDescriptor.java:38"$0$"/**"
"TypeDescriptor.java:39"$0$" * Contextual descriptor about a type to convert from or to."
"TypeDescriptor.java:40"$0$" * Capable of representing arrays and generic collection types."
"TypeDescriptor.java:41"$0$" *"
"TypeDescriptor.java:42"$0$" * @author Keith Donald"
"TypeDescriptor.java:43"$0$" * @author Andy Clement"
"TypeDescriptor.java:44"$0$" * @author Juergen Hoeller"
"TypeDescriptor.java:45"$0$" * @author Phillip Webb"
"TypeDescriptor.java:46"$0$" * @author Sam Brannen"
"TypeDescriptor.java:47"$0$" * @author Stephane Nicoll"
"TypeDescriptor.java:48"$0$" * @since 3.0"
"TypeDescriptor.java:49"$0$" * @see ConversionService#canConvert(TypeDescriptor, TypeDescriptor)"
"TypeDescriptor.java:50"$0$" * @see ConversionService#convert(Object, TypeDescriptor, TypeDescriptor)"
"TypeDescriptor.java:51"$0$" */"
"TypeDescriptor.java:52"$0$"SuppressWarnings(""serial"")"
"TypeDescriptor.java:53"$1$"public class TypeDescriptor implements Serializable {"
"TypeDescriptor.java:54"$1$""
"TypeDescriptor.java:55"$1$"	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];"
"TypeDescriptor.java:56"$1$""
"TypeDescriptor.java:57"$1$"	private static final Map<Class<?>, TypeDescriptor> commonTypesCache = new HashMap<>(32);"
"TypeDescriptor.java:58"$1$""
"TypeDescriptor.java:59"$1$"	private static final Class<?>[] CACHED_COMMON_TYPES = {"
"TypeDescriptor.java:60"$1$"			boolean.class, Boolean.class, byte.class, Byte.class, char.class, Character.class,"
"TypeDescriptor.java:61"$1$"			double.class, Double.class, float.class, Float.class, int.class, Integer.class,"
"TypeDescriptor.java:62"$1$"			long.class, Long.class, short.class, Short.class, String.class, Object.class};"
"TypeDescriptor.java:63"$0$""
"TypeDescriptor.java:64"$1$"	static {"
"TypeDescriptor.java:65"$1$"		for (Class<?> preCachedClass : CACHED_COMMON_TYPES) {"
"TypeDescriptor.java:66"$1$"			commonTypesCache.put(preCachedClass, valueOf(preCachedClass));"
"TypeDescriptor.java:67"$1$"		}"
"TypeDescriptor.java:68"$0$"	}"
"TypeDescriptor.java:69"$0$""
"TypeDescriptor.java:70"$0$""
"TypeDescriptor.java:71"$0$"	private final Class<?> type;"
"TypeDescriptor.java:72"$0$""
"TypeDescriptor.java:73"$0$"	private final ResolvableType resolvableType;"
"TypeDescriptor.java:74"$0$""
"TypeDescriptor.java:75"$0$"	private final AnnotatedElementAdapter annotatedElement;"
"TypeDescriptor.java:76"$0$""
"TypeDescriptor.java:77"$0$""
"TypeDescriptor.java:78"$0$"	/**"
"TypeDescriptor.java:79"$1$"	 * Create a new type descriptor from a {@link MethodParameter}."
"TypeDescriptor.java:80"$0$"	 * <p>Use this constructor when a source or target conversion point is a"
"TypeDescriptor.java:81"$0$"	 * constructor parameter, method parameter, or method return value."
"TypeDescriptor.java:82"$0$"	 * @param methodParameter the method parameter"
"TypeDescriptor.java:83"$0$"	 */"
"TypeDescriptor.java:84"$1$"	public TypeDescriptor(MethodParameter methodParameter) {"
"TypeDescriptor.java:85"$1$"		this.resolvableType = ResolvableType.forMethodParameter(methodParameter);"
"TypeDescriptor.java:86"$1$"		this.type = this.resolvableType.resolve(methodParameter.getNestedParameterType());"
"TypeDescriptor.java:87"$1$"		this.annotatedElement = new AnnotatedElementAdapter(methodParameter.getParameterIndex() == -1 ?"
"TypeDescriptor.java:88"$1$"				methodParameter.getMethodAnnotations() : methodParameter.getParameterAnnotations());"
"TypeDescriptor.java:89"$1$"	}"
"TypeDescriptor.java:90"$0$""
"TypeDescriptor.java:91"$0$"	/**"
"TypeDescriptor.java:92"$1$"	 * Create a new type descriptor from a {@link Field}."
"TypeDescriptor.java:93"$0$"	 * <p>Use this constructor when a source or target conversion point is a field."
"TypeDescriptor.java:94"$0$"	 * @param field the field"
"TypeDescriptor.java:95"$0$"	 */"
"TypeDescriptor.java:96"$1$"	public TypeDescriptor(Field field) {"
"TypeDescriptor.java:97"$1$"		this.resolvableType = ResolvableType.forField(field);"
"TypeDescriptor.java:98"$1$"		this.type = this.resolvableType.resolve(field.getType());"
"TypeDescriptor.java:99"$1$"		this.annotatedElement = new AnnotatedElementAdapter(field.getAnnotations());"
"TypeDescriptor.java:100"$1$"	}"
"TypeDescriptor.java:101"$0$""
"TypeDescriptor.java:102"$0$"	/**"
"TypeDescriptor.java:103"$1$"	 * Create a new type descriptor from a {@link Property}."
"TypeDescriptor.java:104"$0$"	 * <p>Use this constructor when a source or target conversion point is a"
"TypeDescriptor.java:105"$0$"	 * property on a Java class."
"TypeDescriptor.java:106"$0$"	 * @param property the property"
"TypeDescriptor.java:107"$0$"	 */"
"TypeDescriptor.java:108"$1$"	public TypeDescriptor(Property property) {"
"TypeDescriptor.java:109"$1$"		Assert.notNull(property, ""Property must not be null"");"
"TypeDescriptor.java:110"$1$"		this.resolvableType = ResolvableType.forMethodParameter(property.getMethodParameter());"
"TypeDescriptor.java:111"$1$"		this.type = this.resolvableType.resolve(property.getType());"
"TypeDescriptor.java:112"$1$"		this.annotatedElement = new AnnotatedElementAdapter(property.getAnnotations());"
"TypeDescriptor.java:113"$1$"	}"
"TypeDescriptor.java:114"$0$""
"TypeDescriptor.java:115"$0$"	/**"
"TypeDescriptor.java:116"$1$"	 * Create a new type descriptor from a {@link ResolvableType}."
"TypeDescriptor.java:117"$0$"	 * <p>This constructor is used internally and may also be used by subclasses"
"TypeDescriptor.java:118"$0$"	 * that support non-Java languages with extended type systems. It is public"
"TypeDescriptor.java:119"$0$"	 * as of 5.1.4 whereas it was protected before."
"TypeDescriptor.java:120"$0$"	 * @param resolvableType the resolvable type"
"TypeDescriptor.java:121"$1$"	 * @param type the backing type (or {@code null} if it should get resolved)"
"TypeDescriptor.java:122"$0$"	 * @param annotations the type annotations"
"TypeDescriptor.java:123"$0$"	 * @since 4.0"
"TypeDescriptor.java:124"$0$"	 */"
"TypeDescriptor.java:125"$1$"	public TypeDescriptor(ResolvableType resolvableType, @Nullable Class<?> type, @Nullable Annotation[] annotations) {"
"TypeDescriptor.java:126"$1$"		this.resolvableType = resolvableType;"
"TypeDescriptor.java:127"$1$"		this.type = (type != null ? type : resolvableType.toClass());"
"TypeDescriptor.java:128"$1$"		this.annotatedElement = new AnnotatedElementAdapter(annotations);"
"TypeDescriptor.java:129"$1$"	}"
"TypeDescriptor.java:130"$0$""
"TypeDescriptor.java:131"$0$""
"TypeDescriptor.java:132"$0$"	/**"
"TypeDescriptor.java:133"$1$"	 * Variation of {@link #getType()} that accounts for a primitive type by"
"TypeDescriptor.java:134"$0$"	 * returning its object wrapper type."
"TypeDescriptor.java:135"$0$"	 * <p>This is useful for conversion service implementations that wish to"
"TypeDescriptor.java:136"$0$"	 * normalize to object-based types and not work with primitive types directly."
"TypeDescriptor.java:137"$0$"	 */"
"TypeDescriptor.java:138"$1$"	public Class<?> getObjectType() {"
"TypeDescriptor.java:139"$1$"		return ClassUtils.resolvePrimitiveIfNecessary(getType());"
"TypeDescriptor.java:140"$1$"	}"
"TypeDescriptor.java:141"$0$""
"TypeDescriptor.java:142"$0$"	/**"
"TypeDescriptor.java:143"$0$"	 * The type of the backing class, method parameter, field, or property"
"TypeDescriptor.java:144"$0$"	 * described by this TypeDescriptor."
"TypeDescriptor.java:145"$1$"	 * <p>Returns primitive types as-is. See {@link #getObjectType()} for a"
"TypeDescriptor.java:146"$0$"	 * variation of this operation that resolves primitive types to their"
"TypeDescriptor.java:147"$0$"	 * corresponding Object types if necessary."
"TypeDescriptor.java:148"$0$"	 * @see #getObjectType()"
"TypeDescriptor.java:149"$0$"	 */"
"TypeDescriptor.java:150"$1$"	public Class<?> getType() {"
"TypeDescriptor.java:151"$1$"		return this.type;"
"TypeDescriptor.java:152"$1$"	}"
"TypeDescriptor.java:153"$0$""
"TypeDescriptor.java:154"$0$"	/**"
"TypeDescriptor.java:155"$1$"	 * Return the underlying {@link ResolvableType}."
"TypeDescriptor.java:156"$0$"	 * @since 4.0"
"TypeDescriptor.java:157"$0$"	 */"
"TypeDescriptor.java:158"$1$"	public ResolvableType getResolvableType() {"
"TypeDescriptor.java:159"$1$"		return this.resolvableType;"
"TypeDescriptor.java:160"$1$"	}"
"TypeDescriptor.java:161"$0$""
"TypeDescriptor.java:162"$0$"	/**"
"TypeDescriptor.java:163"$1$"	 * Return the underlying source of the descriptor. Will return a {@link Field},"
"TypeDescriptor.java:164"$1$"	 * {@link MethodParameter} or {@link Type} depending on how the {@link TypeDescriptor}"
"TypeDescriptor.java:165"$0$"	 * was constructed. This method is primarily to provide access to additional"
"TypeDescriptor.java:166"$0$"	 * type information or meta-data that alternative JVM languages may provide."
"TypeDescriptor.java:167"$0$"	 * @since 4.0"
"TypeDescriptor.java:168"$0$"	 */"
"TypeDescriptor.java:169"$1$"	public Object getSource() {"
"TypeDescriptor.java:170"$1$"		return this.resolvableType.getSource();"
"TypeDescriptor.java:171"$1$"	}"
"TypeDescriptor.java:172"$0$""
"TypeDescriptor.java:173"$0$"	/**"
"TypeDescriptor.java:174"$1$"	 * Narrows this {@link TypeDescriptor} by setting its type to the class of the"
"TypeDescriptor.java:175"$0$"	 * provided value."
"TypeDescriptor.java:176"$1$"	 * <p>If the value is {@code null}, no narrowing is performed and this TypeDescriptor"
"TypeDescriptor.java:177"$0$"	 * is returned unchanged."
"TypeDescriptor.java:178"$0$"	 * <p>Designed to be called by binding frameworks when they read property, field,"
"TypeDescriptor.java:179"$0$"	 * or method return values. Allows such frameworks to narrow a TypeDescriptor built"
"TypeDescriptor.java:180"$0$"	 * from a declared property, field, or method return value type. For example, a field"
"TypeDescriptor.java:181"$1$"	 * declared as {@code java.lang.Object} would be narrowed to {@code java.util.HashMap}"
"TypeDescriptor.java:182"$1$"	 * if it was set to a {@code java.util.HashMap} value. The narrowed TypeDescriptor"
"TypeDescriptor.java:183"$0$"	 * can then be used to convert the HashMap to some other type. Annotation and nested"
"TypeDescriptor.java:184"$0$"	 * type context is preserved by the narrowed copy."
"TypeDescriptor.java:185"$0$"	 * @param value the value to use for narrowing this type descriptor"
"TypeDescriptor.java:186"$0$"	 * @return this TypeDescriptor narrowed (returns a copy with its type updated to the"
"TypeDescriptor.java:187"$0$"	 * class of the provided value)"
"TypeDescriptor.java:188"$0$"	 */"
"TypeDescriptor.java:189"$1$"	public TypeDescriptor narrow(@Nullable Object value) {"
"TypeDescriptor.java:190"$1$"		if (value == null) {"
"TypeDescriptor.java:191"$1$"			return this;"
"TypeDescriptor.java:192"$1$"		}"
"TypeDescriptor.java:193"$0$"		ResolvableType narrowed = ResolvableType.forType(value.getClass(), getResolvableType());"
"TypeDescriptor.java:194"$0$"		return new TypeDescriptor(narrowed, value.getClass(), getAnnotations());"
"TypeDescriptor.java:195"$0$"	}"
"TypeDescriptor.java:196"$0$""
"TypeDescriptor.java:197"$0$"	/**"
"TypeDescriptor.java:198"$1$"	 * Cast this {@link TypeDescriptor} to a superclass or implemented interface"
"TypeDescriptor.java:199"$0$"	 * preserving annotations and nested type context."
"TypeDescriptor.java:200"$1$"	 * @param superType the super type to cast to (can be {@code null})"
"TypeDescriptor.java:201"$0$"	 * @return a new TypeDescriptor for the up-cast type"
"TypeDescriptor.java:202"$0$"	 * @throws IllegalArgumentException if this type is not assignable to the super-type"
"TypeDescriptor.java:203"$0$"	 * @since 3.2"
"TypeDescriptor.java:204"$0$"	 */"
"TypeDescriptor.java:205"$0$"	@Nullable"
"TypeDescriptor.java:206"$1$"	public TypeDescriptor upcast(@Nullable Class<?> superType) {"
"TypeDescriptor.java:207"$1$"		if (superType == null) {"
"TypeDescriptor.java:208"$1$"			return null;"
"TypeDescriptor.java:209"$1$"		}"
"TypeDescriptor.java:210"$0$"		Assert.isAssignable(superType, getType());"
"TypeDescriptor.java:211"$0$"		return new TypeDescriptor(getResolvableType().as(superType), superType, getAnnotations());"
"TypeDescriptor.java:212"$0$"	}"
"TypeDescriptor.java:213"$0$""
"TypeDescriptor.java:214"$0$"	/**"
"TypeDescriptor.java:215"$0$"	 * Return the name of this type: the fully qualified class name."
"TypeDescriptor.java:216"$0$"	 */"
"TypeDescriptor.java:217"$1$"	public String getName() {"
"TypeDescriptor.java:218"$1$"		return ClassUtils.getQualifiedName(getType());"
"TypeDescriptor.java:219"$1$"	}"
"TypeDescriptor.java:220"$0$""
"TypeDescriptor.java:221"$0$"	/**"
"TypeDescriptor.java:222"$0$"	 * Is this type a primitive type?"
"TypeDescriptor.java:223"$0$"	 */"
"TypeDescriptor.java:224"$1$"	public boolean isPrimitive() {"
"TypeDescriptor.java:225"$1$"		return getType().isPrimitive();"
"TypeDescriptor.java:226"$1$"	}"
"TypeDescriptor.java:227"$0$""
"TypeDescriptor.java:228"$0$"	/**"
"TypeDescriptor.java:229"$0$"	 * Return the annotations associated with this type descriptor, if any."
"TypeDescriptor.java:230"$0$"	 * @return the annotations, or an empty array if none"
"TypeDescriptor.java:231"$0$"	 */"
"TypeDescriptor.java:232"$1$"	public Annotation[] getAnnotations() {"
"TypeDescriptor.java:233"$1$"		return this.annotatedElement.getAnnotations();"
"TypeDescriptor.java:234"$1$"	}"
"TypeDescriptor.java:235"$0$""
"TypeDescriptor.java:236"$0$"	/**"
"TypeDescriptor.java:237"$0$"	 * Determine if this type descriptor has the specified annotation."
"TypeDescriptor.java:238"$0$"	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels"
"TypeDescriptor.java:239"$0$"	 * of meta-annotations."
"TypeDescriptor.java:240"$0$"	 * @param annotationType the annotation type"
"TypeDescriptor.java:241"$0$"	 * @return <tt>true</tt> if the annotation is present"
"TypeDescriptor.java:242"$0$"	 */"
"TypeDescriptor.java:243"$1$"	public boolean hasAnnotation(Class<? extends Annotation> annotationType) {"
"TypeDescriptor.java:244"$1$"		if (this.annotatedElement.isEmpty()) {"
"TypeDescriptor.java:245"$0$"			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()"
"TypeDescriptor.java:246"$0$"			// to return a copy of the array, whereas we can do it more efficiently here."
"TypeDescriptor.java:247"$1$"			return false;"
"TypeDescriptor.java:248"$1$"		}"
"TypeDescriptor.java:249"$0$"		return AnnotatedElementUtils.isAnnotated(this.annotatedElement, annotationType);"
"TypeDescriptor.java:250"$0$"	}"
"TypeDescriptor.java:251"$0$""
"TypeDescriptor.java:252"$0$"	/**"
"TypeDescriptor.java:253"$1$"	 * Obtain the annotation of the specified {@code annotationType} that is on this type descriptor."
"TypeDescriptor.java:254"$0$"	 * <p>As of Spring Framework 4.2, this method supports arbitrary levels of meta-annotations."
"TypeDescriptor.java:255"$0$"	 * @param annotationType the annotation type"
"TypeDescriptor.java:256"$1$"	 * @return the annotation, or {@code null} if no such annotation exists on this type descriptor"
"TypeDescriptor.java:257"$0$"	 */"
"TypeDescriptor.java:258"$0$"	@Nullable"
"TypeDescriptor.java:259"$1$"	public <T extends Annotation> T getAnnotation(Class<T> annotationType) {"
"TypeDescriptor.java:260"$1$"		if (this.annotatedElement.isEmpty()) {"
"TypeDescriptor.java:261"$0$"			// Shortcut: AnnotatedElementUtils would have to expect AnnotatedElement.getAnnotations()"
"TypeDescriptor.java:262"$0$"			// to return a copy of the array, whereas we can do it more efficiently here."
"TypeDescriptor.java:263"$1$"			return null;"
"TypeDescriptor.java:264"$1$"		}"
"TypeDescriptor.java:265"$0$"		return AnnotatedElementUtils.getMergedAnnotation(this.annotatedElement, annotationType);"
"TypeDescriptor.java:266"$0$"	}"
"TypeDescriptor.java:267"$0$""
"TypeDescriptor.java:268"$0$"	/**"
"TypeDescriptor.java:269"$0$"	 * Returns true if an object of this type descriptor can be assigned to the location"
"TypeDescriptor.java:270"$0$"	 * described by the given type descriptor."
"TypeDescriptor.java:271"$1$"	 * <p>For example, {@code valueOf(String.class).isAssignableTo(valueOf(CharSequence.class))}"
"TypeDescriptor.java:272"$1$"	 * returns {@code true} because a String value can be assigned to a CharSequence variable."
"TypeDescriptor.java:273"$1$"	 * On the other hand, {@code valueOf(Number.class).isAssignableTo(valueOf(Integer.class))}"
"TypeDescriptor.java:274"$1$"	 * returns {@code false} because, while all Integers are Numbers, not all Numbers are Integers."
"TypeDescriptor.java:275"$0$"	 * <p>For arrays, collections, and maps, element and key/value types are checked if declared."
"TypeDescriptor.java:276"$0$"	 * For example, a List&lt;String&gt; field value is assignable to a Collection&lt;CharSequence&gt;"
"TypeDescriptor.java:277"$0$"	 * field, but List&lt;Number&gt; is not assignable to List&lt;Integer&gt;."
"TypeDescriptor.java:278"$1$"	 * @return {@code true} if this type is assignable to the type represented by the provided"
"TypeDescriptor.java:279"$0$"	 * type descriptor"
"TypeDescriptor.java:280"$0$"	 * @see #getObjectType()"
"TypeDescriptor.java:281"$0$"	 */"
"TypeDescriptor.java:282"$1$"	public boolean isAssignableTo(TypeDescriptor typeDescriptor) {"
"TypeDescriptor.java:283"$1$"		boolean typesAssignable = typeDescriptor.getObjectType().isAssignableFrom(getObjectType());"
"TypeDescriptor.java:284"$1$"		if (!typesAssignable) {"
"TypeDescriptor.java:285"$1$"			return false;"
"TypeDescriptor.java:286"$1$"		}"
"TypeDescriptor.java:287"$1$"		if (isArray() && typeDescriptor.isArray()) {"
"TypeDescriptor.java:288"$1$"			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());"
"TypeDescriptor.java:289"$1$"		}"
"TypeDescriptor.java:290"$1$"		else if (isCollection() && typeDescriptor.isCollection()) {"
"TypeDescriptor.java:291"$1$"			return isNestedAssignable(getElementTypeDescriptor(), typeDescriptor.getElementTypeDescriptor());"
"TypeDescriptor.java:292"$1$"		}"
"TypeDescriptor.java:293"$1$"		else if (isMap() && typeDescriptor.isMap()) {"
"TypeDescriptor.java:294"$1$"			return isNestedAssignable(getMapKeyTypeDescriptor(), typeDescriptor.getMapKeyTypeDescriptor()) &&"
"TypeDescriptor.java:295"$1$"				isNestedAssignable(getMapValueTypeDescriptor(), typeDescriptor.getMapValueTypeDescriptor());"
"TypeDescriptor.java:296"$1$"		}"
"TypeDescriptor.java:297"$1$"		else {"
"TypeDescriptor.java:298"$1$"			return true;"
"TypeDescriptor.java:299"$1$"		}"
"TypeDescriptor.java:300"$0$"	}"
"TypeDescriptor.java:301"$0$""
"TypeDescriptor.java:302"$0$"	private boolean isNestedAssignable(@Nullable TypeDescriptor nestedTypeDescriptor,"
"TypeDescriptor.java:303"$1$"			@Nullable TypeDescriptor otherNestedTypeDescriptor) {"
"TypeDescriptor.java:304"$1$""
"TypeDescriptor.java:305"$1$"		return (nestedTypeDescriptor == null || otherNestedTypeDescriptor == null ||"
"TypeDescriptor.java:306"$1$"				nestedTypeDescriptor.isAssignableTo(otherNestedTypeDescriptor));"
"TypeDescriptor.java:307"$1$"	}"
"TypeDescriptor.java:308"$0$""
"TypeDescriptor.java:309"$0$"	/**"
"TypeDescriptor.java:310"$1$"	 * Is this type a {@link Collection} type?"
"TypeDescriptor.java:311"$0$"	 */"
"TypeDescriptor.java:312"$1$"	public boolean isCollection() {"
"TypeDescriptor.java:313"$1$"		return Collection.class.isAssignableFrom(getType());"
"TypeDescriptor.java:314"$1$"	}"
"TypeDescriptor.java:315"$0$""
"TypeDescriptor.java:316"$0$"	/**"
"TypeDescriptor.java:317"$0$"	 * Is this type an array type?"
"TypeDescriptor.java:318"$0$"	 */"
"TypeDescriptor.java:319"$1$"	public boolean isArray() {"
"TypeDescriptor.java:320"$1$"		return getType().isArray();"
"TypeDescriptor.java:321"$1$"	}"
"TypeDescriptor.java:322"$0$""
"TypeDescriptor.java:323"$0$"	/**"
"TypeDescriptor.java:324"$0$"	 * If this type is an array, returns the array's component type."
"TypeDescriptor.java:325"$1$"	 * If this type is a {@code Stream}, returns the stream's component type."
"TypeDescriptor.java:326"$1$"	 * If this type is a {@link Collection} and it is parameterized, returns the Collection's element type."
"TypeDescriptor.java:327"$1$"	 * If the Collection is not parameterized, returns {@code null} indicating the element type is not declared."
"TypeDescriptor.java:328"$1$"	 * @return the array component type or Collection element type, or {@code null} if this type is not"
"TypeDescriptor.java:329"$1$"	 * an array type or a {@code java.util.Collection} or if its element type is not parameterized"
"TypeDescriptor.java:330"$0$"	 * @see #elementTypeDescriptor(Object)"
"TypeDescriptor.java:331"$0$"	 */"
"TypeDescriptor.java:332"$0$"	@Nullable"
"TypeDescriptor.java:333"$1$"	public TypeDescriptor getElementTypeDescriptor() {"
"TypeDescriptor.java:334"$1$"		if (getResolvableType().isArray()) {"
"TypeDescriptor.java:335"$1$"			return new TypeDescriptor(getResolvableType().getComponentType(), null, getAnnotations());"
"TypeDescriptor.java:336"$1$"		}"
"TypeDescriptor.java:337"$1$"		if (Stream.class.isAssignableFrom(getType())) {"
"TypeDescriptor.java:338"$1$"			return getRelatedIfResolvable(this, getResolvableType().as(Stream.class).getGeneric(0));"
"TypeDescriptor.java:339"$1$"		}"
"TypeDescriptor.java:340"$0$"		return getRelatedIfResolvable(this, getResolvableType().asCollection().getGeneric(0));"
"TypeDescriptor.java:341"$0$"	}"
"TypeDescriptor.java:342"$0$""
"TypeDescriptor.java:343"$0$"	/**"
"TypeDescriptor.java:344"$1$"	 * If this type is a {@link Collection} or an array, creates a element TypeDescriptor"
"TypeDescriptor.java:345"$0$"	 * from the provided collection or array element."
"TypeDescriptor.java:346"$1$"	 * <p>Narrows the {@link #getElementTypeDescriptor() elementType} property to the class"
"TypeDescriptor.java:347"$0$"	 * of the provided collection or array element. For example, if this describes a"
"TypeDescriptor.java:348"$1$"	 * {@code java.util.List&lt;java.lang.Number&lt;} and the element argument is an"
"TypeDescriptor.java:349"$1$"	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}."
"TypeDescriptor.java:350"$1$"	 * If this describes a {@code java.util.List&lt;?&gt;} and the element argument is an"
"TypeDescriptor.java:351"$1$"	 * {@code java.lang.Integer}, the returned TypeDescriptor will be {@code java.lang.Integer}"
"TypeDescriptor.java:352"$0$"	 * as well."
"TypeDescriptor.java:353"$0$"	 * <p>Annotation and nested type context will be preserved in the narrowed"
"TypeDescriptor.java:354"$0$"	 * TypeDescriptor that is returned."
"TypeDescriptor.java:355"$0$"	 * @param element the collection or array element"
"TypeDescriptor.java:356"$0$"	 * @return a element type descriptor, narrowed to the type of the provided element"
"TypeDescriptor.java:357"$0$"	 * @see #getElementTypeDescriptor()"
"TypeDescriptor.java:358"$0$"	 * @see #narrow(Object)"
"TypeDescriptor.java:359"$0$"	 */"
"TypeDescriptor.java:360"$0$"	@Nullable"
"TypeDescriptor.java:361"$1$"	public TypeDescriptor elementTypeDescriptor(Object element) {"
"TypeDescriptor.java:362"$1$"		return narrow(element, getElementTypeDescriptor());"
"TypeDescriptor.java:363"$1$"	}"
"TypeDescriptor.java:364"$0$""
"TypeDescriptor.java:365"$0$"	/**"
"TypeDescriptor.java:366"$1$"	 * Is this type a {@link Map} type?"
"TypeDescriptor.java:367"$0$"	 */"
"TypeDescriptor.java:368"$1$"	public boolean isMap() {"
"TypeDescriptor.java:369"$1$"		return Map.class.isAssignableFrom(getType());"
"TypeDescriptor.java:370"$1$"	}"
"TypeDescriptor.java:371"$0$""
"TypeDescriptor.java:372"$0$"	/**"
"TypeDescriptor.java:373"$1$"	 * If this type is a {@link Map} and its key type is parameterized,"
"TypeDescriptor.java:374"$0$"	 * returns the map's key type. If the Map's key type is not parameterized,"
"TypeDescriptor.java:375"$1$"	 * returns {@code null} indicating the key type is not declared."
"TypeDescriptor.java:376"$1$"	 * @return the Map key type, or {@code null} if this type is a Map"
"TypeDescriptor.java:377"$0$"	 * but its key type is not parameterized"
"TypeDescriptor.java:378"$1$"	 * @throws IllegalStateException if this type is not a {@code java.util.Map}"
"TypeDescriptor.java:379"$0$"	 */"
"TypeDescriptor.java:380"$0$"	@Nullable"
"TypeDescriptor.java:381"$1$"	public TypeDescriptor getMapKeyTypeDescriptor() {"
"TypeDescriptor.java:382"$1$"		Assert.state(isMap(), ""Not a [java.util.Map]"");"
"TypeDescriptor.java:383"$1$"		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(0));"
"TypeDescriptor.java:384"$1$"	}"
"TypeDescriptor.java:385"$0$""
"TypeDescriptor.java:386"$0$"	/**"
"TypeDescriptor.java:387"$1$"	 * If this type is a {@link Map}, creates a mapKey {@link TypeDescriptor}"
"TypeDescriptor.java:388"$0$"	 * from the provided map key."
"TypeDescriptor.java:389"$1$"	 * <p>Narrows the {@link #getMapKeyTypeDescriptor() mapKeyType} property"
"TypeDescriptor.java:390"$0$"	 * to the class of the provided map key. For example, if this describes a"
"TypeDescriptor.java:391"$1$"	 * {@code java.util.Map&lt;java.lang.Number, java.lang.String&lt;} and the key"
"TypeDescriptor.java:392"$1$"	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be"
"TypeDescriptor.java:393"$1$"	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}"
"TypeDescriptor.java:394"$1$"	 * and the key argument is a {@code java.lang.Integer}, the returned"
"TypeDescriptor.java:395"$1$"	 * TypeDescriptor will be {@code java.lang.Integer} as well."
"TypeDescriptor.java:396"$0$"	 * <p>Annotation and nested type context will be preserved in the narrowed"
"TypeDescriptor.java:397"$0$"	 * TypeDescriptor that is returned."
"TypeDescriptor.java:398"$0$"	 * @param mapKey the map key"
"TypeDescriptor.java:399"$0$"	 * @return the map key type descriptor"
"TypeDescriptor.java:400"$1$"	 * @throws IllegalStateException if this type is not a {@code java.util.Map}"
"TypeDescriptor.java:401"$0$"	 * @see #narrow(Object)"
"TypeDescriptor.java:402"$0$"	 */"
"TypeDescriptor.java:403"$0$"	@Nullable"
"TypeDescriptor.java:404"$1$"	public TypeDescriptor getMapKeyTypeDescriptor(Object mapKey) {"
"TypeDescriptor.java:405"$1$"		return narrow(mapKey, getMapKeyTypeDescriptor());"
"TypeDescriptor.java:406"$1$"	}"
"TypeDescriptor.java:407"$0$""
"TypeDescriptor.java:408"$0$"	/**"
"TypeDescriptor.java:409"$1$"	 * If this type is a {@link Map} and its value type is parameterized,"
"TypeDescriptor.java:410"$0$"	 * returns the map's value type."
"TypeDescriptor.java:411"$1$"	 * <p>If the Map's value type is not parameterized, returns {@code null}"
"TypeDescriptor.java:412"$0$"	 * indicating the value type is not declared."
"TypeDescriptor.java:413"$1$"	 * @return the Map value type, or {@code null} if this type is a Map"
"TypeDescriptor.java:414"$0$"	 * but its value type is not parameterized"
"TypeDescriptor.java:415"$1$"	 * @throws IllegalStateException if this type is not a {@code java.util.Map}"
"TypeDescriptor.java:416"$0$"	 */"
"TypeDescriptor.java:417"$0$"	@Nullable"
"TypeDescriptor.java:418"$1$"	public TypeDescriptor getMapValueTypeDescriptor() {"
"TypeDescriptor.java:419"$1$"		Assert.state(isMap(), ""Not a [java.util.Map]"");"
"TypeDescriptor.java:420"$1$"		return getRelatedIfResolvable(this, getResolvableType().asMap().getGeneric(1));"
"TypeDescriptor.java:421"$1$"	}"
"TypeDescriptor.java:422"$0$""
"TypeDescriptor.java:423"$0$"	/**"
"TypeDescriptor.java:424"$1$"	 * If this type is a {@link Map}, creates a mapValue {@link TypeDescriptor}"
"TypeDescriptor.java:425"$0$"	 * from the provided map value."
"TypeDescriptor.java:426"$1$"	 * <p>Narrows the {@link #getMapValueTypeDescriptor() mapValueType} property"
"TypeDescriptor.java:427"$0$"	 * to the class of the provided map value. For example, if this describes a"
"TypeDescriptor.java:428"$1$"	 * {@code java.util.Map&lt;java.lang.String, java.lang.Number&lt;} and the value"
"TypeDescriptor.java:429"$1$"	 * argument is a {@code java.lang.Integer}, the returned TypeDescriptor will be"
"TypeDescriptor.java:430"$1$"	 * {@code java.lang.Integer}. If this describes a {@code java.util.Map&lt;?, ?&gt;}"
"TypeDescriptor.java:431"$1$"	 * and the value argument is a {@code java.lang.Integer}, the returned"
"TypeDescriptor.java:432"$1$"	 * TypeDescriptor will be {@code java.lang.Integer} as well."
"TypeDescriptor.java:433"$0$"	 * <p>Annotation and nested type context will be preserved in the narrowed"
"TypeDescriptor.java:434"$0$"	 * TypeDescriptor that is returned."
"TypeDescriptor.java:435"$0$"	 * @param mapValue the map value"
"TypeDescriptor.java:436"$0$"	 * @return the map value type descriptor"
"TypeDescriptor.java:437"$1$"	 * @throws IllegalStateException if this type is not a {@code java.util.Map}"
"TypeDescriptor.java:438"$0$"	 * @see #narrow(Object)"
"TypeDescriptor.java:439"$0$"	 */"
"TypeDescriptor.java:440"$0$"	@Nullable"
"TypeDescriptor.java:441"$1$"	public TypeDescriptor getMapValueTypeDescriptor(Object mapValue) {"
"TypeDescriptor.java:442"$1$"		return narrow(mapValue, getMapValueTypeDescriptor());"
"TypeDescriptor.java:443"$1$"	}"
"TypeDescriptor.java:444"$0$""
"TypeDescriptor.java:445"$0$"	@Nullable"
"TypeDescriptor.java:446"$1$"	private TypeDescriptor narrow(@Nullable Object value, @Nullable TypeDescriptor typeDescriptor) {"
"TypeDescriptor.java:447"$1$"		if (typeDescriptor != null) {"
"TypeDescriptor.java:448"$1$"			return typeDescriptor.narrow(value);"
"TypeDescriptor.java:449"$1$"		}"
"TypeDescriptor.java:450"$1$"		if (value != null) {"
"TypeDescriptor.java:451"$1$"			return narrow(value);"
"TypeDescriptor.java:452"$1$"		}"
"TypeDescriptor.java:453"$0$"		return null;"
"TypeDescriptor.java:454"$0$"	}"
"TypeDescriptor.java:455"$0$""
"TypeDescriptor.java:456"$0$"	@Override"
"TypeDescriptor.java:457"$1$"	public boolean equals(@Nullable Object other) {"
"TypeDescriptor.java:458"$1$"		if (this == other) {"
"TypeDescriptor.java:459"$1$"			return true;"
"TypeDescriptor.java:460"$1$"		}"
"TypeDescriptor.java:461"$1$"		if (!(other instanceof TypeDescriptor)) {"
"TypeDescriptor.java:462"$1$"			return false;"
"TypeDescriptor.java:463"$1$"		}"
"TypeDescriptor.java:464"$0$"		TypeDescriptor otherDesc = (TypeDescriptor) other;"
"TypeDescriptor.java:465"$1$"		if (getType() != otherDesc.getType()) {"
"TypeDescriptor.java:466"$1$"			return false;"
"TypeDescriptor.java:467"$1$"		}"
"TypeDescriptor.java:468"$1$"		if (!annotationsMatch(otherDesc)) {"
"TypeDescriptor.java:469"$1$"			return false;"
"TypeDescriptor.java:470"$1$"		}"
"TypeDescriptor.java:471"$1$"		if (isCollection() || isArray()) {"
"TypeDescriptor.java:472"$1$"			return ObjectUtils.nullSafeEquals(getElementTypeDescriptor(), otherDesc.getElementTypeDescriptor());"
"TypeDescriptor.java:473"$1$"		}"
"TypeDescriptor.java:474"$1$"		else if (isMap()) {"
"TypeDescriptor.java:475"$1$"			return (ObjectUtils.nullSafeEquals(getMapKeyTypeDescriptor(), otherDesc.getMapKeyTypeDescriptor()) &&"
"TypeDescriptor.java:476"$1$"					ObjectUtils.nullSafeEquals(getMapValueTypeDescriptor(), otherDesc.getMapValueTypeDescriptor()));"
"TypeDescriptor.java:477"$1$"		}"
"TypeDescriptor.java:478"$1$"		else {"
"TypeDescriptor.java:479"$1$"			return true;"
"TypeDescriptor.java:480"$1$"		}"
"TypeDescriptor.java:481"$0$"	}"
"TypeDescriptor.java:482"$0$""
"TypeDescriptor.java:483"$1$"	private boolean annotationsMatch(TypeDescriptor otherDesc) {"
"TypeDescriptor.java:484"$1$"		Annotation[] anns = getAnnotations();"
"TypeDescriptor.java:485"$1$"		Annotation[] otherAnns = otherDesc.getAnnotations();"
"TypeDescriptor.java:486"$1$"		if (anns == otherAnns) {"
"TypeDescriptor.java:487"$1$"			return true;"
"TypeDescriptor.java:488"$1$"		}"
"TypeDescriptor.java:489"$1$"		if (anns.length != otherAnns.length) {"
"TypeDescriptor.java:490"$1$"			return false;"
"TypeDescriptor.java:491"$1$"		}"
"TypeDescriptor.java:492"$1$"		if (anns.length > 0) {"
"TypeDescriptor.java:493"$1$"			for (int i = 0; i < anns.length; i++) {"
"TypeDescriptor.java:494"$1$"				if (!annotationEquals(anns[i], otherAnns[i])) {"
"TypeDescriptor.java:495"$1$"					return false;"
"TypeDescriptor.java:496"$1$"				}"
"TypeDescriptor.java:497"$0$"			}"
"TypeDescriptor.java:498"$0$"		}"
"TypeDescriptor.java:499"$0$"		return true;"
"TypeDescriptor.java:500"$0$"	}"
"TypeDescriptor.java:501"$0$""
"TypeDescriptor.java:502"$1$"	private boolean annotationEquals(Annotation ann, Annotation otherAnn) {"
"TypeDescriptor.java:503"$0$"		// Annotation.equals is reflective and pretty slow, so let's check identity and proxy type first."
"TypeDescriptor.java:504"$1$"		return (ann == otherAnn || (ann.getClass() == otherAnn.getClass() && ann.equals(otherAnn)));"
"TypeDescriptor.java:505"$1$"	}"
"TypeDescriptor.java:506"$0$""
"TypeDescriptor.java:507"$0$"	@Override"
"TypeDescriptor.java:508"$1$"	public int hashCode() {"
"TypeDescriptor.java:509"$1$"		return getType().hashCode();"
"TypeDescriptor.java:510"$1$"	}"
"TypeDescriptor.java:511"$0$""
"TypeDescriptor.java:512"$0$"	@Override"
"TypeDescriptor.java:513"$1$"	public String toString() {"
"TypeDescriptor.java:514"$1$"		StringBuilder builder = new StringBuilder();"
"TypeDescriptor.java:515"$1$"		for (Annotation ann : getAnnotations()) {"
"TypeDescriptor.java:516"$1$"			builder.append(""@"").append(ann.annotationType().getName()).append(' ');"
"TypeDescriptor.java:517"$1$"		}"
"TypeDescriptor.java:518"$0$"		builder.append(getResolvableType().toString());"
"TypeDescriptor.java:519"$0$"		return builder.toString();"
"TypeDescriptor.java:520"$0$"	}"
"TypeDescriptor.java:521"$0$""
"TypeDescriptor.java:522"$0$""
"TypeDescriptor.java:523"$0$"	/**"
"TypeDescriptor.java:524"$0$"	 * Create a new type descriptor for an object."
"TypeDescriptor.java:525"$0$"	 * <p>Use this factory method to introspect a source object before asking the"
"TypeDescriptor.java:526"$0$"	 * conversion system to convert it to some another type."
"TypeDescriptor.java:527"$1$"	 * <p>If the provided object is {@code null}, returns {@code null}, else calls"
"TypeDescriptor.java:528"$1$"	 * {@link #valueOf(Class)} to build a TypeDescriptor from the object's class."
"TypeDescriptor.java:529"$0$"	 * @param source the source object"
"TypeDescriptor.java:530"$0$"	 * @return the type descriptor"
"TypeDescriptor.java:531"$0$"	 */"
"TypeDescriptor.java:532"$0$"	@Nullable"
"TypeDescriptor.java:533"$1$"	public static TypeDescriptor forObject(@Nullable Object source) {"
"TypeDescriptor.java:534"$1$"		return (source != null ? valueOf(source.getClass()) : null);"
"TypeDescriptor.java:535"$1$"	}"
"TypeDescriptor.java:536"$0$""
"TypeDescriptor.java:537"$0$"	/**"
"TypeDescriptor.java:538"$0$"	 * Create a new type descriptor from the given type."
"TypeDescriptor.java:539"$0$"	 * <p>Use this to instruct the conversion system to convert an object to a"
"TypeDescriptor.java:540"$0$"	 * specific target type, when no type location such as a method parameter or"
"TypeDescriptor.java:541"$0$"	 * field is available to provide additional conversion context."
"TypeDescriptor.java:542"$1$"	 * <p>Generally prefer use of {@link #forObject(Object)} for constructing type"
"TypeDescriptor.java:543"$1$"	 * descriptors from source objects, as it handles the {@code null} object case."
"TypeDescriptor.java:544"$1$"	 * @param type the class (may be {@code null} to indicate {@code Object.class})"
"TypeDescriptor.java:545"$0$"	 * @return the corresponding type descriptor"
"TypeDescriptor.java:546"$0$"	 */"
"TypeDescriptor.java:547"$1$"	public static TypeDescriptor valueOf(@Nullable Class<?> type) {"
"TypeDescriptor.java:548"$1$"		if (type == null) {"
"TypeDescriptor.java:549"$1$"			type = Object.class;"
"TypeDescriptor.java:550"$1$"		}"
"TypeDescriptor.java:551"$0$"		TypeDescriptor desc = commonTypesCache.get(type);"
"TypeDescriptor.java:552"$0$"		return (desc != null ? desc : new TypeDescriptor(ResolvableType.forClass(type), null, null));"
"TypeDescriptor.java:553"$0$"	}"
"TypeDescriptor.java:554"$0$""
"TypeDescriptor.java:555"$0$"	/**"
"TypeDescriptor.java:556"$1$"	 * Create a new type descriptor from a {@link java.util.Collection} type."
"TypeDescriptor.java:557"$0$"	 * <p>Useful for converting to typed Collections."
"TypeDescriptor.java:558"$1$"	 * <p>For example, a {@code List<String>} could be converted to a"
"TypeDescriptor.java:559"$1$"	 * {@code List<EmailAddress>} by converting to a targetType built with this method."
"TypeDescriptor.java:560"$1$"	 * The method call to construct such a {@code TypeDescriptor} would look something"
"TypeDescriptor.java:561"$1$"	 * like: {@code collection(List.class, TypeDescriptor.valueOf(EmailAddress.class));}"
"TypeDescriptor.java:562"$1$"	 * @param collectionType the collection type, which must implement {@link Collection}."
"TypeDescriptor.java:563"$0$"	 * @param elementTypeDescriptor a descriptor for the collection's element type,"
"TypeDescriptor.java:564"$0$"	 * used to convert collection elements"
"TypeDescriptor.java:565"$0$"	 * @return the collection type descriptor"
"TypeDescriptor.java:566"$0$"	 */"
"TypeDescriptor.java:567"$1$"	public static TypeDescriptor collection(Class<?> collectionType, @Nullable TypeDescriptor elementTypeDescriptor) {"
"TypeDescriptor.java:568"$1$"		Assert.notNull(collectionType, ""Collection type must not be null"");"
"TypeDescriptor.java:569"$1$"		if (!Collection.class.isAssignableFrom(collectionType)) {"
"TypeDescriptor.java:570"$1$"			throw new IllegalArgumentException(""Collection type must be a [java.util.Collection]"");"
"TypeDescriptor.java:571"$1$"		}"
"TypeDescriptor.java:572"$0$"		ResolvableType element = (elementTypeDescriptor != null ? elementTypeDescriptor.resolvableType : null);"
"TypeDescriptor.java:573"$0$"		return new TypeDescriptor(ResolvableType.forClassWithGenerics(collectionType, element), null, null);"
"TypeDescriptor.java:574"$0$"	}"
"TypeDescriptor.java:575"$0$""
"TypeDescriptor.java:576"$0$"	/**"
"TypeDescriptor.java:577"$1$"	 * Create a new type descriptor from a {@link java.util.Map} type."
"TypeDescriptor.java:578"$0$"	 * <p>Useful for converting to typed Maps."
"TypeDescriptor.java:579"$0$"	 * <p>For example, a Map&lt;String, String&gt; could be converted to a Map&lt;Id, EmailAddress&gt;"
"TypeDescriptor.java:580"$0$"	 * by converting to a targetType built with this method:"
"TypeDescriptor.java:581"$0$"	 * The method call to construct such a TypeDescriptor would look something like:"
"TypeDescriptor.java:582"$0$"	 * <pre class=""code"">"
"TypeDescriptor.java:583"$0$"	 * map(Map.class, TypeDescriptor.valueOf(Id.class), TypeDescriptor.valueOf(EmailAddress.class));"
"TypeDescriptor.java:584"$0$"	 * </pre>"
"TypeDescriptor.java:585"$1$"	 * @param mapType the map type, which must implement {@link Map}"
"TypeDescriptor.java:586"$0$"	 * @param keyTypeDescriptor a descriptor for the map's key type, used to convert map keys"
"TypeDescriptor.java:587"$0$"	 * @param valueTypeDescriptor the map's value type, used to convert map values"
"TypeDescriptor.java:588"$0$"	 * @return the map type descriptor"
"TypeDescriptor.java:589"$0$"	 */"
"TypeDescriptor.java:590"$0$"	public static TypeDescriptor map(Class<?> mapType, @Nullable TypeDescriptor keyTypeDescriptor,"
"TypeDescriptor.java:591"$1$"			@Nullable TypeDescriptor valueTypeDescriptor) {"
"TypeDescriptor.java:592"$1$""
"TypeDescriptor.java:593"$1$"		Assert.notNull(mapType, ""Map type must not be null"");"
"TypeDescriptor.java:594"$1$"		if (!Map.class.isAssignableFrom(mapType)) {"
"TypeDescriptor.java:595"$1$"			throw new IllegalArgumentException(""Map type must be a [java.util.Map]"");"
"TypeDescriptor.java:596"$1$"		}"
"TypeDescriptor.java:597"$0$"		ResolvableType key = (keyTypeDescriptor != null ? keyTypeDescriptor.resolvableType : null);"
"TypeDescriptor.java:598"$0$"		ResolvableType value = (valueTypeDescriptor != null ? valueTypeDescriptor.resolvableType : null);"
"TypeDescriptor.java:599"$0$"		return new TypeDescriptor(ResolvableType.forClassWithGenerics(mapType, key, value), null, null);"
"TypeDescriptor.java:600"$0$"	}"
"TypeDescriptor.java:601"$0$""
"TypeDescriptor.java:602"$0$"	/**"
"TypeDescriptor.java:603"$0$"	 * Create a new type descriptor as an array of the specified type."
"TypeDescriptor.java:604"$1$"	 * <p>For example to create a {@code Map<String,String>[]} use:"
"TypeDescriptor.java:605"$0$"	 * <pre class=""code"">"
"TypeDescriptor.java:606"$0$"	 * TypeDescriptor.array(TypeDescriptor.map(Map.class, TypeDescriptor.value(String.class), TypeDescriptor.value(String.class)));"
"TypeDescriptor.java:607"$0$"	 * </pre>"
"TypeDescriptor.java:608"$1$"	 * @param elementTypeDescriptor the {@link TypeDescriptor} of the array element or {@code null}"
"TypeDescriptor.java:609"$1$"	 * @return an array {@link TypeDescriptor} or {@code null} if {@code elementTypeDescriptor} is {@code null}"
"TypeDescriptor.java:610"$0$"	 * @since 3.2.1"
"TypeDescriptor.java:611"$0$"	 */"
"TypeDescriptor.java:612"$0$"	@Nullable"
"TypeDescriptor.java:613"$1$"	public static TypeDescriptor array(@Nullable TypeDescriptor elementTypeDescriptor) {"
"TypeDescriptor.java:614"$1$"		if (elementTypeDescriptor == null) {"
"TypeDescriptor.java:615"$1$"			return null;"
"TypeDescriptor.java:616"$1$"		}"
"TypeDescriptor.java:617"$0$"		return new TypeDescriptor(ResolvableType.forArrayComponent(elementTypeDescriptor.resolvableType),"
"TypeDescriptor.java:618"$0$"				null, elementTypeDescriptor.getAnnotations());"
"TypeDescriptor.java:619"$0$"	}"
"TypeDescriptor.java:620"$0$""
"TypeDescriptor.java:621"$0$"	/**"
"TypeDescriptor.java:622"$0$"	 * Create a type descriptor for a nested type declared within the method parameter."
"TypeDescriptor.java:623"$1$"	 * <p>For example, if the methodParameter is a {@code List<String>} and the"
"TypeDescriptor.java:624"$0$"	 * nesting level is 1, the nested type descriptor will be String.class."
"TypeDescriptor.java:625"$1$"	 * <p>If the methodParameter is a {@code List<List<String>>} and the nesting"
"TypeDescriptor.java:626"$0$"	 * level is 2, the nested type descriptor will also be a String.class."
"TypeDescriptor.java:627"$1$"	 * <p>If the methodParameter is a {@code Map<Integer, String>} and the nesting"
"TypeDescriptor.java:628"$0$"	 * level is 1, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:629"$1$"	 * <p>If the methodParameter is a {@code List<Map<Integer, String>>} and the"
"TypeDescriptor.java:630"$0$"	 * nesting level is 2, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:631"$1$"	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not declared."
"TypeDescriptor.java:632"$1$"	 * For example, if the method parameter is a {@code List<?>}, the nested type"
"TypeDescriptor.java:633"$1$"	 * descriptor returned will be {@code null}."
"TypeDescriptor.java:634"$0$"	 * @param methodParameter the method parameter with a nestingLevel of 1"
"TypeDescriptor.java:635"$0$"	 * @param nestingLevel the nesting level of the collection/array element or"
"TypeDescriptor.java:636"$0$"	 * map key/value declaration within the method parameter"
"TypeDescriptor.java:637"$0$"	 * @return the nested type descriptor at the specified nesting level,"
"TypeDescriptor.java:638"$1$"	 * or {@code null} if it could not be obtained"
"TypeDescriptor.java:639"$0$"	 * @throws IllegalArgumentException if the nesting level of the input"
"TypeDescriptor.java:640"$1$"	 * {@link MethodParameter} argument is not 1, or if the types up to the"
"TypeDescriptor.java:641"$0$"	 * specified nesting level are not of collection, array, or map types"
"TypeDescriptor.java:642"$0$"	 */"
"TypeDescriptor.java:643"$0$"	@Nullable"
"TypeDescriptor.java:644"$1$"	public static TypeDescriptor nested(MethodParameter methodParameter, int nestingLevel) {"
"TypeDescriptor.java:645"$1$"		if (methodParameter.getNestingLevel() != 1) {"
"TypeDescriptor.java:646"$1$"			throw new IllegalArgumentException(""MethodParameter nesting level must be 1: "" +"
"TypeDescriptor.java:647"$1$"					""use the nestingLevel parameter to specify the desired nestingLevel for nested type traversal"");"
"TypeDescriptor.java:648"$1$"		}"
"TypeDescriptor.java:649"$0$"		return nested(new TypeDescriptor(methodParameter), nestingLevel);"
"TypeDescriptor.java:650"$0$"	}"
"TypeDescriptor.java:651"$0$""
"TypeDescriptor.java:652"$0$"	/**"
"TypeDescriptor.java:653"$0$"	 * Create a type descriptor for a nested type declared within the field."
"TypeDescriptor.java:654"$1$"	 * <p>For example, if the field is a {@code List<String>} and the nesting"
"TypeDescriptor.java:655"$1$"	 * level is 1, the nested type descriptor will be {@code String.class}."
"TypeDescriptor.java:656"$1$"	 * <p>If the field is a {@code List<List<String>>} and the nesting level is"
"TypeDescriptor.java:657"$1$"	 * 2, the nested type descriptor will also be a {@code String.class}."
"TypeDescriptor.java:658"$1$"	 * <p>If the field is a {@code Map<Integer, String>} and the nesting level"
"TypeDescriptor.java:659"$0$"	 * is 1, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:660"$1$"	 * <p>If the field is a {@code List<Map<Integer, String>>} and the nesting"
"TypeDescriptor.java:661"$0$"	 * level is 2, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:662"$1$"	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not"
"TypeDescriptor.java:663"$1$"	 * declared. For example, if the field is a {@code List<?>}, the nested type"
"TypeDescriptor.java:664"$1$"	 * descriptor returned will be {@code null}."
"TypeDescriptor.java:665"$0$"	 * @param field the field"
"TypeDescriptor.java:666"$0$"	 * @param nestingLevel the nesting level of the collection/array element or"
"TypeDescriptor.java:667"$0$"	 * map key/value declaration within the field"
"TypeDescriptor.java:668"$0$"	 * @return the nested type descriptor at the specified nesting level,"
"TypeDescriptor.java:669"$1$"	 * or {@code null} if it could not be obtained"
"TypeDescriptor.java:670"$0$"	 * @throws IllegalArgumentException if the types up to the specified nesting"
"TypeDescriptor.java:671"$0$"	 * level are not of collection, array, or map types"
"TypeDescriptor.java:672"$0$"	 */"
"TypeDescriptor.java:673"$0$"	@Nullable"
"TypeDescriptor.java:674"$1$"	public static TypeDescriptor nested(Field field, int nestingLevel) {"
"TypeDescriptor.java:675"$1$"		return nested(new TypeDescriptor(field), nestingLevel);"
"TypeDescriptor.java:676"$1$"	}"
"TypeDescriptor.java:677"$0$""
"TypeDescriptor.java:678"$0$"	/**"
"TypeDescriptor.java:679"$0$"	 * Create a type descriptor for a nested type declared within the property."
"TypeDescriptor.java:680"$1$"	 * <p>For example, if the property is a {@code List<String>} and the nesting"
"TypeDescriptor.java:681"$1$"	 * level is 1, the nested type descriptor will be {@code String.class}."
"TypeDescriptor.java:682"$1$"	 * <p>If the property is a {@code List<List<String>>} and the nesting level"
"TypeDescriptor.java:683"$1$"	 * is 2, the nested type descriptor will also be a {@code String.class}."
"TypeDescriptor.java:684"$1$"	 * <p>If the property is a {@code Map<Integer, String>} and the nesting level"
"TypeDescriptor.java:685"$0$"	 * is 1, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:686"$1$"	 * <p>If the property is a {@code List<Map<Integer, String>>} and the nesting"
"TypeDescriptor.java:687"$0$"	 * level is 2, the nested type descriptor will be String, derived from the map value."
"TypeDescriptor.java:688"$1$"	 * <p>Returns {@code null} if a nested type cannot be obtained because it was not"
"TypeDescriptor.java:689"$1$"	 * declared. For example, if the property is a {@code List<?>}, the nested type"
"TypeDescriptor.java:690"$1$"	 * descriptor returned will be {@code null}."
"TypeDescriptor.java:691"$0$"	 * @param property the property"
"TypeDescriptor.java:692"$0$"	 * @param nestingLevel the nesting level of the collection/array element or"
"TypeDescriptor.java:693"$0$"	 * map key/value declaration within the property"
"TypeDescriptor.java:694"$0$"	 * @return the nested type descriptor at the specified nesting level, or"
"TypeDescriptor.java:695"$1$"	 * {@code null} if it could not be obtained"
"TypeDescriptor.java:696"$0$"	 * @throws IllegalArgumentException if the types up to the specified nesting"
"TypeDescriptor.java:697"$0$"	 * level are not of collection, array, or map types"
"TypeDescriptor.java:698"$0$"	 */"
"TypeDescriptor.java:699"$0$"	@Nullable"
"TypeDescriptor.java:700"$1$"	public static TypeDescriptor nested(Property property, int nestingLevel) {"
"TypeDescriptor.java:701"$1$"		return nested(new TypeDescriptor(property), nestingLevel);"
"TypeDescriptor.java:702"$1$"	}"
"TypeDescriptor.java:703"$0$""
"TypeDescriptor.java:704"$0$"	@Nullable"
"TypeDescriptor.java:705"$1$"	private static TypeDescriptor nested(TypeDescriptor typeDescriptor, int nestingLevel) {"
"TypeDescriptor.java:706"$1$"		ResolvableType nested = typeDescriptor.resolvableType;"
"TypeDescriptor.java:707"$1$"		for (int i = 0; i < nestingLevel; i++) {"
"TypeDescriptor.java:708"$1$"			if (Object.class == nested.getType()) {"
"TypeDescriptor.java:709"$0$"				// Could be a collection type but we don't know about its element type,"
"TypeDescriptor.java:710"$0$"				// so let's just assume there is an element type of type Object..."
"TypeDescriptor.java:711"$1$"			}"
"TypeDescriptor.java:712"$1$"			else {"
"TypeDescriptor.java:713"$1$"				nested = nested.getNested(2);"
"TypeDescriptor.java:714"$1$"			}"
"TypeDescriptor.java:715"$0$"		}"
"TypeDescriptor.java:716"$1$"		if (nested == ResolvableType.NONE) {"
"TypeDescriptor.java:717"$1$"			return null;"
"TypeDescriptor.java:718"$1$"		}"
"TypeDescriptor.java:719"$0$"		return getRelatedIfResolvable(typeDescriptor, nested);"
"TypeDescriptor.java:720"$0$"	}"
"TypeDescriptor.java:721"$0$""
"TypeDescriptor.java:722"$0$"	@Nullable"
"TypeDescriptor.java:723"$1$"	private static TypeDescriptor getRelatedIfResolvable(TypeDescriptor source, ResolvableType type) {"
"TypeDescriptor.java:724"$1$"		if (type.resolve() == null) {"
"TypeDescriptor.java:725"$1$"			return null;"
"TypeDescriptor.java:726"$1$"		}"
"TypeDescriptor.java:727"$0$"		return new TypeDescriptor(type, null, source.getAnnotations());"
"TypeDescriptor.java:728"$0$"	}"
"TypeDescriptor.java:729"$0$""
"TypeDescriptor.java:730"$0$""
"TypeDescriptor.java:731"$0$"	/**"
"TypeDescriptor.java:732"$1$"	 * Adapter class for exposing a {@code TypeDescriptor}'s annotations as an"
"TypeDescriptor.java:733"$1$"	 * {@link AnnotatedElement}, in particular to {@link AnnotatedElementUtils}."
"TypeDescriptor.java:734"$0$"	 * @see AnnotatedElementUtils#isAnnotated(AnnotatedElement, Class)"
"TypeDescriptor.java:735"$0$"	 * @see AnnotatedElementUtils#getMergedAnnotation(AnnotatedElement, Class)"
"TypeDescriptor.java:736"$0$"	 */"
"TypeDescriptor.java:737"$1$"	private class AnnotatedElementAdapter implements AnnotatedElement, Serializable {"
"TypeDescriptor.java:738"$1$""
"TypeDescriptor.java:739"$1$"		@Nullable"
"TypeDescriptor.java:740"$1$"		private final Annotation[] annotations;"
"TypeDescriptor.java:741"$1$""
"TypeDescriptor.java:742"$1$"		public AnnotatedElementAdapter(@Nullable Annotation[] annotations) {"
"TypeDescriptor.java:743"$1$"			this.annotations = annotations;"
"TypeDescriptor.java:744"$1$"		}"
"TypeDescriptor.java:745"$0$""
"TypeDescriptor.java:746"$0$"		@Override"
"TypeDescriptor.java:747"$1$"		public boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {"
"TypeDescriptor.java:748"$1$"			for (Annotation annotation : getAnnotations()) {"
"TypeDescriptor.java:749"$1$"				if (annotation.annotationType() == annotationClass) {"
"TypeDescriptor.java:750"$1$"					return true;"
"TypeDescriptor.java:751"$1$"				}"
"TypeDescriptor.java:752"$0$"			}"
"TypeDescriptor.java:753"$0$"			return false;"
"TypeDescriptor.java:754"$0$"		}"
"TypeDescriptor.java:755"$0$""
"TypeDescriptor.java:756"$0$"		@Override"
"TypeDescriptor.java:757"$0$"		@Nullable"
"TypeDescriptor.java:758"$0$"		@SuppressWarnings(""unchecked"")"
"TypeDescriptor.java:759"$1$"		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {"
"TypeDescriptor.java:760"$1$"			for (Annotation annotation : getAnnotations()) {"
"TypeDescriptor.java:761"$1$"				if (annotation.annotationType() == annotationClass) {"
"TypeDescriptor.java:762"$1$"					return (T) annotation;"
"TypeDescriptor.java:763"$1$"				}"
"TypeDescriptor.java:764"$0$"			}"
"TypeDescriptor.java:765"$0$"			return null;"
"TypeDescriptor.java:766"$0$"		}"
"TypeDescriptor.java:767"$0$""
"TypeDescriptor.java:768"$0$"		@Override"
"TypeDescriptor.java:769"$1$"		public Annotation[] getAnnotations() {"
"TypeDescriptor.java:770"$1$"			return (this.annotations != null ? this.annotations.clone() : EMPTY_ANNOTATION_ARRAY);"
"TypeDescriptor.java:771"$1$"		}"
"TypeDescriptor.java:772"$0$""
"TypeDescriptor.java:773"$0$"		@Override"
"TypeDescriptor.java:774"$1$"		public Annotation[] getDeclaredAnnotations() {"
"TypeDescriptor.java:775"$1$"			return getAnnotations();"
"TypeDescriptor.java:776"$1$"		}"
"TypeDescriptor.java:777"$0$""
"TypeDescriptor.java:778"$1$"		public boolean isEmpty() {"
"TypeDescriptor.java:779"$1$"			return ObjectUtils.isEmpty(this.annotations);"
"TypeDescriptor.java:780"$1$"		}"
"TypeDescriptor.java:781"$0$""
"TypeDescriptor.java:782"$0$"		@Override"
"TypeDescriptor.java:783"$1$"		public boolean equals(@Nullable Object other) {"
"TypeDescriptor.java:784"$1$"			return (this == other || (other instanceof AnnotatedElementAdapter &&"
"TypeDescriptor.java:785"$1$"					Arrays.equals(this.annotations, ((AnnotatedElementAdapter) other).annotations)));"
"TypeDescriptor.java:786"$1$"		}"
"TypeDescriptor.java:787"$0$""
"TypeDescriptor.java:788"$0$"		@Override"
"TypeDescriptor.java:789"$1$"		public int hashCode() {"
"TypeDescriptor.java:790"$1$"			return Arrays.hashCode(this.annotations);"
"TypeDescriptor.java:791"$1$"		}"
"TypeDescriptor.java:792"$0$""
"TypeDescriptor.java:793"$0$"		@Override"
"TypeDescriptor.java:794"$1$"		public String toString() {"
"TypeDescriptor.java:795"$1$"			return TypeDescriptor.this.toString();"
"TypeDescriptor.java:796"$1$"		}"
"TypeDescriptor.java:797"$0$"	}"
"TypeDescriptor.java:798"$0$""
"TypeDescriptor.java:799"$0$"}"
"MimeType.java:1"$0$"/*"
"MimeType.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MimeType.java:3"$0$" *"
"MimeType.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MimeType.java:5"$0$" * you may not use this file except in compliance with the License."
"MimeType.java:6"$0$" * You may obtain a copy of the License at"
"MimeType.java:7"$0$" *"
"MimeType.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MimeType.java:9"$0$" *"
"MimeType.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MimeType.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MimeType.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MimeType.java:13"$0$" * See the License for the specific language governing permissions and"
"MimeType.java:14"$0$" * limitations under the License."
"MimeType.java:15"$0$" */"
"MimeType.java:16"$0$""
"MimeType.java:17"$0$"package org.springframework.util;"
"MimeType.java:18"$0$""
"MimeType.java:19"$0$"import java.io.Serializable;"
"MimeType.java:20"$0$"import java.nio.charset.Charset;"
"MimeType.java:21"$0$"import java.util.BitSet;"
"MimeType.java:22"$0$"import java.util.Collection;"
"MimeType.java:23"$0$"import java.util.Collections;"
"MimeType.java:24"$0$"import java.util.Comparator;"
"MimeType.java:25"$0$"import java.util.Iterator;"
"MimeType.java:26"$0$"import java.util.LinkedHashMap;"
"MimeType.java:27"$0$"import java.util.List;"
"MimeType.java:28"$0$"import java.util.Locale;"
"MimeType.java:29"$0$"import java.util.Map;"
"MimeType.java:30"$0$"import java.util.TreeSet;"
"MimeType.java:31"$0$""
"MimeType.java:32"$0$"import org.springframework.lang.Nullable;"
"MimeType.java:33"$0$""
"MimeType.java:34"$0$"/**"
"MimeType.java:35"$0$" * Represents a MIME Type, as originally defined in RFC 2046 and subsequently"
"MimeType.java:36"$0$" * used in other Internet protocols including HTTP."
"MimeType.java:37"$0$" *"
"MimeType.java:38"$0$" * <p>This class, however, does not contain support for the q-parameters used"
"MimeType.java:39"$0$" * in HTTP content negotiation. Those can be found in the subclass"
"MimeType.java:40"$1$" * {@code org.springframework.http.MediaType} in the {@code spring-web} module."
"MimeType.java:41"$0$" *"
"MimeType.java:42"$1$" * <p>Consists of a {@linkplain #getType() type} and a {@linkplain #getSubtype() subtype}."
"MimeType.java:43"$1$" * Also has functionality to parse MIME Type values from a {@code String} using"
"MimeType.java:44"$1$" * {@link #valueOf(String)}. For more parsing options see {@link MimeTypeUtils}."
"MimeType.java:45"$0$" *"
"MimeType.java:46"$0$" * @author Arjen Poutsma"
"MimeType.java:47"$0$" * @author Juergen Hoeller"
"MimeType.java:48"$0$" * @author Rossen Stoyanchev"
"MimeType.java:49"$0$" * @author Sam Brannen"
"MimeType.java:50"$0$" * @since 4.0"
"MimeType.java:51"$0$" * @see MimeTypeUtils"
"MimeType.java:52"$0$" */"
"MimeType.java:53"$1$"public class MimeType implements Comparable<MimeType>, Serializable {"
"MimeType.java:54"$1$""
"MimeType.java:55"$1$"	private static final long serialVersionUID = 4085923477777865903L;"
"MimeType.java:56"$1$""
"MimeType.java:57"$1$""
"MimeType.java:58"$1$"	protected static final String WILDCARD_TYPE = ""*"";"
"MimeType.java:59"$1$""
"MimeType.java:60"$1$"	private static final String PARAM_CHARSET = ""charset"";"
"MimeType.java:61"$1$""
"MimeType.java:62"$1$"	private static final BitSet TOKEN;"
"MimeType.java:63"$1$""
"MimeType.java:64"$1$"	static {"
"MimeType.java:65"$0$"		// variable names refer to RFC 2616, section 2.2"
"MimeType.java:66"$1$"		BitSet ctl = new BitSet(128);"
"MimeType.java:67"$1$"		for (int i = 0; i <= 31; i++) {"
"MimeType.java:68"$1$"			ctl.set(i);"
"MimeType.java:69"$1$"		}"
"MimeType.java:70"$0$"		ctl.set(127);"
"MimeType.java:71"$0$""
"MimeType.java:72"$0$"		BitSet separators = new BitSet(128);"
"MimeType.java:73"$0$"		separators.set('(');"
"MimeType.java:74"$0$"		separators.set(')');"
"MimeType.java:75"$0$"		separators.set('<');"
"MimeType.java:76"$0$"		separators.set('>');"
"MimeType.java:77"$0$"		separators.set('@');"
"MimeType.java:78"$0$"		separators.set(',');"
"MimeType.java:79"$0$"		separators.set(';');"
"MimeType.java:80"$0$"		separators.set(':');"
"MimeType.java:81"$0$"		separators.set('\\');"
"MimeType.java:82"$0$"		separators.set('\""');"
"MimeType.java:83"$0$"		separators.set('/');"
"MimeType.java:84"$0$"		separators.set('[');"
"MimeType.java:85"$0$"		separators.set(']');"
"MimeType.java:86"$0$"		separators.set('?');"
"MimeType.java:87"$0$"		separators.set('=');"
"MimeType.java:88"$1$"		separators.set('{');"
"MimeType.java:89"$1$"		separators.set('}');"
"MimeType.java:90"$0$"		separators.set(' ');"
"MimeType.java:91"$0$"		separators.set('\t');"
"MimeType.java:92"$0$""
"MimeType.java:93"$0$"		TOKEN = new BitSet(128);"
"MimeType.java:94"$0$"		TOKEN.set(0, 128);"
"MimeType.java:95"$0$"		TOKEN.andNot(ctl);"
"MimeType.java:96"$0$"		TOKEN.andNot(separators);"
"MimeType.java:97"$0$"	}"
"MimeType.java:98"$0$""
"MimeType.java:99"$0$""
"MimeType.java:100"$0$"	private final String type;"
"MimeType.java:101"$0$""
"MimeType.java:102"$0$"	private final String subtype;"
"MimeType.java:103"$0$""
"MimeType.java:104"$0$"	private final Map<String, String> parameters;"
"MimeType.java:105"$0$""
"MimeType.java:106"$0$"	@Nullable"
"MimeType.java:107"$0$"	private volatile String toStringValue;"
"MimeType.java:108"$0$""
"MimeType.java:109"$0$""
"MimeType.java:110"$0$"	/**"
"MimeType.java:111"$1$"	 * Create a new {@code MimeType} for the given primary type."
"MimeType.java:112"$1$"	 * <p>The {@linkplain #getSubtype() subtype} is set to <code>""&#42;""</code>,"
"MimeType.java:113"$0$"	 * and the parameters are empty."
"MimeType.java:114"$0$"	 * @param type the primary type"
"MimeType.java:115"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:116"$0$"	 */"
"MimeType.java:117"$1$"	public MimeType(String type) {"
"MimeType.java:118"$1$"		this(type, WILDCARD_TYPE);"
"MimeType.java:119"$1$"	}"
"MimeType.java:120"$0$""
"MimeType.java:121"$0$"	/**"
"MimeType.java:122"$1$"	 * Create a new {@code MimeType} for the given primary type and subtype."
"MimeType.java:123"$0$"	 * <p>The parameters are empty."
"MimeType.java:124"$0$"	 * @param type the primary type"
"MimeType.java:125"$0$"	 * @param subtype the subtype"
"MimeType.java:126"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:127"$0$"	 */"
"MimeType.java:128"$1$"	public MimeType(String type, String subtype) {"
"MimeType.java:129"$1$"		this(type, subtype, Collections.emptyMap());"
"MimeType.java:130"$1$"	}"
"MimeType.java:131"$0$""
"MimeType.java:132"$0$"	/**"
"MimeType.java:133"$1$"	 * Create a new {@code MimeType} for the given type, subtype, and character set."
"MimeType.java:134"$0$"	 * @param type the primary type"
"MimeType.java:135"$0$"	 * @param subtype the subtype"
"MimeType.java:136"$0$"	 * @param charset the character set"
"MimeType.java:137"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:138"$0$"	 */"
"MimeType.java:139"$1$"	public MimeType(String type, String subtype, Charset charset) {"
"MimeType.java:140"$1$"		this(type, subtype, Collections.singletonMap(PARAM_CHARSET, charset.name()));"
"MimeType.java:141"$1$"	}"
"MimeType.java:142"$0$""
"MimeType.java:143"$0$"	/**"
"MimeType.java:144"$1$"	 * Copy-constructor that copies the type, subtype, parameters of the given {@code MimeType},"
"MimeType.java:145"$0$"	 * and allows to set the specified character set."
"MimeType.java:146"$0$"	 * @param other the other MimeType"
"MimeType.java:147"$0$"	 * @param charset the character set"
"MimeType.java:148"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:149"$0$"	 * @since 4.3"
"MimeType.java:150"$0$"	 */"
"MimeType.java:151"$1$"	public MimeType(MimeType other, Charset charset) {"
"MimeType.java:152"$1$"		this(other.getType(), other.getSubtype(), addCharsetParameter(charset, other.getParameters()));"
"MimeType.java:153"$1$"	}"
"MimeType.java:154"$0$""
"MimeType.java:155"$0$"	/**"
"MimeType.java:156"$1$"	 * Copy-constructor that copies the type and subtype of the given {@code MimeType},"
"MimeType.java:157"$0$"	 * and allows for different parameter."
"MimeType.java:158"$0$"	 * @param other the other MimeType"
"MimeType.java:159"$1$"	 * @param parameters the parameters (may be {@code null})"
"MimeType.java:160"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:161"$0$"	 */"
"MimeType.java:162"$1$"	public MimeType(MimeType other, @Nullable Map<String, String> parameters) {"
"MimeType.java:163"$1$"		this(other.getType(), other.getSubtype(), parameters);"
"MimeType.java:164"$1$"	}"
"MimeType.java:165"$0$""
"MimeType.java:166"$0$"	/**"
"MimeType.java:167"$1$"	 * Create a new {@code MimeType} for the given type, subtype, and parameters."
"MimeType.java:168"$0$"	 * @param type the primary type"
"MimeType.java:169"$0$"	 * @param subtype the subtype"
"MimeType.java:170"$1$"	 * @param parameters the parameters (may be {@code null})"
"MimeType.java:171"$0$"	 * @throws IllegalArgumentException if any of the parameters contains illegal characters"
"MimeType.java:172"$0$"	 */"
"MimeType.java:173"$1$"	public MimeType(String type, String subtype, @Nullable Map<String, String> parameters) {"
"MimeType.java:174"$1$"		Assert.hasLength(type, ""'type' must not be empty"");"
"MimeType.java:175"$1$"		Assert.hasLength(subtype, ""'subtype' must not be empty"");"
"MimeType.java:176"$1$"		checkToken(type);"
"MimeType.java:177"$1$"		checkToken(subtype);"
"MimeType.java:178"$1$"		this.type = type.toLowerCase(Locale.ENGLISH);"
"MimeType.java:179"$1$"		this.subtype = subtype.toLowerCase(Locale.ENGLISH);"
"MimeType.java:180"$1$"		if (!CollectionUtils.isEmpty(parameters)) {"
"MimeType.java:181"$1$"			Map<String, String> map = new LinkedCaseInsensitiveMap<>(parameters.size(), Locale.ENGLISH);"
"MimeType.java:182"$1$"			parameters.forEach((attribute, value) -> {"
"MimeType.java:183"$1$"				checkParameters(attribute, value);"
"MimeType.java:184"$1$"				map.put(attribute, value);"
"MimeType.java:185"$1$"			});"
"MimeType.java:186"$0$"			this.parameters = Collections.unmodifiableMap(map);"
"MimeType.java:187"$0$"		}"
"MimeType.java:188"$1$"		else {"
"MimeType.java:189"$1$"			this.parameters = Collections.emptyMap();"
"MimeType.java:190"$1$"		}"
"MimeType.java:191"$0$"	}"
"MimeType.java:192"$0$""
"MimeType.java:193"$0$"	/**"
"MimeType.java:194"$0$"	 * Checks the given token string for illegal characters, as defined in RFC 2616,"
"MimeType.java:195"$0$"	 * section 2.2."
"MimeType.java:196"$0$"	 * @throws IllegalArgumentException in case of illegal characters"
"MimeType.java:197"$0$"	 * @see <a href=""https://tools.ietf.org/html/rfc2616#section-2.2"">HTTP 1.1, section 2.2</a>"
"MimeType.java:198"$0$"	 */"
"MimeType.java:199"$1$"	private void checkToken(String token) {"
"MimeType.java:200"$1$"		for (int i = 0; i < token.length(); i++ ) {"
"MimeType.java:201"$1$"			char ch = token.charAt(i);"
"MimeType.java:202"$1$"			if (!TOKEN.get(ch)) {"
"MimeType.java:203"$1$"				throw new IllegalArgumentException(""Invalid token character '"" + ch + ""' in token \"""" + token + ""\"""");"
"MimeType.java:204"$1$"			}"
"MimeType.java:205"$0$"		}"
"MimeType.java:206"$0$"	}"
"MimeType.java:207"$0$""
"MimeType.java:208"$1$"	protected void checkParameters(String attribute, String value) {"
"MimeType.java:209"$1$"		Assert.hasLength(attribute, ""'attribute' must not be empty"");"
"MimeType.java:210"$1$"		Assert.hasLength(value, ""'value' must not be empty"");"
"MimeType.java:211"$1$"		checkToken(attribute);"
"MimeType.java:212"$1$"		if (PARAM_CHARSET.equals(attribute)) {"
"MimeType.java:213"$1$"			value = unquote(value);"
"MimeType.java:214"$1$"			Charset.forName(value);"
"MimeType.java:215"$1$"		}"
"MimeType.java:216"$1$"		else if (!isQuotedString(value)) {"
"MimeType.java:217"$1$"			checkToken(value);"
"MimeType.java:218"$1$"		}"
"MimeType.java:219"$0$"	}"
"MimeType.java:220"$0$""
"MimeType.java:221"$1$"	private boolean isQuotedString(String s) {"
"MimeType.java:222"$1$"		if (s.length() < 2) {"
"MimeType.java:223"$1$"			return false;"
"MimeType.java:224"$1$"		}"
"MimeType.java:225"$1$"		else {"
"MimeType.java:226"$1$"			return ((s.startsWith(""\"""") && s.endsWith(""\"""")) || (s.startsWith(""'"") && s.endsWith(""'"")));"
"MimeType.java:227"$1$"		}"
"MimeType.java:228"$0$"	}"
"MimeType.java:229"$0$""
"MimeType.java:230"$1$"	protected String unquote(String s) {"
"MimeType.java:231"$1$"		return (isQuotedString(s) ? s.substring(1, s.length() - 1) : s);"
"MimeType.java:232"$1$"	}"
"MimeType.java:233"$0$""
"MimeType.java:234"$0$"	/**"
"MimeType.java:235"$1$"	 * Indicates whether the {@linkplain #getType() type} is the wildcard character"
"MimeType.java:236"$0$"	 * <code>&#42;</code> or not."
"MimeType.java:237"$0$"	 */"
"MimeType.java:238"$1$"	public boolean isWildcardType() {"
"MimeType.java:239"$1$"		return WILDCARD_TYPE.equals(getType());"
"MimeType.java:240"$1$"	}"
"MimeType.java:241"$0$""
"MimeType.java:242"$0$"	/**"
"MimeType.java:243"$1$"	 * Indicates whether the {@linkplain #getSubtype() subtype} is the wildcard"
"MimeType.java:244"$0$"	 * character <code>&#42;</code> or the wildcard character followed by a suffix"
"MimeType.java:245"$0$"	 * (e.g. <code>&#42;+xml</code>)."
"MimeType.java:246"$0$"	 * @return whether the subtype is a wildcard"
"MimeType.java:247"$0$"	 */"
"MimeType.java:248"$1$"	public boolean isWildcardSubtype() {"
"MimeType.java:249"$1$"		return WILDCARD_TYPE.equals(getSubtype()) || getSubtype().startsWith(""*+"");"
"MimeType.java:250"$1$"	}"
"MimeType.java:251"$0$""
"MimeType.java:252"$0$"	/**"
"MimeType.java:253"$0$"	 * Indicates whether this MIME Type is concrete, i.e. whether neither the type"
"MimeType.java:254"$0$"	 * nor the subtype is a wildcard character <code>&#42;</code>."
"MimeType.java:255"$0$"	 * @return whether this MIME Type is concrete"
"MimeType.java:256"$0$"	 */"
"MimeType.java:257"$1$"	public boolean isConcrete() {"
"MimeType.java:258"$1$"		return !isWildcardType() && !isWildcardSubtype();"
"MimeType.java:259"$1$"	}"
"MimeType.java:260"$0$""
"MimeType.java:261"$0$"	/**"
"MimeType.java:262"$0$"	 * Return the primary type."
"MimeType.java:263"$0$"	 */"
"MimeType.java:264"$1$"	public String getType() {"
"MimeType.java:265"$1$"		return this.type;"
"MimeType.java:266"$1$"	}"
"MimeType.java:267"$0$""
"MimeType.java:268"$0$"	/**"
"MimeType.java:269"$0$"	 * Return the subtype."
"MimeType.java:270"$0$"	 */"
"MimeType.java:271"$1$"	public String getSubtype() {"
"MimeType.java:272"$1$"		return this.subtype;"
"MimeType.java:273"$1$"	}"
"MimeType.java:274"$0$""
"MimeType.java:275"$0$"	/**"
"MimeType.java:276"$1$"	 * Return the character set, as indicated by a {@code charset} parameter, if any."
"MimeType.java:277"$1$"	 * @return the character set, or {@code null} if not available"
"MimeType.java:278"$0$"	 * @since 4.3"
"MimeType.java:279"$0$"	 */"
"MimeType.java:280"$0$"	@Nullable"
"MimeType.java:281"$1$"	public Charset getCharset() {"
"MimeType.java:282"$1$"		String charset = getParameter(PARAM_CHARSET);"
"MimeType.java:283"$1$"		return (charset != null ? Charset.forName(unquote(charset)) : null);"
"MimeType.java:284"$1$"	}"
"MimeType.java:285"$0$""
"MimeType.java:286"$0$"	/**"
"MimeType.java:287"$0$"	 * Return a generic parameter value, given a parameter name."
"MimeType.java:288"$0$"	 * @param name the parameter name"
"MimeType.java:289"$1$"	 * @return the parameter value, or {@code null} if not present"
"MimeType.java:290"$0$"	 */"
"MimeType.java:291"$0$"	@Nullable"
"MimeType.java:292"$1$"	public String getParameter(String name) {"
"MimeType.java:293"$1$"		return this.parameters.get(name);"
"MimeType.java:294"$1$"	}"
"MimeType.java:295"$0$""
"MimeType.java:296"$0$"	/**"
"MimeType.java:297"$0$"	 * Return all generic parameter values."
"MimeType.java:298"$1$"	 * @return a read-only map (possibly empty, never {@code null})"
"MimeType.java:299"$0$"	 */"
"MimeType.java:300"$1$"	public Map<String, String> getParameters() {"
"MimeType.java:301"$1$"		return this.parameters;"
"MimeType.java:302"$1$"	}"
"MimeType.java:303"$0$""
"MimeType.java:304"$0$"	/**"
"MimeType.java:305"$0$"	 * Indicate whether this MIME Type includes the given MIME Type."
"MimeType.java:306"$1$"	 * <p>For instance, {@code text/*} includes {@code text/plain} and {@code text/html},"
"MimeType.java:307"$1$"	 * and {@code application/*+xml} includes {@code application/soap+xml}, etc."
"MimeType.java:308"$0$"	 * This method is <b>not</b> symmetric."
"MimeType.java:309"$0$"	 * @param other the reference MIME Type with which to compare"
"MimeType.java:310"$1$"	 * @return {@code true} if this MIME Type includes the given MIME Type;"
"MimeType.java:311"$1$"	 * {@code false} otherwise"
"MimeType.java:312"$0$"	 */"
"MimeType.java:313"$1$"	public boolean includes(@Nullable MimeType other) {"
"MimeType.java:314"$1$"		if (other == null) {"
"MimeType.java:315"$1$"			return false;"
"MimeType.java:316"$1$"		}"
"MimeType.java:317"$1$"		if (isWildcardType()) {"
"MimeType.java:318"$0$"			// */* includes anything"
"MimeType.java:319"$1$"			return true;"
"MimeType.java:320"$1$"		}"
"MimeType.java:321"$1$"		else if (getType().equals(other.getType())) {"
"MimeType.java:322"$1$"			if (getSubtype().equals(other.getSubtype())) {"
"MimeType.java:323"$1$"				return true;"
"MimeType.java:324"$1$"			}"
"MimeType.java:325"$1$"			if (isWildcardSubtype()) {"
"MimeType.java:326"$0$"				// Wildcard with suffix, e.g. application/*+xml"
"MimeType.java:327"$1$"				int thisPlusIdx = getSubtype().lastIndexOf('+');"
"MimeType.java:328"$1$"				if (thisPlusIdx == -1) {"
"MimeType.java:329"$1$"					return true;"
"MimeType.java:330"$1$"				}"
"MimeType.java:331"$1$"				else {"
"MimeType.java:332"$0$"					// application/*+xml includes application/soap+xml"
"MimeType.java:333"$1$"					int otherPlusIdx = other.getSubtype().lastIndexOf('+');"
"MimeType.java:334"$1$"					if (otherPlusIdx != -1) {"
"MimeType.java:335"$1$"						String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx);"
"MimeType.java:336"$1$"						String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1);"
"MimeType.java:337"$1$"						String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1);"
"MimeType.java:338"$1$"						if (thisSubtypeSuffix.equals(otherSubtypeSuffix) && WILDCARD_TYPE.equals(thisSubtypeNoSuffix)) {"
"MimeType.java:339"$1$"							return true;"
"MimeType.java:340"$1$"						}"
"MimeType.java:341"$0$"					}"
"MimeType.java:342"$0$"				}"
"MimeType.java:343"$0$"			}"
"MimeType.java:344"$0$"		}"
"MimeType.java:345"$0$"		return false;"
"MimeType.java:346"$0$"	}"
"MimeType.java:347"$0$""
"MimeType.java:348"$0$"	/**"
"MimeType.java:349"$0$"	 * Indicate whether this MIME Type is compatible with the given MIME Type."
"MimeType.java:350"$1$"	 * <p>For instance, {@code text/*} is compatible with {@code text/plain},"
"MimeType.java:351"$1$"	 * {@code text/html}, and vice versa. In effect, this method is similar to"
"MimeType.java:352"$1$"	 * {@link #includes}, except that it <b>is</b> symmetric."
"MimeType.java:353"$0$"	 * @param other the reference MIME Type with which to compare"
"MimeType.java:354"$1$"	 * @return {@code true} if this MIME Type is compatible with the given MIME Type;"
"MimeType.java:355"$1$"	 * {@code false} otherwise"
"MimeType.java:356"$0$"	 */"
"MimeType.java:357"$1$"	public boolean isCompatibleWith(@Nullable MimeType other) {"
"MimeType.java:358"$1$"		if (other == null) {"
"MimeType.java:359"$1$"			return false;"
"MimeType.java:360"$1$"		}"
"MimeType.java:361"$1$"		if (isWildcardType() || other.isWildcardType()) {"
"MimeType.java:362"$1$"			return true;"
"MimeType.java:363"$1$"		}"
"MimeType.java:364"$1$"		else if (getType().equals(other.getType())) {"
"MimeType.java:365"$1$"			if (getSubtype().equals(other.getSubtype())) {"
"MimeType.java:366"$1$"				return true;"
"MimeType.java:367"$1$"			}"
"MimeType.java:368"$0$"			// Wildcard with suffix? e.g. application/*+xml"
"MimeType.java:369"$1$"			if (isWildcardSubtype() || other.isWildcardSubtype()) {"
"MimeType.java:370"$1$"				int thisPlusIdx = getSubtype().lastIndexOf('+');"
"MimeType.java:371"$1$"				int otherPlusIdx = other.getSubtype().lastIndexOf('+');"
"MimeType.java:372"$1$"				if (thisPlusIdx == -1 && otherPlusIdx == -1) {"
"MimeType.java:373"$1$"					return true;"
"MimeType.java:374"$1$"				}"
"MimeType.java:375"$1$"				else if (thisPlusIdx != -1 && otherPlusIdx != -1) {"
"MimeType.java:376"$1$"					String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx);"
"MimeType.java:377"$1$"					String otherSubtypeNoSuffix = other.getSubtype().substring(0, otherPlusIdx);"
"MimeType.java:378"$1$"					String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1);"
"MimeType.java:379"$1$"					String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1);"
"MimeType.java:380"$1$"					if (thisSubtypeSuffix.equals(otherSubtypeSuffix) &&"
"MimeType.java:381"$1$"							(WILDCARD_TYPE.equals(thisSubtypeNoSuffix) || WILDCARD_TYPE.equals(otherSubtypeNoSuffix))) {"
"MimeType.java:382"$1$"						return true;"
"MimeType.java:383"$1$"					}"
"MimeType.java:384"$0$"				}"
"MimeType.java:385"$0$"			}"
"MimeType.java:386"$0$"		}"
"MimeType.java:387"$0$"		return false;"
"MimeType.java:388"$0$"	}"
"MimeType.java:389"$0$""
"MimeType.java:390"$0$"	/**"
"MimeType.java:391"$1$"	 * Similar to {@link #equals(Object)} but based on the type and subtype"
"MimeType.java:392"$0$"	 * only, i.e. ignoring parameters."
"MimeType.java:393"$0$"	 * @param other the other mime type to compare to"
"MimeType.java:394"$0$"	 * @return whether the two mime types have the same type and subtype"
"MimeType.java:395"$0$"	 * @since 5.1.4"
"MimeType.java:396"$0$"	 */"
"MimeType.java:397"$1$"	public boolean equalsTypeAndSubtype(@Nullable MimeType other) {"
"MimeType.java:398"$1$"		if (other == null) {"
"MimeType.java:399"$1$"			return false;"
"MimeType.java:400"$1$"		}"
"MimeType.java:401"$0$"		return this.type.equalsIgnoreCase(other.type) && this.subtype.equalsIgnoreCase(other.subtype);"
"MimeType.java:402"$0$"	}"
"MimeType.java:403"$0$""
"MimeType.java:404"$0$"	/**"
"MimeType.java:405"$1$"	 * Unlike {@link Collection#contains(Object)} which relies on"
"MimeType.java:406"$1$"	 * {@link MimeType#equals(Object)}, this method only checks the type and the"
"MimeType.java:407"$0$"	 * subtype, but otherwise ignores parameters."
"MimeType.java:408"$0$"	 * @param mimeTypes the list of mime types to perform the check against"
"MimeType.java:409"$0$"	 * @return whether the list contains the given mime type"
"MimeType.java:410"$0$"	 * @since 5.1.4"
"MimeType.java:411"$0$"	 */"
"MimeType.java:412"$1$"	public boolean isPresentIn(Collection<? extends MimeType> mimeTypes) {"
"MimeType.java:413"$1$"		for (MimeType mimeType : mimeTypes) {"
"MimeType.java:414"$1$"			if (mimeType.equalsTypeAndSubtype(this)) {"
"MimeType.java:415"$1$"				return true;"
"MimeType.java:416"$1$"			}"
"MimeType.java:417"$0$"		}"
"MimeType.java:418"$0$"		return false;"
"MimeType.java:419"$0$"	}"
"MimeType.java:420"$0$""
"MimeType.java:421"$0$""
"MimeType.java:422"$0$"	@Override"
"MimeType.java:423"$1$"	public boolean equals(@Nullable Object other) {"
"MimeType.java:424"$1$"		if (this == other) {"
"MimeType.java:425"$1$"			return true;"
"MimeType.java:426"$1$"		}"
"MimeType.java:427"$1$"		if (!(other instanceof MimeType)) {"
"MimeType.java:428"$1$"			return false;"
"MimeType.java:429"$1$"		}"
"MimeType.java:430"$0$"		MimeType otherType = (MimeType) other;"
"MimeType.java:431"$0$"		return (this.type.equalsIgnoreCase(otherType.type) &&"
"MimeType.java:432"$0$"				this.subtype.equalsIgnoreCase(otherType.subtype) &&"
"MimeType.java:433"$0$"				parametersAreEqual(otherType));"
"MimeType.java:434"$0$"	}"
"MimeType.java:435"$0$""
"MimeType.java:436"$0$"	/**"
"MimeType.java:437"$1$"	 * Determine if the parameters in this {@code MimeType} and the supplied"
"MimeType.java:438"$1$"	 * {@code MimeType} are equal, performing case-insensitive comparisons"
"MimeType.java:439"$1$"	 * for {@link Charset Charsets}."
"MimeType.java:440"$0$"	 * @since 4.2"
"MimeType.java:441"$0$"	 */"
"MimeType.java:442"$1$"	private boolean parametersAreEqual(MimeType other) {"
"MimeType.java:443"$1$"		if (this.parameters.size() != other.parameters.size()) {"
"MimeType.java:444"$1$"			return false;"
"MimeType.java:445"$1$"		}"
"MimeType.java:446"$0$""
"MimeType.java:447"$1$"		for (Map.Entry<String, String> entry : this.parameters.entrySet()) {"
"MimeType.java:448"$1$"			String key = entry.getKey();"
"MimeType.java:449"$1$"			if (!other.parameters.containsKey(key)) {"
"MimeType.java:450"$1$"				return false;"
"MimeType.java:451"$1$"			}"
"MimeType.java:452"$1$"			if (PARAM_CHARSET.equals(key)) {"
"MimeType.java:453"$1$"				if (!ObjectUtils.nullSafeEquals(getCharset(), other.getCharset())) {"
"MimeType.java:454"$1$"					return false;"
"MimeType.java:455"$1$"				}"
"MimeType.java:456"$0$"			}"
"MimeType.java:457"$1$"			else if (!ObjectUtils.nullSafeEquals(entry.getValue(), other.parameters.get(key))) {"
"MimeType.java:458"$1$"				return false;"
"MimeType.java:459"$1$"			}"
"MimeType.java:460"$0$"		}"
"MimeType.java:461"$0$""
"MimeType.java:462"$0$"		return true;"
"MimeType.java:463"$0$"	}"
"MimeType.java:464"$0$""
"MimeType.java:465"$0$"	@Override"
"MimeType.java:466"$1$"	public int hashCode() {"
"MimeType.java:467"$1$"		int result = this.type.hashCode();"
"MimeType.java:468"$1$"		result = 31 * result + this.subtype.hashCode();"
"MimeType.java:469"$1$"		result = 31 * result + this.parameters.hashCode();"
"MimeType.java:470"$1$"		return result;"
"MimeType.java:471"$1$"	}"
"MimeType.java:472"$0$""
"MimeType.java:473"$0$"	@Override"
"MimeType.java:474"$1$"	public String toString() {"
"MimeType.java:475"$1$"		String value = this.toStringValue;"
"MimeType.java:476"$1$"		if (value == null) {"
"MimeType.java:477"$1$"			StringBuilder builder = new StringBuilder();"
"MimeType.java:478"$1$"			appendTo(builder);"
"MimeType.java:479"$1$"			value = builder.toString();"
"MimeType.java:480"$1$"			this.toStringValue = value;"
"MimeType.java:481"$1$"		}"
"MimeType.java:482"$0$"		return value;"
"MimeType.java:483"$0$"	}"
"MimeType.java:484"$0$""
"MimeType.java:485"$1$"	protected void appendTo(StringBuilder builder) {"
"MimeType.java:486"$1$"		builder.append(this.type);"
"MimeType.java:487"$1$"		builder.append('/');"
"MimeType.java:488"$1$"		builder.append(this.subtype);"
"MimeType.java:489"$1$"		appendTo(this.parameters, builder);"
"MimeType.java:490"$1$"	}"
"MimeType.java:491"$0$""
"MimeType.java:492"$1$"	private void appendTo(Map<String, String> map, StringBuilder builder) {"
"MimeType.java:493"$1$"		map.forEach((key, val) -> {"
"MimeType.java:494"$1$"			builder.append(';');"
"MimeType.java:495"$1$"			builder.append(key);"
"MimeType.java:496"$1$"			builder.append('=');"
"MimeType.java:497"$1$"			builder.append(val);"
"MimeType.java:498"$1$"		});"
"MimeType.java:499"$0$"	}"
"MimeType.java:500"$0$""
"MimeType.java:501"$0$"	/**"
"MimeType.java:502"$0$"	 * Compares this MIME Type to another alphabetically."
"MimeType.java:503"$0$"	 * @param other the MIME Type to compare to"
"MimeType.java:504"$0$"	 * @see MimeTypeUtils#sortBySpecificity(List)"
"MimeType.java:505"$0$"	 */"
"MimeType.java:506"$0$"	@Override"
"MimeType.java:507"$1$"	public int compareTo(MimeType other) {"
"MimeType.java:508"$1$"		int comp = getType().compareToIgnoreCase(other.getType());"
"MimeType.java:509"$1$"		if (comp != 0) {"
"MimeType.java:510"$1$"			return comp;"
"MimeType.java:511"$1$"		}"
"MimeType.java:512"$0$"		comp = getSubtype().compareToIgnoreCase(other.getSubtype());"
"MimeType.java:513"$1$"		if (comp != 0) {"
"MimeType.java:514"$1$"			return comp;"
"MimeType.java:515"$1$"		}"
"MimeType.java:516"$0$"		comp = getParameters().size() - other.getParameters().size();"
"MimeType.java:517"$1$"		if (comp != 0) {"
"MimeType.java:518"$1$"			return comp;"
"MimeType.java:519"$1$"		}"
"MimeType.java:520"$0$""
"MimeType.java:521"$0$"		TreeSet<String> thisAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);"
"MimeType.java:522"$0$"		thisAttributes.addAll(getParameters().keySet());"
"MimeType.java:523"$0$"		TreeSet<String> otherAttributes = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);"
"MimeType.java:524"$0$"		otherAttributes.addAll(other.getParameters().keySet());"
"MimeType.java:525"$0$"		Iterator<String> thisAttributesIterator = thisAttributes.iterator();"
"MimeType.java:526"$0$"		Iterator<String> otherAttributesIterator = otherAttributes.iterator();"
"MimeType.java:527"$0$""
"MimeType.java:528"$1$"		while (thisAttributesIterator.hasNext()) {"
"MimeType.java:529"$1$"			String thisAttribute = thisAttributesIterator.next();"
"MimeType.java:530"$1$"			String otherAttribute = otherAttributesIterator.next();"
"MimeType.java:531"$1$"			comp = thisAttribute.compareToIgnoreCase(otherAttribute);"
"MimeType.java:532"$1$"			if (comp != 0) {"
"MimeType.java:533"$1$"				return comp;"
"MimeType.java:534"$1$"			}"
"MimeType.java:535"$1$"			if (PARAM_CHARSET.equals(thisAttribute)) {"
"MimeType.java:536"$1$"				Charset thisCharset = getCharset();"
"MimeType.java:537"$1$"				Charset otherCharset = other.getCharset();"
"MimeType.java:538"$1$"				if (thisCharset != otherCharset) {"
"MimeType.java:539"$1$"					if (thisCharset == null) {"
"MimeType.java:540"$1$"						return -1;"
"MimeType.java:541"$1$"					}"
"MimeType.java:542"$1$"					if (otherCharset == null) {"
"MimeType.java:543"$1$"						return 1;"
"MimeType.java:544"$1$"					}"
"MimeType.java:545"$0$"					comp = thisCharset.compareTo(otherCharset);"
"MimeType.java:546"$1$"					if (comp != 0) {"
"MimeType.java:547"$1$"						return comp;"
"MimeType.java:548"$1$"					}"
"MimeType.java:549"$0$"				}"
"MimeType.java:550"$0$"			}"
"MimeType.java:551"$1$"			else {"
"MimeType.java:552"$1$"				String thisValue = getParameters().get(thisAttribute);"
"MimeType.java:553"$1$"				String otherValue = other.getParameters().get(otherAttribute);"
"MimeType.java:554"$1$"				if (otherValue == null) {"
"MimeType.java:555"$1$"					otherValue = """";"
"MimeType.java:556"$1$"				}"
"MimeType.java:557"$0$"				comp = thisValue.compareTo(otherValue);"
"MimeType.java:558"$1$"				if (comp != 0) {"
"MimeType.java:559"$1$"					return comp;"
"MimeType.java:560"$1$"				}"
"MimeType.java:561"$0$"			}"
"MimeType.java:562"$0$"		}"
"MimeType.java:563"$0$""
"MimeType.java:564"$0$"		return 0;"
"MimeType.java:565"$0$"	}"
"MimeType.java:566"$0$""
"MimeType.java:567"$0$""
"MimeType.java:568"$0$"	/**"
"MimeType.java:569"$1$"	 * Parse the given String value into a {@code MimeType} object,"
"MimeType.java:570"$0$"	 * with this method name following the 'valueOf' naming convention"
"MimeType.java:571"$1$"	 * (as supported by {@link org.springframework.core.convert.ConversionService}."
"MimeType.java:572"$0$"	 * @see MimeTypeUtils#parseMimeType(String)"
"MimeType.java:573"$0$"	 */"
"MimeType.java:574"$1$"	public static MimeType valueOf(String value) {"
"MimeType.java:575"$1$"		return MimeTypeUtils.parseMimeType(value);"
"MimeType.java:576"$1$"	}"
"MimeType.java:577"$0$""
"MimeType.java:578"$1$"	private static Map<String, String> addCharsetParameter(Charset charset, Map<String, String> parameters) {"
"MimeType.java:579"$1$"		Map<String, String> map = new LinkedHashMap<>(parameters);"
"MimeType.java:580"$1$"		map.put(PARAM_CHARSET, charset.name());"
"MimeType.java:581"$1$"		return map;"
"MimeType.java:582"$1$"	}"
"MimeType.java:583"$0$""
"MimeType.java:584"$0$""
"MimeType.java:585"$0$"	/**"
"MimeType.java:586"$1$"	 * Comparator to sort {@link MimeType MimeTypes} in order of specificity."
"MimeType.java:587"$0$"	 *"
"MimeType.java:588"$0$"	 * @param <T> the type of mime types that may be compared by this comparator"
"MimeType.java:589"$0$"	 */"
"MimeType.java:590"$1$"	public static class SpecificityComparator<T extends MimeType> implements Comparator<T> {"
"MimeType.java:591"$1$""
"MimeType.java:592"$1$"		@Override"
"MimeType.java:593"$1$"		public int compare(T mimeType1, T mimeType2) {"
"MimeType.java:594"$1$"			if (mimeType1.isWildcardType() && !mimeType2.isWildcardType()) {  // */* < audio/*"
"MimeType.java:595"$1$"				return 1;"
"MimeType.java:596"$1$"			}"
"MimeType.java:597"$1$"			else if (mimeType2.isWildcardType() && !mimeType1.isWildcardType()) {  // audio/* > */*"
"MimeType.java:598"$1$"				return -1;"
"MimeType.java:599"$1$"			}"
"MimeType.java:600"$1$"			else if (!mimeType1.getType().equals(mimeType2.getType())) {  // audio/basic == text/html"
"MimeType.java:601"$1$"				return 0;"
"MimeType.java:602"$1$"			}"
"MimeType.java:603"$1$"			else {  // mediaType1.getType().equals(mediaType2.getType())"
"MimeType.java:604"$1$"				if (mimeType1.isWildcardSubtype() && !mimeType2.isWildcardSubtype()) {  // audio/* < audio/basic"
"MimeType.java:605"$1$"					return 1;"
"MimeType.java:606"$1$"				}"
"MimeType.java:607"$1$"				else if (mimeType2.isWildcardSubtype() && !mimeType1.isWildcardSubtype()) {  // audio/basic > audio/*"
"MimeType.java:608"$1$"					return -1;"
"MimeType.java:609"$1$"				}"
"MimeType.java:610"$1$"				else if (!mimeType1.getSubtype().equals(mimeType2.getSubtype())) {  // audio/basic == audio/wave"
"MimeType.java:611"$1$"					return 0;"
"MimeType.java:612"$1$"				}"
"MimeType.java:613"$1$"				else {  // mediaType2.getSubtype().equals(mediaType2.getSubtype())"
"MimeType.java:614"$1$"					return compareParameters(mimeType1, mimeType2);"
"MimeType.java:615"$1$"				}"
"MimeType.java:616"$0$"			}"
"MimeType.java:617"$0$"		}"
"MimeType.java:618"$0$""
"MimeType.java:619"$1$"		protected int compareParameters(T mimeType1, T mimeType2) {"
"MimeType.java:620"$1$"			int paramsSize1 = mimeType1.getParameters().size();"
"MimeType.java:621"$1$"			int paramsSize2 = mimeType2.getParameters().size();"
"MimeType.java:622"$1$"			return Integer.compare(paramsSize2, paramsSize1);  // audio/basic;level=1 < audio/basic"
"MimeType.java:623"$1$"		}"
"MimeType.java:624"$0$"	}"
"MimeType.java:625"$0$""
"MimeType.java:626"$0$"}"
"DataBufferEncoder.java:1"$0$"/*"
"DataBufferEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"DataBufferEncoder.java:3"$0$" *"
"DataBufferEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DataBufferEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"DataBufferEncoder.java:6"$0$" * You may obtain a copy of the License at"
"DataBufferEncoder.java:7"$0$" *"
"DataBufferEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DataBufferEncoder.java:9"$0$" *"
"DataBufferEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DataBufferEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DataBufferEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DataBufferEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"DataBufferEncoder.java:14"$0$" * limitations under the License."
"DataBufferEncoder.java:15"$0$" */"
"DataBufferEncoder.java:16"$0$""
"DataBufferEncoder.java:17"$0$"package org.springframework.core.codec;"
"DataBufferEncoder.java:18"$0$""
"DataBufferEncoder.java:19"$0$"import java.util.Map;"
"DataBufferEncoder.java:20"$0$""
"DataBufferEncoder.java:21"$0$"import org.reactivestreams.Publisher;"
"DataBufferEncoder.java:22"$0$"import reactor.core.publisher.Flux;"
"DataBufferEncoder.java:23"$0$""
"DataBufferEncoder.java:24"$0$"import org.springframework.core.ResolvableType;"
"DataBufferEncoder.java:25"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"DataBufferEncoder.java:26"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"DataBufferEncoder.java:27"$0$"import org.springframework.lang.Nullable;"
"DataBufferEncoder.java:28"$0$"import org.springframework.util.MimeType;"
"DataBufferEncoder.java:29"$0$"import org.springframework.util.MimeTypeUtils;"
"DataBufferEncoder.java:30"$0$""
"DataBufferEncoder.java:31"$0$"/**"
"DataBufferEncoder.java:32"$1$" * Simple pass-through encoder for {@link DataBuffer DataBuffers}."
"DataBufferEncoder.java:33"$0$" *"
"DataBufferEncoder.java:34"$0$" * @author Arjen Poutsma"
"DataBufferEncoder.java:35"$0$" * @since 5.0"
"DataBufferEncoder.java:36"$0$" */"
"DataBufferEncoder.java:37"$1$"public class DataBufferEncoder extends AbstractEncoder<DataBuffer> {"
"DataBufferEncoder.java:38"$1$""
"DataBufferEncoder.java:39"$1$"	public DataBufferEncoder() {"
"DataBufferEncoder.java:40"$1$"		super(MimeTypeUtils.ALL);"
"DataBufferEncoder.java:41"$1$"	}"
"DataBufferEncoder.java:42"$0$""
"DataBufferEncoder.java:43"$0$""
"DataBufferEncoder.java:44"$0$"	@Override"
"DataBufferEncoder.java:45"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"DataBufferEncoder.java:46"$1$"		Class<?> clazz = elementType.toClass();"
"DataBufferEncoder.java:47"$1$"		return super.canEncode(elementType, mimeType) && DataBuffer.class.isAssignableFrom(clazz);"
"DataBufferEncoder.java:48"$1$"	}"
"DataBufferEncoder.java:49"$0$""
"DataBufferEncoder.java:50"$0$"	@Override"
"DataBufferEncoder.java:51"$0$"	public Flux<DataBuffer> encode(Publisher<? extends DataBuffer> inputStream,"
"DataBufferEncoder.java:52"$0$"			DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,"
"DataBufferEncoder.java:53"$1$"			@Nullable Map<String, Object> hints) {"
"DataBufferEncoder.java:54"$1$""
"DataBufferEncoder.java:55"$1$"		Flux<DataBuffer> flux = Flux.from(inputStream);"
"DataBufferEncoder.java:56"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"DataBufferEncoder.java:57"$1$"			flux = flux.doOnNext(buffer -> logValue(buffer, hints));"
"DataBufferEncoder.java:58"$1$"		}"
"DataBufferEncoder.java:59"$0$"		return flux;"
"DataBufferEncoder.java:60"$0$"	}"
"DataBufferEncoder.java:61"$0$""
"DataBufferEncoder.java:62"$0$"	@Override"
"DataBufferEncoder.java:63"$0$"	public DataBuffer encodeValue(DataBuffer buffer, DataBufferFactory bufferFactory,"
"DataBufferEncoder.java:64"$1$"			ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"DataBufferEncoder.java:65"$1$""
"DataBufferEncoder.java:66"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"DataBufferEncoder.java:67"$1$"			logValue(buffer, hints);"
"DataBufferEncoder.java:68"$1$"		}"
"DataBufferEncoder.java:69"$0$"		return buffer;"
"DataBufferEncoder.java:70"$0$"	}"
"DataBufferEncoder.java:71"$0$""
"DataBufferEncoder.java:72"$1$"	private void logValue(DataBuffer buffer, @Nullable Map<String, Object> hints) {"
"DataBufferEncoder.java:73"$1$"		String logPrefix = Hints.getLogPrefix(hints);"
"DataBufferEncoder.java:74"$1$"		logger.debug(logPrefix + ""Writing "" + buffer.readableByteCount() + "" bytes"");"
"DataBufferEncoder.java:75"$1$"	}"
"DataBufferEncoder.java:76"$0$""
"DataBufferEncoder.java:77"$0$"}"
"EncodedResource.java:1"$0$"/*"
"EncodedResource.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"EncodedResource.java:3"$0$" *"
"EncodedResource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"EncodedResource.java:5"$0$" * you may not use this file except in compliance with the License."
"EncodedResource.java:6"$0$" * You may obtain a copy of the License at"
"EncodedResource.java:7"$0$" *"
"EncodedResource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"EncodedResource.java:9"$0$" *"
"EncodedResource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"EncodedResource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"EncodedResource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"EncodedResource.java:13"$0$" * See the License for the specific language governing permissions and"
"EncodedResource.java:14"$0$" * limitations under the License."
"EncodedResource.java:15"$0$" */"
"EncodedResource.java:16"$0$""
"EncodedResource.java:17"$0$"package org.springframework.core.io.support;"
"EncodedResource.java:18"$0$""
"EncodedResource.java:19"$0$"import java.io.IOException;"
"EncodedResource.java:20"$0$"import java.io.InputStream;"
"EncodedResource.java:21"$0$"import java.io.InputStreamReader;"
"EncodedResource.java:22"$0$"import java.io.Reader;"
"EncodedResource.java:23"$0$"import java.nio.charset.Charset;"
"EncodedResource.java:24"$0$""
"EncodedResource.java:25"$0$"import org.springframework.core.io.InputStreamSource;"
"EncodedResource.java:26"$0$"import org.springframework.core.io.Resource;"
"EncodedResource.java:27"$0$"import org.springframework.lang.Nullable;"
"EncodedResource.java:28"$0$"import org.springframework.util.Assert;"
"EncodedResource.java:29"$0$"import org.springframework.util.ObjectUtils;"
"EncodedResource.java:30"$0$""
"EncodedResource.java:31"$0$"/**"
"EncodedResource.java:32"$1$" * Holder that combines a {@link Resource} descriptor with a specific encoding"
"EncodedResource.java:33"$1$" * or {@code Charset} to be used for reading from the resource."
"EncodedResource.java:34"$0$" *"
"EncodedResource.java:35"$0$" * <p>Used as an argument for operations that support reading content with"
"EncodedResource.java:36"$1$" * a specific encoding, typically via a {@code java.io.Reader}."
"EncodedResource.java:37"$0$" *"
"EncodedResource.java:38"$0$" * @author Juergen Hoeller"
"EncodedResource.java:39"$0$" * @author Sam Brannen"
"EncodedResource.java:40"$0$" * @since 1.2.6"
"EncodedResource.java:41"$0$" * @see Resource#getInputStream()"
"EncodedResource.java:42"$0$" * @see java.io.Reader"
"EncodedResource.java:43"$0$" * @see java.nio.charset.Charset"
"EncodedResource.java:44"$0$" */"
"EncodedResource.java:45"$1$"public class EncodedResource implements InputStreamSource {"
"EncodedResource.java:46"$1$""
"EncodedResource.java:47"$1$"	private final Resource resource;"
"EncodedResource.java:48"$1$""
"EncodedResource.java:49"$1$"	@Nullable"
"EncodedResource.java:50"$1$"	private final String encoding;"
"EncodedResource.java:51"$1$""
"EncodedResource.java:52"$1$"	@Nullable"
"EncodedResource.java:53"$1$"	private final Charset charset;"
"EncodedResource.java:54"$1$""
"EncodedResource.java:55"$1$""
"EncodedResource.java:56"$1$"	/**"
"EncodedResource.java:57"$1$"	 * Create a new {@code EncodedResource} for the given {@code Resource},"
"EncodedResource.java:58"$1$"	 * not specifying an explicit encoding or {@code Charset}."
"EncodedResource.java:59"$1$"	 * @param resource the {@code Resource} to hold (never {@code null})"
"EncodedResource.java:60"$1$"	 */"
"EncodedResource.java:61"$1$"	public EncodedResource(Resource resource) {"
"EncodedResource.java:62"$1$"		this(resource, null, null);"
"EncodedResource.java:63"$1$"	}"
"EncodedResource.java:64"$0$""
"EncodedResource.java:65"$0$"	/**"
"EncodedResource.java:66"$1$"	 * Create a new {@code EncodedResource} for the given {@code Resource},"
"EncodedResource.java:67"$1$"	 * using the specified {@code encoding}."
"EncodedResource.java:68"$1$"	 * @param resource the {@code Resource} to hold (never {@code null})"
"EncodedResource.java:69"$0$"	 * @param encoding the encoding to use for reading from the resource"
"EncodedResource.java:70"$0$"	 */"
"EncodedResource.java:71"$1$"	public EncodedResource(Resource resource, @Nullable String encoding) {"
"EncodedResource.java:72"$1$"		this(resource, encoding, null);"
"EncodedResource.java:73"$1$"	}"
"EncodedResource.java:74"$0$""
"EncodedResource.java:75"$0$"	/**"
"EncodedResource.java:76"$1$"	 * Create a new {@code EncodedResource} for the given {@code Resource},"
"EncodedResource.java:77"$1$"	 * using the specified {@code Charset}."
"EncodedResource.java:78"$1$"	 * @param resource the {@code Resource} to hold (never {@code null})"
"EncodedResource.java:79"$1$"	 * @param charset the {@code Charset} to use for reading from the resource"
"EncodedResource.java:80"$0$"	 */"
"EncodedResource.java:81"$1$"	public EncodedResource(Resource resource, @Nullable Charset charset) {"
"EncodedResource.java:82"$1$"		this(resource, null, charset);"
"EncodedResource.java:83"$1$"	}"
"EncodedResource.java:84"$0$""
"EncodedResource.java:85"$1$"	private EncodedResource(Resource resource, @Nullable String encoding, @Nullable Charset charset) {"
"EncodedResource.java:86"$1$"		super();"
"EncodedResource.java:87"$1$"		Assert.notNull(resource, ""Resource must not be null"");"
"EncodedResource.java:88"$1$"		this.resource = resource;"
"EncodedResource.java:89"$1$"		this.encoding = encoding;"
"EncodedResource.java:90"$1$"		this.charset = charset;"
"EncodedResource.java:91"$1$"	}"
"EncodedResource.java:92"$0$""
"EncodedResource.java:93"$0$""
"EncodedResource.java:94"$0$"	/**"
"EncodedResource.java:95"$1$"	 * Return the {@code Resource} held by this {@code EncodedResource}."
"EncodedResource.java:96"$0$"	 */"
"EncodedResource.java:97"$1$"	public final Resource getResource() {"
"EncodedResource.java:98"$1$"		return this.resource;"
"EncodedResource.java:99"$1$"	}"
"EncodedResource.java:100"$0$""
"EncodedResource.java:101"$0$"	/**"
"EncodedResource.java:102"$1$"	 * Return the encoding to use for reading from the {@linkplain #getResource() resource},"
"EncodedResource.java:103"$1$"	 * or {@code null} if none specified."
"EncodedResource.java:104"$0$"	 */"
"EncodedResource.java:105"$0$"	@Nullable"
"EncodedResource.java:106"$1$"	public final String getEncoding() {"
"EncodedResource.java:107"$1$"		return this.encoding;"
"EncodedResource.java:108"$1$"	}"
"EncodedResource.java:109"$0$""
"EncodedResource.java:110"$0$"	/**"
"EncodedResource.java:111"$1$"	 * Return the {@code Charset} to use for reading from the {@linkplain #getResource() resource},"
"EncodedResource.java:112"$1$"	 * or {@code null} if none specified."
"EncodedResource.java:113"$0$"	 */"
"EncodedResource.java:114"$0$"	@Nullable"
"EncodedResource.java:115"$1$"	public final Charset getCharset() {"
"EncodedResource.java:116"$1$"		return this.charset;"
"EncodedResource.java:117"$1$"	}"
"EncodedResource.java:118"$0$""
"EncodedResource.java:119"$0$"	/**"
"EncodedResource.java:120"$1$"	 * Determine whether a {@link Reader} is required as opposed to an {@link InputStream},"
"EncodedResource.java:121"$1$"	 * i.e. whether an {@linkplain #getEncoding() encoding} or a {@link #getCharset() Charset}"
"EncodedResource.java:122"$0$"	 * has been specified."
"EncodedResource.java:123"$0$"	 * @see #getReader()"
"EncodedResource.java:124"$0$"	 * @see #getInputStream()"
"EncodedResource.java:125"$0$"	 */"
"EncodedResource.java:126"$1$"	public boolean requiresReader() {"
"EncodedResource.java:127"$1$"		return (this.encoding != null || this.charset != null);"
"EncodedResource.java:128"$1$"	}"
"EncodedResource.java:129"$0$""
"EncodedResource.java:130"$0$"	/**"
"EncodedResource.java:131"$1$"	 * Open a {@code java.io.Reader} for the specified resource, using the specified"
"EncodedResource.java:132"$1$"	 * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}"
"EncodedResource.java:133"$0$"	 * (if any)."
"EncodedResource.java:134"$0$"	 * @throws IOException if opening the Reader failed"
"EncodedResource.java:135"$0$"	 * @see #requiresReader()"
"EncodedResource.java:136"$0$"	 * @see #getInputStream()"
"EncodedResource.java:137"$0$"	 */"
"EncodedResource.java:138"$1$"	public Reader getReader() throws IOException {"
"EncodedResource.java:139"$1$"		if (this.charset != null) {"
"EncodedResource.java:140"$1$"			return new InputStreamReader(this.resource.getInputStream(), this.charset);"
"EncodedResource.java:141"$1$"		}"
"EncodedResource.java:142"$1$"		else if (this.encoding != null) {"
"EncodedResource.java:143"$1$"			return new InputStreamReader(this.resource.getInputStream(), this.encoding);"
"EncodedResource.java:144"$1$"		}"
"EncodedResource.java:145"$1$"		else {"
"EncodedResource.java:146"$1$"			return new InputStreamReader(this.resource.getInputStream());"
"EncodedResource.java:147"$1$"		}"
"EncodedResource.java:148"$0$"	}"
"EncodedResource.java:149"$0$""
"EncodedResource.java:150"$0$"	/**"
"EncodedResource.java:151"$1$"	 * Open an {@code InputStream} for the specified resource, ignoring any specified"
"EncodedResource.java:152"$1$"	 * {@link #getCharset() Charset} or {@linkplain #getEncoding() encoding}."
"EncodedResource.java:153"$0$"	 * @throws IOException if opening the InputStream failed"
"EncodedResource.java:154"$0$"	 * @see #requiresReader()"
"EncodedResource.java:155"$0$"	 * @see #getReader()"
"EncodedResource.java:156"$0$"	 */"
"EncodedResource.java:157"$0$"	@Override"
"EncodedResource.java:158"$1$"	public InputStream getInputStream() throws IOException {"
"EncodedResource.java:159"$1$"		return this.resource.getInputStream();"
"EncodedResource.java:160"$1$"	}"
"EncodedResource.java:161"$0$""
"EncodedResource.java:162"$0$""
"EncodedResource.java:163"$0$"	@Override"
"EncodedResource.java:164"$1$"	public boolean equals(@Nullable Object other) {"
"EncodedResource.java:165"$1$"		if (this == other) {"
"EncodedResource.java:166"$1$"			return true;"
"EncodedResource.java:167"$1$"		}"
"EncodedResource.java:168"$1$"		if (!(other instanceof EncodedResource)) {"
"EncodedResource.java:169"$1$"			return false;"
"EncodedResource.java:170"$1$"		}"
"EncodedResource.java:171"$0$"		EncodedResource otherResource = (EncodedResource) other;"
"EncodedResource.java:172"$0$"		return (this.resource.equals(otherResource.resource) &&"
"EncodedResource.java:173"$0$"				ObjectUtils.nullSafeEquals(this.charset, otherResource.charset) &&"
"EncodedResource.java:174"$0$"				ObjectUtils.nullSafeEquals(this.encoding, otherResource.encoding));"
"EncodedResource.java:175"$0$"	}"
"EncodedResource.java:176"$0$""
"EncodedResource.java:177"$0$"	@Override"
"EncodedResource.java:178"$1$"	public int hashCode() {"
"EncodedResource.java:179"$1$"		return this.resource.hashCode();"
"EncodedResource.java:180"$1$"	}"
"EncodedResource.java:181"$0$""
"EncodedResource.java:182"$0$"	@Override"
"EncodedResource.java:183"$1$"	public String toString() {"
"EncodedResource.java:184"$1$"		return this.resource.toString();"
"EncodedResource.java:185"$1$"	}"
"EncodedResource.java:186"$0$""
"EncodedResource.java:187"$0$"}"
"OrderUtils.java:1"$0$"/*"
"OrderUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"OrderUtils.java:3"$0$" *"
"OrderUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"OrderUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"OrderUtils.java:6"$0$" * You may obtain a copy of the License at"
"OrderUtils.java:7"$0$" *"
"OrderUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"OrderUtils.java:9"$0$" *"
"OrderUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"OrderUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"OrderUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"OrderUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"OrderUtils.java:14"$0$" * limitations under the License."
"OrderUtils.java:15"$0$" */"
"OrderUtils.java:16"$0$""
"OrderUtils.java:17"$0$"package org.springframework.core.annotation;"
"OrderUtils.java:18"$0$""
"OrderUtils.java:19"$0$"import java.lang.reflect.AnnotatedElement;"
"OrderUtils.java:20"$0$"import java.util.Map;"
"OrderUtils.java:21"$0$""
"OrderUtils.java:22"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"OrderUtils.java:23"$0$"import org.springframework.lang.Nullable;"
"OrderUtils.java:24"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"OrderUtils.java:25"$0$""
"OrderUtils.java:26"$0$"/**"
"OrderUtils.java:27"$0$" * General utility for determining the order of an object based on its type declaration."
"OrderUtils.java:28"$1$" * Handles Spring's {@link Order} annotation as well as {@link javax.annotation.Priority}."
"OrderUtils.java:29"$0$" *"
"OrderUtils.java:30"$0$" * @author Stephane Nicoll"
"OrderUtils.java:31"$0$" * @author Juergen Hoeller"
"OrderUtils.java:32"$0$" * @since 4.1"
"OrderUtils.java:33"$0$" * @see Order"
"OrderUtils.java:34"$0$" * @see javax.annotation.Priority"
"OrderUtils.java:35"$0$" */"
"OrderUtils.java:36"$1$"public abstract class OrderUtils {"
"OrderUtils.java:37"$1$""
"OrderUtils.java:38"$1$"	/** Cache marker for a non-annotated Class. */"
"OrderUtils.java:39"$1$"	private static final Object NOT_ANNOTATED = new Object();"
"OrderUtils.java:40"$1$""
"OrderUtils.java:41"$1$"	private static final String JAVAX_PRIORITY_ANNOTATION = ""javax.annotation.Priority"";"
"OrderUtils.java:42"$1$""
"OrderUtils.java:43"$1$"	/** Cache for @Order value (or NOT_ANNOTATED marker) per Class. */"
"OrderUtils.java:44"$1$"	private static final Map<AnnotatedElement, Object> orderCache = new ConcurrentReferenceHashMap<>(64);"
"OrderUtils.java:45"$1$""
"OrderUtils.java:46"$1$""
"OrderUtils.java:47"$1$"	/**"
"OrderUtils.java:48"$1$"	 * Return the order on the specified {@code type}, or the specified"
"OrderUtils.java:49"$1$"	 * default value if none can be found."
"OrderUtils.java:50"$1$"	 * <p>Takes care of {@link Order @Order} and {@code @javax.annotation.Priority}."
"OrderUtils.java:51"$1$"	 * @param type the type to handle"
"OrderUtils.java:52"$1$"	 * @return the priority value, or the specified default order if none can be found"
"OrderUtils.java:53"$1$"	 * @since 5.0"
"OrderUtils.java:54"$1$"	 * @see #getPriority(Class)"
"OrderUtils.java:55"$1$"	 */"
"OrderUtils.java:56"$1$"	public static int getOrder(Class<?> type, int defaultOrder) {"
"OrderUtils.java:57"$1$"		Integer order = getOrder(type);"
"OrderUtils.java:58"$1$"		return (order != null ? order : defaultOrder);"
"OrderUtils.java:59"$1$"	}"
"OrderUtils.java:60"$0$""
"OrderUtils.java:61"$0$"	/**"
"OrderUtils.java:62"$1$"	 * Return the order on the specified {@code type}, or the specified"
"OrderUtils.java:63"$0$"	 * default value if none can be found."
"OrderUtils.java:64"$1$"	 * <p>Takes care of {@link Order @Order} and {@code @javax.annotation.Priority}."
"OrderUtils.java:65"$0$"	 * @param type the type to handle"
"OrderUtils.java:66"$0$"	 * @return the priority value, or the specified default order if none can be found"
"OrderUtils.java:67"$0$"	 * @see #getPriority(Class)"
"OrderUtils.java:68"$0$"	 */"
"OrderUtils.java:69"$0$"	@Nullable"
"OrderUtils.java:70"$1$"	public static Integer getOrder(Class<?> type, @Nullable Integer defaultOrder) {"
"OrderUtils.java:71"$1$"		Integer order = getOrder(type);"
"OrderUtils.java:72"$1$"		return (order != null ? order : defaultOrder);"
"OrderUtils.java:73"$1$"	}"
"OrderUtils.java:74"$0$""
"OrderUtils.java:75"$0$"	/**"
"OrderUtils.java:76"$1$"	 * Return the order on the specified {@code type}."
"OrderUtils.java:77"$1$"	 * <p>Takes care of {@link Order @Order} and {@code @javax.annotation.Priority}."
"OrderUtils.java:78"$0$"	 * @param type the type to handle"
"OrderUtils.java:79"$1$"	 * @return the order value, or {@code null} if none can be found"
"OrderUtils.java:80"$0$"	 * @see #getPriority(Class)"
"OrderUtils.java:81"$0$"	 */"
"OrderUtils.java:82"$0$"	@Nullable"
"OrderUtils.java:83"$1$"	public static Integer getOrder(Class<?> type) {"
"OrderUtils.java:84"$1$"		return getOrderFromAnnotations(type, MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY));"
"OrderUtils.java:85"$1$"	}"
"OrderUtils.java:86"$0$""
"OrderUtils.java:87"$0$"	/**"
"OrderUtils.java:88"$0$"	 * Return the order from the specified annotations collection."
"OrderUtils.java:89"$1$"	 * <p>Takes care of {@link Order @Order} and"
"OrderUtils.java:90"$1$"	 * {@code @javax.annotation.Priority}."
"OrderUtils.java:91"$0$"	 * @param element the source element"
"OrderUtils.java:92"$0$"	 * @param annotations the annotation to consider"
"OrderUtils.java:93"$1$"	 * @return the order value, or {@code null} if none can be found"
"OrderUtils.java:94"$0$"	 */"
"OrderUtils.java:95"$0$"	@Nullable"
"OrderUtils.java:96"$1$"	static Integer getOrderFromAnnotations(AnnotatedElement element, MergedAnnotations annotations) {"
"OrderUtils.java:97"$1$"		if (!(element instanceof Class)) {"
"OrderUtils.java:98"$1$"			return findOrder(annotations);"
"OrderUtils.java:99"$1$"		}"
"OrderUtils.java:100"$0$"		Object cached = orderCache.get(element);"
"OrderUtils.java:101"$1$"		if (cached != null) {"
"OrderUtils.java:102"$1$"			return (cached instanceof Integer ? (Integer) cached : null);"
"OrderUtils.java:103"$1$"		}"
"OrderUtils.java:104"$0$"		Integer result = findOrder(annotations);"
"OrderUtils.java:105"$0$"		orderCache.put(element, result != null ? result : NOT_ANNOTATED);"
"OrderUtils.java:106"$0$"		return result;"
"OrderUtils.java:107"$0$"	}"
"OrderUtils.java:108"$0$""
"OrderUtils.java:109"$0$"	@Nullable"
"OrderUtils.java:110"$1$"	private static Integer findOrder(MergedAnnotations annotations) {"
"OrderUtils.java:111"$1$"		MergedAnnotation<Order> orderAnnotation = annotations.get(Order.class);"
"OrderUtils.java:112"$1$"		if (orderAnnotation.isPresent()) {"
"OrderUtils.java:113"$1$"			return orderAnnotation.getInt(MergedAnnotation.VALUE);"
"OrderUtils.java:114"$1$"		}"
"OrderUtils.java:115"$0$"		MergedAnnotation<?> priorityAnnotation = annotations.get(JAVAX_PRIORITY_ANNOTATION);"
"OrderUtils.java:116"$1$"		if (priorityAnnotation.isPresent()) {"
"OrderUtils.java:117"$1$"			return priorityAnnotation.getInt(MergedAnnotation.VALUE);"
"OrderUtils.java:118"$1$"		}"
"OrderUtils.java:119"$0$"		return null;"
"OrderUtils.java:120"$0$"	}"
"OrderUtils.java:121"$0$""
"OrderUtils.java:122"$0$"	/**"
"OrderUtils.java:123"$1$"	 * Return the value of the {@code javax.annotation.Priority} annotation"
"OrderUtils.java:124"$1$"	 * declared on the specified type, or {@code null} if none."
"OrderUtils.java:125"$0$"	 * @param type the type to handle"
"OrderUtils.java:126"$1$"	 * @return the priority value if the annotation is declared, or {@code null} if none"
"OrderUtils.java:127"$0$"	 */"
"OrderUtils.java:128"$0$"	@Nullable"
"OrderUtils.java:129"$1$"	public static Integer getPriority(Class<?> type) {"
"OrderUtils.java:130"$1$"		return MergedAnnotations.from(type, SearchStrategy.TYPE_HIERARCHY).get(JAVAX_PRIORITY_ANNOTATION)"
"OrderUtils.java:131"$1$"				.getValue(MergedAnnotation.VALUE, Integer.class).orElse(null);"
"OrderUtils.java:132"$1$"	}"
"OrderUtils.java:133"$0$""
"OrderUtils.java:134"$0$"}"
"PropertySource.java:1"$0$"/*"
"PropertySource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"PropertySource.java:3"$0$" *"
"PropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"PropertySource.java:6"$0$" * You may obtain a copy of the License at"
"PropertySource.java:7"$0$" *"
"PropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PropertySource.java:9"$0$" *"
"PropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"PropertySource.java:14"$0$" * limitations under the License."
"PropertySource.java:15"$0$" */"
"PropertySource.java:16"$0$""
"PropertySource.java:17"$0$"package org.springframework.core.env;"
"PropertySource.java:18"$0$""
"PropertySource.java:19"$0$"import org.apache.commons.logging.Log;"
"PropertySource.java:20"$0$"import org.apache.commons.logging.LogFactory;"
"PropertySource.java:21"$0$""
"PropertySource.java:22"$0$"import org.springframework.lang.Nullable;"
"PropertySource.java:23"$0$"import org.springframework.util.Assert;"
"PropertySource.java:24"$0$"import org.springframework.util.ObjectUtils;"
"PropertySource.java:25"$0$""
"PropertySource.java:26"$0$"/**"
"PropertySource.java:27"$0$" * Abstract base class representing a source of name/value property pairs. The underlying"
"PropertySource.java:28"$1$" * {@linkplain #getSource() source object} may be of any type {@code T} that encapsulates"
"PropertySource.java:29"$1$" * properties. Examples include {@link java.util.Properties} objects, {@link java.util.Map}"
"PropertySource.java:30"$1$" * objects, {@code ServletContext} and {@code ServletConfig} objects (for access to init"
"PropertySource.java:31"$1$" * parameters). Explore the {@code PropertySource} type hierarchy to see provided"
"PropertySource.java:32"$0$" * implementations."
"PropertySource.java:33"$0$" *"
"PropertySource.java:34"$1$" * <p>{@code PropertySource} objects are not typically used in isolation, but rather"
"PropertySource.java:35"$1$" * through a {@link PropertySources} object, which aggregates property sources and in"
"PropertySource.java:36"$1$" * conjunction with a {@link PropertyResolver} implementation that can perform"
"PropertySource.java:37"$1$" * precedence-based searches across the set of {@code PropertySources}."
"PropertySource.java:38"$0$" *"
"PropertySource.java:39"$1$" * <p>{@code PropertySource} identity is determined not based on the content of"
"PropertySource.java:40"$1$" * encapsulated properties, but rather based on the {@link #getName() name} of the"
"PropertySource.java:41"$1$" * {@code PropertySource} alone. This is useful for manipulating {@code PropertySource}"
"PropertySource.java:42"$1$" * objects when in collection contexts. See operations in {@link MutablePropertySources}"
"PropertySource.java:43"$1$" * as well as the {@link #named(String)} and {@link #toString()} methods for details."
"PropertySource.java:44"$0$" *"
"PropertySource.java:45"$1$" * <p>Note that when working with @{@link"
"PropertySource.java:46"$1$" * org.springframework.context.annotation.Configuration Configuration} classes that"
"PropertySource.java:47"$1$" * the @{@link org.springframework.context.annotation.PropertySource PropertySource}"
"PropertySource.java:48"$0$" * annotation provides a convenient and declarative way of adding property sources to the"
"PropertySource.java:49"$1$" * enclosing {@code Environment}."
"PropertySource.java:50"$0$" *"
"PropertySource.java:51"$0$" * @author Chris Beams"
"PropertySource.java:52"$0$" * @since 3.1"
"PropertySource.java:53"$0$" * @param <T> the source type"
"PropertySource.java:54"$0$" * @see PropertySources"
"PropertySource.java:55"$0$" * @see PropertyResolver"
"PropertySource.java:56"$0$" * @see PropertySourcesPropertyResolver"
"PropertySource.java:57"$0$" * @see MutablePropertySources"
"PropertySource.java:58"$0$" * @see org.springframework.context.annotation.PropertySource"
"PropertySource.java:59"$0$" */"
"PropertySource.java:60"$1$"public abstract class PropertySource<T> {"
"PropertySource.java:61"$1$""
"PropertySource.java:62"$1$"	protected final Log logger = LogFactory.getLog(getClass());"
"PropertySource.java:63"$1$""
"PropertySource.java:64"$1$"	protected final String name;"
"PropertySource.java:65"$1$""
"PropertySource.java:66"$1$"	protected final T source;"
"PropertySource.java:67"$1$""
"PropertySource.java:68"$1$""
"PropertySource.java:69"$1$"	/**"
"PropertySource.java:70"$1$"	 * Create a new {@code PropertySource} with the given name and source object."
"PropertySource.java:71"$1$"	 */"
"PropertySource.java:72"$1$"	public PropertySource(String name, T source) {"
"PropertySource.java:73"$1$"		Assert.hasText(name, ""Property source name must contain at least one character"");"
"PropertySource.java:74"$1$"		Assert.notNull(source, ""Property source must not be null"");"
"PropertySource.java:75"$1$"		this.name = name;"
"PropertySource.java:76"$1$"		this.source = source;"
"PropertySource.java:77"$1$"	}"
"PropertySource.java:78"$0$""
"PropertySource.java:79"$0$"	/**"
"PropertySource.java:80"$1$"	 * Create a new {@code PropertySource} with the given name and with a new"
"PropertySource.java:81"$1$"	 * {@code Object} instance as the underlying source."
"PropertySource.java:82"$0$"	 * <p>Often useful in testing scenarios when creating anonymous implementations"
"PropertySource.java:83"$0$"	 * that never query an actual source but rather return hard-coded values."
"PropertySource.java:84"$0$"	 */"
"PropertySource.java:85"$0$"	@SuppressWarnings(""unchecked"")"
"PropertySource.java:86"$1$"	public PropertySource(String name) {"
"PropertySource.java:87"$1$"		this(name, (T) new Object());"
"PropertySource.java:88"$1$"	}"
"PropertySource.java:89"$0$""
"PropertySource.java:90"$0$""
"PropertySource.java:91"$0$"	/**"
"PropertySource.java:92"$1$"	 * Return the name of this {@code PropertySource}."
"PropertySource.java:93"$0$"	 */"
"PropertySource.java:94"$1$"	public String getName() {"
"PropertySource.java:95"$1$"		return this.name;"
"PropertySource.java:96"$1$"	}"
"PropertySource.java:97"$0$""
"PropertySource.java:98"$0$"	/**"
"PropertySource.java:99"$1$"	 * Return the underlying source object for this {@code PropertySource}."
"PropertySource.java:100"$0$"	 */"
"PropertySource.java:101"$1$"	public T getSource() {"
"PropertySource.java:102"$1$"		return this.source;"
"PropertySource.java:103"$1$"	}"
"PropertySource.java:104"$0$""
"PropertySource.java:105"$0$"	/**"
"PropertySource.java:106"$1$"	 * Return whether this {@code PropertySource} contains the given name."
"PropertySource.java:107"$1$"	 * <p>This implementation simply checks for a {@code null} return value"
"PropertySource.java:108"$1$"	 * from {@link #getProperty(String)}. Subclasses may wish to implement"
"PropertySource.java:109"$0$"	 * a more efficient algorithm if possible."
"PropertySource.java:110"$0$"	 * @param name the property name to find"
"PropertySource.java:111"$0$"	 */"
"PropertySource.java:112"$1$"	public boolean containsProperty(String name) {"
"PropertySource.java:113"$1$"		return (getProperty(name) != null);"
"PropertySource.java:114"$1$"	}"
"PropertySource.java:115"$0$""
"PropertySource.java:116"$0$"	/**"
"PropertySource.java:117"$0$"	 * Return the value associated with the given name,"
"PropertySource.java:118"$1$"	 * or {@code null} if not found."
"PropertySource.java:119"$0$"	 * @param name the property to find"
"PropertySource.java:120"$0$"	 * @see PropertyResolver#getRequiredProperty(String)"
"PropertySource.java:121"$0$"	 */"
"PropertySource.java:122"$0$"	@Nullable"
"PropertySource.java:123"$0$"	public abstract Object getProperty(String name);"
"PropertySource.java:124"$0$""
"PropertySource.java:125"$0$""
"PropertySource.java:126"$0$"	/**"
"PropertySource.java:127"$1$"	 * This {@code PropertySource} object is equal to the given object if:"
"PropertySource.java:128"$0$"	 * <ul>"
"PropertySource.java:129"$0$"	 * <li>they are the same instance"
"PropertySource.java:130"$1$"	 * <li>the {@code name} properties for both objects are equal"
"PropertySource.java:131"$0$"	 * </ul>"
"PropertySource.java:132"$1$"	 * <p>No properties other than {@code name} are evaluated."
"PropertySource.java:133"$0$"	 */"
"PropertySource.java:134"$0$"	@Override"
"PropertySource.java:135"$1$"	public boolean equals(@Nullable Object other) {"
"PropertySource.java:136"$1$"		return (this == other || (other instanceof PropertySource &&"
"PropertySource.java:137"$1$"				ObjectUtils.nullSafeEquals(this.name, ((PropertySource<?>) other).name)));"
"PropertySource.java:138"$1$"	}"
"PropertySource.java:139"$0$""
"PropertySource.java:140"$0$"	/**"
"PropertySource.java:141"$1$"	 * Return a hash code derived from the {@code name} property"
"PropertySource.java:142"$1$"	 * of this {@code PropertySource} object."
"PropertySource.java:143"$0$"	 */"
"PropertySource.java:144"$0$"	@Override"
"PropertySource.java:145"$1$"	public int hashCode() {"
"PropertySource.java:146"$1$"		return ObjectUtils.nullSafeHashCode(this.name);"
"PropertySource.java:147"$1$"	}"
"PropertySource.java:148"$0$""
"PropertySource.java:149"$0$"	/**"
"PropertySource.java:150"$0$"	 * Produce concise output (type and name) if the current log level does not include"
"PropertySource.java:151"$0$"	 * debug. If debug is enabled, produce verbose output including the hash code of the"
"PropertySource.java:152"$0$"	 * PropertySource instance and every name/value property pair."
"PropertySource.java:153"$0$"	 * <p>This variable verbosity is useful as a property source such as system properties"
"PropertySource.java:154"$0$"	 * or environment variables may contain an arbitrary number of property pairs,"
"PropertySource.java:155"$0$"	 * potentially leading to difficult to read exception and log messages."
"PropertySource.java:156"$0$"	 * @see Log#isDebugEnabled()"
"PropertySource.java:157"$0$"	 */"
"PropertySource.java:158"$0$"	@Override"
"PropertySource.java:159"$1$"	public String toString() {"
"PropertySource.java:160"$1$"		if (logger.isDebugEnabled()) {"
"PropertySource.java:161"$1$"			return getClass().getSimpleName() + ""@"" + System.identityHashCode(this) +"
"PropertySource.java:162"$1$"					"" {name='"" + this.name + ""', properties="" + this.source + ""}"";"
"PropertySource.java:163"$1$"		}"
"PropertySource.java:164"$1$"		else {"
"PropertySource.java:165"$1$"			return getClass().getSimpleName() + "" {name='"" + this.name + ""'}"";"
"PropertySource.java:166"$1$"		}"
"PropertySource.java:167"$0$"	}"
"PropertySource.java:168"$0$""
"PropertySource.java:169"$0$""
"PropertySource.java:170"$0$"	/**"
"PropertySource.java:171"$1$"	 * Return a {@code PropertySource} implementation intended for collection comparison purposes only."
"PropertySource.java:172"$1$"	 * <p>Primarily for internal use, but given a collection of {@code PropertySource} objects, may be"
"PropertySource.java:173"$0$"	 * used as follows:"
"PropertySource.java:174"$0$"	 * <pre class=""code"">"
"PropertySource.java:175"$1$"	 * {@code List<PropertySource<?>> sources = new ArrayList<PropertySource<?>>();"
"PropertySource.java:176"$1$"	 * sources.add(new MapPropertySource(""sourceA"", mapA));"
"PropertySource.java:177"$1$"	 * sources.add(new MapPropertySource(""sourceB"", mapB));"
"PropertySource.java:178"$1$"	 * assert sources.contains(PropertySource.named(""sourceA""));"
"PropertySource.java:179"$1$"	 * assert sources.contains(PropertySource.named(""sourceB""));"
"PropertySource.java:180"$1$"	 * assert !sources.contains(PropertySource.named(""sourceC""));"
"PropertySource.java:181"$1$"	 * }</pre>"
"PropertySource.java:182"$1$"	 * The returned {@code PropertySource} will throw {@code UnsupportedOperationException}"
"PropertySource.java:183"$1$"	 * if any methods other than {@code equals(Object)}, {@code hashCode()}, and {@code toString()}"
"PropertySource.java:184"$0$"	 * are called."
"PropertySource.java:185"$1$"	 * @param name the name of the comparison {@code PropertySource} to be created and returned."
"PropertySource.java:186"$0$"	 */"
"PropertySource.java:187"$1$"	public static PropertySource<?> named(String name) {"
"PropertySource.java:188"$1$"		return new ComparisonPropertySource(name);"
"PropertySource.java:189"$1$"	}"
"PropertySource.java:190"$0$""
"PropertySource.java:191"$0$""
"PropertySource.java:192"$0$"	/**"
"PropertySource.java:193"$1$"	 * {@code PropertySource} to be used as a placeholder in cases where an actual"
"PropertySource.java:194"$0$"	 * property source cannot be eagerly initialized at application context"
"PropertySource.java:195"$1$"	 * creation time.  For example, a {@code ServletContext}-based property source"
"PropertySource.java:196"$1$"	 * must wait until the {@code ServletContext} object is available to its enclosing"
"PropertySource.java:197"$1$"	 * {@code ApplicationContext}.  In such cases, a stub should be used to hold the"
"PropertySource.java:198"$0$"	 * intended default position/order of the property source, then be replaced"
"PropertySource.java:199"$0$"	 * during context refresh."
"PropertySource.java:200"$0$"	 * @see org.springframework.context.support.AbstractApplicationContext#initPropertySources()"
"PropertySource.java:201"$0$"	 * @see org.springframework.web.context.support.StandardServletEnvironment"
"PropertySource.java:202"$0$"	 * @see org.springframework.web.context.support.ServletContextPropertySource"
"PropertySource.java:203"$0$"	 */"
"PropertySource.java:204"$1$"	public static class StubPropertySource extends PropertySource<Object> {"
"PropertySource.java:205"$1$""
"PropertySource.java:206"$1$"		public StubPropertySource(String name) {"
"PropertySource.java:207"$1$"			super(name, new Object());"
"PropertySource.java:208"$1$"		}"
"PropertySource.java:209"$0$""
"PropertySource.java:210"$0$"		/**"
"PropertySource.java:211"$1$"		 * Always returns {@code null}."
"PropertySource.java:212"$0$"		 */"
"PropertySource.java:213"$0$"		@Override"
"PropertySource.java:214"$0$"		@Nullable"
"PropertySource.java:215"$1$"		public String getProperty(String name) {"
"PropertySource.java:216"$1$"			return null;"
"PropertySource.java:217"$1$"		}"
"PropertySource.java:218"$0$"	}"
"PropertySource.java:219"$0$""
"PropertySource.java:220"$0$""
"PropertySource.java:221"$0$"	/**"
"PropertySource.java:222"$1$"	 * A {@code PropertySource} implementation intended for collection comparison"
"PropertySource.java:223"$0$"	 * purposes."
"PropertySource.java:224"$0$"	 *"
"PropertySource.java:225"$0$"	 * @see PropertySource#named(String)"
"PropertySource.java:226"$0$"	 */"
"PropertySource.java:227"$1$"	static class ComparisonPropertySource extends StubPropertySource {"
"PropertySource.java:228"$1$""
"PropertySource.java:229"$1$"		private static final String USAGE_ERROR ="
"PropertySource.java:230"$1$"				""ComparisonPropertySource instances are for use with collection comparison only"";"
"PropertySource.java:231"$1$""
"PropertySource.java:232"$1$"		public ComparisonPropertySource(String name) {"
"PropertySource.java:233"$1$"			super(name);"
"PropertySource.java:234"$1$"		}"
"PropertySource.java:235"$0$""
"PropertySource.java:236"$0$"		@Override"
"PropertySource.java:237"$1$"		public Object getSource() {"
"PropertySource.java:238"$1$"			throw new UnsupportedOperationException(USAGE_ERROR);"
"PropertySource.java:239"$1$"		}"
"PropertySource.java:240"$0$""
"PropertySource.java:241"$0$"		@Override"
"PropertySource.java:242"$1$"		public boolean containsProperty(String name) {"
"PropertySource.java:243"$1$"			throw new UnsupportedOperationException(USAGE_ERROR);"
"PropertySource.java:244"$1$"		}"
"PropertySource.java:245"$0$""
"PropertySource.java:246"$0$"		@Override"
"PropertySource.java:247"$0$"		@Nullable"
"PropertySource.java:248"$1$"		public String getProperty(String name) {"
"PropertySource.java:249"$1$"			throw new UnsupportedOperationException(USAGE_ERROR);"
"PropertySource.java:250"$1$"		}"
"PropertySource.java:251"$0$"	}"
"PropertySource.java:252"$0$""
"PropertySource.java:253"$0$"}"
"StreamUtils.java:1"$0$"/*"
"StreamUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"StreamUtils.java:3"$0$" *"
"StreamUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StreamUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"StreamUtils.java:6"$0$" * You may obtain a copy of the License at"
"StreamUtils.java:7"$0$" *"
"StreamUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StreamUtils.java:9"$0$" *"
"StreamUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StreamUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StreamUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StreamUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"StreamUtils.java:14"$0$" * limitations under the License."
"StreamUtils.java:15"$0$" */"
"StreamUtils.java:16"$0$""
"StreamUtils.java:17"$0$"package org.springframework.util;"
"StreamUtils.java:18"$0$""
"StreamUtils.java:19"$0$"import java.io.ByteArrayInputStream;"
"StreamUtils.java:20"$0$"import java.io.ByteArrayOutputStream;"
"StreamUtils.java:21"$0$"import java.io.FilterInputStream;"
"StreamUtils.java:22"$0$"import java.io.FilterOutputStream;"
"StreamUtils.java:23"$0$"import java.io.IOException;"
"StreamUtils.java:24"$0$"import java.io.InputStream;"
"StreamUtils.java:25"$0$"import java.io.InputStreamReader;"
"StreamUtils.java:26"$0$"import java.io.OutputStream;"
"StreamUtils.java:27"$0$"import java.io.OutputStreamWriter;"
"StreamUtils.java:28"$0$"import java.io.UnsupportedEncodingException;"
"StreamUtils.java:29"$0$"import java.io.Writer;"
"StreamUtils.java:30"$0$"import java.nio.charset.Charset;"
"StreamUtils.java:31"$0$""
"StreamUtils.java:32"$0$"import org.springframework.lang.Nullable;"
"StreamUtils.java:33"$0$""
"StreamUtils.java:34"$0$"/**"
"StreamUtils.java:35"$0$" * Simple utility methods for dealing with streams. The copy methods of this class are"
"StreamUtils.java:36"$1$" * similar to those defined in {@link FileCopyUtils} except that all affected streams are"
"StreamUtils.java:37"$0$" * left open when done. All copy methods use a block size of 4096 bytes."
"StreamUtils.java:38"$0$" *"
"StreamUtils.java:39"$0$" * <p>Mainly for use within the framework, but also useful for application code."
"StreamUtils.java:40"$0$" *"
"StreamUtils.java:41"$0$" * @author Juergen Hoeller"
"StreamUtils.java:42"$0$" * @author Phillip Webb"
"StreamUtils.java:43"$0$" * @author Brian Clozel"
"StreamUtils.java:44"$0$" * @since 3.2.2"
"StreamUtils.java:45"$0$" * @see FileCopyUtils"
"StreamUtils.java:46"$0$" */"
"StreamUtils.java:47"$1$"public abstract class StreamUtils {"
"StreamUtils.java:48"$1$""
"StreamUtils.java:49"$1$"	/**"
"StreamUtils.java:50"$1$"	 * The default buffer size used when copying bytes."
"StreamUtils.java:51"$1$"	 */"
"StreamUtils.java:52"$1$"	public static final int BUFFER_SIZE = 4096;"
"StreamUtils.java:53"$1$""
"StreamUtils.java:54"$1$"	private static final byte[] EMPTY_CONTENT = new byte[0];"
"StreamUtils.java:55"$1$""
"StreamUtils.java:56"$1$""
"StreamUtils.java:57"$1$"	/**"
"StreamUtils.java:58"$1$"	 * Copy the contents of the given InputStream into a new byte array."
"StreamUtils.java:59"$1$"	 * <p>Leaves the stream open when done."
"StreamUtils.java:60"$1$"	 * @param in the stream to copy from (may be {@code null} or empty)"
"StreamUtils.java:61"$1$"	 * @return the new byte array that has been copied to (possibly empty)"
"StreamUtils.java:62"$1$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:63"$1$"	 */"
"StreamUtils.java:64"$1$"	public static byte[] copyToByteArray(@Nullable InputStream in) throws IOException {"
"StreamUtils.java:65"$1$"		if (in == null) {"
"StreamUtils.java:66"$1$"			return new byte[0];"
"StreamUtils.java:67"$1$"		}"
"StreamUtils.java:68"$0$""
"StreamUtils.java:69"$0$"		ByteArrayOutputStream out = new ByteArrayOutputStream(BUFFER_SIZE);"
"StreamUtils.java:70"$0$"		copy(in, out);"
"StreamUtils.java:71"$0$"		return out.toByteArray();"
"StreamUtils.java:72"$0$"	}"
"StreamUtils.java:73"$0$""
"StreamUtils.java:74"$0$"	/**"
"StreamUtils.java:75"$0$"	 * Copy the contents of the given InputStream into a String."
"StreamUtils.java:76"$0$"	 * <p>Leaves the stream open when done."
"StreamUtils.java:77"$1$"	 * @param in the InputStream to copy from (may be {@code null} or empty)"
"StreamUtils.java:78"$1$"	 * @param charset the {@link Charset} to use to decode the bytes"
"StreamUtils.java:79"$0$"	 * @return the String that has been copied to (possibly empty)"
"StreamUtils.java:80"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:81"$0$"	 */"
"StreamUtils.java:82"$1$"	public static String copyToString(@Nullable InputStream in, Charset charset) throws IOException {"
"StreamUtils.java:83"$1$"		if (in == null) {"
"StreamUtils.java:84"$1$"			return """";"
"StreamUtils.java:85"$1$"		}"
"StreamUtils.java:86"$0$""
"StreamUtils.java:87"$0$"		StringBuilder out = new StringBuilder();"
"StreamUtils.java:88"$0$"		InputStreamReader reader = new InputStreamReader(in, charset);"
"StreamUtils.java:89"$0$"		char[] buffer = new char[BUFFER_SIZE];"
"StreamUtils.java:90"$0$"		int bytesRead = -1;"
"StreamUtils.java:91"$1$"		while ((bytesRead = reader.read(buffer)) != -1) {"
"StreamUtils.java:92"$1$"			out.append(buffer, 0, bytesRead);"
"StreamUtils.java:93"$1$"		}"
"StreamUtils.java:94"$0$"		return out.toString();"
"StreamUtils.java:95"$0$"	}"
"StreamUtils.java:96"$0$""
"StreamUtils.java:97"$0$"	/**"
"StreamUtils.java:98"$1$"	 * Copy the contents of the given {@link ByteArrayOutputStream} into a {@link String}."
"StreamUtils.java:99"$1$"	 * <p>This is a more effective equivalent of {@code new String(baos.toByteArray(), charset)}."
"StreamUtils.java:100"$1$"	 * <p>As long as the {@code charset} is already available at the point of"
"StreamUtils.java:101"$0$"	 * invocation, no exception is expected to be thrown by this method."
"StreamUtils.java:102"$1$"	 * @param baos the {@code ByteArrayOutputStream} to be copied into a String"
"StreamUtils.java:103"$1$"	 * @param charset the {@link Charset} to use to decode the bytes"
"StreamUtils.java:104"$0$"	 * @return the String that has been copied to (possibly empty)"
"StreamUtils.java:105"$0$"	 * @since 5.2.6"
"StreamUtils.java:106"$0$"	 */"
"StreamUtils.java:107"$1$"	public static String copyToString(ByteArrayOutputStream baos, Charset charset) {"
"StreamUtils.java:108"$1$"		Assert.notNull(baos, ""No ByteArrayOutputStream specified"");"
"StreamUtils.java:109"$1$"		Assert.notNull(charset, ""No Charset specified"");"
"StreamUtils.java:110"$1$"		try {"
"StreamUtils.java:111"$1$"			return baos.toString(charset.name());"
"StreamUtils.java:112"$1$"		}"
"StreamUtils.java:113"$1$"		catch (UnsupportedEncodingException ex) {"
"StreamUtils.java:114"$1$"			throw new RuntimeException(""Failed to copy contents of ByteArrayOutputStream into a String"", ex);"
"StreamUtils.java:115"$1$"		}"
"StreamUtils.java:116"$0$"	}"
"StreamUtils.java:117"$0$""
"StreamUtils.java:118"$0$"	/**"
"StreamUtils.java:119"$0$"	 * Copy the contents of the given byte array to the given OutputStream."
"StreamUtils.java:120"$0$"	 * <p>Leaves the stream open when done."
"StreamUtils.java:121"$0$"	 * @param in the byte array to copy from"
"StreamUtils.java:122"$0$"	 * @param out the OutputStream to copy to"
"StreamUtils.java:123"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:124"$0$"	 */"
"StreamUtils.java:125"$1$"	public static void copy(byte[] in, OutputStream out) throws IOException {"
"StreamUtils.java:126"$1$"		Assert.notNull(in, ""No input byte array specified"");"
"StreamUtils.java:127"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"StreamUtils.java:128"$1$""
"StreamUtils.java:129"$1$"		out.write(in);"
"StreamUtils.java:130"$1$"	}"
"StreamUtils.java:131"$0$""
"StreamUtils.java:132"$0$"	/**"
"StreamUtils.java:133"$0$"	 * Copy the contents of the given String to the given output OutputStream."
"StreamUtils.java:134"$0$"	 * <p>Leaves the stream open when done."
"StreamUtils.java:135"$0$"	 * @param in the String to copy from"
"StreamUtils.java:136"$0$"	 * @param charset the Charset"
"StreamUtils.java:137"$0$"	 * @param out the OutputStream to copy to"
"StreamUtils.java:138"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:139"$0$"	 */"
"StreamUtils.java:140"$1$"	public static void copy(String in, Charset charset, OutputStream out) throws IOException {"
"StreamUtils.java:141"$1$"		Assert.notNull(in, ""No input String specified"");"
"StreamUtils.java:142"$1$"		Assert.notNull(charset, ""No Charset specified"");"
"StreamUtils.java:143"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"StreamUtils.java:144"$1$""
"StreamUtils.java:145"$1$"		Writer writer = new OutputStreamWriter(out, charset);"
"StreamUtils.java:146"$1$"		writer.write(in);"
"StreamUtils.java:147"$1$"		writer.flush();"
"StreamUtils.java:148"$1$"	}"
"StreamUtils.java:149"$0$""
"StreamUtils.java:150"$0$"	/**"
"StreamUtils.java:151"$0$"	 * Copy the contents of the given InputStream to the given OutputStream."
"StreamUtils.java:152"$0$"	 * <p>Leaves both streams open when done."
"StreamUtils.java:153"$0$"	 * @param in the InputStream to copy from"
"StreamUtils.java:154"$0$"	 * @param out the OutputStream to copy to"
"StreamUtils.java:155"$0$"	 * @return the number of bytes copied"
"StreamUtils.java:156"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:157"$0$"	 */"
"StreamUtils.java:158"$1$"	public static int copy(InputStream in, OutputStream out) throws IOException {"
"StreamUtils.java:159"$1$"		Assert.notNull(in, ""No InputStream specified"");"
"StreamUtils.java:160"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"StreamUtils.java:161"$1$""
"StreamUtils.java:162"$1$"		int byteCount = 0;"
"StreamUtils.java:163"$1$"		byte[] buffer = new byte[BUFFER_SIZE];"
"StreamUtils.java:164"$1$"		int bytesRead = -1;"
"StreamUtils.java:165"$1$"		while ((bytesRead = in.read(buffer)) != -1) {"
"StreamUtils.java:166"$1$"			out.write(buffer, 0, bytesRead);"
"StreamUtils.java:167"$1$"			byteCount += bytesRead;"
"StreamUtils.java:168"$1$"		}"
"StreamUtils.java:169"$0$"		out.flush();"
"StreamUtils.java:170"$0$"		return byteCount;"
"StreamUtils.java:171"$0$"	}"
"StreamUtils.java:172"$0$""
"StreamUtils.java:173"$0$"	/**"
"StreamUtils.java:174"$0$"	 * Copy a range of content of the given InputStream to the given OutputStream."
"StreamUtils.java:175"$0$"	 * <p>If the specified range exceeds the length of the InputStream, this copies"
"StreamUtils.java:176"$0$"	 * up to the end of the stream and returns the actual number of copied bytes."
"StreamUtils.java:177"$0$"	 * <p>Leaves both streams open when done."
"StreamUtils.java:178"$0$"	 * @param in the InputStream to copy from"
"StreamUtils.java:179"$0$"	 * @param out the OutputStream to copy to"
"StreamUtils.java:180"$0$"	 * @param start the position to start copying from"
"StreamUtils.java:181"$0$"	 * @param end the position to end copying"
"StreamUtils.java:182"$0$"	 * @return the number of bytes copied"
"StreamUtils.java:183"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:184"$0$"	 * @since 4.3"
"StreamUtils.java:185"$0$"	 */"
"StreamUtils.java:186"$1$"	public static long copyRange(InputStream in, OutputStream out, long start, long end) throws IOException {"
"StreamUtils.java:187"$1$"		Assert.notNull(in, ""No InputStream specified"");"
"StreamUtils.java:188"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"StreamUtils.java:189"$1$""
"StreamUtils.java:190"$1$"		long skipped = in.skip(start);"
"StreamUtils.java:191"$1$"		if (skipped < start) {"
"StreamUtils.java:192"$1$"			throw new IOException(""Skipped only "" + skipped + "" bytes out of "" + start + "" required"");"
"StreamUtils.java:193"$1$"		}"
"StreamUtils.java:194"$0$""
"StreamUtils.java:195"$0$"		long bytesToCopy = end - start + 1;"
"StreamUtils.java:196"$0$"		byte[] buffer = new byte[(int) Math.min(StreamUtils.BUFFER_SIZE, bytesToCopy)];"
"StreamUtils.java:197"$1$"		while (bytesToCopy > 0) {"
"StreamUtils.java:198"$1$"			int bytesRead = in.read(buffer);"
"StreamUtils.java:199"$1$"			if (bytesRead == -1) {"
"StreamUtils.java:200"$1$"				break;"
"StreamUtils.java:201"$1$"			}"
"StreamUtils.java:202"$1$"			else if (bytesRead <= bytesToCopy) {"
"StreamUtils.java:203"$1$"				out.write(buffer, 0, bytesRead);"
"StreamUtils.java:204"$1$"				bytesToCopy -= bytesRead;"
"StreamUtils.java:205"$1$"			}"
"StreamUtils.java:206"$1$"			else {"
"StreamUtils.java:207"$1$"				out.write(buffer, 0, (int) bytesToCopy);"
"StreamUtils.java:208"$1$"				bytesToCopy = 0;"
"StreamUtils.java:209"$1$"			}"
"StreamUtils.java:210"$0$"		}"
"StreamUtils.java:211"$0$"		return (end - start + 1 - bytesToCopy);"
"StreamUtils.java:212"$0$"	}"
"StreamUtils.java:213"$0$""
"StreamUtils.java:214"$0$"	/**"
"StreamUtils.java:215"$0$"	 * Drain the remaining content of the given InputStream."
"StreamUtils.java:216"$0$"	 * <p>Leaves the InputStream open when done."
"StreamUtils.java:217"$0$"	 * @param in the InputStream to drain"
"StreamUtils.java:218"$0$"	 * @return the number of bytes read"
"StreamUtils.java:219"$0$"	 * @throws IOException in case of I/O errors"
"StreamUtils.java:220"$0$"	 * @since 4.3"
"StreamUtils.java:221"$0$"	 */"
"StreamUtils.java:222"$1$"	public static int drain(InputStream in) throws IOException {"
"StreamUtils.java:223"$1$"		Assert.notNull(in, ""No InputStream specified"");"
"StreamUtils.java:224"$1$"		byte[] buffer = new byte[BUFFER_SIZE];"
"StreamUtils.java:225"$1$"		int bytesRead = -1;"
"StreamUtils.java:226"$1$"		int byteCount = 0;"
"StreamUtils.java:227"$1$"		while ((bytesRead = in.read(buffer)) != -1) {"
"StreamUtils.java:228"$1$"			byteCount += bytesRead;"
"StreamUtils.java:229"$1$"		}"
"StreamUtils.java:230"$0$"		return byteCount;"
"StreamUtils.java:231"$0$"	}"
"StreamUtils.java:232"$0$""
"StreamUtils.java:233"$0$"	/**"
"StreamUtils.java:234"$1$"	 * Return an efficient empty {@link InputStream}."
"StreamUtils.java:235"$1$"	 * @return a {@link ByteArrayInputStream} based on an empty byte array"
"StreamUtils.java:236"$0$"	 * @since 4.2.2"
"StreamUtils.java:237"$0$"	 */"
"StreamUtils.java:238"$1$"	public static InputStream emptyInput() {"
"StreamUtils.java:239"$1$"		return new ByteArrayInputStream(EMPTY_CONTENT);"
"StreamUtils.java:240"$1$"	}"
"StreamUtils.java:241"$0$""
"StreamUtils.java:242"$0$"	/**"
"StreamUtils.java:243"$1$"	 * Return a variant of the given {@link InputStream} where calling"
"StreamUtils.java:244"$1$"	 * {@link InputStream#close() close()} has no effect."
"StreamUtils.java:245"$0$"	 * @param in the InputStream to decorate"
"StreamUtils.java:246"$0$"	 * @return a version of the InputStream that ignores calls to close"
"StreamUtils.java:247"$0$"	 */"
"StreamUtils.java:248"$1$"	public static InputStream nonClosing(InputStream in) {"
"StreamUtils.java:249"$1$"		Assert.notNull(in, ""No InputStream specified"");"
"StreamUtils.java:250"$1$"		return new NonClosingInputStream(in);"
"StreamUtils.java:251"$1$"	}"
"StreamUtils.java:252"$0$""
"StreamUtils.java:253"$0$"	/**"
"StreamUtils.java:254"$1$"	 * Return a variant of the given {@link OutputStream} where calling"
"StreamUtils.java:255"$1$"	 * {@link OutputStream#close() close()} has no effect."
"StreamUtils.java:256"$0$"	 * @param out the OutputStream to decorate"
"StreamUtils.java:257"$0$"	 * @return a version of the OutputStream that ignores calls to close"
"StreamUtils.java:258"$0$"	 */"
"StreamUtils.java:259"$1$"	public static OutputStream nonClosing(OutputStream out) {"
"StreamUtils.java:260"$1$"		Assert.notNull(out, ""No OutputStream specified"");"
"StreamUtils.java:261"$1$"		return new NonClosingOutputStream(out);"
"StreamUtils.java:262"$1$"	}"
"StreamUtils.java:263"$0$""
"StreamUtils.java:264"$1$"	private static class NonClosingInputStream extends FilterInputStream {"
"StreamUtils.java:265"$1$""
"StreamUtils.java:266"$1$"		public NonClosingInputStream(InputStream in) {"
"StreamUtils.java:267"$1$"			super(in);"
"StreamUtils.java:268"$1$"		}"
"StreamUtils.java:269"$0$""
"StreamUtils.java:270"$0$"		@Override"
"StreamUtils.java:271"$1$"		public void close() throws IOException {"
"StreamUtils.java:272"$1$"		}"
"StreamUtils.java:273"$0$"	}"
"StreamUtils.java:274"$0$""
"StreamUtils.java:275"$0$""
"StreamUtils.java:276"$1$"	private static class NonClosingOutputStream extends FilterOutputStream {"
"StreamUtils.java:277"$1$""
"StreamUtils.java:278"$1$"		public NonClosingOutputStream(OutputStream out) {"
"StreamUtils.java:279"$1$"			super(out);"
"StreamUtils.java:280"$1$"		}"
"StreamUtils.java:281"$0$""
"StreamUtils.java:282"$0$"		@Override"
"StreamUtils.java:283"$1$"		public void write(byte[] b, int off, int let) throws IOException {"
"StreamUtils.java:284"$0$"			// It is critical that we override this method for performance"
"StreamUtils.java:285"$1$"			this.out.write(b, off, let);"
"StreamUtils.java:286"$1$"		}"
"StreamUtils.java:287"$0$""
"StreamUtils.java:288"$0$"		@Override"
"StreamUtils.java:289"$1$"		public void close() throws IOException {"
"StreamUtils.java:290"$1$"		}"
"StreamUtils.java:291"$0$"	}"
"StreamUtils.java:292"$0$""
"StreamUtils.java:293"$0$"}"
"TypeUtils.java:1"$0$"/*"
"TypeUtils.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"TypeUtils.java:3"$0$" *"
"TypeUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"TypeUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"TypeUtils.java:6"$0$" * You may obtain a copy of the License at"
"TypeUtils.java:7"$0$" *"
"TypeUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"TypeUtils.java:9"$0$" *"
"TypeUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"TypeUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"TypeUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"TypeUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"TypeUtils.java:14"$0$" * limitations under the License."
"TypeUtils.java:15"$0$" */"
"TypeUtils.java:16"$0$""
"TypeUtils.java:17"$0$"package org.springframework.util;"
"TypeUtils.java:18"$0$""
"TypeUtils.java:19"$0$"import java.lang.reflect.GenericArrayType;"
"TypeUtils.java:20"$0$"import java.lang.reflect.ParameterizedType;"
"TypeUtils.java:21"$0$"import java.lang.reflect.Type;"
"TypeUtils.java:22"$0$"import java.lang.reflect.WildcardType;"
"TypeUtils.java:23"$0$""
"TypeUtils.java:24"$0$"import org.springframework.lang.Nullable;"
"TypeUtils.java:25"$0$""
"TypeUtils.java:26"$0$"/**"
"TypeUtils.java:27"$0$" * Utility to work with Java 5 generic type parameters."
"TypeUtils.java:28"$0$" * Mainly for internal use within the framework."
"TypeUtils.java:29"$0$" *"
"TypeUtils.java:30"$0$" * @author Ramnivas Laddad"
"TypeUtils.java:31"$0$" * @author Juergen Hoeller"
"TypeUtils.java:32"$0$" * @author Chris Beams"
"TypeUtils.java:33"$0$" * @since 2.0.7"
"TypeUtils.java:34"$0$" */"
"TypeUtils.java:35"$1$"public abstract class TypeUtils {"
"TypeUtils.java:36"$1$""
"TypeUtils.java:37"$1$"	/**"
"TypeUtils.java:38"$1$"	 * Check if the right-hand side type may be assigned to the left-hand side"
"TypeUtils.java:39"$1$"	 * type following the Java generics rules."
"TypeUtils.java:40"$1$"	 * @param lhsType the target type"
"TypeUtils.java:41"$1$"	 * @param rhsType the value type that should be assigned to the target type"
"TypeUtils.java:42"$1$"	 * @return true if rhs is assignable to lhs"
"TypeUtils.java:43"$1$"	 */"
"TypeUtils.java:44"$1$"	public static boolean isAssignable(Type lhsType, Type rhsType) {"
"TypeUtils.java:45"$1$"		Assert.notNull(lhsType, ""Left-hand side type must not be null"");"
"TypeUtils.java:46"$1$"		Assert.notNull(rhsType, ""Right-hand side type must not be null"");"
"TypeUtils.java:47"$1$""
"TypeUtils.java:48"$0$"		// all types are assignable to themselves and to class Object"
"TypeUtils.java:49"$1$"		if (lhsType.equals(rhsType) || Object.class == lhsType) {"
"TypeUtils.java:50"$1$"			return true;"
"TypeUtils.java:51"$1$"		}"
"TypeUtils.java:52"$0$""
"TypeUtils.java:53"$1$"		if (lhsType instanceof Class) {"
"TypeUtils.java:54"$1$"			Class<?> lhsClass = (Class<?>) lhsType;"
"TypeUtils.java:55"$1$""
"TypeUtils.java:56"$0$"			// just comparing two classes"
"TypeUtils.java:57"$1$"			if (rhsType instanceof Class) {"
"TypeUtils.java:58"$1$"				return ClassUtils.isAssignable(lhsClass, (Class<?>) rhsType);"
"TypeUtils.java:59"$1$"			}"
"TypeUtils.java:60"$0$""
"TypeUtils.java:61"$1$"			if (rhsType instanceof ParameterizedType) {"
"TypeUtils.java:62"$1$"				Type rhsRaw = ((ParameterizedType) rhsType).getRawType();"
"TypeUtils.java:63"$1$""
"TypeUtils.java:64"$0$"				// a parameterized type is always assignable to its raw class type"
"TypeUtils.java:65"$1$"				if (rhsRaw instanceof Class) {"
"TypeUtils.java:66"$1$"					return ClassUtils.isAssignable(lhsClass, (Class<?>) rhsRaw);"
"TypeUtils.java:67"$1$"				}"
"TypeUtils.java:68"$0$"			}"
"TypeUtils.java:69"$1$"			else if (lhsClass.isArray() && rhsType instanceof GenericArrayType) {"
"TypeUtils.java:70"$1$"				Type rhsComponent = ((GenericArrayType) rhsType).getGenericComponentType();"
"TypeUtils.java:71"$1$""
"TypeUtils.java:72"$1$"				return isAssignable(lhsClass.getComponentType(), rhsComponent);"
"TypeUtils.java:73"$1$"			}"
"TypeUtils.java:74"$0$"		}"
"TypeUtils.java:75"$0$""
"TypeUtils.java:76"$0$"		// parameterized types are only assignable to other parameterized types and class types"
"TypeUtils.java:77"$1$"		if (lhsType instanceof ParameterizedType) {"
"TypeUtils.java:78"$1$"			if (rhsType instanceof Class) {"
"TypeUtils.java:79"$1$"				Type lhsRaw = ((ParameterizedType) lhsType).getRawType();"
"TypeUtils.java:80"$1$""
"TypeUtils.java:81"$1$"				if (lhsRaw instanceof Class) {"
"TypeUtils.java:82"$1$"					return ClassUtils.isAssignable((Class<?>) lhsRaw, (Class<?>) rhsType);"
"TypeUtils.java:83"$1$"				}"
"TypeUtils.java:84"$0$"			}"
"TypeUtils.java:85"$1$"			else if (rhsType instanceof ParameterizedType) {"
"TypeUtils.java:86"$1$"				return isAssignable((ParameterizedType) lhsType, (ParameterizedType) rhsType);"
"TypeUtils.java:87"$1$"			}"
"TypeUtils.java:88"$0$"		}"
"TypeUtils.java:89"$0$""
"TypeUtils.java:90"$1$"		if (lhsType instanceof GenericArrayType) {"
"TypeUtils.java:91"$1$"			Type lhsComponent = ((GenericArrayType) lhsType).getGenericComponentType();"
"TypeUtils.java:92"$1$""
"TypeUtils.java:93"$1$"			if (rhsType instanceof Class) {"
"TypeUtils.java:94"$1$"				Class<?> rhsClass = (Class<?>) rhsType;"
"TypeUtils.java:95"$1$""
"TypeUtils.java:96"$1$"				if (rhsClass.isArray()) {"
"TypeUtils.java:97"$1$"					return isAssignable(lhsComponent, rhsClass.getComponentType());"
"TypeUtils.java:98"$1$"				}"
"TypeUtils.java:99"$0$"			}"
"TypeUtils.java:100"$1$"			else if (rhsType instanceof GenericArrayType) {"
"TypeUtils.java:101"$1$"				Type rhsComponent = ((GenericArrayType) rhsType).getGenericComponentType();"
"TypeUtils.java:102"$1$""
"TypeUtils.java:103"$1$"				return isAssignable(lhsComponent, rhsComponent);"
"TypeUtils.java:104"$1$"			}"
"TypeUtils.java:105"$0$"		}"
"TypeUtils.java:106"$0$""
"TypeUtils.java:107"$1$"		if (lhsType instanceof WildcardType) {"
"TypeUtils.java:108"$1$"			return isAssignable((WildcardType) lhsType, rhsType);"
"TypeUtils.java:109"$1$"		}"
"TypeUtils.java:110"$0$""
"TypeUtils.java:111"$0$"		return false;"
"TypeUtils.java:112"$0$"	}"
"TypeUtils.java:113"$0$""
"TypeUtils.java:114"$1$"	private static boolean isAssignable(ParameterizedType lhsType, ParameterizedType rhsType) {"
"TypeUtils.java:115"$1$"		if (lhsType.equals(rhsType)) {"
"TypeUtils.java:116"$1$"			return true;"
"TypeUtils.java:117"$1$"		}"
"TypeUtils.java:118"$0$""
"TypeUtils.java:119"$0$"		Type[] lhsTypeArguments = lhsType.getActualTypeArguments();"
"TypeUtils.java:120"$0$"		Type[] rhsTypeArguments = rhsType.getActualTypeArguments();"
"TypeUtils.java:121"$0$""
"TypeUtils.java:122"$1$"		if (lhsTypeArguments.length != rhsTypeArguments.length) {"
"TypeUtils.java:123"$1$"			return false;"
"TypeUtils.java:124"$1$"		}"
"TypeUtils.java:125"$0$""
"TypeUtils.java:126"$1$"		for (int size = lhsTypeArguments.length, i = 0; i < size; ++i) {"
"TypeUtils.java:127"$1$"			Type lhsArg = lhsTypeArguments[i];"
"TypeUtils.java:128"$1$"			Type rhsArg = rhsTypeArguments[i];"
"TypeUtils.java:129"$1$""
"TypeUtils.java:130"$1$"			if (!lhsArg.equals(rhsArg) &&"
"TypeUtils.java:131"$1$"					!(lhsArg instanceof WildcardType && isAssignable((WildcardType) lhsArg, rhsArg))) {"
"TypeUtils.java:132"$1$"				return false;"
"TypeUtils.java:133"$1$"			}"
"TypeUtils.java:134"$0$"		}"
"TypeUtils.java:135"$0$""
"TypeUtils.java:136"$0$"		return true;"
"TypeUtils.java:137"$0$"	}"
"TypeUtils.java:138"$0$""
"TypeUtils.java:139"$1$"	private static boolean isAssignable(WildcardType lhsType, Type rhsType) {"
"TypeUtils.java:140"$1$"		Type[] lUpperBounds = lhsType.getUpperBounds();"
"TypeUtils.java:141"$1$""
"TypeUtils.java:142"$0$"		// supply the implicit upper bound if none are specified"
"TypeUtils.java:143"$1$"		if (lUpperBounds.length == 0) {"
"TypeUtils.java:144"$1$"			lUpperBounds = new Type[] { Object.class };"
"TypeUtils.java:145"$1$"		}"
"TypeUtils.java:146"$0$""
"TypeUtils.java:147"$0$"		Type[] lLowerBounds = lhsType.getLowerBounds();"
"TypeUtils.java:148"$0$""
"TypeUtils.java:149"$0$"		// supply the implicit lower bound if none are specified"
"TypeUtils.java:150"$1$"		if (lLowerBounds.length == 0) {"
"TypeUtils.java:151"$1$"			lLowerBounds = new Type[] { null };"
"TypeUtils.java:152"$1$"		}"
"TypeUtils.java:153"$0$""
"TypeUtils.java:154"$1$"		if (rhsType instanceof WildcardType) {"
"TypeUtils.java:155"$0$"			// both the upper and lower bounds of the right-hand side must be"
"TypeUtils.java:156"$0$"			// completely enclosed in the upper and lower bounds of the left-"
"TypeUtils.java:157"$0$"			// hand side."
"TypeUtils.java:158"$1$"			WildcardType rhsWcType = (WildcardType) rhsType;"
"TypeUtils.java:159"$1$"			Type[] rUpperBounds = rhsWcType.getUpperBounds();"
"TypeUtils.java:160"$1$""
"TypeUtils.java:161"$1$"			if (rUpperBounds.length == 0) {"
"TypeUtils.java:162"$1$"				rUpperBounds = new Type[] { Object.class };"
"TypeUtils.java:163"$1$"			}"
"TypeUtils.java:164"$0$""
"TypeUtils.java:165"$0$"			Type[] rLowerBounds = rhsWcType.getLowerBounds();"
"TypeUtils.java:166"$0$""
"TypeUtils.java:167"$1$"			if (rLowerBounds.length == 0) {"
"TypeUtils.java:168"$1$"				rLowerBounds = new Type[] { null };"
"TypeUtils.java:169"$1$"			}"
"TypeUtils.java:170"$0$""
"TypeUtils.java:171"$1$"			for (Type lBound : lUpperBounds) {"
"TypeUtils.java:172"$1$"				for (Type rBound : rUpperBounds) {"
"TypeUtils.java:173"$1$"					if (!isAssignableBound(lBound, rBound)) {"
"TypeUtils.java:174"$1$"						return false;"
"TypeUtils.java:175"$1$"					}"
"TypeUtils.java:176"$0$"				}"
"TypeUtils.java:177"$0$""
"TypeUtils.java:178"$1$"				for (Type rBound : rLowerBounds) {"
"TypeUtils.java:179"$1$"					if (!isAssignableBound(lBound, rBound)) {"
"TypeUtils.java:180"$1$"						return false;"
"TypeUtils.java:181"$1$"					}"
"TypeUtils.java:182"$0$"				}"
"TypeUtils.java:183"$0$"			}"
"TypeUtils.java:184"$0$""
"TypeUtils.java:185"$1$"			for (Type lBound : lLowerBounds) {"
"TypeUtils.java:186"$1$"				for (Type rBound : rUpperBounds) {"
"TypeUtils.java:187"$1$"					if (!isAssignableBound(rBound, lBound)) {"
"TypeUtils.java:188"$1$"						return false;"
"TypeUtils.java:189"$1$"					}"
"TypeUtils.java:190"$0$"				}"
"TypeUtils.java:191"$0$""
"TypeUtils.java:192"$1$"				for (Type rBound : rLowerBounds) {"
"TypeUtils.java:193"$1$"					if (!isAssignableBound(rBound, lBound)) {"
"TypeUtils.java:194"$1$"						return false;"
"TypeUtils.java:195"$1$"					}"
"TypeUtils.java:196"$0$"				}"
"TypeUtils.java:197"$0$"			}"
"TypeUtils.java:198"$0$"		}"
"TypeUtils.java:199"$1$"		else {"
"TypeUtils.java:200"$1$"			for (Type lBound : lUpperBounds) {"
"TypeUtils.java:201"$1$"				if (!isAssignableBound(lBound, rhsType)) {"
"TypeUtils.java:202"$1$"					return false;"
"TypeUtils.java:203"$1$"				}"
"TypeUtils.java:204"$0$"			}"
"TypeUtils.java:205"$0$""
"TypeUtils.java:206"$1$"			for (Type lBound : lLowerBounds) {"
"TypeUtils.java:207"$1$"				if (!isAssignableBound(rhsType, lBound)) {"
"TypeUtils.java:208"$1$"					return false;"
"TypeUtils.java:209"$1$"				}"
"TypeUtils.java:210"$0$"			}"
"TypeUtils.java:211"$0$"		}"
"TypeUtils.java:212"$0$""
"TypeUtils.java:213"$0$"		return true;"
"TypeUtils.java:214"$0$"	}"
"TypeUtils.java:215"$0$""
"TypeUtils.java:216"$1$"	public static boolean isAssignableBound(@Nullable Type lhsType, @Nullable Type rhsType) {"
"TypeUtils.java:217"$1$"		if (rhsType == null) {"
"TypeUtils.java:218"$1$"			return true;"
"TypeUtils.java:219"$1$"		}"
"TypeUtils.java:220"$1$"		if (lhsType == null) {"
"TypeUtils.java:221"$1$"			return false;"
"TypeUtils.java:222"$1$"		}"
"TypeUtils.java:223"$0$"		return isAssignable(lhsType, rhsType);"
"TypeUtils.java:224"$0$"	}"
"TypeUtils.java:225"$0$""
"TypeUtils.java:226"$0$"}"
"SimpleAsyncTaskExecutor.java:1"$0$"/*"
"SimpleAsyncTaskExecutor.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"SimpleAsyncTaskExecutor.java:3"$0$" *"
"SimpleAsyncTaskExecutor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleAsyncTaskExecutor.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleAsyncTaskExecutor.java:6"$0$" * You may obtain a copy of the License at"
"SimpleAsyncTaskExecutor.java:7"$0$" *"
"SimpleAsyncTaskExecutor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleAsyncTaskExecutor.java:9"$0$" *"
"SimpleAsyncTaskExecutor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleAsyncTaskExecutor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleAsyncTaskExecutor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleAsyncTaskExecutor.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleAsyncTaskExecutor.java:14"$0$" * limitations under the License."
"SimpleAsyncTaskExecutor.java:15"$0$" */"
"SimpleAsyncTaskExecutor.java:16"$0$""
"SimpleAsyncTaskExecutor.java:17"$0$"package org.springframework.core.task;"
"SimpleAsyncTaskExecutor.java:18"$0$""
"SimpleAsyncTaskExecutor.java:19"$0$"import java.io.Serializable;"
"SimpleAsyncTaskExecutor.java:20"$0$"import java.util.concurrent.Callable;"
"SimpleAsyncTaskExecutor.java:21"$0$"import java.util.concurrent.Future;"
"SimpleAsyncTaskExecutor.java:22"$0$"import java.util.concurrent.FutureTask;"
"SimpleAsyncTaskExecutor.java:23"$0$"import java.util.concurrent.ThreadFactory;"
"SimpleAsyncTaskExecutor.java:24"$0$""
"SimpleAsyncTaskExecutor.java:25"$0$"import org.springframework.lang.Nullable;"
"SimpleAsyncTaskExecutor.java:26"$0$"import org.springframework.util.Assert;"
"SimpleAsyncTaskExecutor.java:27"$0$"import org.springframework.util.ConcurrencyThrottleSupport;"
"SimpleAsyncTaskExecutor.java:28"$0$"import org.springframework.util.CustomizableThreadCreator;"
"SimpleAsyncTaskExecutor.java:29"$0$"import org.springframework.util.concurrent.ListenableFuture;"
"SimpleAsyncTaskExecutor.java:30"$0$"import org.springframework.util.concurrent.ListenableFutureTask;"
"SimpleAsyncTaskExecutor.java:31"$0$""
"SimpleAsyncTaskExecutor.java:32"$0$"/**"
"SimpleAsyncTaskExecutor.java:33"$1$" * {@link TaskExecutor} implementation that fires up a new Thread for each task,"
"SimpleAsyncTaskExecutor.java:34"$0$" * executing it asynchronously."
"SimpleAsyncTaskExecutor.java:35"$0$" *"
"SimpleAsyncTaskExecutor.java:36"$0$" * <p>Supports limiting concurrent threads through the ""concurrencyLimit"""
"SimpleAsyncTaskExecutor.java:37"$0$" * bean property. By default, the number of concurrent threads is unlimited."
"SimpleAsyncTaskExecutor.java:38"$0$" *"
"SimpleAsyncTaskExecutor.java:39"$0$" * <p><b>NOTE: This implementation does not reuse threads!</b> Consider a"
"SimpleAsyncTaskExecutor.java:40"$0$" * thread-pooling TaskExecutor implementation instead, in particular for"
"SimpleAsyncTaskExecutor.java:41"$0$" * executing a large number of short-lived tasks."
"SimpleAsyncTaskExecutor.java:42"$0$" *"
"SimpleAsyncTaskExecutor.java:43"$0$" * @author Juergen Hoeller"
"SimpleAsyncTaskExecutor.java:44"$0$" * @since 2.0"
"SimpleAsyncTaskExecutor.java:45"$0$" * @see #setConcurrencyLimit"
"SimpleAsyncTaskExecutor.java:46"$0$" * @see SyncTaskExecutor"
"SimpleAsyncTaskExecutor.java:47"$0$" * @see org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"
"SimpleAsyncTaskExecutor.java:48"$0$" * @see org.springframework.scheduling.commonj.WorkManagerTaskExecutor"
"SimpleAsyncTaskExecutor.java:49"$0$" */"
"SimpleAsyncTaskExecutor.java:50"$0$"SuppressWarnings(""serial"")"
"SimpleAsyncTaskExecutor.java:51"$0$"public class SimpleAsyncTaskExecutor extends CustomizableThreadCreator"
"SimpleAsyncTaskExecutor.java:52"$1$"		implements AsyncListenableTaskExecutor, Serializable {"
"SimpleAsyncTaskExecutor.java:53"$1$""
"SimpleAsyncTaskExecutor.java:54"$1$"	/**"
"SimpleAsyncTaskExecutor.java:55"$1$"	 * Permit any number of concurrent invocations: that is, don't throttle concurrency."
"SimpleAsyncTaskExecutor.java:56"$1$"	 * @see ConcurrencyThrottleSupport#UNBOUNDED_CONCURRENCY"
"SimpleAsyncTaskExecutor.java:57"$1$"	 */"
"SimpleAsyncTaskExecutor.java:58"$1$"	public static final int UNBOUNDED_CONCURRENCY = ConcurrencyThrottleSupport.UNBOUNDED_CONCURRENCY;"
"SimpleAsyncTaskExecutor.java:59"$1$""
"SimpleAsyncTaskExecutor.java:60"$1$"	/**"
"SimpleAsyncTaskExecutor.java:61"$1$"	 * Switch concurrency 'off': that is, don't allow any concurrent invocations."
"SimpleAsyncTaskExecutor.java:62"$1$"	 * @see ConcurrencyThrottleSupport#NO_CONCURRENCY"
"SimpleAsyncTaskExecutor.java:63"$1$"	 */"
"SimpleAsyncTaskExecutor.java:64"$1$"	public static final int NO_CONCURRENCY = ConcurrencyThrottleSupport.NO_CONCURRENCY;"
"SimpleAsyncTaskExecutor.java:65"$1$""
"SimpleAsyncTaskExecutor.java:66"$1$""
"SimpleAsyncTaskExecutor.java:67"$1$"	/** Internal concurrency throttle used by this executor. */"
"SimpleAsyncTaskExecutor.java:68"$1$"	private final ConcurrencyThrottleAdapter concurrencyThrottle = new ConcurrencyThrottleAdapter();"
"SimpleAsyncTaskExecutor.java:69"$1$""
"SimpleAsyncTaskExecutor.java:70"$1$"	@Nullable"
"SimpleAsyncTaskExecutor.java:71"$1$"	private ThreadFactory threadFactory;"
"SimpleAsyncTaskExecutor.java:72"$1$""
"SimpleAsyncTaskExecutor.java:73"$1$"	@Nullable"
"SimpleAsyncTaskExecutor.java:74"$1$"	private TaskDecorator taskDecorator;"
"SimpleAsyncTaskExecutor.java:75"$1$""
"SimpleAsyncTaskExecutor.java:76"$1$""
"SimpleAsyncTaskExecutor.java:77"$1$"	/**"
"SimpleAsyncTaskExecutor.java:78"$1$"	 * Create a new SimpleAsyncTaskExecutor with default thread name prefix."
"SimpleAsyncTaskExecutor.java:79"$1$"	 */"
"SimpleAsyncTaskExecutor.java:80"$1$"	public SimpleAsyncTaskExecutor() {"
"SimpleAsyncTaskExecutor.java:81"$1$"		super();"
"SimpleAsyncTaskExecutor.java:82"$1$"	}"
"SimpleAsyncTaskExecutor.java:83"$0$""
"SimpleAsyncTaskExecutor.java:84"$0$"	/**"
"SimpleAsyncTaskExecutor.java:85"$0$"	 * Create a new SimpleAsyncTaskExecutor with the given thread name prefix."
"SimpleAsyncTaskExecutor.java:86"$0$"	 * @param threadNamePrefix the prefix to use for the names of newly created threads"
"SimpleAsyncTaskExecutor.java:87"$0$"	 */"
"SimpleAsyncTaskExecutor.java:88"$1$"	public SimpleAsyncTaskExecutor(String threadNamePrefix) {"
"SimpleAsyncTaskExecutor.java:89"$1$"		super(threadNamePrefix);"
"SimpleAsyncTaskExecutor.java:90"$1$"	}"
"SimpleAsyncTaskExecutor.java:91"$0$""
"SimpleAsyncTaskExecutor.java:92"$0$"	/**"
"SimpleAsyncTaskExecutor.java:93"$0$"	 * Create a new SimpleAsyncTaskExecutor with the given external thread factory."
"SimpleAsyncTaskExecutor.java:94"$0$"	 * @param threadFactory the factory to use for creating new Threads"
"SimpleAsyncTaskExecutor.java:95"$0$"	 */"
"SimpleAsyncTaskExecutor.java:96"$1$"	public SimpleAsyncTaskExecutor(ThreadFactory threadFactory) {"
"SimpleAsyncTaskExecutor.java:97"$1$"		this.threadFactory = threadFactory;"
"SimpleAsyncTaskExecutor.java:98"$1$"	}"
"SimpleAsyncTaskExecutor.java:99"$0$""
"SimpleAsyncTaskExecutor.java:100"$0$""
"SimpleAsyncTaskExecutor.java:101"$0$"	/**"
"SimpleAsyncTaskExecutor.java:102"$0$"	 * Specify an external factory to use for creating new Threads,"
"SimpleAsyncTaskExecutor.java:103"$0$"	 * instead of relying on the local properties of this executor."
"SimpleAsyncTaskExecutor.java:104"$0$"	 * <p>You may specify an inner ThreadFactory bean or also a ThreadFactory reference"
"SimpleAsyncTaskExecutor.java:105"$0$"	 * obtained from JNDI (on a Java EE 6 server) or some other lookup mechanism."
"SimpleAsyncTaskExecutor.java:106"$0$"	 * @see #setThreadNamePrefix"
"SimpleAsyncTaskExecutor.java:107"$0$"	 * @see #setThreadPriority"
"SimpleAsyncTaskExecutor.java:108"$0$"	 */"
"SimpleAsyncTaskExecutor.java:109"$1$"	public void setThreadFactory(@Nullable ThreadFactory threadFactory) {"
"SimpleAsyncTaskExecutor.java:110"$1$"		this.threadFactory = threadFactory;"
"SimpleAsyncTaskExecutor.java:111"$1$"	}"
"SimpleAsyncTaskExecutor.java:112"$0$""
"SimpleAsyncTaskExecutor.java:113"$0$"	/**"
"SimpleAsyncTaskExecutor.java:114"$0$"	 * Return the external factory to use for creating new Threads, if any."
"SimpleAsyncTaskExecutor.java:115"$0$"	 */"
"SimpleAsyncTaskExecutor.java:116"$0$"	@Nullable"
"SimpleAsyncTaskExecutor.java:117"$1$"	public final ThreadFactory getThreadFactory() {"
"SimpleAsyncTaskExecutor.java:118"$1$"		return this.threadFactory;"
"SimpleAsyncTaskExecutor.java:119"$1$"	}"
"SimpleAsyncTaskExecutor.java:120"$0$""
"SimpleAsyncTaskExecutor.java:121"$0$"	/**"
"SimpleAsyncTaskExecutor.java:122"$1$"	 * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}"
"SimpleAsyncTaskExecutor.java:123"$0$"	 * about to be executed."
"SimpleAsyncTaskExecutor.java:124"$0$"	 * <p>Note that such a decorator is not necessarily being applied to the"
"SimpleAsyncTaskExecutor.java:125"$1$"	 * user-supplied {@code Runnable}/{@code Callable} but rather to the actual"
"SimpleAsyncTaskExecutor.java:126"$0$"	 * execution callback (which may be a wrapper around the user-supplied task)."
"SimpleAsyncTaskExecutor.java:127"$0$"	 * <p>The primary use case is to set some execution context around the task's"
"SimpleAsyncTaskExecutor.java:128"$0$"	 * invocation, or to provide some monitoring/statistics for task execution."
"SimpleAsyncTaskExecutor.java:129"$0$"	 * @since 4.3"
"SimpleAsyncTaskExecutor.java:130"$0$"	 */"
"SimpleAsyncTaskExecutor.java:131"$1$"	public final void setTaskDecorator(TaskDecorator taskDecorator) {"
"SimpleAsyncTaskExecutor.java:132"$1$"		this.taskDecorator = taskDecorator;"
"SimpleAsyncTaskExecutor.java:133"$1$"	}"
"SimpleAsyncTaskExecutor.java:134"$0$""
"SimpleAsyncTaskExecutor.java:135"$0$"	/**"
"SimpleAsyncTaskExecutor.java:136"$0$"	 * Set the maximum number of parallel accesses allowed."
"SimpleAsyncTaskExecutor.java:137"$0$"	 * -1 indicates no concurrency limit at all."
"SimpleAsyncTaskExecutor.java:138"$0$"	 * <p>In principle, this limit can be changed at runtime,"
"SimpleAsyncTaskExecutor.java:139"$0$"	 * although it is generally designed as a config time setting."
"SimpleAsyncTaskExecutor.java:140"$0$"	 * NOTE: Do not switch between -1 and any concrete limit at runtime,"
"SimpleAsyncTaskExecutor.java:141"$0$"	 * as this will lead to inconsistent concurrency counts: A limit"
"SimpleAsyncTaskExecutor.java:142"$0$"	 * of -1 effectively turns off concurrency counting completely."
"SimpleAsyncTaskExecutor.java:143"$0$"	 * @see #UNBOUNDED_CONCURRENCY"
"SimpleAsyncTaskExecutor.java:144"$0$"	 */"
"SimpleAsyncTaskExecutor.java:145"$1$"	public void setConcurrencyLimit(int concurrencyLimit) {"
"SimpleAsyncTaskExecutor.java:146"$1$"		this.concurrencyThrottle.setConcurrencyLimit(concurrencyLimit);"
"SimpleAsyncTaskExecutor.java:147"$1$"	}"
"SimpleAsyncTaskExecutor.java:148"$0$""
"SimpleAsyncTaskExecutor.java:149"$0$"	/**"
"SimpleAsyncTaskExecutor.java:150"$0$"	 * Return the maximum number of parallel accesses allowed."
"SimpleAsyncTaskExecutor.java:151"$0$"	 */"
"SimpleAsyncTaskExecutor.java:152"$1$"	public final int getConcurrencyLimit() {"
"SimpleAsyncTaskExecutor.java:153"$1$"		return this.concurrencyThrottle.getConcurrencyLimit();"
"SimpleAsyncTaskExecutor.java:154"$1$"	}"
"SimpleAsyncTaskExecutor.java:155"$0$""
"SimpleAsyncTaskExecutor.java:156"$0$"	/**"
"SimpleAsyncTaskExecutor.java:157"$0$"	 * Return whether this throttle is currently active."
"SimpleAsyncTaskExecutor.java:158"$1$"	 * @return {@code true} if the concurrency limit for this instance is active"
"SimpleAsyncTaskExecutor.java:159"$0$"	 * @see #getConcurrencyLimit()"
"SimpleAsyncTaskExecutor.java:160"$0$"	 * @see #setConcurrencyLimit"
"SimpleAsyncTaskExecutor.java:161"$0$"	 */"
"SimpleAsyncTaskExecutor.java:162"$1$"	public final boolean isThrottleActive() {"
"SimpleAsyncTaskExecutor.java:163"$1$"		return this.concurrencyThrottle.isThrottleActive();"
"SimpleAsyncTaskExecutor.java:164"$1$"	}"
"SimpleAsyncTaskExecutor.java:165"$0$""
"SimpleAsyncTaskExecutor.java:166"$0$""
"SimpleAsyncTaskExecutor.java:167"$0$"	/**"
"SimpleAsyncTaskExecutor.java:168"$0$"	 * Executes the given task, within a concurrency throttle"
"SimpleAsyncTaskExecutor.java:169"$0$"	 * if configured (through the superclass's settings)."
"SimpleAsyncTaskExecutor.java:170"$0$"	 * @see #doExecute(Runnable)"
"SimpleAsyncTaskExecutor.java:171"$0$"	 */"
"SimpleAsyncTaskExecutor.java:172"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:173"$1$"	public void execute(Runnable task) {"
"SimpleAsyncTaskExecutor.java:174"$1$"		execute(task, TIMEOUT_INDEFINITE);"
"SimpleAsyncTaskExecutor.java:175"$1$"	}"
"SimpleAsyncTaskExecutor.java:176"$0$""
"SimpleAsyncTaskExecutor.java:177"$0$"	/**"
"SimpleAsyncTaskExecutor.java:178"$0$"	 * Executes the given task, within a concurrency throttle"
"SimpleAsyncTaskExecutor.java:179"$0$"	 * if configured (through the superclass's settings)."
"SimpleAsyncTaskExecutor.java:180"$0$"	 * <p>Executes urgent tasks (with 'immediate' timeout) directly,"
"SimpleAsyncTaskExecutor.java:181"$0$"	 * bypassing the concurrency throttle (if active). All other"
"SimpleAsyncTaskExecutor.java:182"$0$"	 * tasks are subject to throttling."
"SimpleAsyncTaskExecutor.java:183"$0$"	 * @see #TIMEOUT_IMMEDIATE"
"SimpleAsyncTaskExecutor.java:184"$0$"	 * @see #doExecute(Runnable)"
"SimpleAsyncTaskExecutor.java:185"$0$"	 */"
"SimpleAsyncTaskExecutor.java:186"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:187"$1$"	public void execute(Runnable task, long startTimeout) {"
"SimpleAsyncTaskExecutor.java:188"$1$"		Assert.notNull(task, ""Runnable must not be null"");"
"SimpleAsyncTaskExecutor.java:189"$1$"		Runnable taskToUse = (this.taskDecorator != null ? this.taskDecorator.decorate(task) : task);"
"SimpleAsyncTaskExecutor.java:190"$1$"		if (isThrottleActive() && startTimeout > TIMEOUT_IMMEDIATE) {"
"SimpleAsyncTaskExecutor.java:191"$1$"			this.concurrencyThrottle.beforeAccess();"
"SimpleAsyncTaskExecutor.java:192"$1$"			doExecute(new ConcurrencyThrottlingRunnable(taskToUse));"
"SimpleAsyncTaskExecutor.java:193"$1$"		}"
"SimpleAsyncTaskExecutor.java:194"$1$"		else {"
"SimpleAsyncTaskExecutor.java:195"$1$"			doExecute(taskToUse);"
"SimpleAsyncTaskExecutor.java:196"$1$"		}"
"SimpleAsyncTaskExecutor.java:197"$0$"	}"
"SimpleAsyncTaskExecutor.java:198"$0$""
"SimpleAsyncTaskExecutor.java:199"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:200"$1$"	public Future<?> submit(Runnable task) {"
"SimpleAsyncTaskExecutor.java:201"$1$"		FutureTask<Object> future = new FutureTask<>(task, null);"
"SimpleAsyncTaskExecutor.java:202"$1$"		execute(future, TIMEOUT_INDEFINITE);"
"SimpleAsyncTaskExecutor.java:203"$1$"		return future;"
"SimpleAsyncTaskExecutor.java:204"$1$"	}"
"SimpleAsyncTaskExecutor.java:205"$0$""
"SimpleAsyncTaskExecutor.java:206"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:207"$1$"	public <T> Future<T> submit(Callable<T> task) {"
"SimpleAsyncTaskExecutor.java:208"$1$"		FutureTask<T> future = new FutureTask<>(task);"
"SimpleAsyncTaskExecutor.java:209"$1$"		execute(future, TIMEOUT_INDEFINITE);"
"SimpleAsyncTaskExecutor.java:210"$1$"		return future;"
"SimpleAsyncTaskExecutor.java:211"$1$"	}"
"SimpleAsyncTaskExecutor.java:212"$0$""
"SimpleAsyncTaskExecutor.java:213"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:214"$1$"	public ListenableFuture<?> submitListenable(Runnable task) {"
"SimpleAsyncTaskExecutor.java:215"$1$"		ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null);"
"SimpleAsyncTaskExecutor.java:216"$1$"		execute(future, TIMEOUT_INDEFINITE);"
"SimpleAsyncTaskExecutor.java:217"$1$"		return future;"
"SimpleAsyncTaskExecutor.java:218"$1$"	}"
"SimpleAsyncTaskExecutor.java:219"$0$""
"SimpleAsyncTaskExecutor.java:220"$0$"	@Override"
"SimpleAsyncTaskExecutor.java:221"$1$"	public <T> ListenableFuture<T> submitListenable(Callable<T> task) {"
"SimpleAsyncTaskExecutor.java:222"$1$"		ListenableFutureTask<T> future = new ListenableFutureTask<>(task);"
"SimpleAsyncTaskExecutor.java:223"$1$"		execute(future, TIMEOUT_INDEFINITE);"
"SimpleAsyncTaskExecutor.java:224"$1$"		return future;"
"SimpleAsyncTaskExecutor.java:225"$1$"	}"
"SimpleAsyncTaskExecutor.java:226"$0$""
"SimpleAsyncTaskExecutor.java:227"$0$"	/**"
"SimpleAsyncTaskExecutor.java:228"$0$"	 * Template method for the actual execution of a task."
"SimpleAsyncTaskExecutor.java:229"$0$"	 * <p>The default implementation creates a new Thread and starts it."
"SimpleAsyncTaskExecutor.java:230"$0$"	 * @param task the Runnable to execute"
"SimpleAsyncTaskExecutor.java:231"$0$"	 * @see #setThreadFactory"
"SimpleAsyncTaskExecutor.java:232"$0$"	 * @see #createThread"
"SimpleAsyncTaskExecutor.java:233"$0$"	 * @see java.lang.Thread#start()"
"SimpleAsyncTaskExecutor.java:234"$0$"	 */"
"SimpleAsyncTaskExecutor.java:235"$1$"	protected void doExecute(Runnable task) {"
"SimpleAsyncTaskExecutor.java:236"$1$"		Thread thread = (this.threadFactory != null ? this.threadFactory.newThread(task) : createThread(task));"
"SimpleAsyncTaskExecutor.java:237"$1$"		thread.start();"
"SimpleAsyncTaskExecutor.java:238"$1$"	}"
"SimpleAsyncTaskExecutor.java:239"$0$""
"SimpleAsyncTaskExecutor.java:240"$0$""
"SimpleAsyncTaskExecutor.java:241"$0$"	/**"
"SimpleAsyncTaskExecutor.java:242"$0$"	 * Subclass of the general ConcurrencyThrottleSupport class,"
"SimpleAsyncTaskExecutor.java:243"$1$"	 * making {@code beforeAccess()} and {@code afterAccess()}"
"SimpleAsyncTaskExecutor.java:244"$0$"	 * visible to the surrounding class."
"SimpleAsyncTaskExecutor.java:245"$0$"	 */"
"SimpleAsyncTaskExecutor.java:246"$1$"	private static class ConcurrencyThrottleAdapter extends ConcurrencyThrottleSupport {"
"SimpleAsyncTaskExecutor.java:247"$1$""
"SimpleAsyncTaskExecutor.java:248"$1$"		@Override"
"SimpleAsyncTaskExecutor.java:249"$1$"		protected void beforeAccess() {"
"SimpleAsyncTaskExecutor.java:250"$1$"			super.beforeAccess();"
"SimpleAsyncTaskExecutor.java:251"$1$"		}"
"SimpleAsyncTaskExecutor.java:252"$0$""
"SimpleAsyncTaskExecutor.java:253"$0$"		@Override"
"SimpleAsyncTaskExecutor.java:254"$1$"		protected void afterAccess() {"
"SimpleAsyncTaskExecutor.java:255"$1$"			super.afterAccess();"
"SimpleAsyncTaskExecutor.java:256"$1$"		}"
"SimpleAsyncTaskExecutor.java:257"$0$"	}"
"SimpleAsyncTaskExecutor.java:258"$0$""
"SimpleAsyncTaskExecutor.java:259"$0$""
"SimpleAsyncTaskExecutor.java:260"$0$"	/**"
"SimpleAsyncTaskExecutor.java:261"$1$"	 * This Runnable calls {@code afterAccess()} after the"
"SimpleAsyncTaskExecutor.java:262"$0$"	 * target Runnable has finished its execution."
"SimpleAsyncTaskExecutor.java:263"$0$"	 */"
"SimpleAsyncTaskExecutor.java:264"$1$"	private class ConcurrencyThrottlingRunnable implements Runnable {"
"SimpleAsyncTaskExecutor.java:265"$1$""
"SimpleAsyncTaskExecutor.java:266"$1$"		private final Runnable target;"
"SimpleAsyncTaskExecutor.java:267"$1$""
"SimpleAsyncTaskExecutor.java:268"$1$"		public ConcurrencyThrottlingRunnable(Runnable target) {"
"SimpleAsyncTaskExecutor.java:269"$1$"			this.target = target;"
"SimpleAsyncTaskExecutor.java:270"$1$"		}"
"SimpleAsyncTaskExecutor.java:271"$0$""
"SimpleAsyncTaskExecutor.java:272"$0$"		@Override"
"SimpleAsyncTaskExecutor.java:273"$1$"		public void run() {"
"SimpleAsyncTaskExecutor.java:274"$1$"			try {"
"SimpleAsyncTaskExecutor.java:275"$1$"				this.target.run();"
"SimpleAsyncTaskExecutor.java:276"$1$"			}"
"SimpleAsyncTaskExecutor.java:277"$1$"			finally {"
"SimpleAsyncTaskExecutor.java:278"$1$"				concurrencyThrottle.afterAccess();"
"SimpleAsyncTaskExecutor.java:279"$1$"			}"
"SimpleAsyncTaskExecutor.java:280"$0$"		}"
"SimpleAsyncTaskExecutor.java:281"$0$"	}"
"SimpleAsyncTaskExecutor.java:282"$0$""
"SimpleAsyncTaskExecutor.java:283"$0$"}"
"ExceptionTypeFilter.java:1"$0$"/*"
"ExceptionTypeFilter.java:2"$0$" * Copyright 2002-2014 the original author or authors."
"ExceptionTypeFilter.java:3"$0$" *"
"ExceptionTypeFilter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ExceptionTypeFilter.java:5"$0$" * you may not use this file except in compliance with the License."
"ExceptionTypeFilter.java:6"$0$" * You may obtain a copy of the License at"
"ExceptionTypeFilter.java:7"$0$" *"
"ExceptionTypeFilter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ExceptionTypeFilter.java:9"$0$" *"
"ExceptionTypeFilter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ExceptionTypeFilter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ExceptionTypeFilter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ExceptionTypeFilter.java:13"$0$" * See the License for the specific language governing permissions and"
"ExceptionTypeFilter.java:14"$0$" * limitations under the License."
"ExceptionTypeFilter.java:15"$0$" */"
"ExceptionTypeFilter.java:16"$0$""
"ExceptionTypeFilter.java:17"$0$"package org.springframework.util;"
"ExceptionTypeFilter.java:18"$0$""
"ExceptionTypeFilter.java:19"$0$"import java.util.Collection;"
"ExceptionTypeFilter.java:20"$0$""
"ExceptionTypeFilter.java:21"$0$"/**"
"ExceptionTypeFilter.java:22"$1$" * An {@link InstanceFilter} implementation that handles exception types. A type"
"ExceptionTypeFilter.java:23"$0$" * will match against a given candidate if it is assignable to that candidate."
"ExceptionTypeFilter.java:24"$0$" *"
"ExceptionTypeFilter.java:25"$0$" * @author Stephane Nicoll"
"ExceptionTypeFilter.java:26"$0$" * @since 4.1"
"ExceptionTypeFilter.java:27"$0$" */"
"ExceptionTypeFilter.java:28"$1$"public class ExceptionTypeFilter extends InstanceFilter<Class<? extends Throwable>> {"
"ExceptionTypeFilter.java:29"$1$""
"ExceptionTypeFilter.java:30"$1$"	public ExceptionTypeFilter(Collection<? extends Class<? extends Throwable>> includes,"
"ExceptionTypeFilter.java:31"$1$"			Collection<? extends Class<? extends Throwable>> excludes, boolean matchIfEmpty) {"
"ExceptionTypeFilter.java:32"$1$""
"ExceptionTypeFilter.java:33"$1$"		super(includes, excludes, matchIfEmpty);"
"ExceptionTypeFilter.java:34"$1$"	}"
"ExceptionTypeFilter.java:35"$0$""
"ExceptionTypeFilter.java:36"$0$"	@Override"
"ExceptionTypeFilter.java:37"$1$"	protected boolean match(Class<? extends Throwable> instance, Class<? extends Throwable> candidate) {"
"ExceptionTypeFilter.java:38"$1$"		return candidate.isAssignableFrom(instance);"
"ExceptionTypeFilter.java:39"$1$"	}"
"ExceptionTypeFilter.java:40"$0$""
"ExceptionTypeFilter.java:41"$0$"}"
"PropertiesPersister.java:1"$0$"/*"
"PropertiesPersister.java:2"$0$" * Copyright 2002-2016 the original author or authors."
"PropertiesPersister.java:3"$0$" *"
"PropertiesPersister.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PropertiesPersister.java:5"$0$" * you may not use this file except in compliance with the License."
"PropertiesPersister.java:6"$0$" * You may obtain a copy of the License at"
"PropertiesPersister.java:7"$0$" *"
"PropertiesPersister.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PropertiesPersister.java:9"$0$" *"
"PropertiesPersister.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PropertiesPersister.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PropertiesPersister.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PropertiesPersister.java:13"$0$" * See the License for the specific language governing permissions and"
"PropertiesPersister.java:14"$0$" * limitations under the License."
"PropertiesPersister.java:15"$0$" */"
"PropertiesPersister.java:16"$0$""
"PropertiesPersister.java:17"$0$"package org.springframework.util;"
"PropertiesPersister.java:18"$0$""
"PropertiesPersister.java:19"$0$"import java.io.IOException;"
"PropertiesPersister.java:20"$0$"import java.io.InputStream;"
"PropertiesPersister.java:21"$0$"import java.io.OutputStream;"
"PropertiesPersister.java:22"$0$"import java.io.Reader;"
"PropertiesPersister.java:23"$0$"import java.io.Writer;"
"PropertiesPersister.java:24"$0$"import java.util.Properties;"
"PropertiesPersister.java:25"$0$""
"PropertiesPersister.java:26"$0$"/**"
"PropertiesPersister.java:27"$1$" * Strategy interface for persisting {@code java.util.Properties},"
"PropertiesPersister.java:28"$0$" * allowing for pluggable parsing strategies."
"PropertiesPersister.java:29"$0$" *"
"PropertiesPersister.java:30"$0$" * <p>The default implementation is DefaultPropertiesPersister,"
"PropertiesPersister.java:31"$1$" * providing the native parsing of {@code java.util.Properties},"
"PropertiesPersister.java:32"$0$" * but allowing for reading from any Reader and writing to any Writer"
"PropertiesPersister.java:33"$0$" * (which allows to specify an encoding for a properties file)."
"PropertiesPersister.java:34"$0$" *"
"PropertiesPersister.java:35"$0$" * @author Juergen Hoeller"
"PropertiesPersister.java:36"$0$" * @since 10.03.2004"
"PropertiesPersister.java:37"$0$" * @see DefaultPropertiesPersister"
"PropertiesPersister.java:38"$0$" * @see java.util.Properties"
"PropertiesPersister.java:39"$0$" */"
"PropertiesPersister.java:40"$1$"public interface PropertiesPersister {"
"PropertiesPersister.java:41"$1$""
"PropertiesPersister.java:42"$1$"	/**"
"PropertiesPersister.java:43"$1$"	 * Load properties from the given InputStream into the given"
"PropertiesPersister.java:44"$1$"	 * Properties object."
"PropertiesPersister.java:45"$1$"	 * @param props the Properties object to load into"
"PropertiesPersister.java:46"$1$"	 * @param is the InputStream to load from"
"PropertiesPersister.java:47"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:48"$1$"	 * @see java.util.Properties#load"
"PropertiesPersister.java:49"$1$"	 */"
"PropertiesPersister.java:50"$1$"	void load(Properties props, InputStream is) throws IOException;"
"PropertiesPersister.java:51"$1$""
"PropertiesPersister.java:52"$1$"	/**"
"PropertiesPersister.java:53"$1$"	 * Load properties from the given Reader into the given"
"PropertiesPersister.java:54"$1$"	 * Properties object."
"PropertiesPersister.java:55"$1$"	 * @param props the Properties object to load into"
"PropertiesPersister.java:56"$1$"	 * @param reader the Reader to load from"
"PropertiesPersister.java:57"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:58"$1$"	 */"
"PropertiesPersister.java:59"$1$"	void load(Properties props, Reader reader) throws IOException;"
"PropertiesPersister.java:60"$1$""
"PropertiesPersister.java:61"$1$"	/**"
"PropertiesPersister.java:62"$1$"	 * Write the contents of the given Properties object to the"
"PropertiesPersister.java:63"$1$"	 * given OutputStream."
"PropertiesPersister.java:64"$1$"	 * @param props the Properties object to store"
"PropertiesPersister.java:65"$1$"	 * @param os the OutputStream to write to"
"PropertiesPersister.java:66"$1$"	 * @param header the description of the property list"
"PropertiesPersister.java:67"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:68"$1$"	 * @see java.util.Properties#store"
"PropertiesPersister.java:69"$1$"	 */"
"PropertiesPersister.java:70"$1$"	void store(Properties props, OutputStream os, String header) throws IOException;"
"PropertiesPersister.java:71"$1$""
"PropertiesPersister.java:72"$1$"	/**"
"PropertiesPersister.java:73"$1$"	 * Write the contents of the given Properties object to the"
"PropertiesPersister.java:74"$1$"	 * given Writer."
"PropertiesPersister.java:75"$1$"	 * @param props the Properties object to store"
"PropertiesPersister.java:76"$1$"	 * @param writer the Writer to write to"
"PropertiesPersister.java:77"$1$"	 * @param header the description of the property list"
"PropertiesPersister.java:78"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:79"$1$"	 */"
"PropertiesPersister.java:80"$1$"	void store(Properties props, Writer writer, String header) throws IOException;"
"PropertiesPersister.java:81"$1$""
"PropertiesPersister.java:82"$1$"	/**"
"PropertiesPersister.java:83"$1$"	 * Load properties from the given XML InputStream into the"
"PropertiesPersister.java:84"$1$"	 * given Properties object."
"PropertiesPersister.java:85"$1$"	 * @param props the Properties object to load into"
"PropertiesPersister.java:86"$1$"	 * @param is the InputStream to load from"
"PropertiesPersister.java:87"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:88"$1$"	 * @see java.util.Properties#loadFromXML(java.io.InputStream)"
"PropertiesPersister.java:89"$1$"	 */"
"PropertiesPersister.java:90"$1$"	void loadFromXml(Properties props, InputStream is) throws IOException;"
"PropertiesPersister.java:91"$1$""
"PropertiesPersister.java:92"$1$"	/**"
"PropertiesPersister.java:93"$1$"	 * Write the contents of the given Properties object to the"
"PropertiesPersister.java:94"$1$"	 * given XML OutputStream."
"PropertiesPersister.java:95"$1$"	 * @param props the Properties object to store"
"PropertiesPersister.java:96"$1$"	 * @param os the OutputStream to write to"
"PropertiesPersister.java:97"$1$"	 * @param header the description of the property list"
"PropertiesPersister.java:98"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:99"$1$"	 * @see java.util.Properties#storeToXML(java.io.OutputStream, String)"
"PropertiesPersister.java:100"$1$"	 */"
"PropertiesPersister.java:101"$1$"	void storeToXml(Properties props, OutputStream os, String header) throws IOException;"
"PropertiesPersister.java:102"$1$""
"PropertiesPersister.java:103"$1$"	/**"
"PropertiesPersister.java:104"$1$"	 * Write the contents of the given Properties object to the"
"PropertiesPersister.java:105"$1$"	 * given XML OutputStream."
"PropertiesPersister.java:106"$1$"	 * @param props the Properties object to store"
"PropertiesPersister.java:107"$1$"	 * @param os the OutputStream to write to"
"PropertiesPersister.java:108"$1$"	 * @param encoding the encoding to use"
"PropertiesPersister.java:109"$1$"	 * @param header the description of the property list"
"PropertiesPersister.java:110"$1$"	 * @throws IOException in case of I/O errors"
"PropertiesPersister.java:111"$1$"	 * @see java.util.Properties#storeToXML(java.io.OutputStream, String, String)"
"PropertiesPersister.java:112"$1$"	 */"
"PropertiesPersister.java:113"$1$"	void storeToXml(Properties props, OutputStream os, String header, String encoding) throws IOException;"
"PropertiesPersister.java:114"$1$""
"PropertiesPersister.java:115"$1$"}"
"AnnotationFilter.java:1"$0$"/*"
"AnnotationFilter.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotationFilter.java:3"$0$" *"
"AnnotationFilter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationFilter.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationFilter.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationFilter.java:7"$0$" *"
"AnnotationFilter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationFilter.java:9"$0$" *"
"AnnotationFilter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationFilter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationFilter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationFilter.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationFilter.java:14"$0$" * limitations under the License."
"AnnotationFilter.java:15"$0$" */"
"AnnotationFilter.java:16"$0$""
"AnnotationFilter.java:17"$0$"package org.springframework.core.annotation;"
"AnnotationFilter.java:18"$0$""
"AnnotationFilter.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotationFilter.java:20"$0$""
"AnnotationFilter.java:21"$0$"/**"
"AnnotationFilter.java:22"$0$" * Callback interface that can be used to filter specific annotation types."
"AnnotationFilter.java:23"$0$" *"
"AnnotationFilter.java:24"$0$" * @author Phillip Webb"
"AnnotationFilter.java:25"$0$" * @since 5.2"
"AnnotationFilter.java:26"$0$" */"
"AnnotationFilter.java:27"$0$"FunctionalInterface"
"AnnotationFilter.java:28"$1$"public interface AnnotationFilter {"
"AnnotationFilter.java:29"$1$""
"AnnotationFilter.java:30"$1$"	/**"
"AnnotationFilter.java:31"$1$"	 * {@link AnnotationFilter} that matches annotations in the"
"AnnotationFilter.java:32"$1$"	 * {@code java.lang} and {@code org.springframework.lang} packages"
"AnnotationFilter.java:33"$1$"	 * and their subpackages."
"AnnotationFilter.java:34"$1$"	 */"
"AnnotationFilter.java:35"$1$"	AnnotationFilter PLAIN = packages(""java.lang"", ""org.springframework.lang"");"
"AnnotationFilter.java:36"$1$""
"AnnotationFilter.java:37"$1$"	/**"
"AnnotationFilter.java:38"$1$"	 * {@link AnnotationFilter} that matches annotations in the"
"AnnotationFilter.java:39"$1$"	 * {@code java} and {@code javax} packages and their subpackages."
"AnnotationFilter.java:40"$1$"	 */"
"AnnotationFilter.java:41"$1$"	AnnotationFilter JAVA = packages(""java"", ""javax"");"
"AnnotationFilter.java:42"$1$""
"AnnotationFilter.java:43"$1$"	/**"
"AnnotationFilter.java:44"$1$"	 * {@link AnnotationFilter} that always matches and can be used when no"
"AnnotationFilter.java:45"$1$"	 * relevant annotation types are expected to be present at all."
"AnnotationFilter.java:46"$1$"	 */"
"AnnotationFilter.java:47"$1$"	AnnotationFilter ALL = new AnnotationFilter() {"
"AnnotationFilter.java:48"$1$"		@Override"
"AnnotationFilter.java:49"$1$"		public boolean matches(Annotation annotation) {"
"AnnotationFilter.java:50"$1$"			return true;"
"AnnotationFilter.java:51"$1$"		}"
"AnnotationFilter.java:52"$0$"		@Override"
"AnnotationFilter.java:53"$1$"		public boolean matches(Class<?> type) {"
"AnnotationFilter.java:54"$1$"			return true;"
"AnnotationFilter.java:55"$1$"		}"
"AnnotationFilter.java:56"$0$"		@Override"
"AnnotationFilter.java:57"$1$"		public boolean matches(String typeName) {"
"AnnotationFilter.java:58"$1$"			return true;"
"AnnotationFilter.java:59"$1$"		}"
"AnnotationFilter.java:60"$0$"		@Override"
"AnnotationFilter.java:61"$1$"		public String toString() {"
"AnnotationFilter.java:62"$1$"			return ""All annotations filtered"";"
"AnnotationFilter.java:63"$1$"		}"
"AnnotationFilter.java:64"$0$"	};"
"AnnotationFilter.java:65"$0$""
"AnnotationFilter.java:66"$0$"	/**"
"AnnotationFilter.java:67"$1$"	 * {@link AnnotationFilter} that never matches and can be used when no"
"AnnotationFilter.java:68"$0$"	 * filtering is needed (allowing for any annotation types to be present)."
"AnnotationFilter.java:69"$0$"	 */"
"AnnotationFilter.java:70"$1$"	AnnotationFilter NONE = new AnnotationFilter() {"
"AnnotationFilter.java:71"$1$"		@Override"
"AnnotationFilter.java:72"$1$"		public boolean matches(Annotation annotation) {"
"AnnotationFilter.java:73"$1$"			return false;"
"AnnotationFilter.java:74"$1$"		}"
"AnnotationFilter.java:75"$0$"		@Override"
"AnnotationFilter.java:76"$1$"		public boolean matches(Class<?> type) {"
"AnnotationFilter.java:77"$1$"			return false;"
"AnnotationFilter.java:78"$1$"		}"
"AnnotationFilter.java:79"$0$"		@Override"
"AnnotationFilter.java:80"$1$"		public boolean matches(String typeName) {"
"AnnotationFilter.java:81"$1$"			return false;"
"AnnotationFilter.java:82"$1$"		}"
"AnnotationFilter.java:83"$0$"		@Override"
"AnnotationFilter.java:84"$1$"		public String toString() {"
"AnnotationFilter.java:85"$1$"			return ""No annotation filtering"";"
"AnnotationFilter.java:86"$1$"		}"
"AnnotationFilter.java:87"$0$"	};"
"AnnotationFilter.java:88"$0$""
"AnnotationFilter.java:89"$0$""
"AnnotationFilter.java:90"$0$"	/**"
"AnnotationFilter.java:91"$0$"	 * Test if the given annotation matches the filter."
"AnnotationFilter.java:92"$0$"	 * @param annotation the annotation to test"
"AnnotationFilter.java:93"$1$"	 * @return {@code true} if the annotation matches"
"AnnotationFilter.java:94"$0$"	 */"
"AnnotationFilter.java:95"$1$"	default boolean matches(Annotation annotation) {"
"AnnotationFilter.java:96"$1$"		return matches(annotation.annotationType());"
"AnnotationFilter.java:97"$1$"	}"
"AnnotationFilter.java:98"$0$""
"AnnotationFilter.java:99"$0$"	/**"
"AnnotationFilter.java:100"$0$"	 * Test if the given type matches the filter."
"AnnotationFilter.java:101"$0$"	 * @param type the annotation type to test"
"AnnotationFilter.java:102"$1$"	 * @return {@code true} if the annotation matches"
"AnnotationFilter.java:103"$0$"	 */"
"AnnotationFilter.java:104"$1$"	default boolean matches(Class<?> type) {"
"AnnotationFilter.java:105"$1$"		return matches(type.getName());"
"AnnotationFilter.java:106"$1$"	}"
"AnnotationFilter.java:107"$0$""
"AnnotationFilter.java:108"$0$"	/**"
"AnnotationFilter.java:109"$0$"	 * Test if the given type name matches the filter."
"AnnotationFilter.java:110"$0$"	 * @param typeName the fully qualified class name of the annotation type to test"
"AnnotationFilter.java:111"$1$"	 * @return {@code true} if the annotation matches"
"AnnotationFilter.java:112"$0$"	 */"
"AnnotationFilter.java:113"$0$"	boolean matches(String typeName);"
"AnnotationFilter.java:114"$0$""
"AnnotationFilter.java:115"$0$""
"AnnotationFilter.java:116"$0$"	/**"
"AnnotationFilter.java:117"$1$"	 * Create a new {@link AnnotationFilter} that matches annotations in the"
"AnnotationFilter.java:118"$0$"	 * specified packages."
"AnnotationFilter.java:119"$0$"	 * @param packages the annotation packages that should match"
"AnnotationFilter.java:120"$1$"	 * @return a new {@link AnnotationFilter} instance"
"AnnotationFilter.java:121"$0$"	 */"
"AnnotationFilter.java:122"$1$"	static AnnotationFilter packages(String... packages) {"
"AnnotationFilter.java:123"$1$"		return new PackagesAnnotationFilter(packages);"
"AnnotationFilter.java:124"$1$"	}"
"AnnotationFilter.java:125"$0$""
"AnnotationFilter.java:126"$0$"}"
"PooledDataBuffer.java:1"$0$"/*"
"PooledDataBuffer.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"PooledDataBuffer.java:3"$0$" *"
"PooledDataBuffer.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PooledDataBuffer.java:5"$0$" * you may not use this file except in compliance with the License."
"PooledDataBuffer.java:6"$0$" * You may obtain a copy of the License at"
"PooledDataBuffer.java:7"$0$" *"
"PooledDataBuffer.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PooledDataBuffer.java:9"$0$" *"
"PooledDataBuffer.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PooledDataBuffer.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PooledDataBuffer.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PooledDataBuffer.java:13"$0$" * See the License for the specific language governing permissions and"
"PooledDataBuffer.java:14"$0$" * limitations under the License."
"PooledDataBuffer.java:15"$0$" */"
"PooledDataBuffer.java:16"$0$""
"PooledDataBuffer.java:17"$0$"package org.springframework.core.io.buffer;"
"PooledDataBuffer.java:18"$0$""
"PooledDataBuffer.java:19"$0$"/**"
"PooledDataBuffer.java:20"$1$" * Extension of {@link DataBuffer} that allows for buffer that share"
"PooledDataBuffer.java:21"$0$" * a memory pool. Introduces methods for reference counting."
"PooledDataBuffer.java:22"$0$" *"
"PooledDataBuffer.java:23"$0$" * @author Arjen Poutsma"
"PooledDataBuffer.java:24"$0$" * @since 5.0"
"PooledDataBuffer.java:25"$0$" */"
"PooledDataBuffer.java:26"$1$"public interface PooledDataBuffer extends DataBuffer {"
"PooledDataBuffer.java:27"$1$""
"PooledDataBuffer.java:28"$1$"	/**"
"PooledDataBuffer.java:29"$1$"	 * Return {@code true} if this buffer is allocated;"
"PooledDataBuffer.java:30"$1$"	 * {@code false} if it has been deallocated."
"PooledDataBuffer.java:31"$1$"	 * @since 5.1"
"PooledDataBuffer.java:32"$1$"	 */"
"PooledDataBuffer.java:33"$1$"	boolean isAllocated();"
"PooledDataBuffer.java:34"$1$""
"PooledDataBuffer.java:35"$1$"	/**"
"PooledDataBuffer.java:36"$1$"	 * Increase the reference count for this buffer by one."
"PooledDataBuffer.java:37"$1$"	 * @return this buffer"
"PooledDataBuffer.java:38"$1$"	 */"
"PooledDataBuffer.java:39"$1$"	PooledDataBuffer retain();"
"PooledDataBuffer.java:40"$1$""
"PooledDataBuffer.java:41"$1$"	/**"
"PooledDataBuffer.java:42"$1$"	 * Decrease the reference count for this buffer by one,"
"PooledDataBuffer.java:43"$1$"	 * and deallocate it once the count reaches zero."
"PooledDataBuffer.java:44"$1$"	 * @return {@code true} if the buffer was deallocated;"
"PooledDataBuffer.java:45"$1$"	 * {@code false} otherwise"
"PooledDataBuffer.java:46"$1$"	 */"
"PooledDataBuffer.java:47"$1$"	boolean release();"
"PooledDataBuffer.java:48"$1$""
"PooledDataBuffer.java:49"$1$"}"
"InstanceComparator.java:1"$0$"/*"
"InstanceComparator.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"InstanceComparator.java:3"$0$" *"
"InstanceComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"InstanceComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"InstanceComparator.java:6"$0$" * You may obtain a copy of the License at"
"InstanceComparator.java:7"$0$" *"
"InstanceComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"InstanceComparator.java:9"$0$" *"
"InstanceComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"InstanceComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"InstanceComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"InstanceComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"InstanceComparator.java:14"$0$" * limitations under the License."
"InstanceComparator.java:15"$0$" */"
"InstanceComparator.java:16"$0$""
"InstanceComparator.java:17"$0$"package org.springframework.util.comparator;"
"InstanceComparator.java:18"$0$""
"InstanceComparator.java:19"$0$"import java.util.Comparator;"
"InstanceComparator.java:20"$0$""
"InstanceComparator.java:21"$0$"import org.springframework.lang.Nullable;"
"InstanceComparator.java:22"$0$"import org.springframework.util.Assert;"
"InstanceComparator.java:23"$0$""
"InstanceComparator.java:24"$0$"/**"
"InstanceComparator.java:25"$0$" * Compares objects based on an arbitrary class order. Allows objects to be sorted based"
"InstanceComparator.java:26"$0$" * on the types of class that they inherit, for example: this comparator can be used to"
"InstanceComparator.java:27"$1$" * sort a list {@code Number}s such that {@code Long}s occur before {@code Integer}s."
"InstanceComparator.java:28"$0$" *"
"InstanceComparator.java:29"$1$" * <p>Only the specified {@code instanceOrder} classes are considered during comparison."
"InstanceComparator.java:30"$0$" * If two objects are both instances of the ordered type this comparator will return a"
"InstanceComparator.java:31"$1$" * {@code 0}. Consider combining with {@link Comparator#thenComparing(Comparator)}"
"InstanceComparator.java:32"$0$" * if additional sorting is required."
"InstanceComparator.java:33"$0$" *"
"InstanceComparator.java:34"$0$" * @author Phillip Webb"
"InstanceComparator.java:35"$0$" * @since 3.2"
"InstanceComparator.java:36"$0$" * @param <T> the type of objects that may be compared by this comparator"
"InstanceComparator.java:37"$0$" * @see Comparator#thenComparing(Comparator)"
"InstanceComparator.java:38"$0$" */"
"InstanceComparator.java:39"$1$"public class InstanceComparator<T> implements Comparator<T> {"
"InstanceComparator.java:40"$1$""
"InstanceComparator.java:41"$1$"	private final Class<?>[] instanceOrder;"
"InstanceComparator.java:42"$1$""
"InstanceComparator.java:43"$1$""
"InstanceComparator.java:44"$1$"	/**"
"InstanceComparator.java:45"$1$"	 * Create a new {@link InstanceComparator} instance."
"InstanceComparator.java:46"$1$"	 * @param instanceOrder the ordered list of classes that should be used when comparing"
"InstanceComparator.java:47"$1$"	 * objects. Classes earlier in the list will be given a higher priority."
"InstanceComparator.java:48"$1$"	 */"
"InstanceComparator.java:49"$1$"	public InstanceComparator(Class<?>... instanceOrder) {"
"InstanceComparator.java:50"$1$"		Assert.notNull(instanceOrder, ""'instanceOrder' array must not be null"");"
"InstanceComparator.java:51"$1$"		this.instanceOrder = instanceOrder;"
"InstanceComparator.java:52"$1$"	}"
"InstanceComparator.java:53"$0$""
"InstanceComparator.java:54"$0$""
"InstanceComparator.java:55"$0$"	@Override"
"InstanceComparator.java:56"$1$"	public int compare(T o1, T o2) {"
"InstanceComparator.java:57"$1$"		int i1 = getOrder(o1);"
"InstanceComparator.java:58"$1$"		int i2 = getOrder(o2);"
"InstanceComparator.java:59"$1$"		return (Integer.compare(i1, i2));"
"InstanceComparator.java:60"$1$"	}"
"InstanceComparator.java:61"$0$""
"InstanceComparator.java:62"$1$"	private int getOrder(@Nullable T object) {"
"InstanceComparator.java:63"$1$"		if (object != null) {"
"InstanceComparator.java:64"$1$"			for (int i = 0; i < this.instanceOrder.length; i++) {"
"InstanceComparator.java:65"$1$"				if (this.instanceOrder[i].isInstance(object)) {"
"InstanceComparator.java:66"$1$"					return i;"
"InstanceComparator.java:67"$1$"				}"
"InstanceComparator.java:68"$0$"			}"
"InstanceComparator.java:69"$0$"		}"
"InstanceComparator.java:70"$0$"		return this.instanceOrder.length;"
"InstanceComparator.java:71"$0$"	}"
"InstanceComparator.java:72"$0$""
"InstanceComparator.java:73"$0$"}"
"ClassUtils.java:1"$0$"/*"
"ClassUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"ClassUtils.java:3"$0$" *"
"ClassUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ClassUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"ClassUtils.java:6"$0$" * You may obtain a copy of the License at"
"ClassUtils.java:7"$0$" *"
"ClassUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ClassUtils.java:9"$0$" *"
"ClassUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ClassUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ClassUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ClassUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"ClassUtils.java:14"$0$" * limitations under the License."
"ClassUtils.java:15"$0$" */"
"ClassUtils.java:16"$0$""
"ClassUtils.java:17"$0$"package org.springframework.util;"
"ClassUtils.java:18"$0$""
"ClassUtils.java:19"$0$"import java.beans.Introspector;"
"ClassUtils.java:20"$0$"import java.io.Closeable;"
"ClassUtils.java:21"$0$"import java.io.Externalizable;"
"ClassUtils.java:22"$0$"import java.io.Serializable;"
"ClassUtils.java:23"$0$"import java.lang.reflect.Array;"
"ClassUtils.java:24"$0$"import java.lang.reflect.Constructor;"
"ClassUtils.java:25"$0$"import java.lang.reflect.Method;"
"ClassUtils.java:26"$0$"import java.lang.reflect.Modifier;"
"ClassUtils.java:27"$0$"import java.lang.reflect.Proxy;"
"ClassUtils.java:28"$0$"import java.util.Arrays;"
"ClassUtils.java:29"$0$"import java.util.Collection;"
"ClassUtils.java:30"$0$"import java.util.Collections;"
"ClassUtils.java:31"$0$"import java.util.Enumeration;"
"ClassUtils.java:32"$0$"import java.util.HashMap;"
"ClassUtils.java:33"$0$"import java.util.HashSet;"
"ClassUtils.java:34"$0$"import java.util.IdentityHashMap;"
"ClassUtils.java:35"$0$"import java.util.Iterator;"
"ClassUtils.java:36"$0$"import java.util.LinkedHashSet;"
"ClassUtils.java:37"$0$"import java.util.List;"
"ClassUtils.java:38"$0$"import java.util.Map;"
"ClassUtils.java:39"$0$"import java.util.Optional;"
"ClassUtils.java:40"$0$"import java.util.Set;"
"ClassUtils.java:41"$0$"import java.util.StringJoiner;"
"ClassUtils.java:42"$0$""
"ClassUtils.java:43"$0$"import org.springframework.lang.Nullable;"
"ClassUtils.java:44"$0$""
"ClassUtils.java:45"$0$"/**"
"ClassUtils.java:46"$1$" * Miscellaneous {@code java.lang.Class} utility methods."
"ClassUtils.java:47"$0$" * Mainly for internal use within the framework."
"ClassUtils.java:48"$0$" *"
"ClassUtils.java:49"$0$" * @author Juergen Hoeller"
"ClassUtils.java:50"$0$" * @author Keith Donald"
"ClassUtils.java:51"$0$" * @author Rob Harrop"
"ClassUtils.java:52"$0$" * @author Sam Brannen"
"ClassUtils.java:53"$0$" * @since 1.1"
"ClassUtils.java:54"$0$" * @see TypeUtils"
"ClassUtils.java:55"$0$" * @see ReflectionUtils"
"ClassUtils.java:56"$0$" */"
"ClassUtils.java:57"$1$"public abstract class ClassUtils {"
"ClassUtils.java:58"$1$""
"ClassUtils.java:59"$1$"	/** Suffix for array class names: {@code ""[]""}. */"
"ClassUtils.java:60"$1$"	public static final String ARRAY_SUFFIX = ""[]"";"
"ClassUtils.java:61"$1$""
"ClassUtils.java:62"$1$"	/** Prefix for internal array class names: {@code ""[""}. */"
"ClassUtils.java:63"$1$"	private static final String INTERNAL_ARRAY_PREFIX = ""["";"
"ClassUtils.java:64"$1$""
"ClassUtils.java:65"$1$"	/** Prefix for internal non-primitive array class names: {@code ""[L""}. */"
"ClassUtils.java:66"$1$"	private static final String NON_PRIMITIVE_ARRAY_PREFIX = ""[L"";"
"ClassUtils.java:67"$1$""
"ClassUtils.java:68"$1$"	/** A reusable empty class array constant. */"
"ClassUtils.java:69"$1$"	private static final Class<?>[] EMPTY_CLASS_ARRAY = {};"
"ClassUtils.java:70"$1$""
"ClassUtils.java:71"$1$"	/** The package separator character: {@code '.'}. */"
"ClassUtils.java:72"$1$"	private static final char PACKAGE_SEPARATOR = '.';"
"ClassUtils.java:73"$1$""
"ClassUtils.java:74"$1$"	/** The path separator character: {@code '/'}. */"
"ClassUtils.java:75"$1$"	private static final char PATH_SEPARATOR = '/';"
"ClassUtils.java:76"$1$""
"ClassUtils.java:77"$1$"	/** The inner class separator character: {@code '$'}. */"
"ClassUtils.java:78"$1$"	private static final char INNER_CLASS_SEPARATOR = '$';"
"ClassUtils.java:79"$1$""
"ClassUtils.java:80"$1$"	/** The CGLIB class separator: {@code ""$$""}. */"
"ClassUtils.java:81"$1$"	public static final String CGLIB_CLASS_SEPARATOR = ""$$"";"
"ClassUtils.java:82"$1$""
"ClassUtils.java:83"$1$"	/** The "".class"" file suffix. */"
"ClassUtils.java:84"$1$"	public static final String CLASS_FILE_SUFFIX = "".class"";"
"ClassUtils.java:85"$1$""
"ClassUtils.java:86"$1$""
"ClassUtils.java:87"$1$"	/**"
"ClassUtils.java:88"$1$"	 * Map with primitive wrapper type as key and corresponding primitive"
"ClassUtils.java:89"$1$"	 * type as value, for example: Integer.class -> int.class."
"ClassUtils.java:90"$1$"	 */"
"ClassUtils.java:91"$1$"	private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(8);"
"ClassUtils.java:92"$1$""
"ClassUtils.java:93"$1$"	/**"
"ClassUtils.java:94"$1$"	 * Map with primitive type as key and corresponding wrapper"
"ClassUtils.java:95"$1$"	 * type as value, for example: int.class -> Integer.class."
"ClassUtils.java:96"$1$"	 */"
"ClassUtils.java:97"$1$"	private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(8);"
"ClassUtils.java:98"$1$""
"ClassUtils.java:99"$1$"	/**"
"ClassUtils.java:100"$1$"	 * Map with primitive type name as key and corresponding primitive"
"ClassUtils.java:101"$1$"	 * type as value, for example: ""int"" -> ""int.class""."
"ClassUtils.java:102"$1$"	 */"
"ClassUtils.java:103"$1$"	private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);"
"ClassUtils.java:104"$1$""
"ClassUtils.java:105"$1$"	/**"
"ClassUtils.java:106"$1$"	 * Map with common Java language class name as key and corresponding Class as value."
"ClassUtils.java:107"$1$"	 * Primarily for efficient deserialization of remote invocations."
"ClassUtils.java:108"$1$"	 */"
"ClassUtils.java:109"$1$"	private static final Map<String, Class<?>> commonClassCache = new HashMap<>(64);"
"ClassUtils.java:110"$1$""
"ClassUtils.java:111"$1$"	/**"
"ClassUtils.java:112"$1$"	 * Common Java language interfaces which are supposed to be ignored"
"ClassUtils.java:113"$1$"	 * when searching for 'primary' user-level interfaces."
"ClassUtils.java:114"$1$"	 */"
"ClassUtils.java:115"$1$"	private static final Set<Class<?>> javaLanguageInterfaces;"
"ClassUtils.java:116"$1$""
"ClassUtils.java:117"$1$"	/**"
"ClassUtils.java:118"$1$"	 * Cache for equivalent methods on an interface implemented by the declaring class."
"ClassUtils.java:119"$1$"	 */"
"ClassUtils.java:120"$1$"	private static final Map<Method, Method> interfaceMethodCache = new ConcurrentReferenceHashMap<>(256);"
"ClassUtils.java:121"$1$""
"ClassUtils.java:122"$1$""
"ClassUtils.java:123"$1$"	static {"
"ClassUtils.java:124"$1$"		primitiveWrapperTypeMap.put(Boolean.class, boolean.class);"
"ClassUtils.java:125"$1$"		primitiveWrapperTypeMap.put(Byte.class, byte.class);"
"ClassUtils.java:126"$1$"		primitiveWrapperTypeMap.put(Character.class, char.class);"
"ClassUtils.java:127"$1$"		primitiveWrapperTypeMap.put(Double.class, double.class);"
"ClassUtils.java:128"$1$"		primitiveWrapperTypeMap.put(Float.class, float.class);"
"ClassUtils.java:129"$1$"		primitiveWrapperTypeMap.put(Integer.class, int.class);"
"ClassUtils.java:130"$1$"		primitiveWrapperTypeMap.put(Long.class, long.class);"
"ClassUtils.java:131"$1$"		primitiveWrapperTypeMap.put(Short.class, short.class);"
"ClassUtils.java:132"$1$"		primitiveWrapperTypeMap.put(Void.class, void.class);"
"ClassUtils.java:133"$1$""
"ClassUtils.java:134"$0$"		// Map entry iteration is less expensive to initialize than forEach with lambdas"
"ClassUtils.java:135"$1$"		for (Map.Entry<Class<?>, Class<?>> entry : primitiveWrapperTypeMap.entrySet()) {"
"ClassUtils.java:136"$1$"			primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());"
"ClassUtils.java:137"$1$"			registerCommonClasses(entry.getKey());"
"ClassUtils.java:138"$1$"		}"
"ClassUtils.java:139"$0$""
"ClassUtils.java:140"$0$"		Set<Class<?>> primitiveTypes = new HashSet<>(32);"
"ClassUtils.java:141"$0$"		primitiveTypes.addAll(primitiveWrapperTypeMap.values());"
"ClassUtils.java:142"$0$"		Collections.addAll(primitiveTypes, boolean[].class, byte[].class, char[].class,"
"ClassUtils.java:143"$0$"				double[].class, float[].class, int[].class, long[].class, short[].class);"
"ClassUtils.java:144"$0$"		primitiveTypes.add(void.class);"
"ClassUtils.java:145"$1$"		for (Class<?> primitiveType : primitiveTypes) {"
"ClassUtils.java:146"$1$"			primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);"
"ClassUtils.java:147"$1$"		}"
"ClassUtils.java:148"$0$""
"ClassUtils.java:149"$0$"		registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,"
"ClassUtils.java:150"$0$"				Float[].class, Integer[].class, Long[].class, Short[].class);"
"ClassUtils.java:151"$0$"		registerCommonClasses(Number.class, Number[].class, String.class, String[].class,"
"ClassUtils.java:152"$0$"				Class.class, Class[].class, Object.class, Object[].class);"
"ClassUtils.java:153"$0$"		registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class,"
"ClassUtils.java:154"$0$"				Error.class, StackTraceElement.class, StackTraceElement[].class);"
"ClassUtils.java:155"$0$"		registerCommonClasses(Enum.class, Iterable.class, Iterator.class, Enumeration.class,"
"ClassUtils.java:156"$0$"				Collection.class, List.class, Set.class, Map.class, Map.Entry.class, Optional.class);"
"ClassUtils.java:157"$0$""
"ClassUtils.java:158"$1$"		Class<?>[] javaLanguageInterfaceArray = {Serializable.class, Externalizable.class,"
"ClassUtils.java:159"$1$"				Closeable.class, AutoCloseable.class, Cloneable.class, Comparable.class};"
"ClassUtils.java:160"$0$"		registerCommonClasses(javaLanguageInterfaceArray);"
"ClassUtils.java:161"$0$"		javaLanguageInterfaces = new HashSet<>(Arrays.asList(javaLanguageInterfaceArray));"
"ClassUtils.java:162"$0$"	}"
"ClassUtils.java:163"$0$""
"ClassUtils.java:164"$0$""
"ClassUtils.java:165"$0$"	/**"
"ClassUtils.java:166"$0$"	 * Register the given common classes with the ClassUtils cache."
"ClassUtils.java:167"$0$"	 */"
"ClassUtils.java:168"$1$"	private static void registerCommonClasses(Class<?>... commonClasses) {"
"ClassUtils.java:169"$1$"		for (Class<?> clazz : commonClasses) {"
"ClassUtils.java:170"$1$"			commonClassCache.put(clazz.getName(), clazz);"
"ClassUtils.java:171"$1$"		}"
"ClassUtils.java:172"$0$"	}"
"ClassUtils.java:173"$0$""
"ClassUtils.java:174"$0$"	/**"
"ClassUtils.java:175"$0$"	 * Return the default ClassLoader to use: typically the thread context"
"ClassUtils.java:176"$0$"	 * ClassLoader, if available; the ClassLoader that loaded the ClassUtils"
"ClassUtils.java:177"$0$"	 * class will be used as fallback."
"ClassUtils.java:178"$0$"	 * <p>Call this method if you intend to use the thread context ClassLoader"
"ClassUtils.java:179"$0$"	 * in a scenario where you clearly prefer a non-null ClassLoader reference:"
"ClassUtils.java:180"$0$"	 * for example, for class path resource loading (but not necessarily for"
"ClassUtils.java:181"$1$"	 * {@code Class.forName}, which accepts a {@code null} ClassLoader"
"ClassUtils.java:182"$0$"	 * reference as well)."
"ClassUtils.java:183"$1$"	 * @return the default ClassLoader (only {@code null} if even the system"
"ClassUtils.java:184"$0$"	 * ClassLoader isn't accessible)"
"ClassUtils.java:185"$0$"	 * @see Thread#getContextClassLoader()"
"ClassUtils.java:186"$0$"	 * @see ClassLoader#getSystemClassLoader()"
"ClassUtils.java:187"$0$"	 */"
"ClassUtils.java:188"$0$"	@Nullable"
"ClassUtils.java:189"$1$"	public static ClassLoader getDefaultClassLoader() {"
"ClassUtils.java:190"$1$"		ClassLoader cl = null;"
"ClassUtils.java:191"$1$"		try {"
"ClassUtils.java:192"$1$"			cl = Thread.currentThread().getContextClassLoader();"
"ClassUtils.java:193"$1$"		}"
"ClassUtils.java:194"$1$"		catch (Throwable ex) {"
"ClassUtils.java:195"$0$"			// Cannot access thread context ClassLoader - falling back..."
"ClassUtils.java:196"$1$"		}"
"ClassUtils.java:197"$1$"		if (cl == null) {"
"ClassUtils.java:198"$0$"			// No thread context class loader -> use class loader of this class."
"ClassUtils.java:199"$1$"			cl = ClassUtils.class.getClassLoader();"
"ClassUtils.java:200"$1$"			if (cl == null) {"
"ClassUtils.java:201"$0$"				// getClassLoader() returning null indicates the bootstrap ClassLoader"
"ClassUtils.java:202"$1$"				try {"
"ClassUtils.java:203"$1$"					cl = ClassLoader.getSystemClassLoader();"
"ClassUtils.java:204"$1$"				}"
"ClassUtils.java:205"$1$"				catch (Throwable ex) {"
"ClassUtils.java:206"$0$"					// Cannot access system ClassLoader - oh well, maybe the caller can live with null..."
"ClassUtils.java:207"$1$"				}"
"ClassUtils.java:208"$0$"			}"
"ClassUtils.java:209"$0$"		}"
"ClassUtils.java:210"$0$"		return cl;"
"ClassUtils.java:211"$0$"	}"
"ClassUtils.java:212"$0$""
"ClassUtils.java:213"$0$"	/**"
"ClassUtils.java:214"$0$"	 * Override the thread context ClassLoader with the environment's bean ClassLoader"
"ClassUtils.java:215"$0$"	 * if necessary, i.e. if the bean ClassLoader is not equivalent to the thread"
"ClassUtils.java:216"$0$"	 * context ClassLoader already."
"ClassUtils.java:217"$0$"	 * @param classLoaderToUse the actual ClassLoader to use for the thread context"
"ClassUtils.java:218"$1$"	 * @return the original thread context ClassLoader, or {@code null} if not overridden"
"ClassUtils.java:219"$0$"	 */"
"ClassUtils.java:220"$0$"	@Nullable"
"ClassUtils.java:221"$1$"	public static ClassLoader overrideThreadContextClassLoader(@Nullable ClassLoader classLoaderToUse) {"
"ClassUtils.java:222"$1$"		Thread currentThread = Thread.currentThread();"
"ClassUtils.java:223"$1$"		ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();"
"ClassUtils.java:224"$1$"		if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {"
"ClassUtils.java:225"$1$"			currentThread.setContextClassLoader(classLoaderToUse);"
"ClassUtils.java:226"$1$"			return threadContextClassLoader;"
"ClassUtils.java:227"$1$"		}"
"ClassUtils.java:228"$1$"		else {"
"ClassUtils.java:229"$1$"			return null;"
"ClassUtils.java:230"$1$"		}"
"ClassUtils.java:231"$0$"	}"
"ClassUtils.java:232"$0$""
"ClassUtils.java:233"$0$"	/**"
"ClassUtils.java:234"$1$"	 * Replacement for {@code Class.forName()} that also returns Class instances"
"ClassUtils.java:235"$0$"	 * for primitives (e.g. ""int"") and array class names (e.g. ""String[]"")."
"ClassUtils.java:236"$0$"	 * Furthermore, it is also capable of resolving inner class names in Java source"
"ClassUtils.java:237"$0$"	 * style (e.g. ""java.lang.Thread.State"" instead of ""java.lang.Thread$State"")."
"ClassUtils.java:238"$0$"	 * @param name the name of the Class"
"ClassUtils.java:239"$0$"	 * @param classLoader the class loader to use"
"ClassUtils.java:240"$1$"	 * (may be {@code null}, which indicates the default class loader)"
"ClassUtils.java:241"$0$"	 * @return a class instance for the supplied name"
"ClassUtils.java:242"$0$"	 * @throws ClassNotFoundException if the class was not found"
"ClassUtils.java:243"$0$"	 * @throws LinkageError if the class file could not be loaded"
"ClassUtils.java:244"$0$"	 * @see Class#forName(String, boolean, ClassLoader)"
"ClassUtils.java:245"$0$"	 */"
"ClassUtils.java:246"$0$"	public static Class<?> forName(String name, @Nullable ClassLoader classLoader)"
"ClassUtils.java:247"$1$"			throws ClassNotFoundException, LinkageError {"
"ClassUtils.java:248"$1$""
"ClassUtils.java:249"$1$"		Assert.notNull(name, ""Name must not be null"");"
"ClassUtils.java:250"$1$""
"ClassUtils.java:251"$1$"		Class<?> clazz = resolvePrimitiveClassName(name);"
"ClassUtils.java:252"$1$"		if (clazz == null) {"
"ClassUtils.java:253"$1$"			clazz = commonClassCache.get(name);"
"ClassUtils.java:254"$1$"		}"
"ClassUtils.java:255"$1$"		if (clazz != null) {"
"ClassUtils.java:256"$1$"			return clazz;"
"ClassUtils.java:257"$1$"		}"
"ClassUtils.java:258"$0$""
"ClassUtils.java:259"$0$"		// ""java.lang.String[]"" style arrays"
"ClassUtils.java:260"$1$"		if (name.endsWith(ARRAY_SUFFIX)) {"
"ClassUtils.java:261"$1$"			String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());"
"ClassUtils.java:262"$1$"			Class<?> elementClass = forName(elementClassName, classLoader);"
"ClassUtils.java:263"$1$"			return Array.newInstance(elementClass, 0).getClass();"
"ClassUtils.java:264"$1$"		}"
"ClassUtils.java:265"$0$""
"ClassUtils.java:266"$0$"		// ""[Ljava.lang.String;"" style arrays"
"ClassUtils.java:267"$1$"		if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith("";"")) {"
"ClassUtils.java:268"$1$"			String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);"
"ClassUtils.java:269"$1$"			Class<?> elementClass = forName(elementName, classLoader);"
"ClassUtils.java:270"$1$"			return Array.newInstance(elementClass, 0).getClass();"
"ClassUtils.java:271"$1$"		}"
"ClassUtils.java:272"$0$""
"ClassUtils.java:273"$0$"		// ""[[I"" or ""[[Ljava.lang.String;"" style arrays"
"ClassUtils.java:274"$1$"		if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {"
"ClassUtils.java:275"$1$"			String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());"
"ClassUtils.java:276"$1$"			Class<?> elementClass = forName(elementName, classLoader);"
"ClassUtils.java:277"$1$"			return Array.newInstance(elementClass, 0).getClass();"
"ClassUtils.java:278"$1$"		}"
"ClassUtils.java:279"$0$""
"ClassUtils.java:280"$0$"		ClassLoader clToUse = classLoader;"
"ClassUtils.java:281"$1$"		if (clToUse == null) {"
"ClassUtils.java:282"$1$"			clToUse = getDefaultClassLoader();"
"ClassUtils.java:283"$1$"		}"
"ClassUtils.java:284"$1$"		try {"
"ClassUtils.java:285"$1$"			return Class.forName(name, false, clToUse);"
"ClassUtils.java:286"$1$"		}"
"ClassUtils.java:287"$1$"		catch (ClassNotFoundException ex) {"
"ClassUtils.java:288"$1$"			int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:289"$1$"			if (lastDotIndex != -1) {"
"ClassUtils.java:290"$1$"				String innerClassName ="
"ClassUtils.java:291"$1$"						name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);"
"ClassUtils.java:292"$1$"				try {"
"ClassUtils.java:293"$1$"					return Class.forName(innerClassName, false, clToUse);"
"ClassUtils.java:294"$1$"				}"
"ClassUtils.java:295"$1$"				catch (ClassNotFoundException ex2) {"
"ClassUtils.java:296"$0$"					// Swallow - let original exception get through"
"ClassUtils.java:297"$1$"				}"
"ClassUtils.java:298"$0$"			}"
"ClassUtils.java:299"$0$"			throw ex;"
"ClassUtils.java:300"$0$"		}"
"ClassUtils.java:301"$0$"	}"
"ClassUtils.java:302"$0$""
"ClassUtils.java:303"$0$"	/**"
"ClassUtils.java:304"$0$"	 * Resolve the given class name into a Class instance. Supports"
"ClassUtils.java:305"$0$"	 * primitives (like ""int"") and array class names (like ""String[]"")."
"ClassUtils.java:306"$1$"	 * <p>This is effectively equivalent to the {@code forName}"
"ClassUtils.java:307"$0$"	 * method with the same arguments, with the only difference being"
"ClassUtils.java:308"$0$"	 * the exceptions thrown in case of class loading failure."
"ClassUtils.java:309"$0$"	 * @param className the name of the Class"
"ClassUtils.java:310"$0$"	 * @param classLoader the class loader to use"
"ClassUtils.java:311"$1$"	 * (may be {@code null}, which indicates the default class loader)"
"ClassUtils.java:312"$0$"	 * @return a class instance for the supplied name"
"ClassUtils.java:313"$0$"	 * @throws IllegalArgumentException if the class name was not resolvable"
"ClassUtils.java:314"$0$"	 * (that is, the class could not be found or the class file could not be loaded)"
"ClassUtils.java:315"$0$"	 * @throws IllegalStateException if the corresponding class is resolvable but"
"ClassUtils.java:316"$0$"	 * there was a readability mismatch in the inheritance hierarchy of the class"
"ClassUtils.java:317"$0$"	 * (typically a missing dependency declaration in a Jigsaw module definition"
"ClassUtils.java:318"$0$"	 * for a superclass or interface implemented by the class to be loaded here)"
"ClassUtils.java:319"$0$"	 * @see #forName(String, ClassLoader)"
"ClassUtils.java:320"$0$"	 */"
"ClassUtils.java:321"$0$"	public static Class<?> resolveClassName(String className, @Nullable ClassLoader classLoader)"
"ClassUtils.java:322"$1$"			throws IllegalArgumentException {"
"ClassUtils.java:323"$1$""
"ClassUtils.java:324"$1$"		try {"
"ClassUtils.java:325"$1$"			return forName(className, classLoader);"
"ClassUtils.java:326"$1$"		}"
"ClassUtils.java:327"$1$"		catch (IllegalAccessError err) {"
"ClassUtils.java:328"$1$"			throw new IllegalStateException(""Readability mismatch in inheritance hierarchy of class ["" +"
"ClassUtils.java:329"$1$"					className + ""]: "" + err.getMessage(), err);"
"ClassUtils.java:330"$1$"		}"
"ClassUtils.java:331"$1$"		catch (LinkageError err) {"
"ClassUtils.java:332"$1$"			throw new IllegalArgumentException(""Unresolvable class definition for class ["" + className + ""]"", err);"
"ClassUtils.java:333"$1$"		}"
"ClassUtils.java:334"$1$"		catch (ClassNotFoundException ex) {"
"ClassUtils.java:335"$1$"			throw new IllegalArgumentException(""Could not find class ["" + className + ""]"", ex);"
"ClassUtils.java:336"$1$"		}"
"ClassUtils.java:337"$0$"	}"
"ClassUtils.java:338"$0$""
"ClassUtils.java:339"$0$"	/**"
"ClassUtils.java:340"$1$"	 * Determine whether the {@link Class} identified by the supplied name is present"
"ClassUtils.java:341"$1$"	 * and can be loaded. Will return {@code false} if either the class or"
"ClassUtils.java:342"$0$"	 * one of its dependencies is not present or cannot be loaded."
"ClassUtils.java:343"$0$"	 * @param className the name of the class to check"
"ClassUtils.java:344"$0$"	 * @param classLoader the class loader to use"
"ClassUtils.java:345"$1$"	 * (may be {@code null} which indicates the default class loader)"
"ClassUtils.java:346"$0$"	 * @return whether the specified class is present (including all of its"
"ClassUtils.java:347"$0$"	 * superclasses and interfaces)"
"ClassUtils.java:348"$0$"	 * @throws IllegalStateException if the corresponding class is resolvable but"
"ClassUtils.java:349"$0$"	 * there was a readability mismatch in the inheritance hierarchy of the class"
"ClassUtils.java:350"$0$"	 * (typically a missing dependency declaration in a Jigsaw module definition"
"ClassUtils.java:351"$0$"	 * for a superclass or interface implemented by the class to be checked here)"
"ClassUtils.java:352"$0$"	 */"
"ClassUtils.java:353"$1$"	public static boolean isPresent(String className, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:354"$1$"		try {"
"ClassUtils.java:355"$1$"			forName(className, classLoader);"
"ClassUtils.java:356"$1$"			return true;"
"ClassUtils.java:357"$1$"		}"
"ClassUtils.java:358"$1$"		catch (IllegalAccessError err) {"
"ClassUtils.java:359"$1$"			throw new IllegalStateException(""Readability mismatch in inheritance hierarchy of class ["" +"
"ClassUtils.java:360"$1$"					className + ""]: "" + err.getMessage(), err);"
"ClassUtils.java:361"$1$"		}"
"ClassUtils.java:362"$1$"		catch (Throwable ex) {"
"ClassUtils.java:363"$0$"			// Typically ClassNotFoundException or NoClassDefFoundError..."
"ClassUtils.java:364"$1$"			return false;"
"ClassUtils.java:365"$1$"		}"
"ClassUtils.java:366"$0$"	}"
"ClassUtils.java:367"$0$""
"ClassUtils.java:368"$0$"	/**"
"ClassUtils.java:369"$0$"	 * Check whether the given class is visible in the given ClassLoader."
"ClassUtils.java:370"$0$"	 * @param clazz the class to check (typically an interface)"
"ClassUtils.java:371"$0$"	 * @param classLoader the ClassLoader to check against"
"ClassUtils.java:372"$1$"	 * (may be {@code null} in which case this method will always return {@code true})"
"ClassUtils.java:373"$0$"	 */"
"ClassUtils.java:374"$1$"	public static boolean isVisible(Class<?> clazz, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:375"$1$"		if (classLoader == null) {"
"ClassUtils.java:376"$1$"			return true;"
"ClassUtils.java:377"$1$"		}"
"ClassUtils.java:378"$1$"		try {"
"ClassUtils.java:379"$1$"			if (clazz.getClassLoader() == classLoader) {"
"ClassUtils.java:380"$1$"				return true;"
"ClassUtils.java:381"$1$"			}"
"ClassUtils.java:382"$0$"		}"
"ClassUtils.java:383"$1$"		catch (SecurityException ex) {"
"ClassUtils.java:384"$0$"			// Fall through to loadable check below"
"ClassUtils.java:385"$1$"		}"
"ClassUtils.java:386"$0$""
"ClassUtils.java:387"$0$"		// Visible if same Class can be loaded from given ClassLoader"
"ClassUtils.java:388"$0$"		return isLoadable(clazz, classLoader);"
"ClassUtils.java:389"$0$"	}"
"ClassUtils.java:390"$0$""
"ClassUtils.java:391"$0$"	/**"
"ClassUtils.java:392"$0$"	 * Check whether the given class is cache-safe in the given context,"
"ClassUtils.java:393"$0$"	 * i.e. whether it is loaded by the given ClassLoader or a parent of it."
"ClassUtils.java:394"$0$"	 * @param clazz the class to analyze"
"ClassUtils.java:395"$0$"	 * @param classLoader the ClassLoader to potentially cache metadata in"
"ClassUtils.java:396"$1$"	 * (may be {@code null} which indicates the system class loader)"
"ClassUtils.java:397"$0$"	 */"
"ClassUtils.java:398"$1$"	public static boolean isCacheSafe(Class<?> clazz, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:399"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:400"$1$"		try {"
"ClassUtils.java:401"$1$"			ClassLoader target = clazz.getClassLoader();"
"ClassUtils.java:402"$0$"			// Common cases"
"ClassUtils.java:403"$1$"			if (target == classLoader || target == null) {"
"ClassUtils.java:404"$1$"				return true;"
"ClassUtils.java:405"$1$"			}"
"ClassUtils.java:406"$1$"			if (classLoader == null) {"
"ClassUtils.java:407"$1$"				return false;"
"ClassUtils.java:408"$1$"			}"
"ClassUtils.java:409"$0$"			// Check for match in ancestors -> positive"
"ClassUtils.java:410"$0$"			ClassLoader current = classLoader;"
"ClassUtils.java:411"$1$"			while (current != null) {"
"ClassUtils.java:412"$1$"				current = current.getParent();"
"ClassUtils.java:413"$1$"				if (current == target) {"
"ClassUtils.java:414"$1$"					return true;"
"ClassUtils.java:415"$1$"				}"
"ClassUtils.java:416"$0$"			}"
"ClassUtils.java:417"$0$"			// Check for match in children -> negative"
"ClassUtils.java:418"$1$"			while (target != null) {"
"ClassUtils.java:419"$1$"				target = target.getParent();"
"ClassUtils.java:420"$1$"				if (target == classLoader) {"
"ClassUtils.java:421"$1$"					return false;"
"ClassUtils.java:422"$1$"				}"
"ClassUtils.java:423"$0$"			}"
"ClassUtils.java:424"$0$"		}"
"ClassUtils.java:425"$1$"		catch (SecurityException ex) {"
"ClassUtils.java:426"$0$"			// Fall through to loadable check below"
"ClassUtils.java:427"$1$"		}"
"ClassUtils.java:428"$0$""
"ClassUtils.java:429"$0$"		// Fallback for ClassLoaders without parent/child relationship:"
"ClassUtils.java:430"$0$"		// safe if same Class can be loaded from given ClassLoader"
"ClassUtils.java:431"$0$"		return (classLoader != null && isLoadable(clazz, classLoader));"
"ClassUtils.java:432"$0$"	}"
"ClassUtils.java:433"$0$""
"ClassUtils.java:434"$0$"	/**"
"ClassUtils.java:435"$0$"	 * Check whether the given class is loadable in the given ClassLoader."
"ClassUtils.java:436"$0$"	 * @param clazz the class to check (typically an interface)"
"ClassUtils.java:437"$0$"	 * @param classLoader the ClassLoader to check against"
"ClassUtils.java:438"$0$"	 * @since 5.0.6"
"ClassUtils.java:439"$0$"	 */"
"ClassUtils.java:440"$1$"	private static boolean isLoadable(Class<?> clazz, ClassLoader classLoader) {"
"ClassUtils.java:441"$1$"		try {"
"ClassUtils.java:442"$1$"			return (clazz == classLoader.loadClass(clazz.getName()));"
"ClassUtils.java:443"$0$"			// Else: different class with same name found"
"ClassUtils.java:444"$1$"		}"
"ClassUtils.java:445"$1$"		catch (ClassNotFoundException ex) {"
"ClassUtils.java:446"$0$"			// No corresponding class found at all"
"ClassUtils.java:447"$1$"			return false;"
"ClassUtils.java:448"$1$"		}"
"ClassUtils.java:449"$0$"	}"
"ClassUtils.java:450"$0$""
"ClassUtils.java:451"$0$"	/**"
"ClassUtils.java:452"$0$"	 * Resolve the given class name as primitive class, if appropriate,"
"ClassUtils.java:453"$0$"	 * according to the JVM's naming rules for primitive classes."
"ClassUtils.java:454"$0$"	 * <p>Also supports the JVM's internal class names for primitive arrays."
"ClassUtils.java:455"$0$"	 * Does <i>not</i> support the ""[]"" suffix notation for primitive arrays;"
"ClassUtils.java:456"$1$"	 * this is only supported by {@link #forName(String, ClassLoader)}."
"ClassUtils.java:457"$0$"	 * @param name the name of the potentially primitive class"
"ClassUtils.java:458"$1$"	 * @return the primitive class, or {@code null} if the name does not denote"
"ClassUtils.java:459"$0$"	 * a primitive class or primitive array class"
"ClassUtils.java:460"$0$"	 */"
"ClassUtils.java:461"$0$"	@Nullable"
"ClassUtils.java:462"$1$"	public static Class<?> resolvePrimitiveClassName(@Nullable String name) {"
"ClassUtils.java:463"$1$"		Class<?> result = null;"
"ClassUtils.java:464"$0$"		// Most class names will be quite long, considering that they"
"ClassUtils.java:465"$0$"		// SHOULD sit in a package, so a length check is worthwhile."
"ClassUtils.java:466"$1$"		if (name != null && name.length() <= 7) {"
"ClassUtils.java:467"$0$"			// Could be a primitive - likely."
"ClassUtils.java:468"$1$"			result = primitiveTypeNameMap.get(name);"
"ClassUtils.java:469"$1$"		}"
"ClassUtils.java:470"$0$"		return result;"
"ClassUtils.java:471"$0$"	}"
"ClassUtils.java:472"$0$""
"ClassUtils.java:473"$0$"	/**"
"ClassUtils.java:474"$0$"	 * Check if the given class represents a primitive wrapper,"
"ClassUtils.java:475"$0$"	 * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, Double, or"
"ClassUtils.java:476"$0$"	 * Void."
"ClassUtils.java:477"$0$"	 * @param clazz the class to check"
"ClassUtils.java:478"$0$"	 * @return whether the given class is a primitive wrapper class"
"ClassUtils.java:479"$0$"	 */"
"ClassUtils.java:480"$1$"	public static boolean isPrimitiveWrapper(Class<?> clazz) {"
"ClassUtils.java:481"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:482"$1$"		return primitiveWrapperTypeMap.containsKey(clazz);"
"ClassUtils.java:483"$1$"	}"
"ClassUtils.java:484"$0$""
"ClassUtils.java:485"$0$"	/**"
"ClassUtils.java:486"$0$"	 * Check if the given class represents a primitive (i.e. boolean, byte,"
"ClassUtils.java:487"$1$"	 * char, short, int, long, float, or double), {@code void}, or a wrapper for"
"ClassUtils.java:488"$0$"	 * those types (i.e. Boolean, Byte, Character, Short, Integer, Long, Float,"
"ClassUtils.java:489"$0$"	 * Double, or Void)."
"ClassUtils.java:490"$0$"	 * @param clazz the class to check"
"ClassUtils.java:491"$1$"	 * @return {@code true} if the given class represents a primitive, void, or"
"ClassUtils.java:492"$0$"	 * a wrapper class"
"ClassUtils.java:493"$0$"	 */"
"ClassUtils.java:494"$1$"	public static boolean isPrimitiveOrWrapper(Class<?> clazz) {"
"ClassUtils.java:495"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:496"$1$"		return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));"
"ClassUtils.java:497"$1$"	}"
"ClassUtils.java:498"$0$""
"ClassUtils.java:499"$0$"	/**"
"ClassUtils.java:500"$0$"	 * Check if the given class represents an array of primitives,"
"ClassUtils.java:501"$0$"	 * i.e. boolean, byte, char, short, int, long, float, or double."
"ClassUtils.java:502"$0$"	 * @param clazz the class to check"
"ClassUtils.java:503"$0$"	 * @return whether the given class is a primitive array class"
"ClassUtils.java:504"$0$"	 */"
"ClassUtils.java:505"$1$"	public static boolean isPrimitiveArray(Class<?> clazz) {"
"ClassUtils.java:506"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:507"$1$"		return (clazz.isArray() && clazz.getComponentType().isPrimitive());"
"ClassUtils.java:508"$1$"	}"
"ClassUtils.java:509"$0$""
"ClassUtils.java:510"$0$"	/**"
"ClassUtils.java:511"$0$"	 * Check if the given class represents an array of primitive wrappers,"
"ClassUtils.java:512"$0$"	 * i.e. Boolean, Byte, Character, Short, Integer, Long, Float, or Double."
"ClassUtils.java:513"$0$"	 * @param clazz the class to check"
"ClassUtils.java:514"$0$"	 * @return whether the given class is a primitive wrapper array class"
"ClassUtils.java:515"$0$"	 */"
"ClassUtils.java:516"$1$"	public static boolean isPrimitiveWrapperArray(Class<?> clazz) {"
"ClassUtils.java:517"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:518"$1$"		return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));"
"ClassUtils.java:519"$1$"	}"
"ClassUtils.java:520"$0$""
"ClassUtils.java:521"$0$"	/**"
"ClassUtils.java:522"$0$"	 * Resolve the given class if it is a primitive class,"
"ClassUtils.java:523"$0$"	 * returning the corresponding primitive wrapper type instead."
"ClassUtils.java:524"$0$"	 * @param clazz the class to check"
"ClassUtils.java:525"$0$"	 * @return the original class, or a primitive wrapper for the original primitive type"
"ClassUtils.java:526"$0$"	 */"
"ClassUtils.java:527"$1$"	public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {"
"ClassUtils.java:528"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:529"$1$"		return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);"
"ClassUtils.java:530"$1$"	}"
"ClassUtils.java:531"$0$""
"ClassUtils.java:532"$0$"	/**"
"ClassUtils.java:533"$0$"	 * Check if the right-hand side type may be assigned to the left-hand side"
"ClassUtils.java:534"$0$"	 * type, assuming setting by reflection. Considers primitive wrapper"
"ClassUtils.java:535"$0$"	 * classes as assignable to the corresponding primitive types."
"ClassUtils.java:536"$0$"	 * @param lhsType the target type"
"ClassUtils.java:537"$0$"	 * @param rhsType the value type that should be assigned to the target type"
"ClassUtils.java:538"$0$"	 * @return if the target type is assignable from the value type"
"ClassUtils.java:539"$0$"	 * @see TypeUtils#isAssignable(java.lang.reflect.Type, java.lang.reflect.Type)"
"ClassUtils.java:540"$0$"	 */"
"ClassUtils.java:541"$1$"	public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {"
"ClassUtils.java:542"$1$"		Assert.notNull(lhsType, ""Left-hand side type must not be null"");"
"ClassUtils.java:543"$1$"		Assert.notNull(rhsType, ""Right-hand side type must not be null"");"
"ClassUtils.java:544"$1$"		if (lhsType.isAssignableFrom(rhsType)) {"
"ClassUtils.java:545"$1$"			return true;"
"ClassUtils.java:546"$1$"		}"
"ClassUtils.java:547"$1$"		if (lhsType.isPrimitive()) {"
"ClassUtils.java:548"$1$"			Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);"
"ClassUtils.java:549"$1$"			return (lhsType == resolvedPrimitive);"
"ClassUtils.java:550"$1$"		}"
"ClassUtils.java:551"$1$"		else {"
"ClassUtils.java:552"$1$"			Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);"
"ClassUtils.java:553"$1$"			return (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper));"
"ClassUtils.java:554"$1$"		}"
"ClassUtils.java:555"$0$"	}"
"ClassUtils.java:556"$0$""
"ClassUtils.java:557"$0$"	/**"
"ClassUtils.java:558"$0$"	 * Determine if the given type is assignable from the given value,"
"ClassUtils.java:559"$0$"	 * assuming setting by reflection. Considers primitive wrapper classes"
"ClassUtils.java:560"$0$"	 * as assignable to the corresponding primitive types."
"ClassUtils.java:561"$0$"	 * @param type the target type"
"ClassUtils.java:562"$0$"	 * @param value the value that should be assigned to the type"
"ClassUtils.java:563"$0$"	 * @return if the type is assignable from the value"
"ClassUtils.java:564"$0$"	 */"
"ClassUtils.java:565"$1$"	public static boolean isAssignableValue(Class<?> type, @Nullable Object value) {"
"ClassUtils.java:566"$1$"		Assert.notNull(type, ""Type must not be null"");"
"ClassUtils.java:567"$1$"		return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());"
"ClassUtils.java:568"$1$"	}"
"ClassUtils.java:569"$0$""
"ClassUtils.java:570"$0$"	/**"
"ClassUtils.java:571"$0$"	 * Convert a ""/""-based resource path to a "".""-based fully qualified class name."
"ClassUtils.java:572"$0$"	 * @param resourcePath the resource path pointing to a class"
"ClassUtils.java:573"$0$"	 * @return the corresponding fully qualified class name"
"ClassUtils.java:574"$0$"	 */"
"ClassUtils.java:575"$1$"	public static String convertResourcePathToClassName(String resourcePath) {"
"ClassUtils.java:576"$1$"		Assert.notNull(resourcePath, ""Resource path must not be null"");"
"ClassUtils.java:577"$1$"		return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);"
"ClassUtils.java:578"$1$"	}"
"ClassUtils.java:579"$0$""
"ClassUtils.java:580"$0$"	/**"
"ClassUtils.java:581"$0$"	 * Convert a "".""-based fully qualified class name to a ""/""-based resource path."
"ClassUtils.java:582"$0$"	 * @param className the fully qualified class name"
"ClassUtils.java:583"$0$"	 * @return the corresponding resource path, pointing to the class"
"ClassUtils.java:584"$0$"	 */"
"ClassUtils.java:585"$1$"	public static String convertClassNameToResourcePath(String className) {"
"ClassUtils.java:586"$1$"		Assert.notNull(className, ""Class name must not be null"");"
"ClassUtils.java:587"$1$"		return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);"
"ClassUtils.java:588"$1$"	}"
"ClassUtils.java:589"$0$""
"ClassUtils.java:590"$0$"	/**"
"ClassUtils.java:591"$1$"	 * Return a path suitable for use with {@code ClassLoader.getResource}"
"ClassUtils.java:592"$1$"	 * (also suitable for use with {@code Class.getResource} by prepending a"
"ClassUtils.java:593"$0$"	 * slash ('/') to the return value). Built by taking the package of the specified"
"ClassUtils.java:594"$0$"	 * class file, converting all dots ('.') to slashes ('/'), adding a trailing slash"
"ClassUtils.java:595"$0$"	 * if necessary, and concatenating the specified resource name to this."
"ClassUtils.java:596"$0$"	 * <br/>As such, this function may be used to build a path suitable for"
"ClassUtils.java:597"$0$"	 * loading a resource file that is in the same package as a class file,"
"ClassUtils.java:598"$1$"	 * although {@link org.springframework.core.io.ClassPathResource} is usually"
"ClassUtils.java:599"$0$"	 * even more convenient."
"ClassUtils.java:600"$0$"	 * @param clazz the Class whose package will be used as the base"
"ClassUtils.java:601"$0$"	 * @param resourceName the resource name to append. A leading slash is optional."
"ClassUtils.java:602"$0$"	 * @return the built-up resource path"
"ClassUtils.java:603"$0$"	 * @see ClassLoader#getResource"
"ClassUtils.java:604"$0$"	 * @see Class#getResource"
"ClassUtils.java:605"$0$"	 */"
"ClassUtils.java:606"$1$"	public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {"
"ClassUtils.java:607"$1$"		Assert.notNull(resourceName, ""Resource name must not be null"");"
"ClassUtils.java:608"$1$"		if (!resourceName.startsWith(""/"")) {"
"ClassUtils.java:609"$1$"			return classPackageAsResourcePath(clazz) + '/' + resourceName;"
"ClassUtils.java:610"$1$"		}"
"ClassUtils.java:611"$0$"		return classPackageAsResourcePath(clazz) + resourceName;"
"ClassUtils.java:612"$0$"	}"
"ClassUtils.java:613"$0$""
"ClassUtils.java:614"$0$"	/**"
"ClassUtils.java:615"$0$"	 * Given an input class object, return a string which consists of the"
"ClassUtils.java:616"$0$"	 * class's package name as a pathname, i.e., all dots ('.') are replaced by"
"ClassUtils.java:617"$0$"	 * slashes ('/'). Neither a leading nor trailing slash is added. The result"
"ClassUtils.java:618"$0$"	 * could be concatenated with a slash and the name of a resource and fed"
"ClassUtils.java:619"$1$"	 * directly to {@code ClassLoader.getResource()}. For it to be fed to"
"ClassUtils.java:620"$1$"	 * {@code Class.getResource} instead, a leading slash would also have"
"ClassUtils.java:621"$0$"	 * to be prepended to the returned value."
"ClassUtils.java:622"$1$"	 * @param clazz the input class. A {@code null} value or the default"
"ClassUtils.java:623"$0$"	 * (empty) package will result in an empty string ("""") being returned."
"ClassUtils.java:624"$0$"	 * @return a path which represents the package name"
"ClassUtils.java:625"$0$"	 * @see ClassLoader#getResource"
"ClassUtils.java:626"$0$"	 * @see Class#getResource"
"ClassUtils.java:627"$0$"	 */"
"ClassUtils.java:628"$1$"	public static String classPackageAsResourcePath(@Nullable Class<?> clazz) {"
"ClassUtils.java:629"$1$"		if (clazz == null) {"
"ClassUtils.java:630"$1$"			return """";"
"ClassUtils.java:631"$1$"		}"
"ClassUtils.java:632"$0$"		String className = clazz.getName();"
"ClassUtils.java:633"$0$"		int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:634"$1$"		if (packageEndIndex == -1) {"
"ClassUtils.java:635"$1$"			return """";"
"ClassUtils.java:636"$1$"		}"
"ClassUtils.java:637"$0$"		String packageName = className.substring(0, packageEndIndex);"
"ClassUtils.java:638"$0$"		return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);"
"ClassUtils.java:639"$0$"	}"
"ClassUtils.java:640"$0$""
"ClassUtils.java:641"$0$"	/**"
"ClassUtils.java:642"$0$"	 * Build a String that consists of the names of the classes/interfaces"
"ClassUtils.java:643"$0$"	 * in the given array."
"ClassUtils.java:644"$1$"	 * <p>Basically like {@code AbstractCollection.toString()}, but stripping"
"ClassUtils.java:645"$0$"	 * the ""class ""/""interface "" prefix before every class name."
"ClassUtils.java:646"$0$"	 * @param classes an array of Class objects"
"ClassUtils.java:647"$0$"	 * @return a String of form ""[com.foo.Bar, com.foo.Baz]"""
"ClassUtils.java:648"$0$"	 * @see java.util.AbstractCollection#toString()"
"ClassUtils.java:649"$0$"	 */"
"ClassUtils.java:650"$1$"	public static String classNamesToString(Class<?>... classes) {"
"ClassUtils.java:651"$1$"		return classNamesToString(Arrays.asList(classes));"
"ClassUtils.java:652"$1$"	}"
"ClassUtils.java:653"$0$""
"ClassUtils.java:654"$0$"	/**"
"ClassUtils.java:655"$0$"	 * Build a String that consists of the names of the classes/interfaces"
"ClassUtils.java:656"$0$"	 * in the given collection."
"ClassUtils.java:657"$1$"	 * <p>Basically like {@code AbstractCollection.toString()}, but stripping"
"ClassUtils.java:658"$0$"	 * the ""class ""/""interface "" prefix before every class name."
"ClassUtils.java:659"$1$"	 * @param classes a Collection of Class objects (may be {@code null})"
"ClassUtils.java:660"$0$"	 * @return a String of form ""[com.foo.Bar, com.foo.Baz]"""
"ClassUtils.java:661"$0$"	 * @see java.util.AbstractCollection#toString()"
"ClassUtils.java:662"$0$"	 */"
"ClassUtils.java:663"$1$"	public static String classNamesToString(@Nullable Collection<Class<?>> classes) {"
"ClassUtils.java:664"$1$"		if (CollectionUtils.isEmpty(classes)) {"
"ClassUtils.java:665"$1$"			return ""[]"";"
"ClassUtils.java:666"$1$"		}"
"ClassUtils.java:667"$0$"		StringJoiner stringJoiner = new StringJoiner("", "", ""["", ""]"");"
"ClassUtils.java:668"$1$"		for (Class<?> clazz : classes) {"
"ClassUtils.java:669"$1$"			stringJoiner.add(clazz.getName());"
"ClassUtils.java:670"$1$"		}"
"ClassUtils.java:671"$0$"		return stringJoiner.toString();"
"ClassUtils.java:672"$0$"	}"
"ClassUtils.java:673"$0$""
"ClassUtils.java:674"$0$"	/**"
"ClassUtils.java:675"$1$"	 * Copy the given {@code Collection} into a {@code Class} array."
"ClassUtils.java:676"$1$"	 * <p>The {@code Collection} must contain {@code Class} elements only."
"ClassUtils.java:677"$1$"	 * @param collection the {@code Collection} to copy"
"ClassUtils.java:678"$1$"	 * @return the {@code Class} array"
"ClassUtils.java:679"$0$"	 * @since 3.1"
"ClassUtils.java:680"$0$"	 * @see StringUtils#toStringArray"
"ClassUtils.java:681"$0$"	 */"
"ClassUtils.java:682"$1$"	public static Class<?>[] toClassArray(@Nullable Collection<Class<?>> collection) {"
"ClassUtils.java:683"$1$"		return (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_CLASS_ARRAY) : EMPTY_CLASS_ARRAY);"
"ClassUtils.java:684"$1$"	}"
"ClassUtils.java:685"$0$""
"ClassUtils.java:686"$0$"	/**"
"ClassUtils.java:687"$0$"	 * Return all interfaces that the given instance implements as an array,"
"ClassUtils.java:688"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:689"$0$"	 * @param instance the instance to analyze for interfaces"
"ClassUtils.java:690"$0$"	 * @return all interfaces that the given instance implements as an array"
"ClassUtils.java:691"$0$"	 */"
"ClassUtils.java:692"$1$"	public static Class<?>[] getAllInterfaces(Object instance) {"
"ClassUtils.java:693"$1$"		Assert.notNull(instance, ""Instance must not be null"");"
"ClassUtils.java:694"$1$"		return getAllInterfacesForClass(instance.getClass());"
"ClassUtils.java:695"$1$"	}"
"ClassUtils.java:696"$0$""
"ClassUtils.java:697"$0$"	/**"
"ClassUtils.java:698"$0$"	 * Return all interfaces that the given class implements as an array,"
"ClassUtils.java:699"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:700"$0$"	 * <p>If the class itself is an interface, it gets returned as sole interface."
"ClassUtils.java:701"$0$"	 * @param clazz the class to analyze for interfaces"
"ClassUtils.java:702"$0$"	 * @return all interfaces that the given object implements as an array"
"ClassUtils.java:703"$0$"	 */"
"ClassUtils.java:704"$1$"	public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {"
"ClassUtils.java:705"$1$"		return getAllInterfacesForClass(clazz, null);"
"ClassUtils.java:706"$1$"	}"
"ClassUtils.java:707"$0$""
"ClassUtils.java:708"$0$"	/**"
"ClassUtils.java:709"$0$"	 * Return all interfaces that the given class implements as an array,"
"ClassUtils.java:710"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:711"$0$"	 * <p>If the class itself is an interface, it gets returned as sole interface."
"ClassUtils.java:712"$0$"	 * @param clazz the class to analyze for interfaces"
"ClassUtils.java:713"$0$"	 * @param classLoader the ClassLoader that the interfaces need to be visible in"
"ClassUtils.java:714"$1$"	 * (may be {@code null} when accepting all declared interfaces)"
"ClassUtils.java:715"$0$"	 * @return all interfaces that the given object implements as an array"
"ClassUtils.java:716"$0$"	 */"
"ClassUtils.java:717"$1$"	public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:718"$1$"		return toClassArray(getAllInterfacesForClassAsSet(clazz, classLoader));"
"ClassUtils.java:719"$1$"	}"
"ClassUtils.java:720"$0$""
"ClassUtils.java:721"$0$"	/**"
"ClassUtils.java:722"$0$"	 * Return all interfaces that the given instance implements as a Set,"
"ClassUtils.java:723"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:724"$0$"	 * @param instance the instance to analyze for interfaces"
"ClassUtils.java:725"$0$"	 * @return all interfaces that the given instance implements as a Set"
"ClassUtils.java:726"$0$"	 */"
"ClassUtils.java:727"$1$"	public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {"
"ClassUtils.java:728"$1$"		Assert.notNull(instance, ""Instance must not be null"");"
"ClassUtils.java:729"$1$"		return getAllInterfacesForClassAsSet(instance.getClass());"
"ClassUtils.java:730"$1$"	}"
"ClassUtils.java:731"$0$""
"ClassUtils.java:732"$0$"	/**"
"ClassUtils.java:733"$0$"	 * Return all interfaces that the given class implements as a Set,"
"ClassUtils.java:734"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:735"$0$"	 * <p>If the class itself is an interface, it gets returned as sole interface."
"ClassUtils.java:736"$0$"	 * @param clazz the class to analyze for interfaces"
"ClassUtils.java:737"$0$"	 * @return all interfaces that the given object implements as a Set"
"ClassUtils.java:738"$0$"	 */"
"ClassUtils.java:739"$1$"	public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {"
"ClassUtils.java:740"$1$"		return getAllInterfacesForClassAsSet(clazz, null);"
"ClassUtils.java:741"$1$"	}"
"ClassUtils.java:742"$0$""
"ClassUtils.java:743"$0$"	/**"
"ClassUtils.java:744"$0$"	 * Return all interfaces that the given class implements as a Set,"
"ClassUtils.java:745"$0$"	 * including ones implemented by superclasses."
"ClassUtils.java:746"$0$"	 * <p>If the class itself is an interface, it gets returned as sole interface."
"ClassUtils.java:747"$0$"	 * @param clazz the class to analyze for interfaces"
"ClassUtils.java:748"$0$"	 * @param classLoader the ClassLoader that the interfaces need to be visible in"
"ClassUtils.java:749"$1$"	 * (may be {@code null} when accepting all declared interfaces)"
"ClassUtils.java:750"$0$"	 * @return all interfaces that the given object implements as a Set"
"ClassUtils.java:751"$0$"	 */"
"ClassUtils.java:752"$1$"	public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:753"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:754"$1$"		if (clazz.isInterface() && isVisible(clazz, classLoader)) {"
"ClassUtils.java:755"$1$"			return Collections.singleton(clazz);"
"ClassUtils.java:756"$1$"		}"
"ClassUtils.java:757"$0$"		Set<Class<?>> interfaces = new LinkedHashSet<>();"
"ClassUtils.java:758"$0$"		Class<?> current = clazz;"
"ClassUtils.java:759"$1$"		while (current != null) {"
"ClassUtils.java:760"$1$"			Class<?>[] ifcs = current.getInterfaces();"
"ClassUtils.java:761"$1$"			for (Class<?> ifc : ifcs) {"
"ClassUtils.java:762"$1$"				if (isVisible(ifc, classLoader)) {"
"ClassUtils.java:763"$1$"					interfaces.add(ifc);"
"ClassUtils.java:764"$1$"				}"
"ClassUtils.java:765"$0$"			}"
"ClassUtils.java:766"$0$"			current = current.getSuperclass();"
"ClassUtils.java:767"$0$"		}"
"ClassUtils.java:768"$0$"		return interfaces;"
"ClassUtils.java:769"$0$"	}"
"ClassUtils.java:770"$0$""
"ClassUtils.java:771"$0$"	/**"
"ClassUtils.java:772"$0$"	 * Create a composite interface Class for the given interfaces,"
"ClassUtils.java:773"$0$"	 * implementing the given interfaces in one single Class."
"ClassUtils.java:774"$0$"	 * <p>This implementation builds a JDK proxy class for the given interfaces."
"ClassUtils.java:775"$0$"	 * @param interfaces the interfaces to merge"
"ClassUtils.java:776"$0$"	 * @param classLoader the ClassLoader to create the composite Class in"
"ClassUtils.java:777"$0$"	 * @return the merged interface as Class"
"ClassUtils.java:778"$0$"	 * @throws IllegalArgumentException if the specified interfaces expose"
"ClassUtils.java:779"$0$"	 * conflicting method signatures (or a similar constraint is violated)"
"ClassUtils.java:780"$0$"	 * @see java.lang.reflect.Proxy#getProxyClass"
"ClassUtils.java:781"$0$"	 */"
"ClassUtils.java:782"$0$"	@SuppressWarnings(""deprecation"")  // on JDK 9"
"ClassUtils.java:783"$1$"	public static Class<?> createCompositeInterface(Class<?>[] interfaces, @Nullable ClassLoader classLoader) {"
"ClassUtils.java:784"$1$"		Assert.notEmpty(interfaces, ""Interface array must not be empty"");"
"ClassUtils.java:785"$1$"		return Proxy.getProxyClass(classLoader, interfaces);"
"ClassUtils.java:786"$1$"	}"
"ClassUtils.java:787"$0$""
"ClassUtils.java:788"$0$"	/**"
"ClassUtils.java:789"$0$"	 * Determine the common ancestor of the given classes, if any."
"ClassUtils.java:790"$0$"	 * @param clazz1 the class to introspect"
"ClassUtils.java:791"$0$"	 * @param clazz2 the other class to introspect"
"ClassUtils.java:792"$0$"	 * @return the common ancestor (i.e. common superclass, one interface"
"ClassUtils.java:793"$1$"	 * extending the other), or {@code null} if none found. If any of the"
"ClassUtils.java:794"$1$"	 * given classes is {@code null}, the other class will be returned."
"ClassUtils.java:795"$0$"	 * @since 3.2.6"
"ClassUtils.java:796"$0$"	 */"
"ClassUtils.java:797"$0$"	@Nullable"
"ClassUtils.java:798"$1$"	public static Class<?> determineCommonAncestor(@Nullable Class<?> clazz1, @Nullable Class<?> clazz2) {"
"ClassUtils.java:799"$1$"		if (clazz1 == null) {"
"ClassUtils.java:800"$1$"			return clazz2;"
"ClassUtils.java:801"$1$"		}"
"ClassUtils.java:802"$1$"		if (clazz2 == null) {"
"ClassUtils.java:803"$1$"			return clazz1;"
"ClassUtils.java:804"$1$"		}"
"ClassUtils.java:805"$1$"		if (clazz1.isAssignableFrom(clazz2)) {"
"ClassUtils.java:806"$1$"			return clazz1;"
"ClassUtils.java:807"$1$"		}"
"ClassUtils.java:808"$1$"		if (clazz2.isAssignableFrom(clazz1)) {"
"ClassUtils.java:809"$1$"			return clazz2;"
"ClassUtils.java:810"$1$"		}"
"ClassUtils.java:811"$0$"		Class<?> ancestor = clazz1;"
"ClassUtils.java:812"$1$"		do {"
"ClassUtils.java:813"$1$"			ancestor = ancestor.getSuperclass();"
"ClassUtils.java:814"$1$"			if (ancestor == null || Object.class == ancestor) {"
"ClassUtils.java:815"$1$"				return null;"
"ClassUtils.java:816"$1$"			}"
"ClassUtils.java:817"$0$"		}"
"ClassUtils.java:818"$0$"		while (!ancestor.isAssignableFrom(clazz2));"
"ClassUtils.java:819"$0$"		return ancestor;"
"ClassUtils.java:820"$0$"	}"
"ClassUtils.java:821"$0$""
"ClassUtils.java:822"$0$"	/**"
"ClassUtils.java:823"$0$"	 * Determine whether the given interface is a common Java language interface:"
"ClassUtils.java:824"$1$"	 * {@link Serializable}, {@link Externalizable}, {@link Closeable}, {@link AutoCloseable},"
"ClassUtils.java:825"$1$"	 * {@link Cloneable}, {@link Comparable} - all of which can be ignored when looking"
"ClassUtils.java:826"$0$"	 * for 'primary' user-level interfaces. Common characteristics: no service-level"
"ClassUtils.java:827"$0$"	 * operations, no bean property methods, no default methods."
"ClassUtils.java:828"$0$"	 * @param ifc the interface to check"
"ClassUtils.java:829"$0$"	 * @since 5.0.3"
"ClassUtils.java:830"$0$"	 */"
"ClassUtils.java:831"$1$"	public static boolean isJavaLanguageInterface(Class<?> ifc) {"
"ClassUtils.java:832"$1$"		return javaLanguageInterfaces.contains(ifc);"
"ClassUtils.java:833"$1$"	}"
"ClassUtils.java:834"$0$""
"ClassUtils.java:835"$0$"	/**"
"ClassUtils.java:836"$0$"	 * Determine if the supplied class is an <em>inner class</em>,"
"ClassUtils.java:837"$0$"	 * i.e. a non-static member of an enclosing class."
"ClassUtils.java:838"$1$"	 * @return {@code true} if the supplied class is an inner class"
"ClassUtils.java:839"$0$"	 * @since 5.0.5"
"ClassUtils.java:840"$0$"	 * @see Class#isMemberClass()"
"ClassUtils.java:841"$0$"	 */"
"ClassUtils.java:842"$1$"	public static boolean isInnerClass(Class<?> clazz) {"
"ClassUtils.java:843"$1$"		return (clazz.isMemberClass() && !Modifier.isStatic(clazz.getModifiers()));"
"ClassUtils.java:844"$1$"	}"
"ClassUtils.java:845"$0$""
"ClassUtils.java:846"$0$"	/**"
"ClassUtils.java:847"$0$"	 * Check whether the given object is a CGLIB proxy."
"ClassUtils.java:848"$0$"	 * @param object the object to check"
"ClassUtils.java:849"$0$"	 * @see #isCglibProxyClass(Class)"
"ClassUtils.java:850"$0$"	 * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)"
"ClassUtils.java:851"$0$"	 * @deprecated as of 5.2, in favor of custom (possibly narrower) checks"
"ClassUtils.java:852"$0$"	 */"
"ClassUtils.java:853"$0$"	@Deprecated"
"ClassUtils.java:854"$1$"	public static boolean isCglibProxy(Object object) {"
"ClassUtils.java:855"$1$"		return isCglibProxyClass(object.getClass());"
"ClassUtils.java:856"$1$"	}"
"ClassUtils.java:857"$0$""
"ClassUtils.java:858"$0$"	/**"
"ClassUtils.java:859"$0$"	 * Check whether the specified class is a CGLIB-generated class."
"ClassUtils.java:860"$0$"	 * @param clazz the class to check"
"ClassUtils.java:861"$0$"	 * @see #isCglibProxyClassName(String)"
"ClassUtils.java:862"$0$"	 * @deprecated as of 5.2, in favor of custom (possibly narrower) checks"
"ClassUtils.java:863"$0$"	 */"
"ClassUtils.java:864"$0$"	@Deprecated"
"ClassUtils.java:865"$1$"	public static boolean isCglibProxyClass(@Nullable Class<?> clazz) {"
"ClassUtils.java:866"$1$"		return (clazz != null && isCglibProxyClassName(clazz.getName()));"
"ClassUtils.java:867"$1$"	}"
"ClassUtils.java:868"$0$""
"ClassUtils.java:869"$0$"	/**"
"ClassUtils.java:870"$0$"	 * Check whether the specified class name is a CGLIB-generated class."
"ClassUtils.java:871"$0$"	 * @param className the class name to check"
"ClassUtils.java:872"$0$"	 * @deprecated as of 5.2, in favor of custom (possibly narrower) checks"
"ClassUtils.java:873"$0$"	 */"
"ClassUtils.java:874"$0$"	@Deprecated"
"ClassUtils.java:875"$1$"	public static boolean isCglibProxyClassName(@Nullable String className) {"
"ClassUtils.java:876"$1$"		return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));"
"ClassUtils.java:877"$1$"	}"
"ClassUtils.java:878"$0$""
"ClassUtils.java:879"$0$"	/**"
"ClassUtils.java:880"$0$"	 * Return the user-defined class for the given instance: usually simply"
"ClassUtils.java:881"$0$"	 * the class of the given instance, but the original class in case of a"
"ClassUtils.java:882"$0$"	 * CGLIB-generated subclass."
"ClassUtils.java:883"$0$"	 * @param instance the instance to check"
"ClassUtils.java:884"$0$"	 * @return the user-defined class"
"ClassUtils.java:885"$0$"	 */"
"ClassUtils.java:886"$1$"	public static Class<?> getUserClass(Object instance) {"
"ClassUtils.java:887"$1$"		Assert.notNull(instance, ""Instance must not be null"");"
"ClassUtils.java:888"$1$"		return getUserClass(instance.getClass());"
"ClassUtils.java:889"$1$"	}"
"ClassUtils.java:890"$0$""
"ClassUtils.java:891"$0$"	/**"
"ClassUtils.java:892"$0$"	 * Return the user-defined class for the given class: usually simply the given"
"ClassUtils.java:893"$0$"	 * class, but the original class in case of a CGLIB-generated subclass."
"ClassUtils.java:894"$0$"	 * @param clazz the class to check"
"ClassUtils.java:895"$0$"	 * @return the user-defined class"
"ClassUtils.java:896"$0$"	 */"
"ClassUtils.java:897"$1$"	public static Class<?> getUserClass(Class<?> clazz) {"
"ClassUtils.java:898"$1$"		if (clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {"
"ClassUtils.java:899"$1$"			Class<?> superclass = clazz.getSuperclass();"
"ClassUtils.java:900"$1$"			if (superclass != null && superclass != Object.class) {"
"ClassUtils.java:901"$1$"				return superclass;"
"ClassUtils.java:902"$1$"			}"
"ClassUtils.java:903"$0$"		}"
"ClassUtils.java:904"$0$"		return clazz;"
"ClassUtils.java:905"$0$"	}"
"ClassUtils.java:906"$0$""
"ClassUtils.java:907"$0$"	/**"
"ClassUtils.java:908"$0$"	 * Return a descriptive name for the given object's type: usually simply"
"ClassUtils.java:909"$0$"	 * the class name, but component type class name + ""[]"" for arrays,"
"ClassUtils.java:910"$0$"	 * and an appended list of implemented interfaces for JDK proxies."
"ClassUtils.java:911"$0$"	 * @param value the value to introspect"
"ClassUtils.java:912"$0$"	 * @return the qualified name of the class"
"ClassUtils.java:913"$0$"	 */"
"ClassUtils.java:914"$0$"	@Nullable"
"ClassUtils.java:915"$1$"	public static String getDescriptiveType(@Nullable Object value) {"
"ClassUtils.java:916"$1$"		if (value == null) {"
"ClassUtils.java:917"$1$"			return null;"
"ClassUtils.java:918"$1$"		}"
"ClassUtils.java:919"$0$"		Class<?> clazz = value.getClass();"
"ClassUtils.java:920"$1$"		if (Proxy.isProxyClass(clazz)) {"
"ClassUtils.java:921"$1$"			String prefix = clazz.getName() + "" implementing "";"
"ClassUtils.java:922"$1$"			StringJoiner result = new StringJoiner("","", prefix, """");"
"ClassUtils.java:923"$1$"			for (Class<?> ifc : clazz.getInterfaces()) {"
"ClassUtils.java:924"$1$"				result.add(ifc.getName());"
"ClassUtils.java:925"$1$"			}"
"ClassUtils.java:926"$0$"			return result.toString();"
"ClassUtils.java:927"$0$"		}"
"ClassUtils.java:928"$1$"		else {"
"ClassUtils.java:929"$1$"			return clazz.getTypeName();"
"ClassUtils.java:930"$1$"		}"
"ClassUtils.java:931"$0$"	}"
"ClassUtils.java:932"$0$""
"ClassUtils.java:933"$0$"	/**"
"ClassUtils.java:934"$0$"	 * Check whether the given class matches the user-specified type name."
"ClassUtils.java:935"$0$"	 * @param clazz the class to check"
"ClassUtils.java:936"$0$"	 * @param typeName the type name to match"
"ClassUtils.java:937"$0$"	 */"
"ClassUtils.java:938"$1$"	public static boolean matchesTypeName(Class<?> clazz, @Nullable String typeName) {"
"ClassUtils.java:939"$1$"		return (typeName != null &&"
"ClassUtils.java:940"$1$"				(typeName.equals(clazz.getTypeName()) || typeName.equals(clazz.getSimpleName())));"
"ClassUtils.java:941"$1$"	}"
"ClassUtils.java:942"$0$""
"ClassUtils.java:943"$0$"	/**"
"ClassUtils.java:944"$0$"	 * Get the class name without the qualified package name."
"ClassUtils.java:945"$0$"	 * @param className the className to get the short name for"
"ClassUtils.java:946"$0$"	 * @return the class name of the class without the package name"
"ClassUtils.java:947"$0$"	 * @throws IllegalArgumentException if the className is empty"
"ClassUtils.java:948"$0$"	 */"
"ClassUtils.java:949"$1$"	public static String getShortName(String className) {"
"ClassUtils.java:950"$1$"		Assert.hasLength(className, ""Class name must not be empty"");"
"ClassUtils.java:951"$1$"		int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:952"$1$"		int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);"
"ClassUtils.java:953"$1$"		if (nameEndIndex == -1) {"
"ClassUtils.java:954"$1$"			nameEndIndex = className.length();"
"ClassUtils.java:955"$1$"		}"
"ClassUtils.java:956"$0$"		String shortName = className.substring(lastDotIndex + 1, nameEndIndex);"
"ClassUtils.java:957"$0$"		shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);"
"ClassUtils.java:958"$0$"		return shortName;"
"ClassUtils.java:959"$0$"	}"
"ClassUtils.java:960"$0$""
"ClassUtils.java:961"$0$"	/**"
"ClassUtils.java:962"$0$"	 * Get the class name without the qualified package name."
"ClassUtils.java:963"$0$"	 * @param clazz the class to get the short name for"
"ClassUtils.java:964"$0$"	 * @return the class name of the class without the package name"
"ClassUtils.java:965"$0$"	 */"
"ClassUtils.java:966"$1$"	public static String getShortName(Class<?> clazz) {"
"ClassUtils.java:967"$1$"		return getShortName(getQualifiedName(clazz));"
"ClassUtils.java:968"$1$"	}"
"ClassUtils.java:969"$0$""
"ClassUtils.java:970"$0$"	/**"
"ClassUtils.java:971"$0$"	 * Return the short string name of a Java class in uncapitalized JavaBeans"
"ClassUtils.java:972"$0$"	 * property format. Strips the outer class name in case of an inner class."
"ClassUtils.java:973"$0$"	 * @param clazz the class"
"ClassUtils.java:974"$0$"	 * @return the short name rendered in a standard JavaBeans property format"
"ClassUtils.java:975"$0$"	 * @see java.beans.Introspector#decapitalize(String)"
"ClassUtils.java:976"$0$"	 */"
"ClassUtils.java:977"$1$"	public static String getShortNameAsProperty(Class<?> clazz) {"
"ClassUtils.java:978"$1$"		String shortName = getShortName(clazz);"
"ClassUtils.java:979"$1$"		int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:980"$1$"		shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);"
"ClassUtils.java:981"$1$"		return Introspector.decapitalize(shortName);"
"ClassUtils.java:982"$1$"	}"
"ClassUtils.java:983"$0$""
"ClassUtils.java:984"$0$"	/**"
"ClassUtils.java:985"$0$"	 * Determine the name of the class file, relative to the containing"
"ClassUtils.java:986"$0$"	 * package: e.g. ""String.class"""
"ClassUtils.java:987"$0$"	 * @param clazz the class"
"ClassUtils.java:988"$0$"	 * @return the file name of the "".class"" file"
"ClassUtils.java:989"$0$"	 */"
"ClassUtils.java:990"$1$"	public static String getClassFileName(Class<?> clazz) {"
"ClassUtils.java:991"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:992"$1$"		String className = clazz.getName();"
"ClassUtils.java:993"$1$"		int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:994"$1$"		return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;"
"ClassUtils.java:995"$1$"	}"
"ClassUtils.java:996"$0$""
"ClassUtils.java:997"$0$"	/**"
"ClassUtils.java:998"$0$"	 * Determine the name of the package of the given class,"
"ClassUtils.java:999"$1$"	 * e.g. ""java.lang"" for the {@code java.lang.String} class."
"ClassUtils.java:1000"$0$"	 * @param clazz the class"
"ClassUtils.java:1001"$0$"	 * @return the package name, or the empty String if the class"
"ClassUtils.java:1002"$0$"	 * is defined in the default package"
"ClassUtils.java:1003"$0$"	 */"
"ClassUtils.java:1004"$1$"	public static String getPackageName(Class<?> clazz) {"
"ClassUtils.java:1005"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1006"$1$"		return getPackageName(clazz.getName());"
"ClassUtils.java:1007"$1$"	}"
"ClassUtils.java:1008"$0$""
"ClassUtils.java:1009"$0$"	/**"
"ClassUtils.java:1010"$0$"	 * Determine the name of the package of the given fully-qualified class name,"
"ClassUtils.java:1011"$1$"	 * e.g. ""java.lang"" for the {@code java.lang.String} class name."
"ClassUtils.java:1012"$0$"	 * @param fqClassName the fully-qualified class name"
"ClassUtils.java:1013"$0$"	 * @return the package name, or the empty String if the class"
"ClassUtils.java:1014"$0$"	 * is defined in the default package"
"ClassUtils.java:1015"$0$"	 */"
"ClassUtils.java:1016"$1$"	public static String getPackageName(String fqClassName) {"
"ClassUtils.java:1017"$1$"		Assert.notNull(fqClassName, ""Class name must not be null"");"
"ClassUtils.java:1018"$1$"		int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);"
"ClassUtils.java:1019"$1$"		return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : """");"
"ClassUtils.java:1020"$1$"	}"
"ClassUtils.java:1021"$0$""
"ClassUtils.java:1022"$0$"	/**"
"ClassUtils.java:1023"$0$"	 * Return the qualified name of the given class: usually simply"
"ClassUtils.java:1024"$0$"	 * the class name, but component type class name + ""[]"" for arrays."
"ClassUtils.java:1025"$0$"	 * @param clazz the class"
"ClassUtils.java:1026"$0$"	 * @return the qualified name of the class"
"ClassUtils.java:1027"$0$"	 */"
"ClassUtils.java:1028"$1$"	public static String getQualifiedName(Class<?> clazz) {"
"ClassUtils.java:1029"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1030"$1$"		return clazz.getTypeName();"
"ClassUtils.java:1031"$1$"	}"
"ClassUtils.java:1032"$0$""
"ClassUtils.java:1033"$0$"	/**"
"ClassUtils.java:1034"$0$"	 * Return the qualified name of the given method, consisting of"
"ClassUtils.java:1035"$0$"	 * fully qualified interface/class name + ""."" + method name."
"ClassUtils.java:1036"$0$"	 * @param method the method"
"ClassUtils.java:1037"$0$"	 * @return the qualified name of the method"
"ClassUtils.java:1038"$0$"	 */"
"ClassUtils.java:1039"$1$"	public static String getQualifiedMethodName(Method method) {"
"ClassUtils.java:1040"$1$"		return getQualifiedMethodName(method, null);"
"ClassUtils.java:1041"$1$"	}"
"ClassUtils.java:1042"$0$""
"ClassUtils.java:1043"$0$"	/**"
"ClassUtils.java:1044"$0$"	 * Return the qualified name of the given method, consisting of"
"ClassUtils.java:1045"$0$"	 * fully qualified interface/class name + ""."" + method name."
"ClassUtils.java:1046"$0$"	 * @param method the method"
"ClassUtils.java:1047"$0$"	 * @param clazz the clazz that the method is being invoked on"
"ClassUtils.java:1048"$1$"	 * (may be {@code null} to indicate the method's declaring class)"
"ClassUtils.java:1049"$0$"	 * @return the qualified name of the method"
"ClassUtils.java:1050"$0$"	 * @since 4.3.4"
"ClassUtils.java:1051"$0$"	 */"
"ClassUtils.java:1052"$1$"	public static String getQualifiedMethodName(Method method, @Nullable Class<?> clazz) {"
"ClassUtils.java:1053"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ClassUtils.java:1054"$1$"		return (clazz != null ? clazz : method.getDeclaringClass()).getName() + '.' + method.getName();"
"ClassUtils.java:1055"$1$"	}"
"ClassUtils.java:1056"$0$""
"ClassUtils.java:1057"$0$"	/**"
"ClassUtils.java:1058"$0$"	 * Determine whether the given class has a public constructor with the given signature."
"ClassUtils.java:1059"$1$"	 * <p>Essentially translates {@code NoSuchMethodException} to ""false""."
"ClassUtils.java:1060"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1061"$0$"	 * @param paramTypes the parameter types of the method"
"ClassUtils.java:1062"$0$"	 * @return whether the class has a corresponding constructor"
"ClassUtils.java:1063"$0$"	 * @see Class#getConstructor"
"ClassUtils.java:1064"$0$"	 */"
"ClassUtils.java:1065"$1$"	public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {"
"ClassUtils.java:1066"$1$"		return (getConstructorIfAvailable(clazz, paramTypes) != null);"
"ClassUtils.java:1067"$1$"	}"
"ClassUtils.java:1068"$0$""
"ClassUtils.java:1069"$0$"	/**"
"ClassUtils.java:1070"$0$"	 * Determine whether the given class has a public constructor with the given signature,"
"ClassUtils.java:1071"$1$"	 * and return it if available (else return {@code null})."
"ClassUtils.java:1072"$1$"	 * <p>Essentially translates {@code NoSuchMethodException} to {@code null}."
"ClassUtils.java:1073"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1074"$0$"	 * @param paramTypes the parameter types of the method"
"ClassUtils.java:1075"$1$"	 * @return the constructor, or {@code null} if not found"
"ClassUtils.java:1076"$0$"	 * @see Class#getConstructor"
"ClassUtils.java:1077"$0$"	 */"
"ClassUtils.java:1078"$0$"	@Nullable"
"ClassUtils.java:1079"$1$"	public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {"
"ClassUtils.java:1080"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1081"$1$"		try {"
"ClassUtils.java:1082"$1$"			return clazz.getConstructor(paramTypes);"
"ClassUtils.java:1083"$1$"		}"
"ClassUtils.java:1084"$1$"		catch (NoSuchMethodException ex) {"
"ClassUtils.java:1085"$1$"			return null;"
"ClassUtils.java:1086"$1$"		}"
"ClassUtils.java:1087"$0$"	}"
"ClassUtils.java:1088"$0$""
"ClassUtils.java:1089"$0$"	/**"
"ClassUtils.java:1090"$0$"	 * Determine whether the given class has a public method with the given signature."
"ClassUtils.java:1091"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1092"$0$"	 * @param method the method to look for"
"ClassUtils.java:1093"$0$"	 * @return whether the class has a corresponding method"
"ClassUtils.java:1094"$0$"	 * @since 5.2.3"
"ClassUtils.java:1095"$0$"	 */"
"ClassUtils.java:1096"$1$"	public static boolean hasMethod(Class<?> clazz, Method method) {"
"ClassUtils.java:1097"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1098"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ClassUtils.java:1099"$1$"		if (clazz == method.getDeclaringClass()) {"
"ClassUtils.java:1100"$1$"			return true;"
"ClassUtils.java:1101"$1$"		}"
"ClassUtils.java:1102"$0$"		String methodName = method.getName();"
"ClassUtils.java:1103"$0$"		Class<?>[] paramTypes = method.getParameterTypes();"
"ClassUtils.java:1104"$0$"		return getMethodOrNull(clazz, methodName, paramTypes) != null;"
"ClassUtils.java:1105"$0$"	}"
"ClassUtils.java:1106"$0$""
"ClassUtils.java:1107"$0$"	/**"
"ClassUtils.java:1108"$0$"	 * Determine whether the given class has a public method with the given signature."
"ClassUtils.java:1109"$1$"	 * <p>Essentially translates {@code NoSuchMethodException} to ""false""."
"ClassUtils.java:1110"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1111"$0$"	 * @param methodName the name of the method"
"ClassUtils.java:1112"$0$"	 * @param paramTypes the parameter types of the method"
"ClassUtils.java:1113"$0$"	 * @return whether the class has a corresponding method"
"ClassUtils.java:1114"$0$"	 * @see Class#getMethod"
"ClassUtils.java:1115"$0$"	 */"
"ClassUtils.java:1116"$1$"	public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {"
"ClassUtils.java:1117"$1$"		return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);"
"ClassUtils.java:1118"$1$"	}"
"ClassUtils.java:1119"$0$""
"ClassUtils.java:1120"$0$"	/**"
"ClassUtils.java:1121"$0$"	 * Determine whether the given class has a public method with the given signature,"
"ClassUtils.java:1122"$1$"	 * and return it if available (else throws an {@code IllegalStateException})."
"ClassUtils.java:1123"$0$"	 * <p>In case of any signature specified, only returns the method if there is a"
"ClassUtils.java:1124"$0$"	 * unique candidate, i.e. a single public method with the specified name."
"ClassUtils.java:1125"$1$"	 * <p>Essentially translates {@code NoSuchMethodException} to {@code IllegalStateException}."
"ClassUtils.java:1126"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1127"$0$"	 * @param methodName the name of the method"
"ClassUtils.java:1128"$0$"	 * @param paramTypes the parameter types of the method"
"ClassUtils.java:1129"$1$"	 * (may be {@code null} to indicate any signature)"
"ClassUtils.java:1130"$1$"	 * @return the method (never {@code null})"
"ClassUtils.java:1131"$0$"	 * @throws IllegalStateException if the method has not been found"
"ClassUtils.java:1132"$0$"	 * @see Class#getMethod"
"ClassUtils.java:1133"$0$"	 */"
"ClassUtils.java:1134"$1$"	public static Method getMethod(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {"
"ClassUtils.java:1135"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1136"$1$"		Assert.notNull(methodName, ""Method name must not be null"");"
"ClassUtils.java:1137"$1$"		if (paramTypes != null) {"
"ClassUtils.java:1138"$1$"			try {"
"ClassUtils.java:1139"$1$"				return clazz.getMethod(methodName, paramTypes);"
"ClassUtils.java:1140"$1$"			}"
"ClassUtils.java:1141"$1$"			catch (NoSuchMethodException ex) {"
"ClassUtils.java:1142"$1$"				throw new IllegalStateException(""Expected method not found: "" + ex);"
"ClassUtils.java:1143"$1$"			}"
"ClassUtils.java:1144"$0$"		}"
"ClassUtils.java:1145"$1$"		else {"
"ClassUtils.java:1146"$1$"			Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);"
"ClassUtils.java:1147"$1$"			if (candidates.size() == 1) {"
"ClassUtils.java:1148"$1$"				return candidates.iterator().next();"
"ClassUtils.java:1149"$1$"			}"
"ClassUtils.java:1150"$1$"			else if (candidates.isEmpty()) {"
"ClassUtils.java:1151"$1$"				throw new IllegalStateException(""Expected method not found: "" + clazz.getName() + '.' + methodName);"
"ClassUtils.java:1152"$1$"			}"
"ClassUtils.java:1153"$1$"			else {"
"ClassUtils.java:1154"$1$"				throw new IllegalStateException(""No unique method found: "" + clazz.getName() + '.' + methodName);"
"ClassUtils.java:1155"$1$"			}"
"ClassUtils.java:1156"$0$"		}"
"ClassUtils.java:1157"$0$"	}"
"ClassUtils.java:1158"$0$""
"ClassUtils.java:1159"$0$"	/**"
"ClassUtils.java:1160"$0$"	 * Determine whether the given class has a public method with the given signature,"
"ClassUtils.java:1161"$1$"	 * and return it if available (else return {@code null})."
"ClassUtils.java:1162"$0$"	 * <p>In case of any signature specified, only returns the method if there is a"
"ClassUtils.java:1163"$0$"	 * unique candidate, i.e. a single public method with the specified name."
"ClassUtils.java:1164"$1$"	 * <p>Essentially translates {@code NoSuchMethodException} to {@code null}."
"ClassUtils.java:1165"$0$"	 * @param clazz the clazz to analyze"
"ClassUtils.java:1166"$0$"	 * @param methodName the name of the method"
"ClassUtils.java:1167"$0$"	 * @param paramTypes the parameter types of the method"
"ClassUtils.java:1168"$1$"	 * (may be {@code null} to indicate any signature)"
"ClassUtils.java:1169"$1$"	 * @return the method, or {@code null} if not found"
"ClassUtils.java:1170"$0$"	 * @see Class#getMethod"
"ClassUtils.java:1171"$0$"	 */"
"ClassUtils.java:1172"$0$"	@Nullable"
"ClassUtils.java:1173"$1$"	public static Method getMethodIfAvailable(Class<?> clazz, String methodName, @Nullable Class<?>... paramTypes) {"
"ClassUtils.java:1174"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1175"$1$"		Assert.notNull(methodName, ""Method name must not be null"");"
"ClassUtils.java:1176"$1$"		if (paramTypes != null) {"
"ClassUtils.java:1177"$1$"			return getMethodOrNull(clazz, methodName, paramTypes);"
"ClassUtils.java:1178"$1$"		}"
"ClassUtils.java:1179"$1$"		else {"
"ClassUtils.java:1180"$1$"			Set<Method> candidates = findMethodCandidatesByName(clazz, methodName);"
"ClassUtils.java:1181"$1$"			if (candidates.size() == 1) {"
"ClassUtils.java:1182"$1$"				return candidates.iterator().next();"
"ClassUtils.java:1183"$1$"			}"
"ClassUtils.java:1184"$0$"			return null;"
"ClassUtils.java:1185"$0$"		}"
"ClassUtils.java:1186"$0$"	}"
"ClassUtils.java:1187"$0$""
"ClassUtils.java:1188"$0$"	/**"
"ClassUtils.java:1189"$0$"	 * Return the number of methods with a given name (with any argument types),"
"ClassUtils.java:1190"$0$"	 * for the given class and/or its superclasses. Includes non-public methods."
"ClassUtils.java:1191"$0$"	 * @param clazz	the clazz to check"
"ClassUtils.java:1192"$0$"	 * @param methodName the name of the method"
"ClassUtils.java:1193"$0$"	 * @return the number of methods with the given name"
"ClassUtils.java:1194"$0$"	 */"
"ClassUtils.java:1195"$1$"	public static int getMethodCountForName(Class<?> clazz, String methodName) {"
"ClassUtils.java:1196"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1197"$1$"		Assert.notNull(methodName, ""Method name must not be null"");"
"ClassUtils.java:1198"$1$"		int count = 0;"
"ClassUtils.java:1199"$1$"		Method[] declaredMethods = clazz.getDeclaredMethods();"
"ClassUtils.java:1200"$1$"		for (Method method : declaredMethods) {"
"ClassUtils.java:1201"$1$"			if (methodName.equals(method.getName())) {"
"ClassUtils.java:1202"$1$"				count++;"
"ClassUtils.java:1203"$1$"			}"
"ClassUtils.java:1204"$0$"		}"
"ClassUtils.java:1205"$0$"		Class<?>[] ifcs = clazz.getInterfaces();"
"ClassUtils.java:1206"$1$"		for (Class<?> ifc : ifcs) {"
"ClassUtils.java:1207"$1$"			count += getMethodCountForName(ifc, methodName);"
"ClassUtils.java:1208"$1$"		}"
"ClassUtils.java:1209"$1$"		if (clazz.getSuperclass() != null) {"
"ClassUtils.java:1210"$1$"			count += getMethodCountForName(clazz.getSuperclass(), methodName);"
"ClassUtils.java:1211"$1$"		}"
"ClassUtils.java:1212"$0$"		return count;"
"ClassUtils.java:1213"$0$"	}"
"ClassUtils.java:1214"$0$""
"ClassUtils.java:1215"$0$"	/**"
"ClassUtils.java:1216"$0$"	 * Does the given class or one of its superclasses at least have one or more"
"ClassUtils.java:1217"$0$"	 * methods with the supplied name (with any argument types)?"
"ClassUtils.java:1218"$0$"	 * Includes non-public methods."
"ClassUtils.java:1219"$0$"	 * @param clazz	the clazz to check"
"ClassUtils.java:1220"$0$"	 * @param methodName the name of the method"
"ClassUtils.java:1221"$0$"	 * @return whether there is at least one method with the given name"
"ClassUtils.java:1222"$0$"	 */"
"ClassUtils.java:1223"$1$"	public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {"
"ClassUtils.java:1224"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1225"$1$"		Assert.notNull(methodName, ""Method name must not be null"");"
"ClassUtils.java:1226"$1$"		Method[] declaredMethods = clazz.getDeclaredMethods();"
"ClassUtils.java:1227"$1$"		for (Method method : declaredMethods) {"
"ClassUtils.java:1228"$1$"			if (method.getName().equals(methodName)) {"
"ClassUtils.java:1229"$1$"				return true;"
"ClassUtils.java:1230"$1$"			}"
"ClassUtils.java:1231"$0$"		}"
"ClassUtils.java:1232"$0$"		Class<?>[] ifcs = clazz.getInterfaces();"
"ClassUtils.java:1233"$1$"		for (Class<?> ifc : ifcs) {"
"ClassUtils.java:1234"$1$"			if (hasAtLeastOneMethodWithName(ifc, methodName)) {"
"ClassUtils.java:1235"$1$"				return true;"
"ClassUtils.java:1236"$1$"			}"
"ClassUtils.java:1237"$0$"		}"
"ClassUtils.java:1238"$0$"		return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));"
"ClassUtils.java:1239"$0$"	}"
"ClassUtils.java:1240"$0$""
"ClassUtils.java:1241"$0$"	/**"
"ClassUtils.java:1242"$0$"	 * Given a method, which may come from an interface, and a target class used"
"ClassUtils.java:1243"$0$"	 * in the current reflective invocation, find the corresponding target method"
"ClassUtils.java:1244"$1$"	 * if there is one. E.g. the method may be {@code IFoo.bar()} and the"
"ClassUtils.java:1245"$1$"	 * target class may be {@code DefaultFoo}. In this case, the method may be"
"ClassUtils.java:1246"$1$"	 * {@code DefaultFoo.bar()}. This enables attributes on that method to be found."
"ClassUtils.java:1247"$1$"	 * <p><b>NOTE:</b> In contrast to {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},"
"ClassUtils.java:1248"$0$"	 * this method does <i>not</i> resolve Java 5 bridge methods automatically."
"ClassUtils.java:1249"$1$"	 * Call {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}"
"ClassUtils.java:1250"$0$"	 * if bridge method resolution is desirable (e.g. for obtaining metadata from"
"ClassUtils.java:1251"$0$"	 * the original method definition)."
"ClassUtils.java:1252"$0$"	 * <p><b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow reflective"
"ClassUtils.java:1253"$1$"	 * access (e.g. calls to {@code Class#getDeclaredMethods} etc, this implementation"
"ClassUtils.java:1254"$0$"	 * will fall back to returning the originally provided method."
"ClassUtils.java:1255"$0$"	 * @param method the method to be invoked, which may come from an interface"
"ClassUtils.java:1256"$0$"	 * @param targetClass the target class for the current invocation"
"ClassUtils.java:1257"$1$"	 * (may be {@code null} or may not even implement the method)"
"ClassUtils.java:1258"$0$"	 * @return the specific target method, or the original method if the"
"ClassUtils.java:1259"$1$"	 * {@code targetClass} does not implement it"
"ClassUtils.java:1260"$0$"	 * @see #getInterfaceMethodIfPossible"
"ClassUtils.java:1261"$0$"	 */"
"ClassUtils.java:1262"$1$"	public static Method getMostSpecificMethod(Method method, @Nullable Class<?> targetClass) {"
"ClassUtils.java:1263"$1$"		if (targetClass != null && targetClass != method.getDeclaringClass() && isOverridable(method, targetClass)) {"
"ClassUtils.java:1264"$1$"			try {"
"ClassUtils.java:1265"$1$"				if (Modifier.isPublic(method.getModifiers())) {"
"ClassUtils.java:1266"$1$"					try {"
"ClassUtils.java:1267"$1$"						return targetClass.getMethod(method.getName(), method.getParameterTypes());"
"ClassUtils.java:1268"$1$"					}"
"ClassUtils.java:1269"$1$"					catch (NoSuchMethodException ex) {"
"ClassUtils.java:1270"$1$"						return method;"
"ClassUtils.java:1271"$1$"					}"
"ClassUtils.java:1272"$0$"				}"
"ClassUtils.java:1273"$1$"				else {"
"ClassUtils.java:1274"$1$"					Method specificMethod ="
"ClassUtils.java:1275"$1$"							ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());"
"ClassUtils.java:1276"$1$"					return (specificMethod != null ? specificMethod : method);"
"ClassUtils.java:1277"$1$"				}"
"ClassUtils.java:1278"$0$"			}"
"ClassUtils.java:1279"$1$"			catch (SecurityException ex) {"
"ClassUtils.java:1280"$0$"				// Security settings are disallowing reflective access; fall back to 'method' below."
"ClassUtils.java:1281"$1$"			}"
"ClassUtils.java:1282"$0$"		}"
"ClassUtils.java:1283"$0$"		return method;"
"ClassUtils.java:1284"$0$"	}"
"ClassUtils.java:1285"$0$""
"ClassUtils.java:1286"$0$"	/**"
"ClassUtils.java:1287"$0$"	 * Determine a corresponding interface method for the given method handle, if possible."
"ClassUtils.java:1288"$0$"	 * <p>This is particularly useful for arriving at a public exported type on Jigsaw"
"ClassUtils.java:1289"$0$"	 * which can be reflectively invoked without an illegal access warning."
"ClassUtils.java:1290"$0$"	 * @param method the method to be invoked, potentially from an implementation class"
"ClassUtils.java:1291"$0$"	 * @return the corresponding interface method, or the original method if none found"
"ClassUtils.java:1292"$0$"	 * @since 5.1"
"ClassUtils.java:1293"$0$"	 * @see #getMostSpecificMethod"
"ClassUtils.java:1294"$0$"	 */"
"ClassUtils.java:1295"$1$"	public static Method getInterfaceMethodIfPossible(Method method) {"
"ClassUtils.java:1296"$1$"		if (!Modifier.isPublic(method.getModifiers()) || method.getDeclaringClass().isInterface()) {"
"ClassUtils.java:1297"$1$"			return method;"
"ClassUtils.java:1298"$1$"		}"
"ClassUtils.java:1299"$1$"		return interfaceMethodCache.computeIfAbsent(method, key -> {"
"ClassUtils.java:1300"$1$"			Class<?> current = key.getDeclaringClass();"
"ClassUtils.java:1301"$1$"			while (current != null && current != Object.class) {"
"ClassUtils.java:1302"$1$"				Class<?>[] ifcs = current.getInterfaces();"
"ClassUtils.java:1303"$1$"				for (Class<?> ifc : ifcs) {"
"ClassUtils.java:1304"$1$"					try {"
"ClassUtils.java:1305"$1$"						return ifc.getMethod(key.getName(), key.getParameterTypes());"
"ClassUtils.java:1306"$1$"					}"
"ClassUtils.java:1307"$1$"					catch (NoSuchMethodException ex) {"
"ClassUtils.java:1308"$0$"						// ignore"
"ClassUtils.java:1309"$1$"					}"
"ClassUtils.java:1310"$0$"				}"
"ClassUtils.java:1311"$0$"				current = current.getSuperclass();"
"ClassUtils.java:1312"$0$"			}"
"ClassUtils.java:1313"$0$"			return key;"
"ClassUtils.java:1314"$0$"		});"
"ClassUtils.java:1315"$0$"	}"
"ClassUtils.java:1316"$0$""
"ClassUtils.java:1317"$0$"	/**"
"ClassUtils.java:1318"$0$"	 * Determine whether the given method is declared by the user or at least pointing to"
"ClassUtils.java:1319"$0$"	 * a user-declared method."
"ClassUtils.java:1320"$1$"	 * <p>Checks {@link Method#isSynthetic()} (for implementation methods) as well as the"
"ClassUtils.java:1321"$1$"	 * {@code GroovyObject} interface (for interface methods; on an implementation class,"
"ClassUtils.java:1322"$1$"	 * implementations of the {@code GroovyObject} methods will be marked as synthetic anyway)."
"ClassUtils.java:1323"$1$"	 * Note that, despite being synthetic, bridge methods ({@link Method#isBridge()}) are considered"
"ClassUtils.java:1324"$0$"	 * as user-level methods since they are eventually pointing to a user-declared generic method."
"ClassUtils.java:1325"$0$"	 * @param method the method to check"
"ClassUtils.java:1326"$1$"	 * @return {@code true} if the method can be considered as user-declared; [@code false} otherwise"
"ClassUtils.java:1327"$0$"	 */"
"ClassUtils.java:1328"$1$"	public static boolean isUserLevelMethod(Method method) {"
"ClassUtils.java:1329"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ClassUtils.java:1330"$1$"		return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));"
"ClassUtils.java:1331"$1$"	}"
"ClassUtils.java:1332"$0$""
"ClassUtils.java:1333"$1$"	private static boolean isGroovyObjectMethod(Method method) {"
"ClassUtils.java:1334"$1$"		return method.getDeclaringClass().getName().equals(""groovy.lang.GroovyObject"");"
"ClassUtils.java:1335"$1$"	}"
"ClassUtils.java:1336"$0$""
"ClassUtils.java:1337"$0$"	/**"
"ClassUtils.java:1338"$0$"	 * Determine whether the given method is overridable in the given target class."
"ClassUtils.java:1339"$0$"	 * @param method the method to check"
"ClassUtils.java:1340"$0$"	 * @param targetClass the target class to check against"
"ClassUtils.java:1341"$0$"	 */"
"ClassUtils.java:1342"$1$"	private static boolean isOverridable(Method method, @Nullable Class<?> targetClass) {"
"ClassUtils.java:1343"$1$"		if (Modifier.isPrivate(method.getModifiers())) {"
"ClassUtils.java:1344"$1$"			return false;"
"ClassUtils.java:1345"$1$"		}"
"ClassUtils.java:1346"$1$"		if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {"
"ClassUtils.java:1347"$1$"			return true;"
"ClassUtils.java:1348"$1$"		}"
"ClassUtils.java:1349"$0$"		return (targetClass == null ||"
"ClassUtils.java:1350"$0$"				getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass)));"
"ClassUtils.java:1351"$0$"	}"
"ClassUtils.java:1352"$0$""
"ClassUtils.java:1353"$0$"	/**"
"ClassUtils.java:1354"$0$"	 * Return a public static method of a class."
"ClassUtils.java:1355"$0$"	 * @param clazz the class which defines the method"
"ClassUtils.java:1356"$0$"	 * @param methodName the static method name"
"ClassUtils.java:1357"$0$"	 * @param args the parameter types to the method"
"ClassUtils.java:1358"$1$"	 * @return the static method, or {@code null} if no static method was found"
"ClassUtils.java:1359"$0$"	 * @throws IllegalArgumentException if the method name is blank or the clazz is null"
"ClassUtils.java:1360"$0$"	 */"
"ClassUtils.java:1361"$0$"	@Nullable"
"ClassUtils.java:1362"$1$"	public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {"
"ClassUtils.java:1363"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ClassUtils.java:1364"$1$"		Assert.notNull(methodName, ""Method name must not be null"");"
"ClassUtils.java:1365"$1$"		try {"
"ClassUtils.java:1366"$1$"			Method method = clazz.getMethod(methodName, args);"
"ClassUtils.java:1367"$1$"			return Modifier.isStatic(method.getModifiers()) ? method : null;"
"ClassUtils.java:1368"$1$"		}"
"ClassUtils.java:1369"$1$"		catch (NoSuchMethodException ex) {"
"ClassUtils.java:1370"$1$"			return null;"
"ClassUtils.java:1371"$1$"		}"
"ClassUtils.java:1372"$0$"	}"
"ClassUtils.java:1373"$0$""
"ClassUtils.java:1374"$0$""
"ClassUtils.java:1375"$0$"	@Nullable"
"ClassUtils.java:1376"$1$"	private static Method getMethodOrNull(Class<?> clazz, String methodName, Class<?>[] paramTypes) {"
"ClassUtils.java:1377"$1$"		try {"
"ClassUtils.java:1378"$1$"			return clazz.getMethod(methodName, paramTypes);"
"ClassUtils.java:1379"$1$"		}"
"ClassUtils.java:1380"$1$"		catch (NoSuchMethodException ex) {"
"ClassUtils.java:1381"$1$"			return null;"
"ClassUtils.java:1382"$1$"		}"
"ClassUtils.java:1383"$0$"	}"
"ClassUtils.java:1384"$0$""
"ClassUtils.java:1385"$1$"	private static Set<Method> findMethodCandidatesByName(Class<?> clazz, String methodName) {"
"ClassUtils.java:1386"$1$"		Set<Method> candidates = new HashSet<>(1);"
"ClassUtils.java:1387"$1$"		Method[] methods = clazz.getMethods();"
"ClassUtils.java:1388"$1$"		for (Method method : methods) {"
"ClassUtils.java:1389"$1$"			if (methodName.equals(method.getName())) {"
"ClassUtils.java:1390"$1$"				candidates.add(method);"
"ClassUtils.java:1391"$1$"			}"
"ClassUtils.java:1392"$0$"		}"
"ClassUtils.java:1393"$0$"		return candidates;"
"ClassUtils.java:1394"$0$"	}"
"ClassUtils.java:1395"$0$""
"ClassUtils.java:1396"$0$"}"
"MergedAnnotationsCollection.java:1"$0$"/*"
"MergedAnnotationsCollection.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MergedAnnotationsCollection.java:3"$0$" *"
"MergedAnnotationsCollection.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MergedAnnotationsCollection.java:5"$0$" * you may not use this file except in compliance with the License."
"MergedAnnotationsCollection.java:6"$0$" * You may obtain a copy of the License at"
"MergedAnnotationsCollection.java:7"$0$" *"
"MergedAnnotationsCollection.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MergedAnnotationsCollection.java:9"$0$" *"
"MergedAnnotationsCollection.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MergedAnnotationsCollection.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MergedAnnotationsCollection.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MergedAnnotationsCollection.java:13"$0$" * See the License for the specific language governing permissions and"
"MergedAnnotationsCollection.java:14"$0$" * limitations under the License."
"MergedAnnotationsCollection.java:15"$0$" */"
"MergedAnnotationsCollection.java:16"$0$""
"MergedAnnotationsCollection.java:17"$0$"package org.springframework.core.annotation;"
"MergedAnnotationsCollection.java:18"$0$""
"MergedAnnotationsCollection.java:19"$0$"import java.lang.annotation.Annotation;"
"MergedAnnotationsCollection.java:20"$0$"import java.util.Collection;"
"MergedAnnotationsCollection.java:21"$0$"import java.util.Iterator;"
"MergedAnnotationsCollection.java:22"$0$"import java.util.Spliterator;"
"MergedAnnotationsCollection.java:23"$0$"import java.util.Spliterators;"
"MergedAnnotationsCollection.java:24"$0$"import java.util.function.Consumer;"
"MergedAnnotationsCollection.java:25"$0$"import java.util.function.Predicate;"
"MergedAnnotationsCollection.java:26"$0$"import java.util.stream.Stream;"
"MergedAnnotationsCollection.java:27"$0$"import java.util.stream.StreamSupport;"
"MergedAnnotationsCollection.java:28"$0$""
"MergedAnnotationsCollection.java:29"$0$"import org.springframework.lang.Nullable;"
"MergedAnnotationsCollection.java:30"$0$"import org.springframework.util.Assert;"
"MergedAnnotationsCollection.java:31"$0$""
"MergedAnnotationsCollection.java:32"$0$"/**"
"MergedAnnotationsCollection.java:33"$1$" * {@link MergedAnnotations} implementation backed by a {@link Collection} of"
"MergedAnnotationsCollection.java:34"$1$" * {@link MergedAnnotation} instances that represent direct annotations."
"MergedAnnotationsCollection.java:35"$0$" *"
"MergedAnnotationsCollection.java:36"$0$" * @author Phillip Webb"
"MergedAnnotationsCollection.java:37"$0$" * @since 5.2"
"MergedAnnotationsCollection.java:38"$0$" * @see MergedAnnotations#of(Collection)"
"MergedAnnotationsCollection.java:39"$0$" */"
"MergedAnnotationsCollection.java:40"$1$"final class MergedAnnotationsCollection implements MergedAnnotations {"
"MergedAnnotationsCollection.java:41"$1$""
"MergedAnnotationsCollection.java:42"$1$"	private final MergedAnnotation<?>[] annotations;"
"MergedAnnotationsCollection.java:43"$1$""
"MergedAnnotationsCollection.java:44"$1$"	private final AnnotationTypeMappings[] mappings;"
"MergedAnnotationsCollection.java:45"$1$""
"MergedAnnotationsCollection.java:46"$1$""
"MergedAnnotationsCollection.java:47"$1$"	private MergedAnnotationsCollection(Collection<MergedAnnotation<?>> annotations) {"
"MergedAnnotationsCollection.java:48"$1$"		Assert.notNull(annotations, ""Annotations must not be null"");"
"MergedAnnotationsCollection.java:49"$1$"		this.annotations = annotations.toArray(new MergedAnnotation<?>[0]);"
"MergedAnnotationsCollection.java:50"$1$"		this.mappings = new AnnotationTypeMappings[this.annotations.length];"
"MergedAnnotationsCollection.java:51"$1$"		for (int i = 0; i < this.annotations.length; i++) {"
"MergedAnnotationsCollection.java:52"$1$"			MergedAnnotation<?> annotation = this.annotations[i];"
"MergedAnnotationsCollection.java:53"$1$"			Assert.notNull(annotation, ""Annotation must not be null"");"
"MergedAnnotationsCollection.java:54"$1$"			Assert.isTrue(annotation.isDirectlyPresent(), ""Annotation must be directly present"");"
"MergedAnnotationsCollection.java:55"$1$"			Assert.isTrue(annotation.getAggregateIndex() == 0, ""Annotation must have aggregate index of zero"");"
"MergedAnnotationsCollection.java:56"$1$"			this.mappings[i] = AnnotationTypeMappings.forAnnotationType(annotation.getType());"
"MergedAnnotationsCollection.java:57"$1$"		}"
"MergedAnnotationsCollection.java:58"$0$"	}"
"MergedAnnotationsCollection.java:59"$0$""
"MergedAnnotationsCollection.java:60"$0$""
"MergedAnnotationsCollection.java:61"$0$"	@Override"
"MergedAnnotationsCollection.java:62"$1$"	public Iterator<MergedAnnotation<Annotation>> iterator() {"
"MergedAnnotationsCollection.java:63"$1$"		return Spliterators.iterator(spliterator());"
"MergedAnnotationsCollection.java:64"$1$"	}"
"MergedAnnotationsCollection.java:65"$0$""
"MergedAnnotationsCollection.java:66"$0$"	@Override"
"MergedAnnotationsCollection.java:67"$1$"	public Spliterator<MergedAnnotation<Annotation>> spliterator() {"
"MergedAnnotationsCollection.java:68"$1$"		return spliterator(null);"
"MergedAnnotationsCollection.java:69"$1$"	}"
"MergedAnnotationsCollection.java:70"$0$""
"MergedAnnotationsCollection.java:71"$1$"	private <A extends Annotation> Spliterator<MergedAnnotation<A>> spliterator(@Nullable Object annotationType) {"
"MergedAnnotationsCollection.java:72"$1$"		return new AnnotationsSpliterator<>(annotationType);"
"MergedAnnotationsCollection.java:73"$1$"	}"
"MergedAnnotationsCollection.java:74"$0$""
"MergedAnnotationsCollection.java:75"$0$"	@Override"
"MergedAnnotationsCollection.java:76"$1$"	public <A extends Annotation> boolean isPresent(Class<A> annotationType) {"
"MergedAnnotationsCollection.java:77"$1$"		return isPresent(annotationType, false);"
"MergedAnnotationsCollection.java:78"$1$"	}"
"MergedAnnotationsCollection.java:79"$0$""
"MergedAnnotationsCollection.java:80"$0$"	@Override"
"MergedAnnotationsCollection.java:81"$1$"	public boolean isPresent(String annotationType) {"
"MergedAnnotationsCollection.java:82"$1$"		return isPresent(annotationType, false);"
"MergedAnnotationsCollection.java:83"$1$"	}"
"MergedAnnotationsCollection.java:84"$0$""
"MergedAnnotationsCollection.java:85"$0$"	@Override"
"MergedAnnotationsCollection.java:86"$1$"	public <A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType) {"
"MergedAnnotationsCollection.java:87"$1$"		return isPresent(annotationType, true);"
"MergedAnnotationsCollection.java:88"$1$"	}"
"MergedAnnotationsCollection.java:89"$0$""
"MergedAnnotationsCollection.java:90"$0$"	@Override"
"MergedAnnotationsCollection.java:91"$1$"	public boolean isDirectlyPresent(String annotationType) {"
"MergedAnnotationsCollection.java:92"$1$"		return isPresent(annotationType, true);"
"MergedAnnotationsCollection.java:93"$1$"	}"
"MergedAnnotationsCollection.java:94"$0$""
"MergedAnnotationsCollection.java:95"$1$"	private boolean isPresent(Object requiredType, boolean directOnly) {"
"MergedAnnotationsCollection.java:96"$1$"		for (MergedAnnotation<?> annotation : this.annotations) {"
"MergedAnnotationsCollection.java:97"$1$"			Class<? extends Annotation> type = annotation.getType();"
"MergedAnnotationsCollection.java:98"$1$"			if (type == requiredType || type.getName().equals(requiredType)) {"
"MergedAnnotationsCollection.java:99"$1$"				return true;"
"MergedAnnotationsCollection.java:100"$1$"			}"
"MergedAnnotationsCollection.java:101"$0$"		}"
"MergedAnnotationsCollection.java:102"$1$"		if (!directOnly) {"
"MergedAnnotationsCollection.java:103"$1$"			for (AnnotationTypeMappings mappings : this.mappings) {"
"MergedAnnotationsCollection.java:104"$1$"				for (int i = 1; i < mappings.size(); i++) {"
"MergedAnnotationsCollection.java:105"$1$"					AnnotationTypeMapping mapping = mappings.get(i);"
"MergedAnnotationsCollection.java:106"$1$"					if (isMappingForType(mapping, requiredType)) {"
"MergedAnnotationsCollection.java:107"$1$"						return true;"
"MergedAnnotationsCollection.java:108"$1$"					}"
"MergedAnnotationsCollection.java:109"$0$"				}"
"MergedAnnotationsCollection.java:110"$0$"			}"
"MergedAnnotationsCollection.java:111"$0$"		}"
"MergedAnnotationsCollection.java:112"$0$"		return false;"
"MergedAnnotationsCollection.java:113"$0$"	}"
"MergedAnnotationsCollection.java:114"$0$""
"MergedAnnotationsCollection.java:115"$0$"	@Override"
"MergedAnnotationsCollection.java:116"$1$"	public <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType) {"
"MergedAnnotationsCollection.java:117"$1$"		return get(annotationType, null, null);"
"MergedAnnotationsCollection.java:118"$1$"	}"
"MergedAnnotationsCollection.java:119"$0$""
"MergedAnnotationsCollection.java:120"$0$"	@Override"
"MergedAnnotationsCollection.java:121"$0$"	public <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,"
"MergedAnnotationsCollection.java:122"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate) {"
"MergedAnnotationsCollection.java:123"$1$""
"MergedAnnotationsCollection.java:124"$1$"		return get(annotationType, predicate, null);"
"MergedAnnotationsCollection.java:125"$1$"	}"
"MergedAnnotationsCollection.java:126"$0$""
"MergedAnnotationsCollection.java:127"$0$"	@Override"
"MergedAnnotationsCollection.java:128"$0$"	public <A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,"
"MergedAnnotationsCollection.java:129"$0$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate,"
"MergedAnnotationsCollection.java:130"$1$"			@Nullable MergedAnnotationSelector<A> selector) {"
"MergedAnnotationsCollection.java:131"$1$""
"MergedAnnotationsCollection.java:132"$1$"		MergedAnnotation<A> result = find(annotationType, predicate, selector);"
"MergedAnnotationsCollection.java:133"$1$"		return (result != null ? result : MergedAnnotation.missing());"
"MergedAnnotationsCollection.java:134"$1$"	}"
"MergedAnnotationsCollection.java:135"$0$""
"MergedAnnotationsCollection.java:136"$0$"	@Override"
"MergedAnnotationsCollection.java:137"$1$"	public <A extends Annotation> MergedAnnotation<A> get(String annotationType) {"
"MergedAnnotationsCollection.java:138"$1$"		return get(annotationType, null, null);"
"MergedAnnotationsCollection.java:139"$1$"	}"
"MergedAnnotationsCollection.java:140"$0$""
"MergedAnnotationsCollection.java:141"$0$"	@Override"
"MergedAnnotationsCollection.java:142"$0$"	public <A extends Annotation> MergedAnnotation<A> get(String annotationType,"
"MergedAnnotationsCollection.java:143"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate) {"
"MergedAnnotationsCollection.java:144"$1$""
"MergedAnnotationsCollection.java:145"$1$"		return get(annotationType, predicate, null);"
"MergedAnnotationsCollection.java:146"$1$"	}"
"MergedAnnotationsCollection.java:147"$0$""
"MergedAnnotationsCollection.java:148"$0$"	@Override"
"MergedAnnotationsCollection.java:149"$0$"	public <A extends Annotation> MergedAnnotation<A> get(String annotationType,"
"MergedAnnotationsCollection.java:150"$0$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate,"
"MergedAnnotationsCollection.java:151"$1$"			@Nullable MergedAnnotationSelector<A> selector) {"
"MergedAnnotationsCollection.java:152"$1$""
"MergedAnnotationsCollection.java:153"$1$"		MergedAnnotation<A> result = find(annotationType, predicate, selector);"
"MergedAnnotationsCollection.java:154"$1$"		return (result != null ? result : MergedAnnotation.missing());"
"MergedAnnotationsCollection.java:155"$1$"	}"
"MergedAnnotationsCollection.java:156"$0$""
"MergedAnnotationsCollection.java:157"$0$"	@SuppressWarnings(""unchecked"")"
"MergedAnnotationsCollection.java:158"$0$"	@Nullable"
"MergedAnnotationsCollection.java:159"$0$"	private <A extends Annotation> MergedAnnotation<A> find(Object requiredType,"
"MergedAnnotationsCollection.java:160"$0$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate,"
"MergedAnnotationsCollection.java:161"$1$"			@Nullable MergedAnnotationSelector<A> selector) {"
"MergedAnnotationsCollection.java:162"$1$""
"MergedAnnotationsCollection.java:163"$1$"		if (selector == null) {"
"MergedAnnotationsCollection.java:164"$1$"			selector = MergedAnnotationSelectors.nearest();"
"MergedAnnotationsCollection.java:165"$1$"		}"
"MergedAnnotationsCollection.java:166"$0$""
"MergedAnnotationsCollection.java:167"$0$"		MergedAnnotation<A> result = null;"
"MergedAnnotationsCollection.java:168"$1$"		for (int i = 0; i < this.annotations.length; i++) {"
"MergedAnnotationsCollection.java:169"$1$"			MergedAnnotation<?> root = this.annotations[i];"
"MergedAnnotationsCollection.java:170"$1$"			AnnotationTypeMappings mappings = this.mappings[i];"
"MergedAnnotationsCollection.java:171"$1$"			for (int mappingIndex = 0; mappingIndex < mappings.size(); mappingIndex++) {"
"MergedAnnotationsCollection.java:172"$1$"				AnnotationTypeMapping mapping = mappings.get(mappingIndex);"
"MergedAnnotationsCollection.java:173"$1$"				if (!isMappingForType(mapping, requiredType)) {"
"MergedAnnotationsCollection.java:174"$1$"					continue;"
"MergedAnnotationsCollection.java:175"$1$"				}"
"MergedAnnotationsCollection.java:176"$0$"				MergedAnnotation<A> candidate = (mappingIndex == 0"
"MergedAnnotationsCollection.java:177"$0$"						? (MergedAnnotation<A>) root"
"MergedAnnotationsCollection.java:178"$0$"						: TypeMappedAnnotation.createIfPossible(mapping, root, IntrospectionFailureLogger.INFO));"
"MergedAnnotationsCollection.java:179"$1$"				if (candidate != null && (predicate == null || predicate.test(candidate))) {"
"MergedAnnotationsCollection.java:180"$1$"					if (selector.isBestCandidate(candidate)) {"
"MergedAnnotationsCollection.java:181"$1$"						return candidate;"
"MergedAnnotationsCollection.java:182"$1$"					}"
"MergedAnnotationsCollection.java:183"$0$"					result = (result != null ? selector.select(result, candidate) : candidate);"
"MergedAnnotationsCollection.java:184"$0$"				}"
"MergedAnnotationsCollection.java:185"$0$"			}"
"MergedAnnotationsCollection.java:186"$0$"		}"
"MergedAnnotationsCollection.java:187"$0$"		return result;"
"MergedAnnotationsCollection.java:188"$0$"	}"
"MergedAnnotationsCollection.java:189"$0$""
"MergedAnnotationsCollection.java:190"$0$"	@Override"
"MergedAnnotationsCollection.java:191"$1$"	public <A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType) {"
"MergedAnnotationsCollection.java:192"$1$"		return StreamSupport.stream(spliterator(annotationType), false);"
"MergedAnnotationsCollection.java:193"$1$"	}"
"MergedAnnotationsCollection.java:194"$0$""
"MergedAnnotationsCollection.java:195"$0$"	@Override"
"MergedAnnotationsCollection.java:196"$1$"	public <A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType) {"
"MergedAnnotationsCollection.java:197"$1$"		return StreamSupport.stream(spliterator(annotationType), false);"
"MergedAnnotationsCollection.java:198"$1$"	}"
"MergedAnnotationsCollection.java:199"$0$""
"MergedAnnotationsCollection.java:200"$0$"	@Override"
"MergedAnnotationsCollection.java:201"$1$"	public Stream<MergedAnnotation<Annotation>> stream() {"
"MergedAnnotationsCollection.java:202"$1$"		return StreamSupport.stream(spliterator(), false);"
"MergedAnnotationsCollection.java:203"$1$"	}"
"MergedAnnotationsCollection.java:204"$0$""
"MergedAnnotationsCollection.java:205"$1$"	private static boolean isMappingForType(AnnotationTypeMapping mapping, @Nullable Object requiredType) {"
"MergedAnnotationsCollection.java:206"$1$"		if (requiredType == null) {"
"MergedAnnotationsCollection.java:207"$1$"			return true;"
"MergedAnnotationsCollection.java:208"$1$"		}"
"MergedAnnotationsCollection.java:209"$0$"		Class<? extends Annotation> actualType = mapping.getAnnotationType();"
"MergedAnnotationsCollection.java:210"$0$"		return (actualType == requiredType || actualType.getName().equals(requiredType));"
"MergedAnnotationsCollection.java:211"$0$"	}"
"MergedAnnotationsCollection.java:212"$0$""
"MergedAnnotationsCollection.java:213"$1$"	static MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {"
"MergedAnnotationsCollection.java:214"$1$"		Assert.notNull(annotations, ""Annotations must not be null"");"
"MergedAnnotationsCollection.java:215"$1$"		if (annotations.isEmpty()) {"
"MergedAnnotationsCollection.java:216"$1$"			return TypeMappedAnnotations.NONE;"
"MergedAnnotationsCollection.java:217"$1$"		}"
"MergedAnnotationsCollection.java:218"$0$"		return new MergedAnnotationsCollection(annotations);"
"MergedAnnotationsCollection.java:219"$0$"	}"
"MergedAnnotationsCollection.java:220"$0$""
"MergedAnnotationsCollection.java:221"$0$""
"MergedAnnotationsCollection.java:222"$1$"	private class AnnotationsSpliterator<A extends Annotation> implements Spliterator<MergedAnnotation<A>> {"
"MergedAnnotationsCollection.java:223"$1$""
"MergedAnnotationsCollection.java:224"$1$"		@Nullable"
"MergedAnnotationsCollection.java:225"$1$"		private Object requiredType;"
"MergedAnnotationsCollection.java:226"$1$""
"MergedAnnotationsCollection.java:227"$1$"		private final int[] mappingCursors;"
"MergedAnnotationsCollection.java:228"$1$""
"MergedAnnotationsCollection.java:229"$1$"		public AnnotationsSpliterator(@Nullable Object requiredType) {"
"MergedAnnotationsCollection.java:230"$1$"			this.mappingCursors = new int[annotations.length];"
"MergedAnnotationsCollection.java:231"$1$"			this.requiredType = requiredType;"
"MergedAnnotationsCollection.java:232"$1$"		}"
"MergedAnnotationsCollection.java:233"$0$""
"MergedAnnotationsCollection.java:234"$0$"		@Override"
"MergedAnnotationsCollection.java:235"$1$"		public boolean tryAdvance(Consumer<? super MergedAnnotation<A>> action) {"
"MergedAnnotationsCollection.java:236"$1$"			int lowestDistance = Integer.MAX_VALUE;"
"MergedAnnotationsCollection.java:237"$1$"			int annotationResult = -1;"
"MergedAnnotationsCollection.java:238"$1$"			for (int annotationIndex = 0; annotationIndex < annotations.length; annotationIndex++) {"
"MergedAnnotationsCollection.java:239"$1$"				AnnotationTypeMapping mapping = getNextSuitableMapping(annotationIndex);"
"MergedAnnotationsCollection.java:240"$1$"				if (mapping != null && mapping.getDistance() < lowestDistance) {"
"MergedAnnotationsCollection.java:241"$1$"					annotationResult = annotationIndex;"
"MergedAnnotationsCollection.java:242"$1$"					lowestDistance = mapping.getDistance();"
"MergedAnnotationsCollection.java:243"$1$"				}"
"MergedAnnotationsCollection.java:244"$1$"				if (lowestDistance == 0) {"
"MergedAnnotationsCollection.java:245"$1$"					break;"
"MergedAnnotationsCollection.java:246"$1$"				}"
"MergedAnnotationsCollection.java:247"$0$"			}"
"MergedAnnotationsCollection.java:248"$1$"			if (annotationResult != -1) {"
"MergedAnnotationsCollection.java:249"$1$"				MergedAnnotation<A> mergedAnnotation = createMergedAnnotationIfPossible("
"MergedAnnotationsCollection.java:250"$1$"						annotationResult, this.mappingCursors[annotationResult]);"
"MergedAnnotationsCollection.java:251"$1$"				this.mappingCursors[annotationResult]++;"
"MergedAnnotationsCollection.java:252"$1$"				if (mergedAnnotation == null) {"
"MergedAnnotationsCollection.java:253"$1$"					return tryAdvance(action);"
"MergedAnnotationsCollection.java:254"$1$"				}"
"MergedAnnotationsCollection.java:255"$0$"				action.accept(mergedAnnotation);"
"MergedAnnotationsCollection.java:256"$0$"				return true;"
"MergedAnnotationsCollection.java:257"$0$"			}"
"MergedAnnotationsCollection.java:258"$0$"			return false;"
"MergedAnnotationsCollection.java:259"$0$"		}"
"MergedAnnotationsCollection.java:260"$0$""
"MergedAnnotationsCollection.java:261"$0$"		@Nullable"
"MergedAnnotationsCollection.java:262"$1$"		private AnnotationTypeMapping getNextSuitableMapping(int annotationIndex) {"
"MergedAnnotationsCollection.java:263"$1$"			AnnotationTypeMapping mapping;"
"MergedAnnotationsCollection.java:264"$1$"			do {"
"MergedAnnotationsCollection.java:265"$1$"				mapping = getMapping(annotationIndex, this.mappingCursors[annotationIndex]);"
"MergedAnnotationsCollection.java:266"$1$"				if (mapping != null && isMappingForType(mapping, this.requiredType)) {"
"MergedAnnotationsCollection.java:267"$1$"					return mapping;"
"MergedAnnotationsCollection.java:268"$1$"				}"
"MergedAnnotationsCollection.java:269"$0$"				this.mappingCursors[annotationIndex]++;"
"MergedAnnotationsCollection.java:270"$0$"			}"
"MergedAnnotationsCollection.java:271"$0$"			while (mapping != null);"
"MergedAnnotationsCollection.java:272"$0$"			return null;"
"MergedAnnotationsCollection.java:273"$0$"		}"
"MergedAnnotationsCollection.java:274"$0$""
"MergedAnnotationsCollection.java:275"$0$"		@Nullable"
"MergedAnnotationsCollection.java:276"$1$"		private AnnotationTypeMapping getMapping(int annotationIndex, int mappingIndex) {"
"MergedAnnotationsCollection.java:277"$1$"			AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[annotationIndex];"
"MergedAnnotationsCollection.java:278"$1$"			return (mappingIndex < mappings.size() ? mappings.get(mappingIndex) : null);"
"MergedAnnotationsCollection.java:279"$1$"		}"
"MergedAnnotationsCollection.java:280"$0$""
"MergedAnnotationsCollection.java:281"$0$"		@Nullable"
"MergedAnnotationsCollection.java:282"$0$"		@SuppressWarnings(""unchecked"")"
"MergedAnnotationsCollection.java:283"$1$"		private MergedAnnotation<A> createMergedAnnotationIfPossible(int annotationIndex, int mappingIndex) {"
"MergedAnnotationsCollection.java:284"$1$"			MergedAnnotation<?> root = annotations[annotationIndex];"
"MergedAnnotationsCollection.java:285"$1$"			if (mappingIndex == 0) {"
"MergedAnnotationsCollection.java:286"$1$"				return (MergedAnnotation<A>) root;"
"MergedAnnotationsCollection.java:287"$1$"			}"
"MergedAnnotationsCollection.java:288"$0$"			IntrospectionFailureLogger logger = (this.requiredType != null ?"
"MergedAnnotationsCollection.java:289"$0$"					IntrospectionFailureLogger.INFO : IntrospectionFailureLogger.DEBUG);"
"MergedAnnotationsCollection.java:290"$0$"			return TypeMappedAnnotation.createIfPossible("
"MergedAnnotationsCollection.java:291"$0$"					mappings[annotationIndex].get(mappingIndex), root, logger);"
"MergedAnnotationsCollection.java:292"$0$"		}"
"MergedAnnotationsCollection.java:293"$0$""
"MergedAnnotationsCollection.java:294"$0$"		@Override"
"MergedAnnotationsCollection.java:295"$0$"		@Nullable"
"MergedAnnotationsCollection.java:296"$1$"		public Spliterator<MergedAnnotation<A>> trySplit() {"
"MergedAnnotationsCollection.java:297"$1$"			return null;"
"MergedAnnotationsCollection.java:298"$1$"		}"
"MergedAnnotationsCollection.java:299"$0$""
"MergedAnnotationsCollection.java:300"$0$"		@Override"
"MergedAnnotationsCollection.java:301"$1$"		public long estimateSize() {"
"MergedAnnotationsCollection.java:302"$1$"			int size = 0;"
"MergedAnnotationsCollection.java:303"$1$"			for (int i = 0; i < annotations.length; i++) {"
"MergedAnnotationsCollection.java:304"$1$"				AnnotationTypeMappings mappings = MergedAnnotationsCollection.this.mappings[i];"
"MergedAnnotationsCollection.java:305"$1$"				int numberOfMappings = mappings.size();"
"MergedAnnotationsCollection.java:306"$1$"				numberOfMappings -= Math.min(this.mappingCursors[i], mappings.size());"
"MergedAnnotationsCollection.java:307"$1$"				size += numberOfMappings;"
"MergedAnnotationsCollection.java:308"$1$"			}"
"MergedAnnotationsCollection.java:309"$0$"			return size;"
"MergedAnnotationsCollection.java:310"$0$"		}"
"MergedAnnotationsCollection.java:311"$0$""
"MergedAnnotationsCollection.java:312"$0$"		@Override"
"MergedAnnotationsCollection.java:313"$1$"		public int characteristics() {"
"MergedAnnotationsCollection.java:314"$1$"			return NONNULL | IMMUTABLE;"
"MergedAnnotationsCollection.java:315"$1$"		}"
"MergedAnnotationsCollection.java:316"$0$"	}"
"MergedAnnotationsCollection.java:317"$0$""
"MergedAnnotationsCollection.java:318"$0$"}"
"MethodMetadataReadingVisitor.java:1"$0$"/*"
"MethodMetadataReadingVisitor.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"MethodMetadataReadingVisitor.java:3"$0$" *"
"MethodMetadataReadingVisitor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MethodMetadataReadingVisitor.java:5"$0$" * you may not use this file except in compliance with the License."
"MethodMetadataReadingVisitor.java:6"$0$" * You may obtain a copy of the License at"
"MethodMetadataReadingVisitor.java:7"$0$" *"
"MethodMetadataReadingVisitor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MethodMetadataReadingVisitor.java:9"$0$" *"
"MethodMetadataReadingVisitor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MethodMetadataReadingVisitor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MethodMetadataReadingVisitor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MethodMetadataReadingVisitor.java:13"$0$" * See the License for the specific language governing permissions and"
"MethodMetadataReadingVisitor.java:14"$0$" * limitations under the License."
"MethodMetadataReadingVisitor.java:15"$0$" */"
"MethodMetadataReadingVisitor.java:16"$0$""
"MethodMetadataReadingVisitor.java:17"$0$"package org.springframework.core.type.classreading;"
"MethodMetadataReadingVisitor.java:18"$0$""
"MethodMetadataReadingVisitor.java:19"$0$"import java.util.LinkedHashMap;"
"MethodMetadataReadingVisitor.java:20"$0$"import java.util.List;"
"MethodMetadataReadingVisitor.java:21"$0$"import java.util.Map;"
"MethodMetadataReadingVisitor.java:22"$0$"import java.util.Set;"
"MethodMetadataReadingVisitor.java:23"$0$""
"MethodMetadataReadingVisitor.java:24"$0$"import org.springframework.asm.AnnotationVisitor;"
"MethodMetadataReadingVisitor.java:25"$0$"import org.springframework.asm.MethodVisitor;"
"MethodMetadataReadingVisitor.java:26"$0$"import org.springframework.asm.Opcodes;"
"MethodMetadataReadingVisitor.java:27"$0$"import org.springframework.asm.SpringAsmInfo;"
"MethodMetadataReadingVisitor.java:28"$0$"import org.springframework.asm.Type;"
"MethodMetadataReadingVisitor.java:29"$0$"import org.springframework.core.annotation.AnnotationAttributes;"
"MethodMetadataReadingVisitor.java:30"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"MethodMetadataReadingVisitor.java:31"$0$"import org.springframework.core.type.MethodMetadata;"
"MethodMetadataReadingVisitor.java:32"$0$"import org.springframework.lang.Nullable;"
"MethodMetadataReadingVisitor.java:33"$0$"import org.springframework.util.LinkedMultiValueMap;"
"MethodMetadataReadingVisitor.java:34"$0$"import org.springframework.util.MultiValueMap;"
"MethodMetadataReadingVisitor.java:35"$0$""
"MethodMetadataReadingVisitor.java:36"$0$"/**"
"MethodMetadataReadingVisitor.java:37"$0$" * ASM method visitor which looks for the annotations defined on a method,"
"MethodMetadataReadingVisitor.java:38"$1$" * exposing them through the {@link org.springframework.core.type.MethodMetadata}"
"MethodMetadataReadingVisitor.java:39"$0$" * interface."
"MethodMetadataReadingVisitor.java:40"$0$" *"
"MethodMetadataReadingVisitor.java:41"$0$" * @author Juergen Hoeller"
"MethodMetadataReadingVisitor.java:42"$0$" * @author Mark Pollack"
"MethodMetadataReadingVisitor.java:43"$0$" * @author Costin Leau"
"MethodMetadataReadingVisitor.java:44"$0$" * @author Chris Beams"
"MethodMetadataReadingVisitor.java:45"$0$" * @author Phillip Webb"
"MethodMetadataReadingVisitor.java:46"$0$" * @since 3.0"
"MethodMetadataReadingVisitor.java:47"$0$" * @deprecated As of Spring Framework 5.2, this class and related classes in this"
"MethodMetadataReadingVisitor.java:48"$1$" * package have been replaced by {@link SimpleAnnotationMetadataReadingVisitor}"
"MethodMetadataReadingVisitor.java:49"$0$" * and related classes for internal use within the framework."
"MethodMetadataReadingVisitor.java:50"$0$" */"
"MethodMetadataReadingVisitor.java:51"$0$"Deprecated"
"MethodMetadataReadingVisitor.java:52"$1$"public class MethodMetadataReadingVisitor extends MethodVisitor implements MethodMetadata {"
"MethodMetadataReadingVisitor.java:53"$1$""
"MethodMetadataReadingVisitor.java:54"$1$"	protected final String methodName;"
"MethodMetadataReadingVisitor.java:55"$1$""
"MethodMetadataReadingVisitor.java:56"$1$"	protected final int access;"
"MethodMetadataReadingVisitor.java:57"$1$""
"MethodMetadataReadingVisitor.java:58"$1$"	protected final String declaringClassName;"
"MethodMetadataReadingVisitor.java:59"$1$""
"MethodMetadataReadingVisitor.java:60"$1$"	protected final String returnTypeName;"
"MethodMetadataReadingVisitor.java:61"$1$""
"MethodMetadataReadingVisitor.java:62"$1$"	@Nullable"
"MethodMetadataReadingVisitor.java:63"$1$"	protected final ClassLoader classLoader;"
"MethodMetadataReadingVisitor.java:64"$1$""
"MethodMetadataReadingVisitor.java:65"$1$"	protected final Set<MethodMetadata> methodMetadataSet;"
"MethodMetadataReadingVisitor.java:66"$1$""
"MethodMetadataReadingVisitor.java:67"$1$"	protected final Map<String, Set<String>> metaAnnotationMap = new LinkedHashMap<>(4);"
"MethodMetadataReadingVisitor.java:68"$1$""
"MethodMetadataReadingVisitor.java:69"$1$"	protected final LinkedMultiValueMap<String, AnnotationAttributes> attributesMap = new LinkedMultiValueMap<>(4);"
"MethodMetadataReadingVisitor.java:70"$1$""
"MethodMetadataReadingVisitor.java:71"$1$""
"MethodMetadataReadingVisitor.java:72"$1$"	public MethodMetadataReadingVisitor(String methodName, int access, String declaringClassName,"
"MethodMetadataReadingVisitor.java:73"$1$"			String returnTypeName, @Nullable ClassLoader classLoader, Set<MethodMetadata> methodMetadataSet) {"
"MethodMetadataReadingVisitor.java:74"$1$""
"MethodMetadataReadingVisitor.java:75"$1$"		super(SpringAsmInfo.ASM_VERSION);"
"MethodMetadataReadingVisitor.java:76"$1$"		this.methodName = methodName;"
"MethodMetadataReadingVisitor.java:77"$1$"		this.access = access;"
"MethodMetadataReadingVisitor.java:78"$1$"		this.declaringClassName = declaringClassName;"
"MethodMetadataReadingVisitor.java:79"$1$"		this.returnTypeName = returnTypeName;"
"MethodMetadataReadingVisitor.java:80"$1$"		this.classLoader = classLoader;"
"MethodMetadataReadingVisitor.java:81"$1$"		this.methodMetadataSet = methodMetadataSet;"
"MethodMetadataReadingVisitor.java:82"$1$"	}"
"MethodMetadataReadingVisitor.java:83"$0$""
"MethodMetadataReadingVisitor.java:84"$0$""
"MethodMetadataReadingVisitor.java:85"$0$"	@Override"
"MethodMetadataReadingVisitor.java:86"$1$"	public MergedAnnotations getAnnotations() {"
"MethodMetadataReadingVisitor.java:87"$1$"		throw new UnsupportedOperationException();"
"MethodMetadataReadingVisitor.java:88"$1$"	}"
"MethodMetadataReadingVisitor.java:89"$0$""
"MethodMetadataReadingVisitor.java:90"$0$"	@Override"
"MethodMetadataReadingVisitor.java:91"$0$"	@Nullable"
"MethodMetadataReadingVisitor.java:92"$1$"	public AnnotationVisitor visitAnnotation(final String desc, boolean visible) {"
"MethodMetadataReadingVisitor.java:93"$1$"		if (!visible) {"
"MethodMetadataReadingVisitor.java:94"$1$"			return null;"
"MethodMetadataReadingVisitor.java:95"$1$"		}"
"MethodMetadataReadingVisitor.java:96"$0$"		this.methodMetadataSet.add(this);"
"MethodMetadataReadingVisitor.java:97"$0$"		String className = Type.getType(desc).getClassName();"
"MethodMetadataReadingVisitor.java:98"$0$"		return new AnnotationAttributesReadingVisitor("
"MethodMetadataReadingVisitor.java:99"$0$"				className, this.attributesMap, this.metaAnnotationMap, this.classLoader);"
"MethodMetadataReadingVisitor.java:100"$0$"	}"
"MethodMetadataReadingVisitor.java:101"$0$""
"MethodMetadataReadingVisitor.java:102"$0$""
"MethodMetadataReadingVisitor.java:103"$0$"	@Override"
"MethodMetadataReadingVisitor.java:104"$1$"	public String getMethodName() {"
"MethodMetadataReadingVisitor.java:105"$1$"		return this.methodName;"
"MethodMetadataReadingVisitor.java:106"$1$"	}"
"MethodMetadataReadingVisitor.java:107"$0$""
"MethodMetadataReadingVisitor.java:108"$0$"	@Override"
"MethodMetadataReadingVisitor.java:109"$1$"	public boolean isAbstract() {"
"MethodMetadataReadingVisitor.java:110"$1$"		return ((this.access & Opcodes.ACC_ABSTRACT) != 0);"
"MethodMetadataReadingVisitor.java:111"$1$"	}"
"MethodMetadataReadingVisitor.java:112"$0$""
"MethodMetadataReadingVisitor.java:113"$0$"	@Override"
"MethodMetadataReadingVisitor.java:114"$1$"	public boolean isStatic() {"
"MethodMetadataReadingVisitor.java:115"$1$"		return ((this.access & Opcodes.ACC_STATIC) != 0);"
"MethodMetadataReadingVisitor.java:116"$1$"	}"
"MethodMetadataReadingVisitor.java:117"$0$""
"MethodMetadataReadingVisitor.java:118"$0$"	@Override"
"MethodMetadataReadingVisitor.java:119"$1$"	public boolean isFinal() {"
"MethodMetadataReadingVisitor.java:120"$1$"		return ((this.access & Opcodes.ACC_FINAL) != 0);"
"MethodMetadataReadingVisitor.java:121"$1$"	}"
"MethodMetadataReadingVisitor.java:122"$0$""
"MethodMetadataReadingVisitor.java:123"$0$"	@Override"
"MethodMetadataReadingVisitor.java:124"$1$"	public boolean isOverridable() {"
"MethodMetadataReadingVisitor.java:125"$1$"		return (!isStatic() && !isFinal() && ((this.access & Opcodes.ACC_PRIVATE) == 0));"
"MethodMetadataReadingVisitor.java:126"$1$"	}"
"MethodMetadataReadingVisitor.java:127"$0$""
"MethodMetadataReadingVisitor.java:128"$0$"	@Override"
"MethodMetadataReadingVisitor.java:129"$1$"	public boolean isAnnotated(String annotationName) {"
"MethodMetadataReadingVisitor.java:130"$1$"		return this.attributesMap.containsKey(annotationName);"
"MethodMetadataReadingVisitor.java:131"$1$"	}"
"MethodMetadataReadingVisitor.java:132"$0$""
"MethodMetadataReadingVisitor.java:133"$0$"	@Override"
"MethodMetadataReadingVisitor.java:134"$0$"	@Nullable"
"MethodMetadataReadingVisitor.java:135"$1$"	public AnnotationAttributes getAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"MethodMetadataReadingVisitor.java:136"$1$"		AnnotationAttributes raw = AnnotationReadingVisitorUtils.getMergedAnnotationAttributes("
"MethodMetadataReadingVisitor.java:137"$1$"				this.attributesMap, this.metaAnnotationMap, annotationName);"
"MethodMetadataReadingVisitor.java:138"$1$"		if (raw == null) {"
"MethodMetadataReadingVisitor.java:139"$1$"			return null;"
"MethodMetadataReadingVisitor.java:140"$1$"		}"
"MethodMetadataReadingVisitor.java:141"$0$"		return AnnotationReadingVisitorUtils.convertClassValues("
"MethodMetadataReadingVisitor.java:142"$0$"				""method '"" + getMethodName() + ""'"", this.classLoader, raw, classValuesAsString);"
"MethodMetadataReadingVisitor.java:143"$0$"	}"
"MethodMetadataReadingVisitor.java:144"$0$""
"MethodMetadataReadingVisitor.java:145"$0$"	@Override"
"MethodMetadataReadingVisitor.java:146"$0$"	@Nullable"
"MethodMetadataReadingVisitor.java:147"$1$"	public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"MethodMetadataReadingVisitor.java:148"$1$"		if (!this.attributesMap.containsKey(annotationName)) {"
"MethodMetadataReadingVisitor.java:149"$1$"			return null;"
"MethodMetadataReadingVisitor.java:150"$1$"		}"
"MethodMetadataReadingVisitor.java:151"$0$"		MultiValueMap<String, Object> allAttributes = new LinkedMultiValueMap<>();"
"MethodMetadataReadingVisitor.java:152"$0$"		List<AnnotationAttributes> attributesList = this.attributesMap.get(annotationName);"
"MethodMetadataReadingVisitor.java:153"$1$"		if (attributesList != null) {"
"MethodMetadataReadingVisitor.java:154"$1$"			String annotatedElement = ""method '"" + getMethodName() + '\'';"
"MethodMetadataReadingVisitor.java:155"$1$"			for (AnnotationAttributes annotationAttributes : attributesList) {"
"MethodMetadataReadingVisitor.java:156"$1$"				AnnotationAttributes convertedAttributes = AnnotationReadingVisitorUtils.convertClassValues("
"MethodMetadataReadingVisitor.java:157"$1$"						annotatedElement, this.classLoader, annotationAttributes, classValuesAsString);"
"MethodMetadataReadingVisitor.java:158"$1$"				convertedAttributes.forEach(allAttributes::add);"
"MethodMetadataReadingVisitor.java:159"$1$"			}"
"MethodMetadataReadingVisitor.java:160"$0$"		}"
"MethodMetadataReadingVisitor.java:161"$0$"		return allAttributes;"
"MethodMetadataReadingVisitor.java:162"$0$"	}"
"MethodMetadataReadingVisitor.java:163"$0$""
"MethodMetadataReadingVisitor.java:164"$0$"	@Override"
"MethodMetadataReadingVisitor.java:165"$1$"	public String getDeclaringClassName() {"
"MethodMetadataReadingVisitor.java:166"$1$"		return this.declaringClassName;"
"MethodMetadataReadingVisitor.java:167"$1$"	}"
"MethodMetadataReadingVisitor.java:168"$0$""
"MethodMetadataReadingVisitor.java:169"$0$"	@Override"
"MethodMetadataReadingVisitor.java:170"$1$"	public String getReturnTypeName() {"
"MethodMetadataReadingVisitor.java:171"$1$"		return this.returnTypeName;"
"MethodMetadataReadingVisitor.java:172"$1$"	}"
"MethodMetadataReadingVisitor.java:173"$0$""
"MethodMetadataReadingVisitor.java:174"$0$"}"
"SimpleAliasRegistry.java:1"$0$"/*"
"SimpleAliasRegistry.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"SimpleAliasRegistry.java:3"$0$" *"
"SimpleAliasRegistry.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleAliasRegistry.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleAliasRegistry.java:6"$0$" * You may obtain a copy of the License at"
"SimpleAliasRegistry.java:7"$0$" *"
"SimpleAliasRegistry.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleAliasRegistry.java:9"$0$" *"
"SimpleAliasRegistry.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleAliasRegistry.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleAliasRegistry.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleAliasRegistry.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleAliasRegistry.java:14"$0$" * limitations under the License."
"SimpleAliasRegistry.java:15"$0$" */"
"SimpleAliasRegistry.java:16"$0$""
"SimpleAliasRegistry.java:17"$0$"package org.springframework.core;"
"SimpleAliasRegistry.java:18"$0$""
"SimpleAliasRegistry.java:19"$0$"import java.util.ArrayList;"
"SimpleAliasRegistry.java:20"$0$"import java.util.HashMap;"
"SimpleAliasRegistry.java:21"$0$"import java.util.List;"
"SimpleAliasRegistry.java:22"$0$"import java.util.Map;"
"SimpleAliasRegistry.java:23"$0$"import java.util.concurrent.ConcurrentHashMap;"
"SimpleAliasRegistry.java:24"$0$""
"SimpleAliasRegistry.java:25"$0$"import org.apache.commons.logging.Log;"
"SimpleAliasRegistry.java:26"$0$"import org.apache.commons.logging.LogFactory;"
"SimpleAliasRegistry.java:27"$0$""
"SimpleAliasRegistry.java:28"$0$"import org.springframework.util.Assert;"
"SimpleAliasRegistry.java:29"$0$"import org.springframework.util.ObjectUtils;"
"SimpleAliasRegistry.java:30"$0$"import org.springframework.util.StringUtils;"
"SimpleAliasRegistry.java:31"$0$"import org.springframework.util.StringValueResolver;"
"SimpleAliasRegistry.java:32"$0$""
"SimpleAliasRegistry.java:33"$0$"/**"
"SimpleAliasRegistry.java:34"$1$" * Simple implementation of the {@link AliasRegistry} interface."
"SimpleAliasRegistry.java:35"$0$" * <p>Serves as base class for"
"SimpleAliasRegistry.java:36"$1$" * {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}"
"SimpleAliasRegistry.java:37"$0$" * implementations."
"SimpleAliasRegistry.java:38"$0$" *"
"SimpleAliasRegistry.java:39"$0$" * @author Juergen Hoeller"
"SimpleAliasRegistry.java:40"$0$" * @author Qimiao Chen"
"SimpleAliasRegistry.java:41"$0$" * @since 2.5.2"
"SimpleAliasRegistry.java:42"$0$" */"
"SimpleAliasRegistry.java:43"$1$"public class SimpleAliasRegistry implements AliasRegistry {"
"SimpleAliasRegistry.java:44"$1$""
"SimpleAliasRegistry.java:45"$1$"	/** Logger available to subclasses. */"
"SimpleAliasRegistry.java:46"$1$"	protected final Log logger = LogFactory.getLog(getClass());"
"SimpleAliasRegistry.java:47"$1$""
"SimpleAliasRegistry.java:48"$1$"	/** Map from alias to canonical name. */"
"SimpleAliasRegistry.java:49"$1$"	private final Map<String, String> aliasMap = new ConcurrentHashMap<>(16);"
"SimpleAliasRegistry.java:50"$1$""
"SimpleAliasRegistry.java:51"$1$""
"SimpleAliasRegistry.java:52"$1$"	@Override"
"SimpleAliasRegistry.java:53"$1$"	public void registerAlias(String name, String alias) {"
"SimpleAliasRegistry.java:54"$1$"		Assert.hasText(name, ""'name' must not be empty"");"
"SimpleAliasRegistry.java:55"$1$"		Assert.hasText(alias, ""'alias' must not be empty"");"
"SimpleAliasRegistry.java:56"$1$"		synchronized (this.aliasMap) {"
"SimpleAliasRegistry.java:57"$1$"			if (alias.equals(name)) {"
"SimpleAliasRegistry.java:58"$1$"				this.aliasMap.remove(alias);"
"SimpleAliasRegistry.java:59"$1$"				if (logger.isDebugEnabled()) {"
"SimpleAliasRegistry.java:60"$1$"					logger.debug(""Alias definition '"" + alias + ""' ignored since it points to same name"");"
"SimpleAliasRegistry.java:61"$1$"				}"
"SimpleAliasRegistry.java:62"$0$"			}"
"SimpleAliasRegistry.java:63"$1$"			else {"
"SimpleAliasRegistry.java:64"$1$"				String registeredName = this.aliasMap.get(alias);"
"SimpleAliasRegistry.java:65"$1$"				if (registeredName != null) {"
"SimpleAliasRegistry.java:66"$1$"					if (registeredName.equals(name)) {"
"SimpleAliasRegistry.java:67"$0$"						// An existing alias - no need to re-register"
"SimpleAliasRegistry.java:68"$1$"						return;"
"SimpleAliasRegistry.java:69"$1$"					}"
"SimpleAliasRegistry.java:70"$1$"					if (!allowAliasOverriding()) {"
"SimpleAliasRegistry.java:71"$1$"						throw new IllegalStateException(""Cannot define alias '"" + alias + ""' for name '"" +"
"SimpleAliasRegistry.java:72"$1$"								name + ""': It is already registered for name '"" + registeredName + ""'."");"
"SimpleAliasRegistry.java:73"$1$"					}"
"SimpleAliasRegistry.java:74"$1$"					if (logger.isDebugEnabled()) {"
"SimpleAliasRegistry.java:75"$1$"						logger.debug(""Overriding alias '"" + alias + ""' definition for registered name '"" +"
"SimpleAliasRegistry.java:76"$1$"								registeredName + ""' with new target name '"" + name + ""'"");"
"SimpleAliasRegistry.java:77"$1$"					}"
"SimpleAliasRegistry.java:78"$0$"				}"
"SimpleAliasRegistry.java:79"$0$"				checkForAliasCircle(name, alias);"
"SimpleAliasRegistry.java:80"$0$"				this.aliasMap.put(alias, name);"
"SimpleAliasRegistry.java:81"$1$"				if (logger.isTraceEnabled()) {"
"SimpleAliasRegistry.java:82"$1$"					logger.trace(""Alias definition '"" + alias + ""' registered for name '"" + name + ""'"");"
"SimpleAliasRegistry.java:83"$1$"				}"
"SimpleAliasRegistry.java:84"$0$"			}"
"SimpleAliasRegistry.java:85"$0$"		}"
"SimpleAliasRegistry.java:86"$0$"	}"
"SimpleAliasRegistry.java:87"$0$""
"SimpleAliasRegistry.java:88"$0$"	/**"
"SimpleAliasRegistry.java:89"$0$"	 * Determine whether alias overriding is allowed."
"SimpleAliasRegistry.java:90"$1$"	 * <p>Default is {@code true}."
"SimpleAliasRegistry.java:91"$0$"	 */"
"SimpleAliasRegistry.java:92"$1$"	protected boolean allowAliasOverriding() {"
"SimpleAliasRegistry.java:93"$1$"		return true;"
"SimpleAliasRegistry.java:94"$1$"	}"
"SimpleAliasRegistry.java:95"$0$""
"SimpleAliasRegistry.java:96"$0$"	/**"
"SimpleAliasRegistry.java:97"$0$"	 * Determine whether the given name has the given alias registered."
"SimpleAliasRegistry.java:98"$0$"	 * @param name the name to check"
"SimpleAliasRegistry.java:99"$0$"	 * @param alias the alias to look for"
"SimpleAliasRegistry.java:100"$0$"	 * @since 4.2.1"
"SimpleAliasRegistry.java:101"$0$"	 */"
"SimpleAliasRegistry.java:102"$1$"	public boolean hasAlias(String name, String alias) {"
"SimpleAliasRegistry.java:103"$1$"		String registeredName = this.aliasMap.get(alias);"
"SimpleAliasRegistry.java:104"$1$"		return ObjectUtils.nullSafeEquals(registeredName, name) || (registeredName != null"
"SimpleAliasRegistry.java:105"$1$"				&& hasAlias(name, registeredName));"
"SimpleAliasRegistry.java:106"$1$"	}"
"SimpleAliasRegistry.java:107"$0$""
"SimpleAliasRegistry.java:108"$0$"	@Override"
"SimpleAliasRegistry.java:109"$1$"	public void removeAlias(String alias) {"
"SimpleAliasRegistry.java:110"$1$"		synchronized (this.aliasMap) {"
"SimpleAliasRegistry.java:111"$1$"			String name = this.aliasMap.remove(alias);"
"SimpleAliasRegistry.java:112"$1$"			if (name == null) {"
"SimpleAliasRegistry.java:113"$1$"				throw new IllegalStateException(""No alias '"" + alias + ""' registered"");"
"SimpleAliasRegistry.java:114"$1$"			}"
"SimpleAliasRegistry.java:115"$0$"		}"
"SimpleAliasRegistry.java:116"$0$"	}"
"SimpleAliasRegistry.java:117"$0$""
"SimpleAliasRegistry.java:118"$0$"	@Override"
"SimpleAliasRegistry.java:119"$1$"	public boolean isAlias(String name) {"
"SimpleAliasRegistry.java:120"$1$"		return this.aliasMap.containsKey(name);"
"SimpleAliasRegistry.java:121"$1$"	}"
"SimpleAliasRegistry.java:122"$0$""
"SimpleAliasRegistry.java:123"$0$"	@Override"
"SimpleAliasRegistry.java:124"$1$"	public String[] getAliases(String name) {"
"SimpleAliasRegistry.java:125"$1$"		List<String> result = new ArrayList<>();"
"SimpleAliasRegistry.java:126"$1$"		synchronized (this.aliasMap) {"
"SimpleAliasRegistry.java:127"$1$"			retrieveAliases(name, result);"
"SimpleAliasRegistry.java:128"$1$"		}"
"SimpleAliasRegistry.java:129"$0$"		return StringUtils.toStringArray(result);"
"SimpleAliasRegistry.java:130"$0$"	}"
"SimpleAliasRegistry.java:131"$0$""
"SimpleAliasRegistry.java:132"$0$"	/**"
"SimpleAliasRegistry.java:133"$0$"	 * Transitively retrieve all aliases for the given name."
"SimpleAliasRegistry.java:134"$0$"	 * @param name the target name to find aliases for"
"SimpleAliasRegistry.java:135"$0$"	 * @param result the resulting aliases list"
"SimpleAliasRegistry.java:136"$0$"	 */"
"SimpleAliasRegistry.java:137"$1$"	private void retrieveAliases(String name, List<String> result) {"
"SimpleAliasRegistry.java:138"$1$"		this.aliasMap.forEach((alias, registeredName) -> {"
"SimpleAliasRegistry.java:139"$1$"			if (registeredName.equals(name)) {"
"SimpleAliasRegistry.java:140"$1$"				result.add(alias);"
"SimpleAliasRegistry.java:141"$1$"				retrieveAliases(alias, result);"
"SimpleAliasRegistry.java:142"$1$"			}"
"SimpleAliasRegistry.java:143"$0$"		});"
"SimpleAliasRegistry.java:144"$0$"	}"
"SimpleAliasRegistry.java:145"$0$""
"SimpleAliasRegistry.java:146"$0$"	/**"
"SimpleAliasRegistry.java:147"$0$"	 * Resolve all alias target names and aliases registered in this"
"SimpleAliasRegistry.java:148"$1$"	 * registry, applying the given {@link StringValueResolver} to them."
"SimpleAliasRegistry.java:149"$0$"	 * <p>The value resolver may for example resolve placeholders"
"SimpleAliasRegistry.java:150"$0$"	 * in target bean names and even in alias names."
"SimpleAliasRegistry.java:151"$0$"	 * @param valueResolver the StringValueResolver to apply"
"SimpleAliasRegistry.java:152"$0$"	 */"
"SimpleAliasRegistry.java:153"$1$"	public void resolveAliases(StringValueResolver valueResolver) {"
"SimpleAliasRegistry.java:154"$1$"		Assert.notNull(valueResolver, ""StringValueResolver must not be null"");"
"SimpleAliasRegistry.java:155"$1$"		synchronized (this.aliasMap) {"
"SimpleAliasRegistry.java:156"$1$"			Map<String, String> aliasCopy = new HashMap<>(this.aliasMap);"
"SimpleAliasRegistry.java:157"$1$"			aliasCopy.forEach((alias, registeredName) -> {"
"SimpleAliasRegistry.java:158"$1$"				String resolvedAlias = valueResolver.resolveStringValue(alias);"
"SimpleAliasRegistry.java:159"$1$"				String resolvedName = valueResolver.resolveStringValue(registeredName);"
"SimpleAliasRegistry.java:160"$1$"				if (resolvedAlias == null || resolvedName == null || resolvedAlias.equals(resolvedName)) {"
"SimpleAliasRegistry.java:161"$1$"					this.aliasMap.remove(alias);"
"SimpleAliasRegistry.java:162"$1$"				}"
"SimpleAliasRegistry.java:163"$1$"				else if (!resolvedAlias.equals(alias)) {"
"SimpleAliasRegistry.java:164"$1$"					String existingName = this.aliasMap.get(resolvedAlias);"
"SimpleAliasRegistry.java:165"$1$"					if (existingName != null) {"
"SimpleAliasRegistry.java:166"$1$"						if (existingName.equals(resolvedName)) {"
"SimpleAliasRegistry.java:167"$0$"							// Pointing to existing alias - just remove placeholder"
"SimpleAliasRegistry.java:168"$1$"							this.aliasMap.remove(alias);"
"SimpleAliasRegistry.java:169"$1$"							return;"
"SimpleAliasRegistry.java:170"$1$"						}"
"SimpleAliasRegistry.java:171"$0$"						throw new IllegalStateException("
"SimpleAliasRegistry.java:172"$0$"								""Cannot register resolved alias '"" + resolvedAlias + ""' (original: '"" + alias +"
"SimpleAliasRegistry.java:173"$0$"								""') for name '"" + resolvedName + ""': It is already registered for name '"" +"
"SimpleAliasRegistry.java:174"$0$"								registeredName + ""'."");"
"SimpleAliasRegistry.java:175"$0$"					}"
"SimpleAliasRegistry.java:176"$0$"					checkForAliasCircle(resolvedName, resolvedAlias);"
"SimpleAliasRegistry.java:177"$0$"					this.aliasMap.remove(alias);"
"SimpleAliasRegistry.java:178"$0$"					this.aliasMap.put(resolvedAlias, resolvedName);"
"SimpleAliasRegistry.java:179"$0$"				}"
"SimpleAliasRegistry.java:180"$1$"				else if (!registeredName.equals(resolvedName)) {"
"SimpleAliasRegistry.java:181"$1$"					this.aliasMap.put(alias, resolvedName);"
"SimpleAliasRegistry.java:182"$1$"				}"
"SimpleAliasRegistry.java:183"$0$"			});"
"SimpleAliasRegistry.java:184"$0$"		}"
"SimpleAliasRegistry.java:185"$0$"	}"
"SimpleAliasRegistry.java:186"$0$""
"SimpleAliasRegistry.java:187"$0$"	/**"
"SimpleAliasRegistry.java:188"$0$"	 * Check whether the given name points back to the given alias as an alias"
"SimpleAliasRegistry.java:189"$0$"	 * in the other direction already, catching a circular reference upfront"
"SimpleAliasRegistry.java:190"$0$"	 * and throwing a corresponding IllegalStateException."
"SimpleAliasRegistry.java:191"$0$"	 * @param name the candidate name"
"SimpleAliasRegistry.java:192"$0$"	 * @param alias the candidate alias"
"SimpleAliasRegistry.java:193"$0$"	 * @see #registerAlias"
"SimpleAliasRegistry.java:194"$0$"	 * @see #hasAlias"
"SimpleAliasRegistry.java:195"$0$"	 */"
"SimpleAliasRegistry.java:196"$1$"	protected void checkForAliasCircle(String name, String alias) {"
"SimpleAliasRegistry.java:197"$1$"		if (hasAlias(alias, name)) {"
"SimpleAliasRegistry.java:198"$1$"			throw new IllegalStateException(""Cannot register alias '"" + alias +"
"SimpleAliasRegistry.java:199"$1$"					""' for name '"" + name + ""': Circular reference - '"" +"
"SimpleAliasRegistry.java:200"$1$"					name + ""' is a direct or indirect alias for '"" + alias + ""' already"");"
"SimpleAliasRegistry.java:201"$1$"		}"
"SimpleAliasRegistry.java:202"$0$"	}"
"SimpleAliasRegistry.java:203"$0$""
"SimpleAliasRegistry.java:204"$0$"	/**"
"SimpleAliasRegistry.java:205"$0$"	 * Determine the raw name, resolving aliases to canonical names."
"SimpleAliasRegistry.java:206"$0$"	 * @param name the user-specified name"
"SimpleAliasRegistry.java:207"$0$"	 * @return the transformed name"
"SimpleAliasRegistry.java:208"$0$"	 */"
"SimpleAliasRegistry.java:209"$1$"	public String canonicalName(String name) {"
"SimpleAliasRegistry.java:210"$1$"		String canonicalName = name;"
"SimpleAliasRegistry.java:211"$0$"		// Handle aliasing..."
"SimpleAliasRegistry.java:212"$1$"		String resolvedName;"
"SimpleAliasRegistry.java:213"$1$"		do {"
"SimpleAliasRegistry.java:214"$1$"			resolvedName = this.aliasMap.get(canonicalName);"
"SimpleAliasRegistry.java:215"$1$"			if (resolvedName != null) {"
"SimpleAliasRegistry.java:216"$1$"				canonicalName = resolvedName;"
"SimpleAliasRegistry.java:217"$1$"			}"
"SimpleAliasRegistry.java:218"$0$"		}"
"SimpleAliasRegistry.java:219"$0$"		while (resolvedName != null);"
"SimpleAliasRegistry.java:220"$0$"		return canonicalName;"
"SimpleAliasRegistry.java:221"$0$"	}"
"SimpleAliasRegistry.java:222"$0$""
"SimpleAliasRegistry.java:223"$0$"}"
"MergedAnnotationCollectors.java:1"$0$"/*"
"MergedAnnotationCollectors.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MergedAnnotationCollectors.java:3"$0$" *"
"MergedAnnotationCollectors.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MergedAnnotationCollectors.java:5"$0$" * you may not use this file except in compliance with the License."
"MergedAnnotationCollectors.java:6"$0$" * You may obtain a copy of the License at"
"MergedAnnotationCollectors.java:7"$0$" *"
"MergedAnnotationCollectors.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MergedAnnotationCollectors.java:9"$0$" *"
"MergedAnnotationCollectors.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MergedAnnotationCollectors.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MergedAnnotationCollectors.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MergedAnnotationCollectors.java:13"$0$" * See the License for the specific language governing permissions and"
"MergedAnnotationCollectors.java:14"$0$" * limitations under the License."
"MergedAnnotationCollectors.java:15"$0$" */"
"MergedAnnotationCollectors.java:16"$0$""
"MergedAnnotationCollectors.java:17"$0$"package org.springframework.core.annotation;"
"MergedAnnotationCollectors.java:18"$0$""
"MergedAnnotationCollectors.java:19"$0$"import java.lang.annotation.Annotation;"
"MergedAnnotationCollectors.java:20"$0$"import java.util.ArrayList;"
"MergedAnnotationCollectors.java:21"$0$"import java.util.LinkedHashSet;"
"MergedAnnotationCollectors.java:22"$0$"import java.util.List;"
"MergedAnnotationCollectors.java:23"$0$"import java.util.Set;"
"MergedAnnotationCollectors.java:24"$0$"import java.util.function.Function;"
"MergedAnnotationCollectors.java:25"$0$"import java.util.function.IntFunction;"
"MergedAnnotationCollectors.java:26"$0$"import java.util.stream.Collector;"
"MergedAnnotationCollectors.java:27"$0$"import java.util.stream.Collector.Characteristics;"
"MergedAnnotationCollectors.java:28"$0$""
"MergedAnnotationCollectors.java:29"$0$"import org.springframework.core.annotation.MergedAnnotation.Adapt;"
"MergedAnnotationCollectors.java:30"$0$"import org.springframework.util.LinkedMultiValueMap;"
"MergedAnnotationCollectors.java:31"$0$"import org.springframework.util.MultiValueMap;"
"MergedAnnotationCollectors.java:32"$0$""
"MergedAnnotationCollectors.java:33"$0$"/**"
"MergedAnnotationCollectors.java:34"$0$" * Collector implementations that provide various reduction operations for"
"MergedAnnotationCollectors.java:35"$1$" * {@link MergedAnnotation} instances."
"MergedAnnotationCollectors.java:36"$0$" *"
"MergedAnnotationCollectors.java:37"$0$" * @author Phillip Webb"
"MergedAnnotationCollectors.java:38"$0$" * @since 5.2"
"MergedAnnotationCollectors.java:39"$0$" */"
"MergedAnnotationCollectors.java:40"$1$"public abstract class MergedAnnotationCollectors {"
"MergedAnnotationCollectors.java:41"$1$""
"MergedAnnotationCollectors.java:42"$1$"	private static final Characteristics[] NO_CHARACTERISTICS = {};"
"MergedAnnotationCollectors.java:43"$1$""
"MergedAnnotationCollectors.java:44"$1$"	private static final Characteristics[] IDENTITY_FINISH_CHARACTERISTICS = {Characteristics.IDENTITY_FINISH};"
"MergedAnnotationCollectors.java:45"$1$""
"MergedAnnotationCollectors.java:46"$1$""
"MergedAnnotationCollectors.java:47"$1$"	private MergedAnnotationCollectors() {"
"MergedAnnotationCollectors.java:48"$1$"	}"
"MergedAnnotationCollectors.java:49"$0$""
"MergedAnnotationCollectors.java:50"$0$""
"MergedAnnotationCollectors.java:51"$0$"	/**"
"MergedAnnotationCollectors.java:52"$1$"	 * Create a new {@link Collector} that accumulates merged annotations to a"
"MergedAnnotationCollectors.java:53"$1$"	 * {@link LinkedHashSet} containing {@linkplain MergedAnnotation#synthesize()"
"MergedAnnotationCollectors.java:54"$0$"	 * synthesized} versions."
"MergedAnnotationCollectors.java:55"$0$"	 * @param <A> the annotation type"
"MergedAnnotationCollectors.java:56"$1$"	 * @return a {@link Collector} which collects and synthesizes the"
"MergedAnnotationCollectors.java:57"$1$"	 * annotations into a {@link Set}"
"MergedAnnotationCollectors.java:58"$0$"	 */"
"MergedAnnotationCollectors.java:59"$1$"	public static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Set<A>> toAnnotationSet() {"
"MergedAnnotationCollectors.java:60"$1$"		return Collector.of(ArrayList<A>::new, (list, annotation) -> list.add(annotation.synthesize()),"
"MergedAnnotationCollectors.java:61"$1$"				MergedAnnotationCollectors::addAll, LinkedHashSet::new);"
"MergedAnnotationCollectors.java:62"$1$"	}"
"MergedAnnotationCollectors.java:63"$0$""
"MergedAnnotationCollectors.java:64"$0$"	/**"
"MergedAnnotationCollectors.java:65"$1$"	 * Create a new {@link Collector} that accumulates merged annotations to an"
"MergedAnnotationCollectors.java:66"$1$"	 * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()"
"MergedAnnotationCollectors.java:67"$0$"	 * synthesized} versions."
"MergedAnnotationCollectors.java:68"$0$"	 * @param <A> the annotation type"
"MergedAnnotationCollectors.java:69"$1$"	 * @return a {@link Collector} which collects and synthesizes the"
"MergedAnnotationCollectors.java:70"$1$"	 * annotations into an {@code Annotation[]}"
"MergedAnnotationCollectors.java:71"$0$"	 * @see #toAnnotationArray(IntFunction)"
"MergedAnnotationCollectors.java:72"$0$"	 */"
"MergedAnnotationCollectors.java:73"$1$"	public static <A extends Annotation> Collector<MergedAnnotation<A>, ?, Annotation[]> toAnnotationArray() {"
"MergedAnnotationCollectors.java:74"$1$"		return toAnnotationArray(Annotation[]::new);"
"MergedAnnotationCollectors.java:75"$1$"	}"
"MergedAnnotationCollectors.java:76"$0$""
"MergedAnnotationCollectors.java:77"$0$"	/**"
"MergedAnnotationCollectors.java:78"$1$"	 * Create a new {@link Collector} that accumulates merged annotations to an"
"MergedAnnotationCollectors.java:79"$1$"	 * {@link Annotation} array containing {@linkplain MergedAnnotation#synthesize()"
"MergedAnnotationCollectors.java:80"$0$"	 * synthesized} versions."
"MergedAnnotationCollectors.java:81"$0$"	 * @param <A> the annotation type"
"MergedAnnotationCollectors.java:82"$0$"	 * @param <R> the resulting array type"
"MergedAnnotationCollectors.java:83"$0$"	 * @param generator a function which produces a new array of the desired"
"MergedAnnotationCollectors.java:84"$0$"	 * type and the provided length"
"MergedAnnotationCollectors.java:85"$1$"	 * @return a {@link Collector} which collects and synthesizes the"
"MergedAnnotationCollectors.java:86"$0$"	 * annotations into an annotation array"
"MergedAnnotationCollectors.java:87"$0$"	 * @see #toAnnotationArray"
"MergedAnnotationCollectors.java:88"$0$"	 */"
"MergedAnnotationCollectors.java:89"$0$"	public static <R extends Annotation, A extends R> Collector<MergedAnnotation<A>, ?, R[]> toAnnotationArray("
"MergedAnnotationCollectors.java:90"$1$"			IntFunction<R[]> generator) {"
"MergedAnnotationCollectors.java:91"$1$""
"MergedAnnotationCollectors.java:92"$1$"		return Collector.of(ArrayList::new, (list, annotation) -> list.add(annotation.synthesize()),"
"MergedAnnotationCollectors.java:93"$1$"				MergedAnnotationCollectors::addAll, list -> list.toArray(generator.apply(list.size())));"
"MergedAnnotationCollectors.java:94"$1$"	}"
"MergedAnnotationCollectors.java:95"$0$""
"MergedAnnotationCollectors.java:96"$0$"	/**"
"MergedAnnotationCollectors.java:97"$1$"	 * Create a new {@link Collector} that accumulates merged annotations to an"
"MergedAnnotationCollectors.java:98"$1$"	 * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)"
"MergedAnnotationCollectors.java:99"$0$"	 * added} from each merged annotation"
"MergedAnnotationCollectors.java:100"$1$"	 * {@link MergedAnnotation#asMap(Adapt...) as a map}."
"MergedAnnotationCollectors.java:101"$0$"	 * @param <A> the annotation type"
"MergedAnnotationCollectors.java:102"$0$"	 * @param adaptations the adaptations that should be applied to the annotation values"
"MergedAnnotationCollectors.java:103"$1$"	 * @return a {@link Collector} which collects and synthesizes the"
"MergedAnnotationCollectors.java:104"$1$"	 * annotations into a {@link LinkedMultiValueMap}"
"MergedAnnotationCollectors.java:105"$0$"	 * @see #toMultiValueMap(Function, MergedAnnotation.Adapt...)"
"MergedAnnotationCollectors.java:106"$0$"	 */"
"MergedAnnotationCollectors.java:107"$0$"	public static <A extends Annotation> Collector<MergedAnnotation<A>, ?, MultiValueMap<String, Object>> toMultiValueMap("
"MergedAnnotationCollectors.java:108"$1$"			Adapt... adaptations) {"
"MergedAnnotationCollectors.java:109"$1$""
"MergedAnnotationCollectors.java:110"$1$"		return toMultiValueMap(Function.identity(), adaptations);"
"MergedAnnotationCollectors.java:111"$1$"	}"
"MergedAnnotationCollectors.java:112"$0$""
"MergedAnnotationCollectors.java:113"$0$"	/**"
"MergedAnnotationCollectors.java:114"$1$"	 * Create a new {@link Collector} that accumulates merged annotations to an"
"MergedAnnotationCollectors.java:115"$1$"	 * {@link MultiValueMap} with items {@linkplain MultiValueMap#add(Object, Object)"
"MergedAnnotationCollectors.java:116"$0$"	 * added} from each merged annotation"
"MergedAnnotationCollectors.java:117"$1$"	 * {@link MergedAnnotation#asMap(Adapt...) as a map}."
"MergedAnnotationCollectors.java:118"$0$"	 * @param <A> the annotation type"
"MergedAnnotationCollectors.java:119"$0$"	 * @param adaptations the adaptations that should be applied to the annotation values"
"MergedAnnotationCollectors.java:120"$1$"	 * @param finisher the finisher function for the new {@link MultiValueMap}"
"MergedAnnotationCollectors.java:121"$1$"	 * @return a {@link Collector} which collects and synthesizes the"
"MergedAnnotationCollectors.java:122"$1$"	 * annotations into a {@link LinkedMultiValueMap}"
"MergedAnnotationCollectors.java:123"$0$"	 * @see #toMultiValueMap(MergedAnnotation.Adapt...)"
"MergedAnnotationCollectors.java:124"$0$"	 */"
"MergedAnnotationCollectors.java:125"$0$"	public static <A extends Annotation> Collector<MergedAnnotation<A>, ?, MultiValueMap<String, Object>> toMultiValueMap("
"MergedAnnotationCollectors.java:126"$0$"			Function<MultiValueMap<String, Object>, MultiValueMap<String, Object>> finisher,"
"MergedAnnotationCollectors.java:127"$1$"			Adapt... adaptations) {"
"MergedAnnotationCollectors.java:128"$1$""
"MergedAnnotationCollectors.java:129"$1$"		Characteristics[] characteristics = (isSameInstance(finisher, Function.identity()) ?"
"MergedAnnotationCollectors.java:130"$1$"				IDENTITY_FINISH_CHARACTERISTICS : NO_CHARACTERISTICS);"
"MergedAnnotationCollectors.java:131"$1$"		return Collector.of(LinkedMultiValueMap::new,"
"MergedAnnotationCollectors.java:132"$1$"				(map, annotation) -> annotation.asMap(adaptations).forEach(map::add),"
"MergedAnnotationCollectors.java:133"$1$"				MergedAnnotationCollectors::merge, finisher, characteristics);"
"MergedAnnotationCollectors.java:134"$1$"	}"
"MergedAnnotationCollectors.java:135"$0$""
"MergedAnnotationCollectors.java:136"$0$""
"MergedAnnotationCollectors.java:137"$1$"	private static boolean isSameInstance(Object instance, Object candidate) {"
"MergedAnnotationCollectors.java:138"$1$"		return instance == candidate;"
"MergedAnnotationCollectors.java:139"$1$"	}"
"MergedAnnotationCollectors.java:140"$0$""
"MergedAnnotationCollectors.java:141"$1$"	private static <E, L extends List<E>> L addAll(L list, L additions) {"
"MergedAnnotationCollectors.java:142"$1$"		list.addAll(additions);"
"MergedAnnotationCollectors.java:143"$1$"		return list;"
"MergedAnnotationCollectors.java:144"$1$"	}"
"MergedAnnotationCollectors.java:145"$0$""
"MergedAnnotationCollectors.java:146"$0$"	private static <K, V> MultiValueMap<K, V> merge(MultiValueMap<K, V> map,"
"MergedAnnotationCollectors.java:147"$1$"			MultiValueMap<K, V> additions) {"
"MergedAnnotationCollectors.java:148"$1$"		map.addAll(additions);"
"MergedAnnotationCollectors.java:149"$1$"		return map;"
"MergedAnnotationCollectors.java:150"$1$"	}"
"MergedAnnotationCollectors.java:151"$0$""
"MergedAnnotationCollectors.java:152"$0$"}"
"AttributeMethods.java:1"$0$"/*"
"AttributeMethods.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AttributeMethods.java:3"$0$" *"
"AttributeMethods.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AttributeMethods.java:5"$0$" * you may not use this file except in compliance with the License."
"AttributeMethods.java:6"$0$" * You may obtain a copy of the License at"
"AttributeMethods.java:7"$0$" *"
"AttributeMethods.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AttributeMethods.java:9"$0$" *"
"AttributeMethods.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AttributeMethods.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AttributeMethods.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AttributeMethods.java:13"$0$" * See the License for the specific language governing permissions and"
"AttributeMethods.java:14"$0$" * limitations under the License."
"AttributeMethods.java:15"$0$" */"
"AttributeMethods.java:16"$0$""
"AttributeMethods.java:17"$0$"package org.springframework.core.annotation;"
"AttributeMethods.java:18"$0$""
"AttributeMethods.java:19"$0$"import java.lang.annotation.Annotation;"
"AttributeMethods.java:20"$0$"import java.lang.reflect.Method;"
"AttributeMethods.java:21"$0$"import java.util.Arrays;"
"AttributeMethods.java:22"$0$"import java.util.Comparator;"
"AttributeMethods.java:23"$0$"import java.util.Map;"
"AttributeMethods.java:24"$0$""
"AttributeMethods.java:25"$0$"import org.springframework.lang.Nullable;"
"AttributeMethods.java:26"$0$"import org.springframework.util.Assert;"
"AttributeMethods.java:27"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"AttributeMethods.java:28"$0$"import org.springframework.util.ReflectionUtils;"
"AttributeMethods.java:29"$0$""
"AttributeMethods.java:30"$0$"/**"
"AttributeMethods.java:31"$1$" * Provides a quick way to access the attribute methods of an {@link Annotation}"
"AttributeMethods.java:32"$0$" * with consistent ordering as well as a few useful utility methods."
"AttributeMethods.java:33"$0$" *"
"AttributeMethods.java:34"$0$" * @author Phillip Webb"
"AttributeMethods.java:35"$0$" * @since 5.2"
"AttributeMethods.java:36"$0$" */"
"AttributeMethods.java:37"$1$"final class AttributeMethods {"
"AttributeMethods.java:38"$1$""
"AttributeMethods.java:39"$1$"	static final AttributeMethods NONE = new AttributeMethods(null, new Method[0]);"
"AttributeMethods.java:40"$1$""
"AttributeMethods.java:41"$1$""
"AttributeMethods.java:42"$1$"	private static final Map<Class<? extends Annotation>, AttributeMethods> cache ="
"AttributeMethods.java:43"$1$"			new ConcurrentReferenceHashMap<>();"
"AttributeMethods.java:44"$1$""
"AttributeMethods.java:45"$1$"	private static final Comparator<Method> methodComparator = (m1, m2) -> {"
"AttributeMethods.java:46"$1$"		if (m1 != null && m2 != null) {"
"AttributeMethods.java:47"$1$"			return m1.getName().compareTo(m2.getName());"
"AttributeMethods.java:48"$1$"		}"
"AttributeMethods.java:49"$0$"		return m1 != null ? -1 : 1;"
"AttributeMethods.java:50"$0$"	};"
"AttributeMethods.java:51"$0$""
"AttributeMethods.java:52"$0$""
"AttributeMethods.java:53"$0$"	@Nullable"
"AttributeMethods.java:54"$0$"	private final Class<? extends Annotation> annotationType;"
"AttributeMethods.java:55"$0$""
"AttributeMethods.java:56"$0$"	private final Method[] attributeMethods;"
"AttributeMethods.java:57"$0$""
"AttributeMethods.java:58"$0$"	private final boolean[] canThrowTypeNotPresentException;"
"AttributeMethods.java:59"$0$""
"AttributeMethods.java:60"$0$"	private final boolean hasDefaultValueMethod;"
"AttributeMethods.java:61"$0$""
"AttributeMethods.java:62"$0$"	private final boolean hasNestedAnnotation;"
"AttributeMethods.java:63"$0$""
"AttributeMethods.java:64"$0$""
"AttributeMethods.java:65"$1$"	private AttributeMethods(@Nullable Class<? extends Annotation> annotationType, Method[] attributeMethods) {"
"AttributeMethods.java:66"$1$"		this.annotationType = annotationType;"
"AttributeMethods.java:67"$1$"		this.attributeMethods = attributeMethods;"
"AttributeMethods.java:68"$1$"		this.canThrowTypeNotPresentException = new boolean[attributeMethods.length];"
"AttributeMethods.java:69"$1$"		boolean foundDefaultValueMethod = false;"
"AttributeMethods.java:70"$1$"		boolean foundNestedAnnotation = false;"
"AttributeMethods.java:71"$1$"		for (int i = 0; i < attributeMethods.length; i++) {"
"AttributeMethods.java:72"$1$"			Method method = this.attributeMethods[i];"
"AttributeMethods.java:73"$1$"			Class<?> type = method.getReturnType();"
"AttributeMethods.java:74"$1$"			if (method.getDefaultValue() != null) {"
"AttributeMethods.java:75"$1$"				foundDefaultValueMethod = true;"
"AttributeMethods.java:76"$1$"			}"
"AttributeMethods.java:77"$1$"			if (type.isAnnotation() || (type.isArray() && type.getComponentType().isAnnotation())) {"
"AttributeMethods.java:78"$1$"				foundNestedAnnotation = true;"
"AttributeMethods.java:79"$1$"			}"
"AttributeMethods.java:80"$0$"			ReflectionUtils.makeAccessible(method);"
"AttributeMethods.java:81"$0$"			this.canThrowTypeNotPresentException[i] = (type == Class.class || type == Class[].class || type.isEnum());"
"AttributeMethods.java:82"$0$"		}"
"AttributeMethods.java:83"$0$"		this.hasDefaultValueMethod = foundDefaultValueMethod;"
"AttributeMethods.java:84"$0$"		this.hasNestedAnnotation = foundNestedAnnotation;"
"AttributeMethods.java:85"$0$"	}"
"AttributeMethods.java:86"$0$""
"AttributeMethods.java:87"$0$""
"AttributeMethods.java:88"$0$"	/**"
"AttributeMethods.java:89"$0$"	 * Determine if this instance only contains a single attribute named"
"AttributeMethods.java:90"$1$"	 * {@code value}."
"AttributeMethods.java:91"$1$"	 * @return {@code true} if there is only a value attribute"
"AttributeMethods.java:92"$0$"	 */"
"AttributeMethods.java:93"$1$"	boolean hasOnlyValueAttribute() {"
"AttributeMethods.java:94"$1$"		return (this.attributeMethods.length == 1 &&"
"AttributeMethods.java:95"$1$"				MergedAnnotation.VALUE.equals(this.attributeMethods[0].getName()));"
"AttributeMethods.java:96"$1$"	}"
"AttributeMethods.java:97"$0$""
"AttributeMethods.java:98"$0$""
"AttributeMethods.java:99"$0$"	/**"
"AttributeMethods.java:100"$0$"	 * Determine if values from the given annotation can be safely accessed without"
"AttributeMethods.java:101"$1$"	 * causing any {@link TypeNotPresentException TypeNotPresentExceptions}."
"AttributeMethods.java:102"$0$"	 * @param annotation the annotation to check"
"AttributeMethods.java:103"$1$"	 * @return {@code true} if all values are present"
"AttributeMethods.java:104"$0$"	 * @see #validate(Annotation)"
"AttributeMethods.java:105"$0$"	 */"
"AttributeMethods.java:106"$1$"	boolean isValid(Annotation annotation) {"
"AttributeMethods.java:107"$1$"		assertAnnotation(annotation);"
"AttributeMethods.java:108"$1$"		for (int i = 0; i < size(); i++) {"
"AttributeMethods.java:109"$1$"			if (canThrowTypeNotPresentException(i)) {"
"AttributeMethods.java:110"$1$"				try {"
"AttributeMethods.java:111"$1$"					get(i).invoke(annotation);"
"AttributeMethods.java:112"$1$"				}"
"AttributeMethods.java:113"$1$"				catch (Throwable ex) {"
"AttributeMethods.java:114"$1$"					return false;"
"AttributeMethods.java:115"$1$"				}"
"AttributeMethods.java:116"$0$"			}"
"AttributeMethods.java:117"$0$"		}"
"AttributeMethods.java:118"$0$"		return true;"
"AttributeMethods.java:119"$0$"	}"
"AttributeMethods.java:120"$0$""
"AttributeMethods.java:121"$0$"	/**"
"AttributeMethods.java:122"$0$"	 * Check if values from the given annotation can be safely accessed without causing"
"AttributeMethods.java:123"$1$"	 * any {@link TypeNotPresentException TypeNotPresentExceptions}. In particular,"
"AttributeMethods.java:124"$0$"	 * this method is designed to cover Google App Engine's late arrival of such"
"AttributeMethods.java:125"$1$"	 * exceptions for {@code Class} values (instead of the more typical early"
"AttributeMethods.java:126"$1$"	 * {@code Class.getAnnotations() failure}."
"AttributeMethods.java:127"$0$"	 * @param annotation the annotation to validate"
"AttributeMethods.java:128"$1$"	 * @throws IllegalStateException if a declared {@code Class} attribute could not be read"
"AttributeMethods.java:129"$0$"	 * @see #isValid(Annotation)"
"AttributeMethods.java:130"$0$"	 */"
"AttributeMethods.java:131"$1$"	void validate(Annotation annotation) {"
"AttributeMethods.java:132"$1$"		assertAnnotation(annotation);"
"AttributeMethods.java:133"$1$"		for (int i = 0; i < size(); i++) {"
"AttributeMethods.java:134"$1$"			if (canThrowTypeNotPresentException(i)) {"
"AttributeMethods.java:135"$1$"				try {"
"AttributeMethods.java:136"$1$"					get(i).invoke(annotation);"
"AttributeMethods.java:137"$1$"				}"
"AttributeMethods.java:138"$1$"				catch (Throwable ex) {"
"AttributeMethods.java:139"$1$"					throw new IllegalStateException(""Could not obtain annotation attribute value for "" +"
"AttributeMethods.java:140"$1$"							get(i).getName() + "" declared on "" + annotation.annotationType(), ex);"
"AttributeMethods.java:141"$1$"				}"
"AttributeMethods.java:142"$0$"			}"
"AttributeMethods.java:143"$0$"		}"
"AttributeMethods.java:144"$0$"	}"
"AttributeMethods.java:145"$0$""
"AttributeMethods.java:146"$1$"	private void assertAnnotation(Annotation annotation) {"
"AttributeMethods.java:147"$1$"		Assert.notNull(annotation, ""Annotation must not be null"");"
"AttributeMethods.java:148"$1$"		if (this.annotationType != null) {"
"AttributeMethods.java:149"$1$"			Assert.isInstanceOf(this.annotationType, annotation);"
"AttributeMethods.java:150"$1$"		}"
"AttributeMethods.java:151"$0$"	}"
"AttributeMethods.java:152"$0$""
"AttributeMethods.java:153"$0$"	/**"
"AttributeMethods.java:154"$1$"	 * Get the attribute with the specified name or {@code null} if no"
"AttributeMethods.java:155"$0$"	 * matching attribute exists."
"AttributeMethods.java:156"$0$"	 * @param name the attribute name to find"
"AttributeMethods.java:157"$1$"	 * @return the attribute method or {@code null}"
"AttributeMethods.java:158"$0$"	 */"
"AttributeMethods.java:159"$0$"	@Nullable"
"AttributeMethods.java:160"$1$"	Method get(String name) {"
"AttributeMethods.java:161"$1$"		int index = indexOf(name);"
"AttributeMethods.java:162"$1$"		return index != -1 ? this.attributeMethods[index] : null;"
"AttributeMethods.java:163"$1$"	}"
"AttributeMethods.java:164"$0$""
"AttributeMethods.java:165"$0$"	/**"
"AttributeMethods.java:166"$0$"	 * Get the attribute at the specified index."
"AttributeMethods.java:167"$0$"	 * @param index the index of the attribute to return"
"AttributeMethods.java:168"$0$"	 * @return the attribute method"
"AttributeMethods.java:169"$0$"	 * @throws IndexOutOfBoundsException if the index is out of range"
"AttributeMethods.java:170"$0$"	 * (<tt>index &lt; 0 || index &gt;= size()</tt>)"
"AttributeMethods.java:171"$0$"	 */"
"AttributeMethods.java:172"$1$"	Method get(int index) {"
"AttributeMethods.java:173"$1$"		return this.attributeMethods[index];"
"AttributeMethods.java:174"$1$"	}"
"AttributeMethods.java:175"$0$""
"AttributeMethods.java:176"$0$"	/**"
"AttributeMethods.java:177"$0$"	 * Determine if the attribute at the specified index could throw a"
"AttributeMethods.java:178"$1$"	 * {@link TypeNotPresentException} when accessed."
"AttributeMethods.java:179"$0$"	 * @param index the index of the attribute to check"
"AttributeMethods.java:180"$1$"	 * @return {@code true} if the attribute can throw a"
"AttributeMethods.java:181"$1$"	 * {@link TypeNotPresentException}"
"AttributeMethods.java:182"$0$"	 */"
"AttributeMethods.java:183"$1$"	boolean canThrowTypeNotPresentException(int index) {"
"AttributeMethods.java:184"$1$"		return this.canThrowTypeNotPresentException[index];"
"AttributeMethods.java:185"$1$"	}"
"AttributeMethods.java:186"$0$""
"AttributeMethods.java:187"$0$"	/**"
"AttributeMethods.java:188"$1$"	 * Get the index of the attribute with the specified name, or {@code -1}"
"AttributeMethods.java:189"$0$"	 * if there is no attribute with the name."
"AttributeMethods.java:190"$0$"	 * @param name the name to find"
"AttributeMethods.java:191"$1$"	 * @return the index of the attribute, or {@code -1}"
"AttributeMethods.java:192"$0$"	 */"
"AttributeMethods.java:193"$1$"	int indexOf(String name) {"
"AttributeMethods.java:194"$1$"		for (int i = 0; i < this.attributeMethods.length; i++) {"
"AttributeMethods.java:195"$1$"			if (this.attributeMethods[i].getName().equals(name)) {"
"AttributeMethods.java:196"$1$"				return i;"
"AttributeMethods.java:197"$1$"			}"
"AttributeMethods.java:198"$0$"		}"
"AttributeMethods.java:199"$0$"		return -1;"
"AttributeMethods.java:200"$0$"	}"
"AttributeMethods.java:201"$0$""
"AttributeMethods.java:202"$0$"	/**"
"AttributeMethods.java:203"$1$"	 * Get the index of the specified attribute, or {@code -1} if the"
"AttributeMethods.java:204"$0$"	 * attribute is not in this collection."
"AttributeMethods.java:205"$0$"	 * @param attribute the attribute to find"
"AttributeMethods.java:206"$1$"	 * @return the index of the attribute, or {@code -1}"
"AttributeMethods.java:207"$0$"	 */"
"AttributeMethods.java:208"$1$"	int indexOf(Method attribute) {"
"AttributeMethods.java:209"$1$"		for (int i = 0; i < this.attributeMethods.length; i++) {"
"AttributeMethods.java:210"$1$"			if (this.attributeMethods[i].equals(attribute)) {"
"AttributeMethods.java:211"$1$"				return i;"
"AttributeMethods.java:212"$1$"			}"
"AttributeMethods.java:213"$0$"		}"
"AttributeMethods.java:214"$0$"		return -1;"
"AttributeMethods.java:215"$0$"	}"
"AttributeMethods.java:216"$0$""
"AttributeMethods.java:217"$0$"	/**"
"AttributeMethods.java:218"$0$"	 * Get the number of attributes in this collection."
"AttributeMethods.java:219"$0$"	 * @return the number of attributes"
"AttributeMethods.java:220"$0$"	 */"
"AttributeMethods.java:221"$1$"	int size() {"
"AttributeMethods.java:222"$1$"		return this.attributeMethods.length;"
"AttributeMethods.java:223"$1$"	}"
"AttributeMethods.java:224"$0$""
"AttributeMethods.java:225"$0$"	/**"
"AttributeMethods.java:226"$0$"	 * Determine if at least one of the attribute methods has a default value."
"AttributeMethods.java:227"$1$"	 * @return {@code true} if there is at least one attribute method with a default value"
"AttributeMethods.java:228"$0$"	 */"
"AttributeMethods.java:229"$1$"	boolean hasDefaultValueMethod() {"
"AttributeMethods.java:230"$1$"		return this.hasDefaultValueMethod;"
"AttributeMethods.java:231"$1$"	}"
"AttributeMethods.java:232"$0$""
"AttributeMethods.java:233"$0$"	/**"
"AttributeMethods.java:234"$0$"	 * Determine if at least one of the attribute methods is a nested annotation."
"AttributeMethods.java:235"$1$"	 * @return {@code true} if there is at least one attribute method with a nested"
"AttributeMethods.java:236"$0$"	 * annotation type"
"AttributeMethods.java:237"$0$"	 */"
"AttributeMethods.java:238"$1$"	boolean hasNestedAnnotation() {"
"AttributeMethods.java:239"$1$"		return this.hasNestedAnnotation;"
"AttributeMethods.java:240"$1$"	}"
"AttributeMethods.java:241"$0$""
"AttributeMethods.java:242"$0$""
"AttributeMethods.java:243"$0$"	/**"
"AttributeMethods.java:244"$0$"	 * Get the attribute methods for the given annotation type."
"AttributeMethods.java:245"$0$"	 * @param annotationType the annotation type"
"AttributeMethods.java:246"$0$"	 * @return the attribute methods for the annotation type"
"AttributeMethods.java:247"$0$"	 */"
"AttributeMethods.java:248"$1$"	static AttributeMethods forAnnotationType(@Nullable Class<? extends Annotation> annotationType) {"
"AttributeMethods.java:249"$1$"		if (annotationType == null) {"
"AttributeMethods.java:250"$1$"			return NONE;"
"AttributeMethods.java:251"$1$"		}"
"AttributeMethods.java:252"$0$"		return cache.computeIfAbsent(annotationType, AttributeMethods::compute);"
"AttributeMethods.java:253"$0$"	}"
"AttributeMethods.java:254"$0$""
"AttributeMethods.java:255"$1$"	private static AttributeMethods compute(Class<? extends Annotation> annotationType) {"
"AttributeMethods.java:256"$1$"		Method[] methods = annotationType.getDeclaredMethods();"
"AttributeMethods.java:257"$1$"		int size = methods.length;"
"AttributeMethods.java:258"$1$"		for (int i = 0; i < methods.length; i++) {"
"AttributeMethods.java:259"$1$"			if (!isAttributeMethod(methods[i])) {"
"AttributeMethods.java:260"$1$"				methods[i] = null;"
"AttributeMethods.java:261"$1$"				size--;"
"AttributeMethods.java:262"$1$"			}"
"AttributeMethods.java:263"$0$"		}"
"AttributeMethods.java:264"$1$"		if (size == 0) {"
"AttributeMethods.java:265"$1$"			return NONE;"
"AttributeMethods.java:266"$1$"		}"
"AttributeMethods.java:267"$0$"		Arrays.sort(methods, methodComparator);"
"AttributeMethods.java:268"$0$"		Method[] attributeMethods = Arrays.copyOf(methods, size);"
"AttributeMethods.java:269"$0$"		return new AttributeMethods(annotationType, attributeMethods);"
"AttributeMethods.java:270"$0$"	}"
"AttributeMethods.java:271"$0$""
"AttributeMethods.java:272"$1$"	private static boolean isAttributeMethod(Method method) {"
"AttributeMethods.java:273"$1$"		return (method.getParameterCount() == 0 && method.getReturnType() != void.class);"
"AttributeMethods.java:274"$1$"	}"
"AttributeMethods.java:275"$0$""
"AttributeMethods.java:276"$0$"	/**"
"AttributeMethods.java:277"$0$"	 * Create a description for the given attribute method suitable to use in"
"AttributeMethods.java:278"$0$"	 * exception messages and logs."
"AttributeMethods.java:279"$0$"	 * @param attribute the attribute to describe"
"AttributeMethods.java:280"$0$"	 * @return a description of the attribute"
"AttributeMethods.java:281"$0$"	 */"
"AttributeMethods.java:282"$1$"	static String describe(@Nullable Method attribute) {"
"AttributeMethods.java:283"$1$"		if (attribute == null) {"
"AttributeMethods.java:284"$1$"			return ""(none)"";"
"AttributeMethods.java:285"$1$"		}"
"AttributeMethods.java:286"$0$"		return describe(attribute.getDeclaringClass(), attribute.getName());"
"AttributeMethods.java:287"$0$"	}"
"AttributeMethods.java:288"$0$""
"AttributeMethods.java:289"$0$"	/**"
"AttributeMethods.java:290"$0$"	 * Create a description for the given attribute method suitable to use in"
"AttributeMethods.java:291"$0$"	 * exception messages and logs."
"AttributeMethods.java:292"$0$"	 * @param annotationType the annotation type"
"AttributeMethods.java:293"$0$"	 * @param attributeName the attribute name"
"AttributeMethods.java:294"$0$"	 * @return a description of the attribute"
"AttributeMethods.java:295"$0$"	 */"
"AttributeMethods.java:296"$1$"	static String describe(@Nullable Class<?> annotationType, @Nullable String attributeName) {"
"AttributeMethods.java:297"$1$"		if (attributeName == null) {"
"AttributeMethods.java:298"$1$"			return ""(none)"";"
"AttributeMethods.java:299"$1$"		}"
"AttributeMethods.java:300"$0$"		String in = (annotationType != null ? "" in annotation ["" + annotationType.getName() + ""]"" : """");"
"AttributeMethods.java:301"$0$"		return ""attribute '"" + attributeName + ""'"" + in;"
"AttributeMethods.java:302"$0$"	}"
"AttributeMethods.java:303"$0$""
"AttributeMethods.java:304"$0$"}"
"LinkedMultiValueMap.java:1"$0$"/*"
"LinkedMultiValueMap.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"LinkedMultiValueMap.java:3"$0$" *"
"LinkedMultiValueMap.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"LinkedMultiValueMap.java:5"$0$" * you may not use this file except in compliance with the License."
"LinkedMultiValueMap.java:6"$0$" * You may obtain a copy of the License at"
"LinkedMultiValueMap.java:7"$0$" *"
"LinkedMultiValueMap.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"LinkedMultiValueMap.java:9"$0$" *"
"LinkedMultiValueMap.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"LinkedMultiValueMap.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"LinkedMultiValueMap.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"LinkedMultiValueMap.java:13"$0$" * See the License for the specific language governing permissions and"
"LinkedMultiValueMap.java:14"$0$" * limitations under the License."
"LinkedMultiValueMap.java:15"$0$" */"
"LinkedMultiValueMap.java:16"$0$""
"LinkedMultiValueMap.java:17"$0$"package org.springframework.util;"
"LinkedMultiValueMap.java:18"$0$""
"LinkedMultiValueMap.java:19"$0$"import java.io.Serializable;"
"LinkedMultiValueMap.java:20"$0$"import java.util.Collection;"
"LinkedMultiValueMap.java:21"$0$"import java.util.LinkedHashMap;"
"LinkedMultiValueMap.java:22"$0$"import java.util.LinkedList;"
"LinkedMultiValueMap.java:23"$0$"import java.util.List;"
"LinkedMultiValueMap.java:24"$0$"import java.util.Map;"
"LinkedMultiValueMap.java:25"$0$"import java.util.Set;"
"LinkedMultiValueMap.java:26"$0$""
"LinkedMultiValueMap.java:27"$0$"import org.springframework.lang.Nullable;"
"LinkedMultiValueMap.java:28"$0$""
"LinkedMultiValueMap.java:29"$0$"/**"
"LinkedMultiValueMap.java:30"$1$" * Simple implementation of {@link MultiValueMap} that wraps a {@link LinkedHashMap},"
"LinkedMultiValueMap.java:31"$1$" * storing multiple values in a {@link LinkedList}."
"LinkedMultiValueMap.java:32"$0$" *"
"LinkedMultiValueMap.java:33"$0$" * <p>This Map implementation is generally not thread-safe. It is primarily designed"
"LinkedMultiValueMap.java:34"$0$" * for data structures exposed from request objects, for use in a single thread only."
"LinkedMultiValueMap.java:35"$0$" *"
"LinkedMultiValueMap.java:36"$0$" * @author Arjen Poutsma"
"LinkedMultiValueMap.java:37"$0$" * @author Juergen Hoeller"
"LinkedMultiValueMap.java:38"$0$" * @since 3.0"
"LinkedMultiValueMap.java:39"$0$" * @param <K> the key type"
"LinkedMultiValueMap.java:40"$0$" * @param <V> the value element type"
"LinkedMultiValueMap.java:41"$0$" */"
"LinkedMultiValueMap.java:42"$1$"public class LinkedMultiValueMap<K, V> implements MultiValueMap<K, V>, Serializable, Cloneable {"
"LinkedMultiValueMap.java:43"$1$""
"LinkedMultiValueMap.java:44"$1$"	private static final long serialVersionUID = 3801124242820219131L;"
"LinkedMultiValueMap.java:45"$1$""
"LinkedMultiValueMap.java:46"$1$"	private final Map<K, List<V>> targetMap;"
"LinkedMultiValueMap.java:47"$1$""
"LinkedMultiValueMap.java:48"$1$""
"LinkedMultiValueMap.java:49"$1$"	/**"
"LinkedMultiValueMap.java:50"$1$"	 * Create a new LinkedMultiValueMap that wraps a {@link LinkedHashMap}."
"LinkedMultiValueMap.java:51"$1$"	 */"
"LinkedMultiValueMap.java:52"$1$"	public LinkedMultiValueMap() {"
"LinkedMultiValueMap.java:53"$1$"		this.targetMap = new LinkedHashMap<>();"
"LinkedMultiValueMap.java:54"$1$"	}"
"LinkedMultiValueMap.java:55"$0$""
"LinkedMultiValueMap.java:56"$0$"	/**"
"LinkedMultiValueMap.java:57"$1$"	 * Create a new LinkedMultiValueMap that wraps a {@link LinkedHashMap}"
"LinkedMultiValueMap.java:58"$0$"	 * with the given initial capacity."
"LinkedMultiValueMap.java:59"$0$"	 * @param initialCapacity the initial capacity"
"LinkedMultiValueMap.java:60"$0$"	 */"
"LinkedMultiValueMap.java:61"$1$"	public LinkedMultiValueMap(int initialCapacity) {"
"LinkedMultiValueMap.java:62"$1$"		this.targetMap = new LinkedHashMap<>(initialCapacity);"
"LinkedMultiValueMap.java:63"$1$"	}"
"LinkedMultiValueMap.java:64"$0$""
"LinkedMultiValueMap.java:65"$0$"	/**"
"LinkedMultiValueMap.java:66"$0$"	 * Copy constructor: Create a new LinkedMultiValueMap with the same mappings as"
"LinkedMultiValueMap.java:67"$0$"	 * the specified Map. Note that this will be a shallow copy; its value-holding"
"LinkedMultiValueMap.java:68"$0$"	 * List entries will get reused and therefore cannot get modified independently."
"LinkedMultiValueMap.java:69"$0$"	 * @param otherMap the Map whose mappings are to be placed in this Map"
"LinkedMultiValueMap.java:70"$0$"	 * @see #clone()"
"LinkedMultiValueMap.java:71"$0$"	 * @see #deepCopy()"
"LinkedMultiValueMap.java:72"$0$"	 */"
"LinkedMultiValueMap.java:73"$1$"	public LinkedMultiValueMap(Map<K, List<V>> otherMap) {"
"LinkedMultiValueMap.java:74"$1$"		this.targetMap = new LinkedHashMap<>(otherMap);"
"LinkedMultiValueMap.java:75"$1$"	}"
"LinkedMultiValueMap.java:76"$0$""
"LinkedMultiValueMap.java:77"$0$""
"LinkedMultiValueMap.java:78"$0$"	// MultiValueMap implementation"
"LinkedMultiValueMap.java:79"$0$""
"LinkedMultiValueMap.java:80"$0$"	@Override"
"LinkedMultiValueMap.java:81"$0$"	@Nullable"
"LinkedMultiValueMap.java:82"$1$"	public V getFirst(K key) {"
"LinkedMultiValueMap.java:83"$1$"		List<V> values = this.targetMap.get(key);"
"LinkedMultiValueMap.java:84"$1$"		return (values != null && !values.isEmpty() ? values.get(0) : null);"
"LinkedMultiValueMap.java:85"$1$"	}"
"LinkedMultiValueMap.java:86"$0$""
"LinkedMultiValueMap.java:87"$0$"	@Override"
"LinkedMultiValueMap.java:88"$1$"	public void add(K key, @Nullable V value) {"
"LinkedMultiValueMap.java:89"$1$"		List<V> values = this.targetMap.computeIfAbsent(key, k -> new LinkedList<>());"
"LinkedMultiValueMap.java:90"$1$"		values.add(value);"
"LinkedMultiValueMap.java:91"$1$"	}"
"LinkedMultiValueMap.java:92"$0$""
"LinkedMultiValueMap.java:93"$0$"	@Override"
"LinkedMultiValueMap.java:94"$1$"	public void addAll(K key, List<? extends V> values) {"
"LinkedMultiValueMap.java:95"$1$"		List<V> currentValues = this.targetMap.computeIfAbsent(key, k -> new LinkedList<>());"
"LinkedMultiValueMap.java:96"$1$"		currentValues.addAll(values);"
"LinkedMultiValueMap.java:97"$1$"	}"
"LinkedMultiValueMap.java:98"$0$""
"LinkedMultiValueMap.java:99"$0$"	@Override"
"LinkedMultiValueMap.java:100"$1$"	public void addAll(MultiValueMap<K, V> values) {"
"LinkedMultiValueMap.java:101"$1$"		for (Entry<K, List<V>> entry : values.entrySet()) {"
"LinkedMultiValueMap.java:102"$1$"			addAll(entry.getKey(), entry.getValue());"
"LinkedMultiValueMap.java:103"$1$"		}"
"LinkedMultiValueMap.java:104"$0$"	}"
"LinkedMultiValueMap.java:105"$0$""
"LinkedMultiValueMap.java:106"$0$"	@Override"
"LinkedMultiValueMap.java:107"$1$"	public void set(K key, @Nullable V value) {"
"LinkedMultiValueMap.java:108"$1$"		List<V> values = new LinkedList<>();"
"LinkedMultiValueMap.java:109"$1$"		values.add(value);"
"LinkedMultiValueMap.java:110"$1$"		this.targetMap.put(key, values);"
"LinkedMultiValueMap.java:111"$1$"	}"
"LinkedMultiValueMap.java:112"$0$""
"LinkedMultiValueMap.java:113"$0$"	@Override"
"LinkedMultiValueMap.java:114"$1$"	public void setAll(Map<K, V> values) {"
"LinkedMultiValueMap.java:115"$1$"		values.forEach(this::set);"
"LinkedMultiValueMap.java:116"$1$"	}"
"LinkedMultiValueMap.java:117"$0$""
"LinkedMultiValueMap.java:118"$0$"	@Override"
"LinkedMultiValueMap.java:119"$1$"	public Map<K, V> toSingleValueMap() {"
"LinkedMultiValueMap.java:120"$1$"		LinkedHashMap<K, V> singleValueMap = new LinkedHashMap<>(this.targetMap.size());"
"LinkedMultiValueMap.java:121"$1$"		this.targetMap.forEach((key, values) -> {"
"LinkedMultiValueMap.java:122"$1$"			if (values != null && !values.isEmpty()) {"
"LinkedMultiValueMap.java:123"$1$"				singleValueMap.put(key, values.get(0));"
"LinkedMultiValueMap.java:124"$1$"			}"
"LinkedMultiValueMap.java:125"$0$"		});"
"LinkedMultiValueMap.java:126"$0$"		return singleValueMap;"
"LinkedMultiValueMap.java:127"$0$"	}"
"LinkedMultiValueMap.java:128"$0$""
"LinkedMultiValueMap.java:129"$0$""
"LinkedMultiValueMap.java:130"$0$"	// Map implementation"
"LinkedMultiValueMap.java:131"$0$""
"LinkedMultiValueMap.java:132"$0$"	@Override"
"LinkedMultiValueMap.java:133"$1$"	public int size() {"
"LinkedMultiValueMap.java:134"$1$"		return this.targetMap.size();"
"LinkedMultiValueMap.java:135"$1$"	}"
"LinkedMultiValueMap.java:136"$0$""
"LinkedMultiValueMap.java:137"$0$"	@Override"
"LinkedMultiValueMap.java:138"$1$"	public boolean isEmpty() {"
"LinkedMultiValueMap.java:139"$1$"		return this.targetMap.isEmpty();"
"LinkedMultiValueMap.java:140"$1$"	}"
"LinkedMultiValueMap.java:141"$0$""
"LinkedMultiValueMap.java:142"$0$"	@Override"
"LinkedMultiValueMap.java:143"$1$"	public boolean containsKey(Object key) {"
"LinkedMultiValueMap.java:144"$1$"		return this.targetMap.containsKey(key);"
"LinkedMultiValueMap.java:145"$1$"	}"
"LinkedMultiValueMap.java:146"$0$""
"LinkedMultiValueMap.java:147"$0$"	@Override"
"LinkedMultiValueMap.java:148"$1$"	public boolean containsValue(Object value) {"
"LinkedMultiValueMap.java:149"$1$"		return this.targetMap.containsValue(value);"
"LinkedMultiValueMap.java:150"$1$"	}"
"LinkedMultiValueMap.java:151"$0$""
"LinkedMultiValueMap.java:152"$0$"	@Override"
"LinkedMultiValueMap.java:153"$0$"	@Nullable"
"LinkedMultiValueMap.java:154"$1$"	public List<V> get(Object key) {"
"LinkedMultiValueMap.java:155"$1$"		return this.targetMap.get(key);"
"LinkedMultiValueMap.java:156"$1$"	}"
"LinkedMultiValueMap.java:157"$0$""
"LinkedMultiValueMap.java:158"$0$"	@Override"
"LinkedMultiValueMap.java:159"$0$"	@Nullable"
"LinkedMultiValueMap.java:160"$1$"	public List<V> put(K key, List<V> value) {"
"LinkedMultiValueMap.java:161"$1$"		return this.targetMap.put(key, value);"
"LinkedMultiValueMap.java:162"$1$"	}"
"LinkedMultiValueMap.java:163"$0$""
"LinkedMultiValueMap.java:164"$0$"	@Override"
"LinkedMultiValueMap.java:165"$0$"	@Nullable"
"LinkedMultiValueMap.java:166"$1$"	public List<V> remove(Object key) {"
"LinkedMultiValueMap.java:167"$1$"		return this.targetMap.remove(key);"
"LinkedMultiValueMap.java:168"$1$"	}"
"LinkedMultiValueMap.java:169"$0$""
"LinkedMultiValueMap.java:170"$0$"	@Override"
"LinkedMultiValueMap.java:171"$1$"	public void putAll(Map<? extends K, ? extends List<V>> map) {"
"LinkedMultiValueMap.java:172"$1$"		this.targetMap.putAll(map);"
"LinkedMultiValueMap.java:173"$1$"	}"
"LinkedMultiValueMap.java:174"$0$""
"LinkedMultiValueMap.java:175"$0$"	@Override"
"LinkedMultiValueMap.java:176"$1$"	public void clear() {"
"LinkedMultiValueMap.java:177"$1$"		this.targetMap.clear();"
"LinkedMultiValueMap.java:178"$1$"	}"
"LinkedMultiValueMap.java:179"$0$""
"LinkedMultiValueMap.java:180"$0$"	@Override"
"LinkedMultiValueMap.java:181"$1$"	public Set<K> keySet() {"
"LinkedMultiValueMap.java:182"$1$"		return this.targetMap.keySet();"
"LinkedMultiValueMap.java:183"$1$"	}"
"LinkedMultiValueMap.java:184"$0$""
"LinkedMultiValueMap.java:185"$0$"	@Override"
"LinkedMultiValueMap.java:186"$1$"	public Collection<List<V>> values() {"
"LinkedMultiValueMap.java:187"$1$"		return this.targetMap.values();"
"LinkedMultiValueMap.java:188"$1$"	}"
"LinkedMultiValueMap.java:189"$0$""
"LinkedMultiValueMap.java:190"$0$"	@Override"
"LinkedMultiValueMap.java:191"$1$"	public Set<Entry<K, List<V>>> entrySet() {"
"LinkedMultiValueMap.java:192"$1$"		return this.targetMap.entrySet();"
"LinkedMultiValueMap.java:193"$1$"	}"
"LinkedMultiValueMap.java:194"$0$""
"LinkedMultiValueMap.java:195"$0$""
"LinkedMultiValueMap.java:196"$0$"	/**"
"LinkedMultiValueMap.java:197"$0$"	 * Create a deep copy of this Map."
"LinkedMultiValueMap.java:198"$0$"	 * @return a copy of this Map, including a copy of each value-holding List entry"
"LinkedMultiValueMap.java:199"$1$"	 * (consistently using an independent modifiable {@link LinkedList} for each entry)"
"LinkedMultiValueMap.java:200"$1$"	 * along the lines of {@code MultiValueMap.addAll} semantics"
"LinkedMultiValueMap.java:201"$0$"	 * @since 4.2"
"LinkedMultiValueMap.java:202"$0$"	 * @see #addAll(MultiValueMap)"
"LinkedMultiValueMap.java:203"$0$"	 * @see #clone()"
"LinkedMultiValueMap.java:204"$0$"	 */"
"LinkedMultiValueMap.java:205"$1$"	public LinkedMultiValueMap<K, V> deepCopy() {"
"LinkedMultiValueMap.java:206"$1$"		LinkedMultiValueMap<K, V> copy = new LinkedMultiValueMap<>(this.targetMap.size());"
"LinkedMultiValueMap.java:207"$1$"		this.targetMap.forEach((key, value) -> copy.put(key, new LinkedList<>(value)));"
"LinkedMultiValueMap.java:208"$1$"		return copy;"
"LinkedMultiValueMap.java:209"$1$"	}"
"LinkedMultiValueMap.java:210"$0$""
"LinkedMultiValueMap.java:211"$0$"	/**"
"LinkedMultiValueMap.java:212"$0$"	 * Create a regular copy of this Map."
"LinkedMultiValueMap.java:213"$0$"	 * @return a shallow copy of this Map, reusing this Map's value-holding List entries"
"LinkedMultiValueMap.java:214"$0$"	 * (even if some entries are shared or unmodifiable) along the lines of standard"
"LinkedMultiValueMap.java:215"$1$"	 * {@code Map.put} semantics"
"LinkedMultiValueMap.java:216"$0$"	 * @since 4.2"
"LinkedMultiValueMap.java:217"$0$"	 * @see #put(Object, List)"
"LinkedMultiValueMap.java:218"$0$"	 * @see #putAll(Map)"
"LinkedMultiValueMap.java:219"$0$"	 * @see LinkedMultiValueMap#LinkedMultiValueMap(Map)"
"LinkedMultiValueMap.java:220"$0$"	 * @see #deepCopy()"
"LinkedMultiValueMap.java:221"$0$"	 */"
"LinkedMultiValueMap.java:222"$0$"	@Override"
"LinkedMultiValueMap.java:223"$1$"	public LinkedMultiValueMap<K, V> clone() {"
"LinkedMultiValueMap.java:224"$1$"		return new LinkedMultiValueMap<>(this);"
"LinkedMultiValueMap.java:225"$1$"	}"
"LinkedMultiValueMap.java:226"$0$""
"LinkedMultiValueMap.java:227"$0$"	@Override"
"LinkedMultiValueMap.java:228"$1$"	public boolean equals(@Nullable Object obj) {"
"LinkedMultiValueMap.java:229"$1$"		return this.targetMap.equals(obj);"
"LinkedMultiValueMap.java:230"$1$"	}"
"LinkedMultiValueMap.java:231"$0$""
"LinkedMultiValueMap.java:232"$0$"	@Override"
"LinkedMultiValueMap.java:233"$1$"	public int hashCode() {"
"LinkedMultiValueMap.java:234"$1$"		return this.targetMap.hashCode();"
"LinkedMultiValueMap.java:235"$1$"	}"
"LinkedMultiValueMap.java:236"$0$""
"LinkedMultiValueMap.java:237"$0$"	@Override"
"LinkedMultiValueMap.java:238"$1$"	public String toString() {"
"LinkedMultiValueMap.java:239"$1$"		return this.targetMap.toString();"
"LinkedMultiValueMap.java:240"$1$"	}"
"LinkedMultiValueMap.java:241"$0$""
"LinkedMultiValueMap.java:242"$0$"}"
"ResourceRegion.java:1"$0$"/*"
"ResourceRegion.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ResourceRegion.java:3"$0$" *"
"ResourceRegion.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceRegion.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceRegion.java:6"$0$" * You may obtain a copy of the License at"
"ResourceRegion.java:7"$0$" *"
"ResourceRegion.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceRegion.java:9"$0$" *"
"ResourceRegion.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceRegion.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceRegion.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceRegion.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceRegion.java:14"$0$" * limitations under the License."
"ResourceRegion.java:15"$0$" */"
"ResourceRegion.java:16"$0$""
"ResourceRegion.java:17"$0$"package org.springframework.core.io.support;"
"ResourceRegion.java:18"$0$""
"ResourceRegion.java:19"$0$"import org.springframework.core.io.Resource;"
"ResourceRegion.java:20"$0$"import org.springframework.util.Assert;"
"ResourceRegion.java:21"$0$""
"ResourceRegion.java:22"$0$"/**"
"ResourceRegion.java:23"$1$" * Region of a {@link Resource} implementation, materialized by a {@code position}"
"ResourceRegion.java:24"$1$" * within the {@link Resource} and a byte {@code count} for the length of that region."
"ResourceRegion.java:25"$0$" *"
"ResourceRegion.java:26"$0$" * @author Arjen Poutsma"
"ResourceRegion.java:27"$0$" * @since 4.3"
"ResourceRegion.java:28"$0$" */"
"ResourceRegion.java:29"$1$"public class ResourceRegion {"
"ResourceRegion.java:30"$1$""
"ResourceRegion.java:31"$1$"	private final Resource resource;"
"ResourceRegion.java:32"$1$""
"ResourceRegion.java:33"$1$"	private final long position;"
"ResourceRegion.java:34"$1$""
"ResourceRegion.java:35"$1$"	private final long count;"
"ResourceRegion.java:36"$1$""
"ResourceRegion.java:37"$1$""
"ResourceRegion.java:38"$1$"	/**"
"ResourceRegion.java:39"$1$"	 * Create a new {@code ResourceRegion} from a given {@link Resource}."
"ResourceRegion.java:40"$1$"	 * This region of a resource is represented by a start {@code position}"
"ResourceRegion.java:41"$1$"	 * and a byte {@code count} within the given {@code Resource}."
"ResourceRegion.java:42"$1$"	 * @param resource a Resource"
"ResourceRegion.java:43"$1$"	 * @param position the start position of the region in that resource"
"ResourceRegion.java:44"$1$"	 * @param count the byte count of the region in that resource"
"ResourceRegion.java:45"$1$"	 */"
"ResourceRegion.java:46"$1$"	public ResourceRegion(Resource resource, long position, long count) {"
"ResourceRegion.java:47"$1$"		Assert.notNull(resource, ""Resource must not be null"");"
"ResourceRegion.java:48"$1$"		Assert.isTrue(position >= 0, ""'position' must be larger than or equal to 0"");"
"ResourceRegion.java:49"$1$"		Assert.isTrue(count >= 0, ""'count' must be larger than or equal to 0"");"
"ResourceRegion.java:50"$1$"		this.resource = resource;"
"ResourceRegion.java:51"$1$"		this.position = position;"
"ResourceRegion.java:52"$1$"		this.count = count;"
"ResourceRegion.java:53"$1$"	}"
"ResourceRegion.java:54"$0$""
"ResourceRegion.java:55"$0$""
"ResourceRegion.java:56"$0$"	/**"
"ResourceRegion.java:57"$1$"	 * Return the underlying {@link Resource} for this {@code ResourceRegion}."
"ResourceRegion.java:58"$0$"	 */"
"ResourceRegion.java:59"$1$"	public Resource getResource() {"
"ResourceRegion.java:60"$1$"		return this.resource;"
"ResourceRegion.java:61"$1$"	}"
"ResourceRegion.java:62"$0$""
"ResourceRegion.java:63"$0$"	/**"
"ResourceRegion.java:64"$1$"	 * Return the start position of this region in the underlying {@link Resource}."
"ResourceRegion.java:65"$0$"	 */"
"ResourceRegion.java:66"$1$"	public long getPosition() {"
"ResourceRegion.java:67"$1$"		return this.position;"
"ResourceRegion.java:68"$1$"	}"
"ResourceRegion.java:69"$0$""
"ResourceRegion.java:70"$0$"	/**"
"ResourceRegion.java:71"$1$"	 * Return the byte count of this region in the underlying {@link Resource}."
"ResourceRegion.java:72"$0$"	 */"
"ResourceRegion.java:73"$1$"	public long getCount() {"
"ResourceRegion.java:74"$1$"		return this.count;"
"ResourceRegion.java:75"$1$"	}"
"ResourceRegion.java:76"$0$""
"ResourceRegion.java:77"$0$"}"
"StandardAnnotationMetadata.java:1"$0$"/*"
"StandardAnnotationMetadata.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"StandardAnnotationMetadata.java:3"$0$" *"
"StandardAnnotationMetadata.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StandardAnnotationMetadata.java:5"$0$" * you may not use this file except in compliance with the License."
"StandardAnnotationMetadata.java:6"$0$" * You may obtain a copy of the License at"
"StandardAnnotationMetadata.java:7"$0$" *"
"StandardAnnotationMetadata.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StandardAnnotationMetadata.java:9"$0$" *"
"StandardAnnotationMetadata.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StandardAnnotationMetadata.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StandardAnnotationMetadata.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StandardAnnotationMetadata.java:13"$0$" * See the License for the specific language governing permissions and"
"StandardAnnotationMetadata.java:14"$0$" * limitations under the License."
"StandardAnnotationMetadata.java:15"$0$" */"
"StandardAnnotationMetadata.java:16"$0$""
"StandardAnnotationMetadata.java:17"$0$"package org.springframework.core.type;"
"StandardAnnotationMetadata.java:18"$0$""
"StandardAnnotationMetadata.java:19"$0$"import java.lang.annotation.Annotation;"
"StandardAnnotationMetadata.java:20"$0$"import java.lang.reflect.Method;"
"StandardAnnotationMetadata.java:21"$0$"import java.util.Collections;"
"StandardAnnotationMetadata.java:22"$0$"import java.util.LinkedHashSet;"
"StandardAnnotationMetadata.java:23"$0$"import java.util.Map;"
"StandardAnnotationMetadata.java:24"$0$"import java.util.Set;"
"StandardAnnotationMetadata.java:25"$0$""
"StandardAnnotationMetadata.java:26"$0$"import org.springframework.core.annotation.AnnotatedElementUtils;"
"StandardAnnotationMetadata.java:27"$0$"import org.springframework.core.annotation.AnnotationFilter;"
"StandardAnnotationMetadata.java:28"$0$"import org.springframework.core.annotation.AnnotationUtils;"
"StandardAnnotationMetadata.java:29"$0$"import org.springframework.core.annotation.MergedAnnotation;"
"StandardAnnotationMetadata.java:30"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"StandardAnnotationMetadata.java:31"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"StandardAnnotationMetadata.java:32"$0$"import org.springframework.core.annotation.RepeatableContainers;"
"StandardAnnotationMetadata.java:33"$0$"import org.springframework.lang.Nullable;"
"StandardAnnotationMetadata.java:34"$0$"import org.springframework.util.MultiValueMap;"
"StandardAnnotationMetadata.java:35"$0$"import org.springframework.util.ReflectionUtils;"
"StandardAnnotationMetadata.java:36"$0$""
"StandardAnnotationMetadata.java:37"$0$"/**"
"StandardAnnotationMetadata.java:38"$1$" * {@link AnnotationMetadata} implementation that uses standard reflection"
"StandardAnnotationMetadata.java:39"$1$" * to introspect a given {@link Class}."
"StandardAnnotationMetadata.java:40"$0$" *"
"StandardAnnotationMetadata.java:41"$0$" * @author Juergen Hoeller"
"StandardAnnotationMetadata.java:42"$0$" * @author Mark Fisher"
"StandardAnnotationMetadata.java:43"$0$" * @author Chris Beams"
"StandardAnnotationMetadata.java:44"$0$" * @author Phillip Webb"
"StandardAnnotationMetadata.java:45"$0$" * @author Sam Brannen"
"StandardAnnotationMetadata.java:46"$0$" * @since 2.5"
"StandardAnnotationMetadata.java:47"$0$" */"
"StandardAnnotationMetadata.java:48"$1$"public class StandardAnnotationMetadata extends StandardClassMetadata implements AnnotationMetadata {"
"StandardAnnotationMetadata.java:49"$1$""
"StandardAnnotationMetadata.java:50"$1$"	private final MergedAnnotations mergedAnnotations;"
"StandardAnnotationMetadata.java:51"$1$""
"StandardAnnotationMetadata.java:52"$1$"	private final boolean nestedAnnotationsAsMap;"
"StandardAnnotationMetadata.java:53"$1$""
"StandardAnnotationMetadata.java:54"$1$"	@Nullable"
"StandardAnnotationMetadata.java:55"$1$"	private Set<String> annotationTypes;"
"StandardAnnotationMetadata.java:56"$1$""
"StandardAnnotationMetadata.java:57"$1$""
"StandardAnnotationMetadata.java:58"$1$"	/**"
"StandardAnnotationMetadata.java:59"$1$"	 * Create a new {@code StandardAnnotationMetadata} wrapper for the given Class."
"StandardAnnotationMetadata.java:60"$1$"	 * @param introspectedClass the Class to introspect"
"StandardAnnotationMetadata.java:61"$1$"	 * @see #StandardAnnotationMetadata(Class, boolean)"
"StandardAnnotationMetadata.java:62"$1$"	 * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}"
"StandardAnnotationMetadata.java:63"$1$"	 */"
"StandardAnnotationMetadata.java:64"$1$"	@Deprecated"
"StandardAnnotationMetadata.java:65"$1$"	public StandardAnnotationMetadata(Class<?> introspectedClass) {"
"StandardAnnotationMetadata.java:66"$1$"		this(introspectedClass, false);"
"StandardAnnotationMetadata.java:67"$1$"	}"
"StandardAnnotationMetadata.java:68"$0$""
"StandardAnnotationMetadata.java:69"$0$"	/**"
"StandardAnnotationMetadata.java:70"$1$"	 * Create a new {@link StandardAnnotationMetadata} wrapper for the given Class,"
"StandardAnnotationMetadata.java:71"$0$"	 * providing the option to return any nested annotations or annotation arrays in the"
"StandardAnnotationMetadata.java:72"$1$"	 * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead"
"StandardAnnotationMetadata.java:73"$1$"	 * of actual {@link Annotation} instances."
"StandardAnnotationMetadata.java:74"$0$"	 * @param introspectedClass the Class to introspect"
"StandardAnnotationMetadata.java:75"$0$"	 * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as"
"StandardAnnotationMetadata.java:76"$1$"	 * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility"
"StandardAnnotationMetadata.java:77"$1$"	 * with ASM-based {@link AnnotationMetadata} implementations"
"StandardAnnotationMetadata.java:78"$0$"	 * @since 3.1.1"
"StandardAnnotationMetadata.java:79"$1$"	 * @deprecated since 5.2 in favor of the factory method {@link AnnotationMetadata#introspect(Class)}."
"StandardAnnotationMetadata.java:80"$1$"	 * Use {@link MergedAnnotation#asMap(org.springframework.core.annotation.MergedAnnotation.Adapt...) MergedAnnotation.asMap}"
"StandardAnnotationMetadata.java:81"$1$"	 * from {@link #getAnnotations()} rather than {@link #getAnnotationAttributes(String)}"
"StandardAnnotationMetadata.java:82"$1$"	 * if {@code nestedAnnotationsAsMap} is {@code false}"
"StandardAnnotationMetadata.java:83"$0$"	 */"
"StandardAnnotationMetadata.java:84"$0$"	@Deprecated"
"StandardAnnotationMetadata.java:85"$1$"	public StandardAnnotationMetadata(Class<?> introspectedClass, boolean nestedAnnotationsAsMap) {"
"StandardAnnotationMetadata.java:86"$1$"		super(introspectedClass);"
"StandardAnnotationMetadata.java:87"$1$"		this.mergedAnnotations = MergedAnnotations.from(introspectedClass,"
"StandardAnnotationMetadata.java:88"$1$"				SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none(),"
"StandardAnnotationMetadata.java:89"$1$"				AnnotationFilter.NONE);"
"StandardAnnotationMetadata.java:90"$1$"		this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;"
"StandardAnnotationMetadata.java:91"$1$"	}"
"StandardAnnotationMetadata.java:92"$0$""
"StandardAnnotationMetadata.java:93"$0$""
"StandardAnnotationMetadata.java:94"$0$"	@Override"
"StandardAnnotationMetadata.java:95"$1$"	public MergedAnnotations getAnnotations() {"
"StandardAnnotationMetadata.java:96"$1$"		return this.mergedAnnotations;"
"StandardAnnotationMetadata.java:97"$1$"	}"
"StandardAnnotationMetadata.java:98"$0$""
"StandardAnnotationMetadata.java:99"$0$"	@Override"
"StandardAnnotationMetadata.java:100"$1$"	public Set<String> getAnnotationTypes() {"
"StandardAnnotationMetadata.java:101"$1$"		Set<String> annotationTypes = this.annotationTypes;"
"StandardAnnotationMetadata.java:102"$1$"		if (annotationTypes == null) {"
"StandardAnnotationMetadata.java:103"$1$"			annotationTypes = Collections.unmodifiableSet(AnnotationMetadata.super.getAnnotationTypes());"
"StandardAnnotationMetadata.java:104"$1$"			this.annotationTypes = annotationTypes;"
"StandardAnnotationMetadata.java:105"$1$"		}"
"StandardAnnotationMetadata.java:106"$0$"		return annotationTypes;"
"StandardAnnotationMetadata.java:107"$0$"	}"
"StandardAnnotationMetadata.java:108"$0$""
"StandardAnnotationMetadata.java:109"$0$"	@Override"
"StandardAnnotationMetadata.java:110"$0$"	@Nullable"
"StandardAnnotationMetadata.java:111"$1$"	public Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"StandardAnnotationMetadata.java:112"$1$"		if (this.nestedAnnotationsAsMap) {"
"StandardAnnotationMetadata.java:113"$1$"			return AnnotationMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);"
"StandardAnnotationMetadata.java:114"$1$"		}"
"StandardAnnotationMetadata.java:115"$0$"		return AnnotatedElementUtils.getMergedAnnotationAttributes("
"StandardAnnotationMetadata.java:116"$0$"				getIntrospectedClass(), annotationName, classValuesAsString, false);"
"StandardAnnotationMetadata.java:117"$0$"	}"
"StandardAnnotationMetadata.java:118"$0$""
"StandardAnnotationMetadata.java:119"$0$"	@Override"
"StandardAnnotationMetadata.java:120"$0$"	@Nullable"
"StandardAnnotationMetadata.java:121"$1$"	public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"StandardAnnotationMetadata.java:122"$1$"		if (this.nestedAnnotationsAsMap) {"
"StandardAnnotationMetadata.java:123"$1$"			return AnnotationMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);"
"StandardAnnotationMetadata.java:124"$1$"		}"
"StandardAnnotationMetadata.java:125"$0$"		return AnnotatedElementUtils.getAllAnnotationAttributes("
"StandardAnnotationMetadata.java:126"$0$"				getIntrospectedClass(), annotationName, classValuesAsString, false);"
"StandardAnnotationMetadata.java:127"$0$"	}"
"StandardAnnotationMetadata.java:128"$0$""
"StandardAnnotationMetadata.java:129"$0$"	@Override"
"StandardAnnotationMetadata.java:130"$1$"	public boolean hasAnnotatedMethods(String annotationName) {"
"StandardAnnotationMetadata.java:131"$1$"		if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {"
"StandardAnnotationMetadata.java:132"$1$"			try {"
"StandardAnnotationMetadata.java:133"$1$"				Method[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());"
"StandardAnnotationMetadata.java:134"$1$"				for (Method method : methods) {"
"StandardAnnotationMetadata.java:135"$1$"					if (isAnnotatedMethod(method, annotationName)) {"
"StandardAnnotationMetadata.java:136"$1$"						return true;"
"StandardAnnotationMetadata.java:137"$1$"					}"
"StandardAnnotationMetadata.java:138"$0$"				}"
"StandardAnnotationMetadata.java:139"$0$"			}"
"StandardAnnotationMetadata.java:140"$1$"			catch (Throwable ex) {"
"StandardAnnotationMetadata.java:141"$1$"				throw new IllegalStateException(""Failed to introspect annotated methods on "" + getIntrospectedClass(), ex);"
"StandardAnnotationMetadata.java:142"$1$"			}"
"StandardAnnotationMetadata.java:143"$0$"		}"
"StandardAnnotationMetadata.java:144"$0$"		return false;"
"StandardAnnotationMetadata.java:145"$0$"	}"
"StandardAnnotationMetadata.java:146"$0$""
"StandardAnnotationMetadata.java:147"$0$"	@Override"
"StandardAnnotationMetadata.java:148"$0$"	@SuppressWarnings(""deprecation"")"
"StandardAnnotationMetadata.java:149"$1$"	public Set<MethodMetadata> getAnnotatedMethods(String annotationName) {"
"StandardAnnotationMetadata.java:150"$1$"		Set<MethodMetadata> annotatedMethods = null;"
"StandardAnnotationMetadata.java:151"$1$"		if (AnnotationUtils.isCandidateClass(getIntrospectedClass(), annotationName)) {"
"StandardAnnotationMetadata.java:152"$1$"			try {"
"StandardAnnotationMetadata.java:153"$1$"				Method[] methods = ReflectionUtils.getDeclaredMethods(getIntrospectedClass());"
"StandardAnnotationMetadata.java:154"$1$"				for (Method method : methods) {"
"StandardAnnotationMetadata.java:155"$1$"					if (isAnnotatedMethod(method, annotationName)) {"
"StandardAnnotationMetadata.java:156"$1$"						if (annotatedMethods == null) {"
"StandardAnnotationMetadata.java:157"$1$"							annotatedMethods = new LinkedHashSet<>(4);"
"StandardAnnotationMetadata.java:158"$1$"						}"
"StandardAnnotationMetadata.java:159"$0$"						annotatedMethods.add(new StandardMethodMetadata(method, this.nestedAnnotationsAsMap));"
"StandardAnnotationMetadata.java:160"$0$"					}"
"StandardAnnotationMetadata.java:161"$0$"				}"
"StandardAnnotationMetadata.java:162"$0$"			}"
"StandardAnnotationMetadata.java:163"$1$"			catch (Throwable ex) {"
"StandardAnnotationMetadata.java:164"$1$"				throw new IllegalStateException(""Failed to introspect annotated methods on "" + getIntrospectedClass(), ex);"
"StandardAnnotationMetadata.java:165"$1$"			}"
"StandardAnnotationMetadata.java:166"$0$"		}"
"StandardAnnotationMetadata.java:167"$0$"		return annotatedMethods != null ? annotatedMethods : Collections.emptySet();"
"StandardAnnotationMetadata.java:168"$0$"	}"
"StandardAnnotationMetadata.java:169"$0$""
"StandardAnnotationMetadata.java:170"$1$"	private boolean isAnnotatedMethod(Method method, String annotationName) {"
"StandardAnnotationMetadata.java:171"$1$"		return !method.isBridge() && method.getAnnotations().length > 0 &&"
"StandardAnnotationMetadata.java:172"$1$"				AnnotatedElementUtils.isAnnotated(method, annotationName);"
"StandardAnnotationMetadata.java:173"$1$"	}"
"StandardAnnotationMetadata.java:174"$0$""
"StandardAnnotationMetadata.java:175"$0$""
"StandardAnnotationMetadata.java:176"$1$"	static AnnotationMetadata from(Class<?> introspectedClass) {"
"StandardAnnotationMetadata.java:177"$1$"		return new StandardAnnotationMetadata(introspectedClass, true);"
"StandardAnnotationMetadata.java:178"$1$"	}"
"StandardAnnotationMetadata.java:179"$0$""
"StandardAnnotationMetadata.java:180"$0$"}"
"ByteBufferDecoder.java:1"$0$"/*"
"ByteBufferDecoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ByteBufferDecoder.java:3"$0$" *"
"ByteBufferDecoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ByteBufferDecoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ByteBufferDecoder.java:6"$0$" * You may obtain a copy of the License at"
"ByteBufferDecoder.java:7"$0$" *"
"ByteBufferDecoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ByteBufferDecoder.java:9"$0$" *"
"ByteBufferDecoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ByteBufferDecoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ByteBufferDecoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ByteBufferDecoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ByteBufferDecoder.java:14"$0$" * limitations under the License."
"ByteBufferDecoder.java:15"$0$" */"
"ByteBufferDecoder.java:16"$0$""
"ByteBufferDecoder.java:17"$0$"package org.springframework.core.codec;"
"ByteBufferDecoder.java:18"$0$""
"ByteBufferDecoder.java:19"$0$"import java.nio.ByteBuffer;"
"ByteBufferDecoder.java:20"$0$"import java.util.Map;"
"ByteBufferDecoder.java:21"$0$""
"ByteBufferDecoder.java:22"$0$"import org.springframework.core.ResolvableType;"
"ByteBufferDecoder.java:23"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ByteBufferDecoder.java:24"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"ByteBufferDecoder.java:25"$0$"import org.springframework.lang.Nullable;"
"ByteBufferDecoder.java:26"$0$"import org.springframework.util.MimeType;"
"ByteBufferDecoder.java:27"$0$"import org.springframework.util.MimeTypeUtils;"
"ByteBufferDecoder.java:28"$0$""
"ByteBufferDecoder.java:29"$0$"/**"
"ByteBufferDecoder.java:30"$1$" * Decoder for {@link ByteBuffer ByteBuffers}."
"ByteBufferDecoder.java:31"$0$" *"
"ByteBufferDecoder.java:32"$0$" * @author Sebastien Deleuze"
"ByteBufferDecoder.java:33"$0$" * @author Arjen Poutsma"
"ByteBufferDecoder.java:34"$0$" * @author Rossen Stoyanchev"
"ByteBufferDecoder.java:35"$0$" * @since 5.0"
"ByteBufferDecoder.java:36"$0$" */"
"ByteBufferDecoder.java:37"$1$"public class ByteBufferDecoder extends AbstractDataBufferDecoder<ByteBuffer> {"
"ByteBufferDecoder.java:38"$1$""
"ByteBufferDecoder.java:39"$1$"	public ByteBufferDecoder() {"
"ByteBufferDecoder.java:40"$1$"		super(MimeTypeUtils.ALL);"
"ByteBufferDecoder.java:41"$1$"	}"
"ByteBufferDecoder.java:42"$0$""
"ByteBufferDecoder.java:43"$0$""
"ByteBufferDecoder.java:44"$0$"	@Override"
"ByteBufferDecoder.java:45"$1$"	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ByteBufferDecoder.java:46"$1$"		return (ByteBuffer.class.isAssignableFrom(elementType.toClass()) &&"
"ByteBufferDecoder.java:47"$1$"				super.canDecode(elementType, mimeType));"
"ByteBufferDecoder.java:48"$1$"	}"
"ByteBufferDecoder.java:49"$0$""
"ByteBufferDecoder.java:50"$0$"	@Override"
"ByteBufferDecoder.java:51"$0$"	public ByteBuffer decode(DataBuffer dataBuffer, ResolvableType elementType,"
"ByteBufferDecoder.java:52"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ByteBufferDecoder.java:53"$1$""
"ByteBufferDecoder.java:54"$1$"		int byteCount = dataBuffer.readableByteCount();"
"ByteBufferDecoder.java:55"$1$"		ByteBuffer copy = ByteBuffer.allocate(byteCount);"
"ByteBufferDecoder.java:56"$1$"		copy.put(dataBuffer.asByteBuffer());"
"ByteBufferDecoder.java:57"$1$"		copy.flip();"
"ByteBufferDecoder.java:58"$1$"		DataBufferUtils.release(dataBuffer);"
"ByteBufferDecoder.java:59"$1$"		if (logger.isDebugEnabled()) {"
"ByteBufferDecoder.java:60"$1$"			logger.debug(Hints.getLogPrefix(hints) + ""Read "" + byteCount + "" bytes"");"
"ByteBufferDecoder.java:61"$1$"		}"
"ByteBufferDecoder.java:62"$0$"		return copy;"
"ByteBufferDecoder.java:63"$0$"	}"
"ByteBufferDecoder.java:64"$0$""
"ByteBufferDecoder.java:65"$0$"}"
"ResourcePropertySource.java:1"$0$"/*"
"ResourcePropertySource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ResourcePropertySource.java:3"$0$" *"
"ResourcePropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourcePropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourcePropertySource.java:6"$0$" * You may obtain a copy of the License at"
"ResourcePropertySource.java:7"$0$" *"
"ResourcePropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourcePropertySource.java:9"$0$" *"
"ResourcePropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourcePropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourcePropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourcePropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourcePropertySource.java:14"$0$" * limitations under the License."
"ResourcePropertySource.java:15"$0$" */"
"ResourcePropertySource.java:16"$0$""
"ResourcePropertySource.java:17"$0$"package org.springframework.core.io.support;"
"ResourcePropertySource.java:18"$0$""
"ResourcePropertySource.java:19"$0$"import java.io.IOException;"
"ResourcePropertySource.java:20"$0$"import java.util.Map;"
"ResourcePropertySource.java:21"$0$"import java.util.Properties;"
"ResourcePropertySource.java:22"$0$""
"ResourcePropertySource.java:23"$0$"import org.springframework.core.env.PropertiesPropertySource;"
"ResourcePropertySource.java:24"$0$"import org.springframework.core.io.DefaultResourceLoader;"
"ResourcePropertySource.java:25"$0$"import org.springframework.core.io.Resource;"
"ResourcePropertySource.java:26"$0$"import org.springframework.lang.Nullable;"
"ResourcePropertySource.java:27"$0$"import org.springframework.util.StringUtils;"
"ResourcePropertySource.java:28"$0$""
"ResourcePropertySource.java:29"$0$"/**"
"ResourcePropertySource.java:30"$1$" * Subclass of {@link PropertiesPropertySource} that loads a {@link Properties} object"
"ResourcePropertySource.java:31"$1$" * from a given {@link org.springframework.core.io.Resource} or resource location such as"
"ResourcePropertySource.java:32"$1$" * {@code ""classpath:/com/myco/foo.properties""} or {@code ""file:/path/to/file.xml""}."
"ResourcePropertySource.java:33"$0$" *"
"ResourcePropertySource.java:34"$0$" * <p>Both traditional and XML-based properties file formats are supported; however, in"
"ResourcePropertySource.java:35"$1$" * order for XML processing to take effect, the underlying {@code Resource}'s"
"ResourcePropertySource.java:36"$1$" * {@link org.springframework.core.io.Resource#getFilename() getFilename()} method must"
"ResourcePropertySource.java:37"$1$" * return a non-{@code null} value that ends in {@code "".xml""}."
"ResourcePropertySource.java:38"$0$" *"
"ResourcePropertySource.java:39"$0$" * @author Chris Beams"
"ResourcePropertySource.java:40"$0$" * @author Juergen Hoeller"
"ResourcePropertySource.java:41"$0$" * @since 3.1"
"ResourcePropertySource.java:42"$0$" * @see org.springframework.core.io.Resource"
"ResourcePropertySource.java:43"$0$" * @see org.springframework.core.io.support.EncodedResource"
"ResourcePropertySource.java:44"$0$" */"
"ResourcePropertySource.java:45"$1$"public class ResourcePropertySource extends PropertiesPropertySource {"
"ResourcePropertySource.java:46"$1$""
"ResourcePropertySource.java:47"$1$"	/** The original resource name, if different from the given name. */"
"ResourcePropertySource.java:48"$1$"	@Nullable"
"ResourcePropertySource.java:49"$1$"	private final String resourceName;"
"ResourcePropertySource.java:50"$1$""
"ResourcePropertySource.java:51"$1$""
"ResourcePropertySource.java:52"$1$"	/**"
"ResourcePropertySource.java:53"$1$"	 * Create a PropertySource having the given name based on Properties"
"ResourcePropertySource.java:54"$1$"	 * loaded from the given encoded resource."
"ResourcePropertySource.java:55"$1$"	 */"
"ResourcePropertySource.java:56"$1$"	public ResourcePropertySource(String name, EncodedResource resource) throws IOException {"
"ResourcePropertySource.java:57"$1$"		super(name, PropertiesLoaderUtils.loadProperties(resource));"
"ResourcePropertySource.java:58"$1$"		this.resourceName = getNameForResource(resource.getResource());"
"ResourcePropertySource.java:59"$1$"	}"
"ResourcePropertySource.java:60"$0$""
"ResourcePropertySource.java:61"$0$"	/**"
"ResourcePropertySource.java:62"$0$"	 * Create a PropertySource based on Properties loaded from the given resource."
"ResourcePropertySource.java:63"$0$"	 * The name of the PropertySource will be generated based on the"
"ResourcePropertySource.java:64"$1$"	 * {@link Resource#getDescription() description} of the given resource."
"ResourcePropertySource.java:65"$0$"	 */"
"ResourcePropertySource.java:66"$1$"	public ResourcePropertySource(EncodedResource resource) throws IOException {"
"ResourcePropertySource.java:67"$1$"		super(getNameForResource(resource.getResource()), PropertiesLoaderUtils.loadProperties(resource));"
"ResourcePropertySource.java:68"$1$"		this.resourceName = null;"
"ResourcePropertySource.java:69"$1$"	}"
"ResourcePropertySource.java:70"$0$""
"ResourcePropertySource.java:71"$0$"	/**"
"ResourcePropertySource.java:72"$0$"	 * Create a PropertySource having the given name based on Properties"
"ResourcePropertySource.java:73"$0$"	 * loaded from the given encoded resource."
"ResourcePropertySource.java:74"$0$"	 */"
"ResourcePropertySource.java:75"$1$"	public ResourcePropertySource(String name, Resource resource) throws IOException {"
"ResourcePropertySource.java:76"$1$"		super(name, PropertiesLoaderUtils.loadProperties(new EncodedResource(resource)));"
"ResourcePropertySource.java:77"$1$"		this.resourceName = getNameForResource(resource);"
"ResourcePropertySource.java:78"$1$"	}"
"ResourcePropertySource.java:79"$0$""
"ResourcePropertySource.java:80"$0$"	/**"
"ResourcePropertySource.java:81"$0$"	 * Create a PropertySource based on Properties loaded from the given resource."
"ResourcePropertySource.java:82"$0$"	 * The name of the PropertySource will be generated based on the"
"ResourcePropertySource.java:83"$1$"	 * {@link Resource#getDescription() description} of the given resource."
"ResourcePropertySource.java:84"$0$"	 */"
"ResourcePropertySource.java:85"$1$"	public ResourcePropertySource(Resource resource) throws IOException {"
"ResourcePropertySource.java:86"$1$"		super(getNameForResource(resource), PropertiesLoaderUtils.loadProperties(new EncodedResource(resource)));"
"ResourcePropertySource.java:87"$1$"		this.resourceName = null;"
"ResourcePropertySource.java:88"$1$"	}"
"ResourcePropertySource.java:89"$0$""
"ResourcePropertySource.java:90"$0$"	/**"
"ResourcePropertySource.java:91"$0$"	 * Create a PropertySource having the given name based on Properties loaded from"
"ResourcePropertySource.java:92"$0$"	 * the given resource location and using the given class loader to load the"
"ResourcePropertySource.java:93"$1$"	 * resource (assuming it is prefixed with {@code classpath:})."
"ResourcePropertySource.java:94"$0$"	 */"
"ResourcePropertySource.java:95"$1$"	public ResourcePropertySource(String name, String location, ClassLoader classLoader) throws IOException {"
"ResourcePropertySource.java:96"$1$"		this(name, new DefaultResourceLoader(classLoader).getResource(location));"
"ResourcePropertySource.java:97"$1$"	}"
"ResourcePropertySource.java:98"$0$""
"ResourcePropertySource.java:99"$0$"	/**"
"ResourcePropertySource.java:100"$0$"	 * Create a PropertySource based on Properties loaded from the given resource"
"ResourcePropertySource.java:101"$0$"	 * location and use the given class loader to load the resource, assuming it is"
"ResourcePropertySource.java:102"$1$"	 * prefixed with {@code classpath:}. The name of the PropertySource will be"
"ResourcePropertySource.java:103"$1$"	 * generated based on the {@link Resource#getDescription() description} of the"
"ResourcePropertySource.java:104"$0$"	 * resource."
"ResourcePropertySource.java:105"$0$"	 */"
"ResourcePropertySource.java:106"$1$"	public ResourcePropertySource(String location, ClassLoader classLoader) throws IOException {"
"ResourcePropertySource.java:107"$1$"		this(new DefaultResourceLoader(classLoader).getResource(location));"
"ResourcePropertySource.java:108"$1$"	}"
"ResourcePropertySource.java:109"$0$""
"ResourcePropertySource.java:110"$0$"	/**"
"ResourcePropertySource.java:111"$0$"	 * Create a PropertySource having the given name based on Properties loaded from"
"ResourcePropertySource.java:112"$0$"	 * the given resource location. The default thread context class loader will be"
"ResourcePropertySource.java:113"$0$"	 * used to load the resource (assuming the location string is prefixed with"
"ResourcePropertySource.java:114"$1$"	 * {@code classpath:}."
"ResourcePropertySource.java:115"$0$"	 */"
"ResourcePropertySource.java:116"$1$"	public ResourcePropertySource(String name, String location) throws IOException {"
"ResourcePropertySource.java:117"$1$"		this(name, new DefaultResourceLoader().getResource(location));"
"ResourcePropertySource.java:118"$1$"	}"
"ResourcePropertySource.java:119"$0$""
"ResourcePropertySource.java:120"$0$"	/**"
"ResourcePropertySource.java:121"$0$"	 * Create a PropertySource based on Properties loaded from the given resource"
"ResourcePropertySource.java:122"$0$"	 * location. The name of the PropertySource will be generated based on the"
"ResourcePropertySource.java:123"$1$"	 * {@link Resource#getDescription() description} of the resource."
"ResourcePropertySource.java:124"$0$"	 */"
"ResourcePropertySource.java:125"$1$"	public ResourcePropertySource(String location) throws IOException {"
"ResourcePropertySource.java:126"$1$"		this(new DefaultResourceLoader().getResource(location));"
"ResourcePropertySource.java:127"$1$"	}"
"ResourcePropertySource.java:128"$0$""
"ResourcePropertySource.java:129"$1$"	private ResourcePropertySource(String name, @Nullable String resourceName, Map<String, Object> source) {"
"ResourcePropertySource.java:130"$1$"		super(name, source);"
"ResourcePropertySource.java:131"$1$"		this.resourceName = resourceName;"
"ResourcePropertySource.java:132"$1$"	}"
"ResourcePropertySource.java:133"$0$""
"ResourcePropertySource.java:134"$0$""
"ResourcePropertySource.java:135"$0$"	/**"
"ResourcePropertySource.java:136"$1$"	 * Return a potentially adapted variant of this {@link ResourcePropertySource},"
"ResourcePropertySource.java:137"$0$"	 * overriding the previously given (or derived) name with the specified name."
"ResourcePropertySource.java:138"$0$"	 * @since 4.0.4"
"ResourcePropertySource.java:139"$0$"	 */"
"ResourcePropertySource.java:140"$1$"	public ResourcePropertySource withName(String name) {"
"ResourcePropertySource.java:141"$1$"		if (this.name.equals(name)) {"
"ResourcePropertySource.java:142"$1$"			return this;"
"ResourcePropertySource.java:143"$1$"		}"
"ResourcePropertySource.java:144"$0$"		// Store the original resource name if necessary..."
"ResourcePropertySource.java:145"$1$"		if (this.resourceName != null) {"
"ResourcePropertySource.java:146"$1$"			if (this.resourceName.equals(name)) {"
"ResourcePropertySource.java:147"$1$"				return new ResourcePropertySource(this.resourceName, null, this.source);"
"ResourcePropertySource.java:148"$1$"			}"
"ResourcePropertySource.java:149"$1$"			else {"
"ResourcePropertySource.java:150"$1$"				return new ResourcePropertySource(name, this.resourceName, this.source);"
"ResourcePropertySource.java:151"$1$"			}"
"ResourcePropertySource.java:152"$0$"		}"
"ResourcePropertySource.java:153"$1$"		else {"
"ResourcePropertySource.java:154"$0$"			// Current name is resource name -> preserve it in the extra field..."
"ResourcePropertySource.java:155"$1$"			return new ResourcePropertySource(name, this.name, this.source);"
"ResourcePropertySource.java:156"$1$"		}"
"ResourcePropertySource.java:157"$0$"	}"
"ResourcePropertySource.java:158"$0$""
"ResourcePropertySource.java:159"$0$"	/**"
"ResourcePropertySource.java:160"$1$"	 * Return a potentially adapted variant of this {@link ResourcePropertySource},"
"ResourcePropertySource.java:161"$0$"	 * overriding the previously given name (if any) with the original resource name"
"ResourcePropertySource.java:162"$0$"	 * (equivalent to the name generated by the name-less constructor variants)."
"ResourcePropertySource.java:163"$0$"	 * @since 4.1"
"ResourcePropertySource.java:164"$0$"	 */"
"ResourcePropertySource.java:165"$1$"	public ResourcePropertySource withResourceName() {"
"ResourcePropertySource.java:166"$1$"		if (this.resourceName == null) {"
"ResourcePropertySource.java:167"$1$"			return this;"
"ResourcePropertySource.java:168"$1$"		}"
"ResourcePropertySource.java:169"$0$"		return new ResourcePropertySource(this.resourceName, null, this.source);"
"ResourcePropertySource.java:170"$0$"	}"
"ResourcePropertySource.java:171"$0$""
"ResourcePropertySource.java:172"$0$""
"ResourcePropertySource.java:173"$0$"	/**"
"ResourcePropertySource.java:174"$0$"	 * Return the description for the given Resource; if the description is"
"ResourcePropertySource.java:175"$0$"	 * empty, return the class name of the resource plus its identity hash code."
"ResourcePropertySource.java:176"$0$"	 * @see org.springframework.core.io.Resource#getDescription()"
"ResourcePropertySource.java:177"$0$"	 */"
"ResourcePropertySource.java:178"$1$"	private static String getNameForResource(Resource resource) {"
"ResourcePropertySource.java:179"$1$"		String name = resource.getDescription();"
"ResourcePropertySource.java:180"$1$"		if (!StringUtils.hasText(name)) {"
"ResourcePropertySource.java:181"$1$"			name = resource.getClass().getSimpleName() + ""@"" + System.identityHashCode(resource);"
"ResourcePropertySource.java:182"$1$"		}"
"ResourcePropertySource.java:183"$0$"		return name;"
"ResourcePropertySource.java:184"$0$"	}"
"ResourcePropertySource.java:185"$0$""
"ResourcePropertySource.java:186"$0$"}"
"TransformerUtils.java:1"$0$"/*"
"TransformerUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"TransformerUtils.java:3"$0$" *"
"TransformerUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"TransformerUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"TransformerUtils.java:6"$0$" * You may obtain a copy of the License at"
"TransformerUtils.java:7"$0$" *"
"TransformerUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"TransformerUtils.java:9"$0$" *"
"TransformerUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"TransformerUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"TransformerUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"TransformerUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"TransformerUtils.java:14"$0$" * limitations under the License."
"TransformerUtils.java:15"$0$" */"
"TransformerUtils.java:16"$0$""
"TransformerUtils.java:17"$0$"package org.springframework.util.xml;"
"TransformerUtils.java:18"$0$""
"TransformerUtils.java:19"$0$"import javax.xml.transform.OutputKeys;"
"TransformerUtils.java:20"$0$"import javax.xml.transform.Transformer;"
"TransformerUtils.java:21"$0$""
"TransformerUtils.java:22"$0$"import org.springframework.util.Assert;"
"TransformerUtils.java:23"$0$""
"TransformerUtils.java:24"$0$"/**"
"TransformerUtils.java:25"$1$" * Contains common behavior relating to {@link javax.xml.transform.Transformer Transformers}"
"TransformerUtils.java:26"$1$" * and the {@code javax.xml.transform} package in general."
"TransformerUtils.java:27"$0$" *"
"TransformerUtils.java:28"$0$" * @author Rick Evans"
"TransformerUtils.java:29"$0$" * @author Juergen Hoeller"
"TransformerUtils.java:30"$0$" * @since 2.5.5"
"TransformerUtils.java:31"$0$" */"
"TransformerUtils.java:32"$1$"public abstract class TransformerUtils {"
"TransformerUtils.java:33"$1$""
"TransformerUtils.java:34"$1$"	/**"
"TransformerUtils.java:35"$1$"	 * The indent amount of characters if {@link #enableIndenting indenting is enabled}."
"TransformerUtils.java:36"$1$"	 * <p>Defaults to ""2""."
"TransformerUtils.java:37"$1$"	 */"
"TransformerUtils.java:38"$1$"	public static final int DEFAULT_INDENT_AMOUNT = 2;"
"TransformerUtils.java:39"$1$""
"TransformerUtils.java:40"$1$""
"TransformerUtils.java:41"$1$"	/**"
"TransformerUtils.java:42"$1$"	 * Enable indenting for the supplied {@link javax.xml.transform.Transformer}."
"TransformerUtils.java:43"$1$"	 * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}"
"TransformerUtils.java:44"$1$"	 * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters."
"TransformerUtils.java:45"$1$"	 * @param transformer the target transformer"
"TransformerUtils.java:46"$1$"	 * @see javax.xml.transform.Transformer#setOutputProperty(String, String)"
"TransformerUtils.java:47"$1$"	 * @see javax.xml.transform.OutputKeys#INDENT"
"TransformerUtils.java:48"$1$"	 */"
"TransformerUtils.java:49"$1$"	public static void enableIndenting(Transformer transformer) {"
"TransformerUtils.java:50"$1$"		enableIndenting(transformer, DEFAULT_INDENT_AMOUNT);"
"TransformerUtils.java:51"$1$"	}"
"TransformerUtils.java:52"$0$""
"TransformerUtils.java:53"$0$"	/**"
"TransformerUtils.java:54"$1$"	 * Enable indenting for the supplied {@link javax.xml.transform.Transformer}."
"TransformerUtils.java:55"$1$"	 * <p>If the underlying XSLT engine is Xalan, then the special output key {@code indent-amount}"
"TransformerUtils.java:56"$1$"	 * will be also be set to a value of {@link #DEFAULT_INDENT_AMOUNT} characters."
"TransformerUtils.java:57"$0$"	 * @param transformer the target transformer"
"TransformerUtils.java:58"$0$"	 * @param indentAmount the size of the indent (2 characters, 3 characters, etc)"
"TransformerUtils.java:59"$0$"	 * @see javax.xml.transform.Transformer#setOutputProperty(String, String)"
"TransformerUtils.java:60"$0$"	 * @see javax.xml.transform.OutputKeys#INDENT"
"TransformerUtils.java:61"$0$"	 */"
"TransformerUtils.java:62"$1$"	public static void enableIndenting(Transformer transformer, int indentAmount) {"
"TransformerUtils.java:63"$1$"		Assert.notNull(transformer, ""Transformer must not be null"");"
"TransformerUtils.java:64"$1$"		if (indentAmount < 0) {"
"TransformerUtils.java:65"$1$"			throw new IllegalArgumentException(""Invalid indent amount (must not be less than zero): "" + indentAmount);"
"TransformerUtils.java:66"$1$"		}"
"TransformerUtils.java:67"$0$"		transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");"
"TransformerUtils.java:68"$1$"		try {"
"TransformerUtils.java:69"$0$"			// Xalan-specific, but this is the most common XSLT engine in any case"
"TransformerUtils.java:70"$1$"			transformer.setOutputProperty(""{http://xml.apache.org/xalan}indent-amount"", String.valueOf(indentAmount));"
"TransformerUtils.java:71"$1$"		}"
"TransformerUtils.java:72"$1$"		catch (IllegalArgumentException ignored) {"
"TransformerUtils.java:73"$1$"		}"
"TransformerUtils.java:74"$0$"	}"
"TransformerUtils.java:75"$0$""
"TransformerUtils.java:76"$0$"	/**"
"TransformerUtils.java:77"$1$"	 * Disable indenting for the supplied {@link javax.xml.transform.Transformer}."
"TransformerUtils.java:78"$0$"	 * @param transformer the target transformer"
"TransformerUtils.java:79"$0$"	 * @see javax.xml.transform.OutputKeys#INDENT"
"TransformerUtils.java:80"$0$"	 */"
"TransformerUtils.java:81"$1$"	public static void disableIndenting(Transformer transformer) {"
"TransformerUtils.java:82"$1$"		Assert.notNull(transformer, ""Transformer must not be null"");"
"TransformerUtils.java:83"$1$"		transformer.setOutputProperty(OutputKeys.INDENT, ""no"");"
"TransformerUtils.java:84"$1$"	}"
"TransformerUtils.java:85"$0$""
"TransformerUtils.java:86"$0$"}"
"AntPathMatcher.java:1"$0$"/*"
"AntPathMatcher.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"AntPathMatcher.java:3"$0$" *"
"AntPathMatcher.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AntPathMatcher.java:5"$0$" * you may not use this file except in compliance with the License."
"AntPathMatcher.java:6"$0$" * You may obtain a copy of the License at"
"AntPathMatcher.java:7"$0$" *"
"AntPathMatcher.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AntPathMatcher.java:9"$0$" *"
"AntPathMatcher.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AntPathMatcher.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AntPathMatcher.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AntPathMatcher.java:13"$0$" * See the License for the specific language governing permissions and"
"AntPathMatcher.java:14"$0$" * limitations under the License."
"AntPathMatcher.java:15"$0$" */"
"AntPathMatcher.java:16"$0$""
"AntPathMatcher.java:17"$0$"package org.springframework.util;"
"AntPathMatcher.java:18"$0$""
"AntPathMatcher.java:19"$0$"import java.util.Comparator;"
"AntPathMatcher.java:20"$0$"import java.util.LinkedHashMap;"
"AntPathMatcher.java:21"$0$"import java.util.LinkedList;"
"AntPathMatcher.java:22"$0$"import java.util.List;"
"AntPathMatcher.java:23"$0$"import java.util.Map;"
"AntPathMatcher.java:24"$0$"import java.util.concurrent.ConcurrentHashMap;"
"AntPathMatcher.java:25"$0$"import java.util.regex.Matcher;"
"AntPathMatcher.java:26"$0$"import java.util.regex.Pattern;"
"AntPathMatcher.java:27"$0$""
"AntPathMatcher.java:28"$0$"import org.springframework.lang.Nullable;"
"AntPathMatcher.java:29"$0$""
"AntPathMatcher.java:30"$0$"/**"
"AntPathMatcher.java:31"$1$" * {@link PathMatcher} implementation for Ant-style path patterns."
"AntPathMatcher.java:32"$0$" *"
"AntPathMatcher.java:33"$0$" * <p>Part of this mapping code has been kindly borrowed from <a href=""https://ant.apache.org"">Apache Ant</a>."
"AntPathMatcher.java:34"$0$" *"
"AntPathMatcher.java:35"$0$" * <p>The mapping matches URLs using the following rules:<br>"
"AntPathMatcher.java:36"$0$" * <ul>"
"AntPathMatcher.java:37"$1$" * <li>{@code ?} matches one character</li>"
"AntPathMatcher.java:38"$1$" * <li>{@code *} matches zero or more characters</li>"
"AntPathMatcher.java:39"$1$" * <li>{@code **} matches zero or more <em>directories</em> in a path</li>"
"AntPathMatcher.java:40"$1$" * <li>{@code {spring:[a-z]+}} matches the regexp {@code [a-z]+} as a path variable named ""spring""</li>"
"AntPathMatcher.java:41"$0$" * </ul>"
"AntPathMatcher.java:42"$0$" *"
"AntPathMatcher.java:43"$0$" * <h3>Examples</h3>"
"AntPathMatcher.java:44"$0$" * <ul>"
"AntPathMatcher.java:45"$1$" * <li>{@code com/t?st.jsp} &mdash; matches {@code com/test.jsp} but also"
"AntPathMatcher.java:46"$1$" * {@code com/tast.jsp} or {@code com/txst.jsp}</li>"
"AntPathMatcher.java:47"$1$" * <li>{@code com/*.jsp} &mdash; matches all {@code .jsp} files in the"
"AntPathMatcher.java:48"$1$" * {@code com} directory</li>"
"AntPathMatcher.java:49"$1$" * <li><code>com/&#42;&#42;/test.jsp</code> &mdash; matches all {@code test.jsp}"
"AntPathMatcher.java:50"$1$" * files underneath the {@code com} path</li>"
"AntPathMatcher.java:51"$0$" * <li><code>org/springframework/&#42;&#42;/*.jsp</code> &mdash; matches all"
"AntPathMatcher.java:52"$1$" * {@code .jsp} files underneath the {@code org/springframework} path</li>"
"AntPathMatcher.java:53"$0$" * <li><code>org/&#42;&#42;/servlet/bla.jsp</code> &mdash; matches"
"AntPathMatcher.java:54"$1$" * {@code org/springframework/servlet/bla.jsp} but also"
"AntPathMatcher.java:55"$1$" * {@code org/springframework/testing/servlet/bla.jsp} and {@code org/servlet/bla.jsp}</li>"
"AntPathMatcher.java:56"$1$" * <li>{@code com/{filename:\\w+}.jsp} will match {@code com/test.jsp} and assign the value {@code test}"
"AntPathMatcher.java:57"$1$" * to the {@code filename} variable</li>"
"AntPathMatcher.java:58"$0$" * </ul>"
"AntPathMatcher.java:59"$0$" *"
"AntPathMatcher.java:60"$0$" * <p><strong>Note:</strong> a pattern and a path must both be absolute or must"
"AntPathMatcher.java:61"$0$" * both be relative in order for the two to match. Therefore it is recommended"
"AntPathMatcher.java:62"$0$" * that users of this implementation to sanitize patterns in order to prefix"
"AntPathMatcher.java:63"$0$" * them with ""/"" as it makes sense in the context in which they're used."
"AntPathMatcher.java:64"$0$" *"
"AntPathMatcher.java:65"$0$" * @author Alef Arendsen"
"AntPathMatcher.java:66"$0$" * @author Juergen Hoeller"
"AntPathMatcher.java:67"$0$" * @author Rob Harrop"
"AntPathMatcher.java:68"$0$" * @author Arjen Poutsma"
"AntPathMatcher.java:69"$0$" * @author Rossen Stoyanchev"
"AntPathMatcher.java:70"$0$" * @author Sam Brannen"
"AntPathMatcher.java:71"$0$" * @since 16.07.2003"
"AntPathMatcher.java:72"$0$" */"
"AntPathMatcher.java:73"$1$"public class AntPathMatcher implements PathMatcher {"
"AntPathMatcher.java:74"$1$""
"AntPathMatcher.java:75"$1$"	/** Default path separator: ""/"". */"
"AntPathMatcher.java:76"$1$"	public static final String DEFAULT_PATH_SEPARATOR = ""/"";"
"AntPathMatcher.java:77"$1$""
"AntPathMatcher.java:78"$1$"	private static final int CACHE_TURNOFF_THRESHOLD = 65536;"
"AntPathMatcher.java:79"$1$""
"AntPathMatcher.java:80"$1$"	private static final Pattern VARIABLE_PATTERN = Pattern.compile(""\\{[^/]+?}"");"
"AntPathMatcher.java:81"$1$""
"AntPathMatcher.java:82"$1$"	private static final char[] WILDCARD_CHARS = { '*', '?', '{' };"
"AntPathMatcher.java:83"$1$""
"AntPathMatcher.java:84"$1$""
"AntPathMatcher.java:85"$1$"	private String pathSeparator;"
"AntPathMatcher.java:86"$1$""
"AntPathMatcher.java:87"$1$"	private PathSeparatorPatternCache pathSeparatorPatternCache;"
"AntPathMatcher.java:88"$1$""
"AntPathMatcher.java:89"$1$"	private boolean caseSensitive = true;"
"AntPathMatcher.java:90"$1$""
"AntPathMatcher.java:91"$1$"	private boolean trimTokens = false;"
"AntPathMatcher.java:92"$1$""
"AntPathMatcher.java:93"$1$"	@Nullable"
"AntPathMatcher.java:94"$1$"	private volatile Boolean cachePatterns;"
"AntPathMatcher.java:95"$1$""
"AntPathMatcher.java:96"$1$"	private final Map<String, String[]> tokenizedPatternCache = new ConcurrentHashMap<>(256);"
"AntPathMatcher.java:97"$1$""
"AntPathMatcher.java:98"$1$"	final Map<String, AntPathStringMatcher> stringMatcherCache = new ConcurrentHashMap<>(256);"
"AntPathMatcher.java:99"$1$""
"AntPathMatcher.java:100"$1$""
"AntPathMatcher.java:101"$1$"	/**"
"AntPathMatcher.java:102"$1$"	 * Create a new instance with the {@link #DEFAULT_PATH_SEPARATOR}."
"AntPathMatcher.java:103"$1$"	 */"
"AntPathMatcher.java:104"$1$"	public AntPathMatcher() {"
"AntPathMatcher.java:105"$1$"		this.pathSeparator = DEFAULT_PATH_SEPARATOR;"
"AntPathMatcher.java:106"$1$"		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(DEFAULT_PATH_SEPARATOR);"
"AntPathMatcher.java:107"$1$"	}"
"AntPathMatcher.java:108"$0$""
"AntPathMatcher.java:109"$0$"	/**"
"AntPathMatcher.java:110"$0$"	 * A convenient, alternative constructor to use with a custom path separator."
"AntPathMatcher.java:111"$1$"	 * @param pathSeparator the path separator to use, must not be {@code null}."
"AntPathMatcher.java:112"$0$"	 * @since 4.1"
"AntPathMatcher.java:113"$0$"	 */"
"AntPathMatcher.java:114"$1$"	public AntPathMatcher(String pathSeparator) {"
"AntPathMatcher.java:115"$1$"		Assert.notNull(pathSeparator, ""'pathSeparator' is required"");"
"AntPathMatcher.java:116"$1$"		this.pathSeparator = pathSeparator;"
"AntPathMatcher.java:117"$1$"		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(pathSeparator);"
"AntPathMatcher.java:118"$1$"	}"
"AntPathMatcher.java:119"$0$""
"AntPathMatcher.java:120"$0$""
"AntPathMatcher.java:121"$0$"	/**"
"AntPathMatcher.java:122"$0$"	 * Set the path separator to use for pattern parsing."
"AntPathMatcher.java:123"$0$"	 * <p>Default is ""/"", as in Ant."
"AntPathMatcher.java:124"$0$"	 */"
"AntPathMatcher.java:125"$1$"	public void setPathSeparator(@Nullable String pathSeparator) {"
"AntPathMatcher.java:126"$1$"		this.pathSeparator = (pathSeparator != null ? pathSeparator : DEFAULT_PATH_SEPARATOR);"
"AntPathMatcher.java:127"$1$"		this.pathSeparatorPatternCache = new PathSeparatorPatternCache(this.pathSeparator);"
"AntPathMatcher.java:128"$1$"	}"
"AntPathMatcher.java:129"$0$""
"AntPathMatcher.java:130"$0$"	/**"
"AntPathMatcher.java:131"$0$"	 * Specify whether to perform pattern matching in a case-sensitive fashion."
"AntPathMatcher.java:132"$1$"	 * <p>Default is {@code true}. Switch this to {@code false} for case-insensitive matching."
"AntPathMatcher.java:133"$0$"	 * @since 4.2"
"AntPathMatcher.java:134"$0$"	 */"
"AntPathMatcher.java:135"$1$"	public void setCaseSensitive(boolean caseSensitive) {"
"AntPathMatcher.java:136"$1$"		this.caseSensitive = caseSensitive;"
"AntPathMatcher.java:137"$1$"	}"
"AntPathMatcher.java:138"$0$""
"AntPathMatcher.java:139"$0$"	/**"
"AntPathMatcher.java:140"$0$"	 * Specify whether to trim tokenized paths and patterns."
"AntPathMatcher.java:141"$1$"	 * <p>Default is {@code false}."
"AntPathMatcher.java:142"$0$"	 */"
"AntPathMatcher.java:143"$1$"	public void setTrimTokens(boolean trimTokens) {"
"AntPathMatcher.java:144"$1$"		this.trimTokens = trimTokens;"
"AntPathMatcher.java:145"$1$"	}"
"AntPathMatcher.java:146"$0$""
"AntPathMatcher.java:147"$0$"	/**"
"AntPathMatcher.java:148"$0$"	 * Specify whether to cache parsed pattern metadata for patterns passed"
"AntPathMatcher.java:149"$1$"	 * into this matcher's {@link #match} method. A value of {@code true}"
"AntPathMatcher.java:150"$1$"	 * activates an unlimited pattern cache; a value of {@code false} turns"
"AntPathMatcher.java:151"$0$"	 * the pattern cache off completely."
"AntPathMatcher.java:152"$0$"	 * <p>Default is for the cache to be on, but with the variant to automatically"
"AntPathMatcher.java:153"$0$"	 * turn it off when encountering too many patterns to cache at runtime"
"AntPathMatcher.java:154"$0$"	 * (the threshold is 65536), assuming that arbitrary permutations of patterns"
"AntPathMatcher.java:155"$0$"	 * are coming in, with little chance for encountering a recurring pattern."
"AntPathMatcher.java:156"$0$"	 * @since 4.0.1"
"AntPathMatcher.java:157"$0$"	 * @see #getStringMatcher(String)"
"AntPathMatcher.java:158"$0$"	 */"
"AntPathMatcher.java:159"$1$"	public void setCachePatterns(boolean cachePatterns) {"
"AntPathMatcher.java:160"$1$"		this.cachePatterns = cachePatterns;"
"AntPathMatcher.java:161"$1$"	}"
"AntPathMatcher.java:162"$0$""
"AntPathMatcher.java:163"$1$"	private void deactivatePatternCache() {"
"AntPathMatcher.java:164"$1$"		this.cachePatterns = false;"
"AntPathMatcher.java:165"$1$"		this.tokenizedPatternCache.clear();"
"AntPathMatcher.java:166"$1$"		this.stringMatcherCache.clear();"
"AntPathMatcher.java:167"$1$"	}"
"AntPathMatcher.java:168"$0$""
"AntPathMatcher.java:169"$0$""
"AntPathMatcher.java:170"$0$"	@Override"
"AntPathMatcher.java:171"$1$"	public boolean isPattern(@Nullable String path) {"
"AntPathMatcher.java:172"$1$"		if (path == null) {"
"AntPathMatcher.java:173"$1$"			return false;"
"AntPathMatcher.java:174"$1$"		}"
"AntPathMatcher.java:175"$0$"		boolean uriVar = false;"
"AntPathMatcher.java:176"$1$"		for (int i = 0; i < path.length(); i++) {"
"AntPathMatcher.java:177"$1$"			char c = path.charAt(i);"
"AntPathMatcher.java:178"$1$"			if (c == '*' || c == '?') {"
"AntPathMatcher.java:179"$1$"				return true;"
"AntPathMatcher.java:180"$1$"			}"
"AntPathMatcher.java:181"$1$"			if (c == '{') {"
"AntPathMatcher.java:182"$1$"				uriVar = true;"
"AntPathMatcher.java:183"$1$"				continue;"
"AntPathMatcher.java:184"$1$"			}"
"AntPathMatcher.java:185"$1$"			if (c == '}' && uriVar) {"
"AntPathMatcher.java:186"$0$"				return true;"
"AntPathMatcher.java:187"$0$"			}"
"AntPathMatcher.java:188"$0$"		}"
"AntPathMatcher.java:189"$0$"		return false;"
"AntPathMatcher.java:190"$0$"	}"
"AntPathMatcher.java:191"$0$""
"AntPathMatcher.java:192"$0$"	@Override"
"AntPathMatcher.java:193"$1$"	public boolean match(String pattern, String path) {"
"AntPathMatcher.java:194"$1$"		return doMatch(pattern, path, true, null);"
"AntPathMatcher.java:195"$1$"	}"
"AntPathMatcher.java:196"$0$""
"AntPathMatcher.java:197"$0$"	@Override"
"AntPathMatcher.java:198"$1$"	public boolean matchStart(String pattern, String path) {"
"AntPathMatcher.java:199"$1$"		return doMatch(pattern, path, false, null);"
"AntPathMatcher.java:200"$1$"	}"
"AntPathMatcher.java:201"$0$""
"AntPathMatcher.java:202"$0$"	/**"
"AntPathMatcher.java:203"$1$"	 * Actually match the given {@code path} against the given {@code pattern}."
"AntPathMatcher.java:204"$0$"	 * @param pattern the pattern to match against"
"AntPathMatcher.java:205"$0$"	 * @param path the path to test"
"AntPathMatcher.java:206"$0$"	 * @param fullMatch whether a full pattern match is required (else a pattern match"
"AntPathMatcher.java:207"$0$"	 * as far as the given base path goes is sufficient)"
"AntPathMatcher.java:208"$1$"	 * @return {@code true} if the supplied {@code path} matched, {@code false} if it didn't"
"AntPathMatcher.java:209"$0$"	 */"
"AntPathMatcher.java:210"$0$"	protected boolean doMatch(String pattern, @Nullable String path, boolean fullMatch,"
"AntPathMatcher.java:211"$1$"			@Nullable Map<String, String> uriTemplateVariables) {"
"AntPathMatcher.java:212"$1$""
"AntPathMatcher.java:213"$1$"		if (path == null || path.startsWith(this.pathSeparator) != pattern.startsWith(this.pathSeparator)) {"
"AntPathMatcher.java:214"$1$"			return false;"
"AntPathMatcher.java:215"$1$"		}"
"AntPathMatcher.java:216"$0$""
"AntPathMatcher.java:217"$0$"		String[] pattDirs = tokenizePattern(pattern);"
"AntPathMatcher.java:218"$1$"		if (fullMatch && this.caseSensitive && !isPotentialMatch(path, pattDirs)) {"
"AntPathMatcher.java:219"$1$"			return false;"
"AntPathMatcher.java:220"$1$"		}"
"AntPathMatcher.java:221"$0$""
"AntPathMatcher.java:222"$0$"		String[] pathDirs = tokenizePath(path);"
"AntPathMatcher.java:223"$0$"		int pattIdxStart = 0;"
"AntPathMatcher.java:224"$0$"		int pattIdxEnd = pattDirs.length - 1;"
"AntPathMatcher.java:225"$0$"		int pathIdxStart = 0;"
"AntPathMatcher.java:226"$0$"		int pathIdxEnd = pathDirs.length - 1;"
"AntPathMatcher.java:227"$0$""
"AntPathMatcher.java:228"$0$"		// Match all elements up to the first **"
"AntPathMatcher.java:229"$1$"		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {"
"AntPathMatcher.java:230"$1$"			String pattDir = pattDirs[pattIdxStart];"
"AntPathMatcher.java:231"$1$"			if (""**"".equals(pattDir)) {"
"AntPathMatcher.java:232"$1$"				break;"
"AntPathMatcher.java:233"$1$"			}"
"AntPathMatcher.java:234"$1$"			if (!matchStrings(pattDir, pathDirs[pathIdxStart], uriTemplateVariables)) {"
"AntPathMatcher.java:235"$1$"				return false;"
"AntPathMatcher.java:236"$1$"			}"
"AntPathMatcher.java:237"$0$"			pattIdxStart++;"
"AntPathMatcher.java:238"$0$"			pathIdxStart++;"
"AntPathMatcher.java:239"$0$"		}"
"AntPathMatcher.java:240"$0$""
"AntPathMatcher.java:241"$1$"		if (pathIdxStart > pathIdxEnd) {"
"AntPathMatcher.java:242"$0$"			// Path is exhausted, only match if rest of pattern is * or **'s"
"AntPathMatcher.java:243"$1$"			if (pattIdxStart > pattIdxEnd) {"
"AntPathMatcher.java:244"$1$"				return (pattern.endsWith(this.pathSeparator) == path.endsWith(this.pathSeparator));"
"AntPathMatcher.java:245"$1$"			}"
"AntPathMatcher.java:246"$1$"			if (!fullMatch) {"
"AntPathMatcher.java:247"$1$"				return true;"
"AntPathMatcher.java:248"$1$"			}"
"AntPathMatcher.java:249"$1$"			if (pattIdxStart == pattIdxEnd && pattDirs[pattIdxStart].equals(""*"") && path.endsWith(this.pathSeparator)) {"
"AntPathMatcher.java:250"$1$"				return true;"
"AntPathMatcher.java:251"$1$"			}"
"AntPathMatcher.java:252"$1$"			for (int i = pattIdxStart; i <= pattIdxEnd; i++) {"
"AntPathMatcher.java:253"$1$"				if (!pattDirs[i].equals(""**"")) {"
"AntPathMatcher.java:254"$1$"					return false;"
"AntPathMatcher.java:255"$1$"				}"
"AntPathMatcher.java:256"$0$"			}"
"AntPathMatcher.java:257"$0$"			return true;"
"AntPathMatcher.java:258"$0$"		}"
"AntPathMatcher.java:259"$1$"		else if (pattIdxStart > pattIdxEnd) {"
"AntPathMatcher.java:260"$0$"			// String not exhausted, but pattern is. Failure."
"AntPathMatcher.java:261"$1$"			return false;"
"AntPathMatcher.java:262"$1$"		}"
"AntPathMatcher.java:263"$1$"		else if (!fullMatch && ""**"".equals(pattDirs[pattIdxStart])) {"
"AntPathMatcher.java:264"$0$"			// Path start definitely matches due to ""**"" part in pattern."
"AntPathMatcher.java:265"$1$"			return true;"
"AntPathMatcher.java:266"$1$"		}"
"AntPathMatcher.java:267"$0$""
"AntPathMatcher.java:268"$0$"		// up to last '**'"
"AntPathMatcher.java:269"$1$"		while (pattIdxStart <= pattIdxEnd && pathIdxStart <= pathIdxEnd) {"
"AntPathMatcher.java:270"$1$"			String pattDir = pattDirs[pattIdxEnd];"
"AntPathMatcher.java:271"$1$"			if (pattDir.equals(""**"")) {"
"AntPathMatcher.java:272"$1$"				break;"
"AntPathMatcher.java:273"$1$"			}"
"AntPathMatcher.java:274"$1$"			if (!matchStrings(pattDir, pathDirs[pathIdxEnd], uriTemplateVariables)) {"
"AntPathMatcher.java:275"$1$"				return false;"
"AntPathMatcher.java:276"$1$"			}"
"AntPathMatcher.java:277"$0$"			pattIdxEnd--;"
"AntPathMatcher.java:278"$0$"			pathIdxEnd--;"
"AntPathMatcher.java:279"$0$"		}"
"AntPathMatcher.java:280"$1$"		if (pathIdxStart > pathIdxEnd) {"
"AntPathMatcher.java:281"$0$"			// String is exhausted"
"AntPathMatcher.java:282"$1$"			for (int i = pattIdxStart; i <= pattIdxEnd; i++) {"
"AntPathMatcher.java:283"$1$"				if (!pattDirs[i].equals(""**"")) {"
"AntPathMatcher.java:284"$1$"					return false;"
"AntPathMatcher.java:285"$1$"				}"
"AntPathMatcher.java:286"$0$"			}"
"AntPathMatcher.java:287"$0$"			return true;"
"AntPathMatcher.java:288"$0$"		}"
"AntPathMatcher.java:289"$0$""
"AntPathMatcher.java:290"$1$"		while (pattIdxStart != pattIdxEnd && pathIdxStart <= pathIdxEnd) {"
"AntPathMatcher.java:291"$1$"			int patIdxTmp = -1;"
"AntPathMatcher.java:292"$1$"			for (int i = pattIdxStart + 1; i <= pattIdxEnd; i++) {"
"AntPathMatcher.java:293"$1$"				if (pattDirs[i].equals(""**"")) {"
"AntPathMatcher.java:294"$1$"					patIdxTmp = i;"
"AntPathMatcher.java:295"$1$"					break;"
"AntPathMatcher.java:296"$1$"				}"
"AntPathMatcher.java:297"$0$"			}"
"AntPathMatcher.java:298"$1$"			if (patIdxTmp == pattIdxStart + 1) {"
"AntPathMatcher.java:299"$0$"				// '**/**' situation, so skip one"
"AntPathMatcher.java:300"$1$"				pattIdxStart++;"
"AntPathMatcher.java:301"$1$"				continue;"
"AntPathMatcher.java:302"$1$"			}"
"AntPathMatcher.java:303"$0$"			// Find the pattern between padIdxStart & padIdxTmp in str between"
"AntPathMatcher.java:304"$0$"			// strIdxStart & strIdxEnd"
"AntPathMatcher.java:305"$0$"			int patLength = (patIdxTmp - pattIdxStart - 1);"
"AntPathMatcher.java:306"$0$"			int strLength = (pathIdxEnd - pathIdxStart + 1);"
"AntPathMatcher.java:307"$0$"			int foundIdx = -1;"
"AntPathMatcher.java:308"$0$""
"AntPathMatcher.java:309"$0$"			strLoop:"
"AntPathMatcher.java:310"$1$"			for (int i = 0; i <= strLength - patLength; i++) {"
"AntPathMatcher.java:311"$1$"				for (int j = 0; j < patLength; j++) {"
"AntPathMatcher.java:312"$1$"					String subPat = pattDirs[pattIdxStart + j + 1];"
"AntPathMatcher.java:313"$1$"					String subStr = pathDirs[pathIdxStart + i + j];"
"AntPathMatcher.java:314"$1$"					if (!matchStrings(subPat, subStr, uriTemplateVariables)) {"
"AntPathMatcher.java:315"$1$"						continue strLoop;"
"AntPathMatcher.java:316"$1$"					}"
"AntPathMatcher.java:317"$0$"				}"
"AntPathMatcher.java:318"$0$"				foundIdx = pathIdxStart + i;"
"AntPathMatcher.java:319"$0$"				break;"
"AntPathMatcher.java:320"$0$"			}"
"AntPathMatcher.java:321"$0$""
"AntPathMatcher.java:322"$1$"			if (foundIdx == -1) {"
"AntPathMatcher.java:323"$1$"				return false;"
"AntPathMatcher.java:324"$1$"			}"
"AntPathMatcher.java:325"$0$""
"AntPathMatcher.java:326"$0$"			pattIdxStart = patIdxTmp;"
"AntPathMatcher.java:327"$0$"			pathIdxStart = foundIdx + patLength;"
"AntPathMatcher.java:328"$0$"		}"
"AntPathMatcher.java:329"$0$""
"AntPathMatcher.java:330"$1$"		for (int i = pattIdxStart; i <= pattIdxEnd; i++) {"
"AntPathMatcher.java:331"$1$"			if (!pattDirs[i].equals(""**"")) {"
"AntPathMatcher.java:332"$1$"				return false;"
"AntPathMatcher.java:333"$1$"			}"
"AntPathMatcher.java:334"$0$"		}"
"AntPathMatcher.java:335"$0$""
"AntPathMatcher.java:336"$0$"		return true;"
"AntPathMatcher.java:337"$0$"	}"
"AntPathMatcher.java:338"$0$""
"AntPathMatcher.java:339"$1$"	private boolean isPotentialMatch(String path, String[] pattDirs) {"
"AntPathMatcher.java:340"$1$"		if (!this.trimTokens) {"
"AntPathMatcher.java:341"$1$"			int pos = 0;"
"AntPathMatcher.java:342"$1$"			for (String pattDir : pattDirs) {"
"AntPathMatcher.java:343"$1$"				int skipped = skipSeparator(path, pos, this.pathSeparator);"
"AntPathMatcher.java:344"$1$"				pos += skipped;"
"AntPathMatcher.java:345"$1$"				skipped = skipSegment(path, pos, pattDir);"
"AntPathMatcher.java:346"$1$"				if (skipped < pattDir.length()) {"
"AntPathMatcher.java:347"$1$"					return (skipped > 0 || (pattDir.length() > 0 && isWildcardChar(pattDir.charAt(0))));"
"AntPathMatcher.java:348"$1$"				}"
"AntPathMatcher.java:349"$0$"				pos += skipped;"
"AntPathMatcher.java:350"$0$"			}"
"AntPathMatcher.java:351"$0$"		}"
"AntPathMatcher.java:352"$0$"		return true;"
"AntPathMatcher.java:353"$0$"	}"
"AntPathMatcher.java:354"$0$""
"AntPathMatcher.java:355"$1$"	private int skipSegment(String path, int pos, String prefix) {"
"AntPathMatcher.java:356"$1$"		int skipped = 0;"
"AntPathMatcher.java:357"$1$"		for (int i = 0; i < prefix.length(); i++) {"
"AntPathMatcher.java:358"$1$"			char c = prefix.charAt(i);"
"AntPathMatcher.java:359"$1$"			if (isWildcardChar(c)) {"
"AntPathMatcher.java:360"$1$"				return skipped;"
"AntPathMatcher.java:361"$1$"			}"
"AntPathMatcher.java:362"$0$"			int currPos = pos + skipped;"
"AntPathMatcher.java:363"$1$"			if (currPos >= path.length()) {"
"AntPathMatcher.java:364"$1$"				return 0;"
"AntPathMatcher.java:365"$1$"			}"
"AntPathMatcher.java:366"$1$"			if (c == path.charAt(currPos)) {"
"AntPathMatcher.java:367"$1$"				skipped++;"
"AntPathMatcher.java:368"$1$"			}"
"AntPathMatcher.java:369"$0$"		}"
"AntPathMatcher.java:370"$0$"		return skipped;"
"AntPathMatcher.java:371"$0$"	}"
"AntPathMatcher.java:372"$0$""
"AntPathMatcher.java:373"$1$"	private int skipSeparator(String path, int pos, String separator) {"
"AntPathMatcher.java:374"$1$"		int skipped = 0;"
"AntPathMatcher.java:375"$1$"		while (path.startsWith(separator, pos + skipped)) {"
"AntPathMatcher.java:376"$1$"			skipped += separator.length();"
"AntPathMatcher.java:377"$1$"		}"
"AntPathMatcher.java:378"$0$"		return skipped;"
"AntPathMatcher.java:379"$0$"	}"
"AntPathMatcher.java:380"$0$""
"AntPathMatcher.java:381"$1$"	private boolean isWildcardChar(char c) {"
"AntPathMatcher.java:382"$1$"		for (char candidate : WILDCARD_CHARS) {"
"AntPathMatcher.java:383"$1$"			if (c == candidate) {"
"AntPathMatcher.java:384"$1$"				return true;"
"AntPathMatcher.java:385"$1$"			}"
"AntPathMatcher.java:386"$0$"		}"
"AntPathMatcher.java:387"$0$"		return false;"
"AntPathMatcher.java:388"$0$"	}"
"AntPathMatcher.java:389"$0$""
"AntPathMatcher.java:390"$0$"	/**"
"AntPathMatcher.java:391"$0$"	 * Tokenize the given path pattern into parts, based on this matcher's settings."
"AntPathMatcher.java:392"$1$"	 * <p>Performs caching based on {@link #setCachePatterns}, delegating to"
"AntPathMatcher.java:393"$1$"	 * {@link #tokenizePath(String)} for the actual tokenization algorithm."
"AntPathMatcher.java:394"$0$"	 * @param pattern the pattern to tokenize"
"AntPathMatcher.java:395"$0$"	 * @return the tokenized pattern parts"
"AntPathMatcher.java:396"$0$"	 */"
"AntPathMatcher.java:397"$1$"	protected String[] tokenizePattern(String pattern) {"
"AntPathMatcher.java:398"$1$"		String[] tokenized = null;"
"AntPathMatcher.java:399"$1$"		Boolean cachePatterns = this.cachePatterns;"
"AntPathMatcher.java:400"$1$"		if (cachePatterns == null || cachePatterns.booleanValue()) {"
"AntPathMatcher.java:401"$1$"			tokenized = this.tokenizedPatternCache.get(pattern);"
"AntPathMatcher.java:402"$1$"		}"
"AntPathMatcher.java:403"$1$"		if (tokenized == null) {"
"AntPathMatcher.java:404"$1$"			tokenized = tokenizePath(pattern);"
"AntPathMatcher.java:405"$1$"			if (cachePatterns == null && this.tokenizedPatternCache.size() >= CACHE_TURNOFF_THRESHOLD) {"
"AntPathMatcher.java:406"$0$"				// Try to adapt to the runtime situation that we're encountering:"
"AntPathMatcher.java:407"$0$"				// There are obviously too many different patterns coming in here..."
"AntPathMatcher.java:408"$0$"				// So let's turn off the cache since the patterns are unlikely to be reoccurring."
"AntPathMatcher.java:409"$1$"				deactivatePatternCache();"
"AntPathMatcher.java:410"$1$"				return tokenized;"
"AntPathMatcher.java:411"$1$"			}"
"AntPathMatcher.java:412"$1$"			if (cachePatterns == null || cachePatterns.booleanValue()) {"
"AntPathMatcher.java:413"$1$"				this.tokenizedPatternCache.put(pattern, tokenized);"
"AntPathMatcher.java:414"$1$"			}"
"AntPathMatcher.java:415"$0$"		}"
"AntPathMatcher.java:416"$0$"		return tokenized;"
"AntPathMatcher.java:417"$0$"	}"
"AntPathMatcher.java:418"$0$""
"AntPathMatcher.java:419"$0$"	/**"
"AntPathMatcher.java:420"$0$"	 * Tokenize the given path into parts, based on this matcher's settings."
"AntPathMatcher.java:421"$0$"	 * @param path the path to tokenize"
"AntPathMatcher.java:422"$0$"	 * @return the tokenized path parts"
"AntPathMatcher.java:423"$0$"	 */"
"AntPathMatcher.java:424"$1$"	protected String[] tokenizePath(String path) {"
"AntPathMatcher.java:425"$1$"		return StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);"
"AntPathMatcher.java:426"$1$"	}"
"AntPathMatcher.java:427"$0$""
"AntPathMatcher.java:428"$0$"	/**"
"AntPathMatcher.java:429"$0$"	 * Test whether or not a string matches against a pattern."
"AntPathMatcher.java:430"$1$"	 * @param pattern the pattern to match against (never {@code null})"
"AntPathMatcher.java:431"$1$"	 * @param str the String which must be matched against the pattern (never {@code null})"
"AntPathMatcher.java:432"$1$"	 * @return {@code true} if the string matches against the pattern, or {@code false} otherwise"
"AntPathMatcher.java:433"$0$"	 */"
"AntPathMatcher.java:434"$0$"	private boolean matchStrings(String pattern, String str,"
"AntPathMatcher.java:435"$1$"			@Nullable Map<String, String> uriTemplateVariables) {"
"AntPathMatcher.java:436"$1$""
"AntPathMatcher.java:437"$1$"		return getStringMatcher(pattern).matchStrings(str, uriTemplateVariables);"
"AntPathMatcher.java:438"$1$"	}"
"AntPathMatcher.java:439"$0$""
"AntPathMatcher.java:440"$0$"	/**"
"AntPathMatcher.java:441"$1$"	 * Build or retrieve an {@link AntPathStringMatcher} for the given pattern."
"AntPathMatcher.java:442"$0$"	 * <p>The default implementation checks this AntPathMatcher's internal cache"
"AntPathMatcher.java:443"$1$"	 * (see {@link #setCachePatterns}), creating a new AntPathStringMatcher instance"
"AntPathMatcher.java:444"$0$"	 * if no cached copy is found."
"AntPathMatcher.java:445"$0$"	 * <p>When encountering too many patterns to cache at runtime (the threshold is 65536),"
"AntPathMatcher.java:446"$0$"	 * it turns the default cache off, assuming that arbitrary permutations of patterns"
"AntPathMatcher.java:447"$0$"	 * are coming in, with little chance for encountering a recurring pattern."
"AntPathMatcher.java:448"$0$"	 * <p>This method may be overridden to implement a custom cache strategy."
"AntPathMatcher.java:449"$1$"	 * @param pattern the pattern to match against (never {@code null})"
"AntPathMatcher.java:450"$1$"	 * @return a corresponding AntPathStringMatcher (never {@code null})"
"AntPathMatcher.java:451"$0$"	 * @see #setCachePatterns"
"AntPathMatcher.java:452"$0$"	 */"
"AntPathMatcher.java:453"$1$"	protected AntPathStringMatcher getStringMatcher(String pattern) {"
"AntPathMatcher.java:454"$1$"		AntPathStringMatcher matcher = null;"
"AntPathMatcher.java:455"$1$"		Boolean cachePatterns = this.cachePatterns;"
"AntPathMatcher.java:456"$1$"		if (cachePatterns == null || cachePatterns.booleanValue()) {"
"AntPathMatcher.java:457"$1$"			matcher = this.stringMatcherCache.get(pattern);"
"AntPathMatcher.java:458"$1$"		}"
"AntPathMatcher.java:459"$1$"		if (matcher == null) {"
"AntPathMatcher.java:460"$1$"			matcher = new AntPathStringMatcher(pattern, this.caseSensitive);"
"AntPathMatcher.java:461"$1$"			if (cachePatterns == null && this.stringMatcherCache.size() >= CACHE_TURNOFF_THRESHOLD) {"
"AntPathMatcher.java:462"$0$"				// Try to adapt to the runtime situation that we're encountering:"
"AntPathMatcher.java:463"$0$"				// There are obviously too many different patterns coming in here..."
"AntPathMatcher.java:464"$0$"				// So let's turn off the cache since the patterns are unlikely to be reoccurring."
"AntPathMatcher.java:465"$1$"				deactivatePatternCache();"
"AntPathMatcher.java:466"$1$"				return matcher;"
"AntPathMatcher.java:467"$1$"			}"
"AntPathMatcher.java:468"$1$"			if (cachePatterns == null || cachePatterns.booleanValue()) {"
"AntPathMatcher.java:469"$1$"				this.stringMatcherCache.put(pattern, matcher);"
"AntPathMatcher.java:470"$1$"			}"
"AntPathMatcher.java:471"$0$"		}"
"AntPathMatcher.java:472"$0$"		return matcher;"
"AntPathMatcher.java:473"$0$"	}"
"AntPathMatcher.java:474"$0$""
"AntPathMatcher.java:475"$0$"	/**"
"AntPathMatcher.java:476"$0$"	 * Given a pattern and a full path, determine the pattern-mapped part. <p>For example: <ul>"
"AntPathMatcher.java:477"$1$"	 * <li>'{@code /docs/cvs/commit.html}' and '{@code /docs/cvs/commit.html} -> ''</li>"
"AntPathMatcher.java:478"$1$"	 * <li>'{@code /docs/*}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>"
"AntPathMatcher.java:479"$1$"	 * <li>'{@code /docs/cvs/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code commit.html}'</li>"
"AntPathMatcher.java:480"$1$"	 * <li>'{@code /docs/**}' and '{@code /docs/cvs/commit} -> '{@code cvs/commit}'</li>"
"AntPathMatcher.java:481"$1$"	 * <li>'{@code /docs/**\/*.html}' and '{@code /docs/cvs/commit.html} -> '{@code cvs/commit.html}'</li>"
"AntPathMatcher.java:482"$1$"	 * <li>'{@code /*.html}' and '{@code /docs/cvs/commit.html} -> '{@code docs/cvs/commit.html}'</li>"
"AntPathMatcher.java:483"$1$"	 * <li>'{@code *.html}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li>"
"AntPathMatcher.java:484"$1$"	 * <li>'{@code *}' and '{@code /docs/cvs/commit.html} -> '{@code /docs/cvs/commit.html}'</li> </ul>"
"AntPathMatcher.java:485"$1$"	 * <p>Assumes that {@link #match} returns {@code true} for '{@code pattern}' and '{@code path}', but"
"AntPathMatcher.java:486"$0$"	 * does <strong>not</strong> enforce this."
"AntPathMatcher.java:487"$0$"	 */"
"AntPathMatcher.java:488"$0$"	@Override"
"AntPathMatcher.java:489"$1$"	public String extractPathWithinPattern(String pattern, String path) {"
"AntPathMatcher.java:490"$1$"		String[] patternParts = StringUtils.tokenizeToStringArray(pattern, this.pathSeparator, this.trimTokens, true);"
"AntPathMatcher.java:491"$1$"		String[] pathParts = StringUtils.tokenizeToStringArray(path, this.pathSeparator, this.trimTokens, true);"
"AntPathMatcher.java:492"$1$"		StringBuilder builder = new StringBuilder();"
"AntPathMatcher.java:493"$1$"		boolean pathStarted = false;"
"AntPathMatcher.java:494"$1$""
"AntPathMatcher.java:495"$1$"		for (int segment = 0; segment < patternParts.length; segment++) {"
"AntPathMatcher.java:496"$1$"			String patternPart = patternParts[segment];"
"AntPathMatcher.java:497"$1$"			if (patternPart.indexOf('*') > -1 || patternPart.indexOf('?') > -1) {"
"AntPathMatcher.java:498"$1$"				for (; segment < pathParts.length; segment++) {"
"AntPathMatcher.java:499"$1$"					if (pathStarted || (segment == 0 && !pattern.startsWith(this.pathSeparator))) {"
"AntPathMatcher.java:500"$1$"						builder.append(this.pathSeparator);"
"AntPathMatcher.java:501"$1$"					}"
"AntPathMatcher.java:502"$0$"					builder.append(pathParts[segment]);"
"AntPathMatcher.java:503"$0$"					pathStarted = true;"
"AntPathMatcher.java:504"$0$"				}"
"AntPathMatcher.java:505"$0$"			}"
"AntPathMatcher.java:506"$0$"		}"
"AntPathMatcher.java:507"$0$""
"AntPathMatcher.java:508"$0$"		return builder.toString();"
"AntPathMatcher.java:509"$0$"	}"
"AntPathMatcher.java:510"$0$""
"AntPathMatcher.java:511"$0$"	@Override"
"AntPathMatcher.java:512"$1$"	public Map<String, String> extractUriTemplateVariables(String pattern, String path) {"
"AntPathMatcher.java:513"$1$"		Map<String, String> variables = new LinkedHashMap<>();"
"AntPathMatcher.java:514"$1$"		boolean result = doMatch(pattern, path, true, variables);"
"AntPathMatcher.java:515"$1$"		if (!result) {"
"AntPathMatcher.java:516"$1$"			throw new IllegalStateException(""Pattern \"""" + pattern + ""\"" is not a match for \"""" + path + ""\"""");"
"AntPathMatcher.java:517"$1$"		}"
"AntPathMatcher.java:518"$0$"		return variables;"
"AntPathMatcher.java:519"$0$"	}"
"AntPathMatcher.java:520"$0$""
"AntPathMatcher.java:521"$0$"	/**"
"AntPathMatcher.java:522"$0$"	 * Combine two patterns into a new pattern."
"AntPathMatcher.java:523"$0$"	 * <p>This implementation simply concatenates the two patterns, unless"
"AntPathMatcher.java:524"$1$"	 * the first pattern contains a file extension match (e.g., {@code *.html})."
"AntPathMatcher.java:525"$0$"	 * In that case, the second pattern will be merged into the first. Otherwise,"
"AntPathMatcher.java:526"$1$"	 * an {@code IllegalArgumentException} will be thrown."
"AntPathMatcher.java:527"$0$"	 * <h3>Examples</h3>"
"AntPathMatcher.java:528"$0$"	 * <table border=""1"">"
"AntPathMatcher.java:529"$0$"	 * <tr><th>Pattern 1</th><th>Pattern 2</th><th>Result</th></tr>"
"AntPathMatcher.java:530"$1$"	 * <tr><td>{@code null}</td><td>{@code null}</td><td>&nbsp;</td></tr>"
"AntPathMatcher.java:531"$1$"	 * <tr><td>/hotels</td><td>{@code null}</td><td>/hotels</td></tr>"
"AntPathMatcher.java:532"$1$"	 * <tr><td>{@code null}</td><td>/hotels</td><td>/hotels</td></tr>"
"AntPathMatcher.java:533"$0$"	 * <tr><td>/hotels</td><td>/bookings</td><td>/hotels/bookings</td></tr>"
"AntPathMatcher.java:534"$0$"	 * <tr><td>/hotels</td><td>bookings</td><td>/hotels/bookings</td></tr>"
"AntPathMatcher.java:535"$0$"	 * <tr><td>/hotels/*</td><td>/bookings</td><td>/hotels/bookings</td></tr>"
"AntPathMatcher.java:536"$0$"	 * <tr><td>/hotels/&#42;&#42;</td><td>/bookings</td><td>/hotels/&#42;&#42;/bookings</td></tr>"
"AntPathMatcher.java:537"$1$"	 * <tr><td>/hotels</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>"
"AntPathMatcher.java:538"$1$"	 * <tr><td>/hotels/*</td><td>{hotel}</td><td>/hotels/{hotel}</td></tr>"
"AntPathMatcher.java:539"$1$"	 * <tr><td>/hotels/&#42;&#42;</td><td>{hotel}</td><td>/hotels/&#42;&#42;/{hotel}</td></tr>"
"AntPathMatcher.java:540"$0$"	 * <tr><td>/*.html</td><td>/hotels.html</td><td>/hotels.html</td></tr>"
"AntPathMatcher.java:541"$0$"	 * <tr><td>/*.html</td><td>/hotels</td><td>/hotels.html</td></tr>"
"AntPathMatcher.java:542"$1$"	 * <tr><td>/*.html</td><td>/*.txt</td><td>{@code IllegalArgumentException}</td></tr>"
"AntPathMatcher.java:543"$0$"	 * </table>"
"AntPathMatcher.java:544"$0$"	 * @param pattern1 the first pattern"
"AntPathMatcher.java:545"$0$"	 * @param pattern2 the second pattern"
"AntPathMatcher.java:546"$0$"	 * @return the combination of the two patterns"
"AntPathMatcher.java:547"$0$"	 * @throws IllegalArgumentException if the two patterns cannot be combined"
"AntPathMatcher.java:548"$0$"	 */"
"AntPathMatcher.java:549"$0$"	@Override"
"AntPathMatcher.java:550"$1$"	public String combine(String pattern1, String pattern2) {"
"AntPathMatcher.java:551"$1$"		if (!StringUtils.hasText(pattern1) && !StringUtils.hasText(pattern2)) {"
"AntPathMatcher.java:552"$1$"			return """";"
"AntPathMatcher.java:553"$1$"		}"
"AntPathMatcher.java:554"$1$"		if (!StringUtils.hasText(pattern1)) {"
"AntPathMatcher.java:555"$1$"			return pattern2;"
"AntPathMatcher.java:556"$1$"		}"
"AntPathMatcher.java:557"$1$"		if (!StringUtils.hasText(pattern2)) {"
"AntPathMatcher.java:558"$1$"			return pattern1;"
"AntPathMatcher.java:559"$1$"		}"
"AntPathMatcher.java:560"$0$""
"AntPathMatcher.java:561"$1$"		boolean pattern1ContainsUriVar = (pattern1.indexOf('{') != -1);"
"AntPathMatcher.java:562"$1$"		if (!pattern1.equals(pattern2) && !pattern1ContainsUriVar && match(pattern1, pattern2)) {"
"AntPathMatcher.java:563"$0$"			// /* + /hotel -> /hotel ; ""/*.*"" + ""/*.html"" -> /*.html"
"AntPathMatcher.java:564"$0$"			// However /user + /user -> /usr/user ; /{foo} + /bar -> /{foo}/bar"
"AntPathMatcher.java:565"$1$"			return pattern2;"
"AntPathMatcher.java:566"$1$"		}"
"AntPathMatcher.java:567"$0$""
"AntPathMatcher.java:568"$0$"		// /hotels/* + /booking -> /hotels/booking"
"AntPathMatcher.java:569"$0$"		// /hotels/* + booking -> /hotels/booking"
"AntPathMatcher.java:570"$1$"		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnWildCard())) {"
"AntPathMatcher.java:571"$1$"			return concat(pattern1.substring(0, pattern1.length() - 2), pattern2);"
"AntPathMatcher.java:572"$1$"		}"
"AntPathMatcher.java:573"$0$""
"AntPathMatcher.java:574"$0$"		// /hotels/** + /booking -> /hotels/**/booking"
"AntPathMatcher.java:575"$0$"		// /hotels/** + booking -> /hotels/**/booking"
"AntPathMatcher.java:576"$1$"		if (pattern1.endsWith(this.pathSeparatorPatternCache.getEndsOnDoubleWildCard())) {"
"AntPathMatcher.java:577"$1$"			return concat(pattern1, pattern2);"
"AntPathMatcher.java:578"$1$"		}"
"AntPathMatcher.java:579"$0$""
"AntPathMatcher.java:580"$0$"		int starDotPos1 = pattern1.indexOf(""*."");"
"AntPathMatcher.java:581"$1$"		if (pattern1ContainsUriVar || starDotPos1 == -1 || this.pathSeparator.equals(""."")) {"
"AntPathMatcher.java:582"$0$"			// simply concatenate the two patterns"
"AntPathMatcher.java:583"$1$"			return concat(pattern1, pattern2);"
"AntPathMatcher.java:584"$1$"		}"
"AntPathMatcher.java:585"$0$""
"AntPathMatcher.java:586"$0$"		String ext1 = pattern1.substring(starDotPos1 + 1);"
"AntPathMatcher.java:587"$0$"		int dotPos2 = pattern2.indexOf('.');"
"AntPathMatcher.java:588"$0$"		String file2 = (dotPos2 == -1 ? pattern2 : pattern2.substring(0, dotPos2));"
"AntPathMatcher.java:589"$0$"		String ext2 = (dotPos2 == -1 ? """" : pattern2.substring(dotPos2));"
"AntPathMatcher.java:590"$0$"		boolean ext1All = (ext1.equals("".*"") || ext1.isEmpty());"
"AntPathMatcher.java:591"$0$"		boolean ext2All = (ext2.equals("".*"") || ext2.isEmpty());"
"AntPathMatcher.java:592"$1$"		if (!ext1All && !ext2All) {"
"AntPathMatcher.java:593"$1$"			throw new IllegalArgumentException(""Cannot combine patterns: "" + pattern1 + "" vs "" + pattern2);"
"AntPathMatcher.java:594"$1$"		}"
"AntPathMatcher.java:595"$0$"		String ext = (ext1All ? ext2 : ext1);"
"AntPathMatcher.java:596"$0$"		return file2 + ext;"
"AntPathMatcher.java:597"$0$"	}"
"AntPathMatcher.java:598"$0$""
"AntPathMatcher.java:599"$1$"	private String concat(String path1, String path2) {"
"AntPathMatcher.java:600"$1$"		boolean path1EndsWithSeparator = path1.endsWith(this.pathSeparator);"
"AntPathMatcher.java:601"$1$"		boolean path2StartsWithSeparator = path2.startsWith(this.pathSeparator);"
"AntPathMatcher.java:602"$1$""
"AntPathMatcher.java:603"$1$"		if (path1EndsWithSeparator && path2StartsWithSeparator) {"
"AntPathMatcher.java:604"$1$"			return path1 + path2.substring(1);"
"AntPathMatcher.java:605"$1$"		}"
"AntPathMatcher.java:606"$1$"		else if (path1EndsWithSeparator || path2StartsWithSeparator) {"
"AntPathMatcher.java:607"$1$"			return path1 + path2;"
"AntPathMatcher.java:608"$1$"		}"
"AntPathMatcher.java:609"$1$"		else {"
"AntPathMatcher.java:610"$1$"			return path1 + this.pathSeparator + path2;"
"AntPathMatcher.java:611"$1$"		}"
"AntPathMatcher.java:612"$0$"	}"
"AntPathMatcher.java:613"$0$""
"AntPathMatcher.java:614"$0$"	/**"
"AntPathMatcher.java:615"$1$"	 * Given a full path, returns a {@link Comparator} suitable for sorting patterns in order of"
"AntPathMatcher.java:616"$0$"	 * explicitness."
"AntPathMatcher.java:617"$1$"	 * <p>This {@code Comparator} will {@linkplain java.util.List#sort(Comparator) sort}"
"AntPathMatcher.java:618"$0$"	 * a list so that more specific patterns (without URI templates or wild cards) come before"
"AntPathMatcher.java:619"$0$"	 * generic patterns. So given a list with the following patterns, the returned comparator"
"AntPathMatcher.java:620"$0$"	 * will sort this list so that the order will be as indicated."
"AntPathMatcher.java:621"$0$"	 * <ol>"
"AntPathMatcher.java:622"$1$"	 * <li>{@code /hotels/new}</li>"
"AntPathMatcher.java:623"$1$"	 * <li>{@code /hotels/{hotel}}</li>"
"AntPathMatcher.java:624"$1$"	 * <li>{@code /hotels/*}</li>"
"AntPathMatcher.java:625"$0$"	 * </ol>"
"AntPathMatcher.java:626"$0$"	 * <p>The full path given as parameter is used to test for exact matches. So when the given path"
"AntPathMatcher.java:627"$1$"	 * is {@code /hotels/2}, the pattern {@code /hotels/2} will be sorted before {@code /hotels/1}."
"AntPathMatcher.java:628"$0$"	 * @param path the full path to use for comparison"
"AntPathMatcher.java:629"$0$"	 * @return a comparator capable of sorting patterns in order of explicitness"
"AntPathMatcher.java:630"$0$"	 */"
"AntPathMatcher.java:631"$0$"	@Override"
"AntPathMatcher.java:632"$1$"	public Comparator<String> getPatternComparator(String path) {"
"AntPathMatcher.java:633"$1$"		return new AntPatternComparator(path);"
"AntPathMatcher.java:634"$1$"	}"
"AntPathMatcher.java:635"$0$""
"AntPathMatcher.java:636"$0$""
"AntPathMatcher.java:637"$0$"	/**"
"AntPathMatcher.java:638"$1$"	 * Tests whether or not a string matches against a pattern via a {@link Pattern}."
"AntPathMatcher.java:639"$0$"	 * <p>The pattern may contain special characters: '*' means zero or more characters; '?' means one and"
"AntPathMatcher.java:640"$1$"	 * only one character; '{' and '}' indicate a URI template pattern. For example <tt>/users/{user}</tt>."
"AntPathMatcher.java:641"$0$"	 */"
"AntPathMatcher.java:642"$1$"	protected static class AntPathStringMatcher {"
"AntPathMatcher.java:643"$1$""
"AntPathMatcher.java:644"$1$"		private static final Pattern GLOB_PATTERN = Pattern.compile(""\\?|\\*|\\{((?:\\{[^/]+?}|[^/{}]|\\\\[{}])+?)}"");"
"AntPathMatcher.java:645"$1$""
"AntPathMatcher.java:646"$1$"		private static final String DEFAULT_VARIABLE_PATTERN = ""(.*)"";"
"AntPathMatcher.java:647"$1$""
"AntPathMatcher.java:648"$1$"		private final Pattern pattern;"
"AntPathMatcher.java:649"$1$""
"AntPathMatcher.java:650"$1$"		private final List<String> variableNames = new LinkedList<>();"
"AntPathMatcher.java:651"$1$""
"AntPathMatcher.java:652"$1$"		public AntPathStringMatcher(String pattern) {"
"AntPathMatcher.java:653"$1$"			this(pattern, true);"
"AntPathMatcher.java:654"$1$"		}"
"AntPathMatcher.java:655"$0$""
"AntPathMatcher.java:656"$1$"		public AntPathStringMatcher(String pattern, boolean caseSensitive) {"
"AntPathMatcher.java:657"$1$"			StringBuilder patternBuilder = new StringBuilder();"
"AntPathMatcher.java:658"$1$"			Matcher matcher = GLOB_PATTERN.matcher(pattern);"
"AntPathMatcher.java:659"$1$"			int end = 0;"
"AntPathMatcher.java:660"$1$"			while (matcher.find()) {"
"AntPathMatcher.java:661"$1$"				patternBuilder.append(quote(pattern, end, matcher.start()));"
"AntPathMatcher.java:662"$1$"				String match = matcher.group();"
"AntPathMatcher.java:663"$1$"				if (""?"".equals(match)) {"
"AntPathMatcher.java:664"$1$"					patternBuilder.append('.');"
"AntPathMatcher.java:665"$1$"				}"
"AntPathMatcher.java:666"$1$"				else if (""*"".equals(match)) {"
"AntPathMatcher.java:667"$1$"					patternBuilder.append("".*"");"
"AntPathMatcher.java:668"$1$"				}"
"AntPathMatcher.java:669"$1$"				else if (match.startsWith(""{"") && match.endsWith(""}"")) {"
"AntPathMatcher.java:670"$0$"					int colonIdx = match.indexOf(':');"
"AntPathMatcher.java:671"$1$"					if (colonIdx == -1) {"
"AntPathMatcher.java:672"$1$"						patternBuilder.append(DEFAULT_VARIABLE_PATTERN);"
"AntPathMatcher.java:673"$1$"						this.variableNames.add(matcher.group(1));"
"AntPathMatcher.java:674"$1$"					}"
"AntPathMatcher.java:675"$1$"					else {"
"AntPathMatcher.java:676"$1$"						String variablePattern = match.substring(colonIdx + 1, match.length() - 1);"
"AntPathMatcher.java:677"$1$"						patternBuilder.append('(');"
"AntPathMatcher.java:678"$1$"						patternBuilder.append(variablePattern);"
"AntPathMatcher.java:679"$1$"						patternBuilder.append(')');"
"AntPathMatcher.java:680"$1$"						String variableName = match.substring(1, colonIdx);"
"AntPathMatcher.java:681"$1$"						this.variableNames.add(variableName);"
"AntPathMatcher.java:682"$1$"					}"
"AntPathMatcher.java:683"$0$"				}"
"AntPathMatcher.java:684"$0$"				end = matcher.end();"
"AntPathMatcher.java:685"$0$"			}"
"AntPathMatcher.java:686"$0$"			patternBuilder.append(quote(pattern, end, pattern.length()));"
"AntPathMatcher.java:687"$0$"			this.pattern = (caseSensitive ? Pattern.compile(patternBuilder.toString()) :"
"AntPathMatcher.java:688"$0$"					Pattern.compile(patternBuilder.toString(), Pattern.CASE_INSENSITIVE));"
"AntPathMatcher.java:689"$0$"		}"
"AntPathMatcher.java:690"$0$""
"AntPathMatcher.java:691"$1$"		private String quote(String s, int start, int end) {"
"AntPathMatcher.java:692"$1$"			if (start == end) {"
"AntPathMatcher.java:693"$1$"				return """";"
"AntPathMatcher.java:694"$1$"			}"
"AntPathMatcher.java:695"$0$"			return Pattern.quote(s.substring(start, end));"
"AntPathMatcher.java:696"$0$"		}"
"AntPathMatcher.java:697"$0$""
"AntPathMatcher.java:698"$0$"		/**"
"AntPathMatcher.java:699"$0$"		 * Main entry point."
"AntPathMatcher.java:700"$1$"		 * @return {@code true} if the string matches against the pattern, or {@code false} otherwise."
"AntPathMatcher.java:701"$0$"		 */"
"AntPathMatcher.java:702"$1$"		public boolean matchStrings(String str, @Nullable Map<String, String> uriTemplateVariables) {"
"AntPathMatcher.java:703"$1$"			Matcher matcher = this.pattern.matcher(str);"
"AntPathMatcher.java:704"$1$"			if (matcher.matches()) {"
"AntPathMatcher.java:705"$1$"				if (uriTemplateVariables != null) {"
"AntPathMatcher.java:706"$0$"					// SPR-8455"
"AntPathMatcher.java:707"$1$"					if (this.variableNames.size() != matcher.groupCount()) {"
"AntPathMatcher.java:708"$1$"						throw new IllegalArgumentException(""The number of capturing groups in the pattern segment "" +"
"AntPathMatcher.java:709"$1$"								this.pattern + "" does not match the number of URI template variables it defines, "" +"
"AntPathMatcher.java:710"$1$"								""which can occur if capturing groups are used in a URI template regex. "" +"
"AntPathMatcher.java:711"$1$"								""Use non-capturing groups instead."");"
"AntPathMatcher.java:712"$1$"					}"
"AntPathMatcher.java:713"$1$"					for (int i = 1; i <= matcher.groupCount(); i++) {"
"AntPathMatcher.java:714"$1$"						String name = this.variableNames.get(i - 1);"
"AntPathMatcher.java:715"$1$"						String value = matcher.group(i);"
"AntPathMatcher.java:716"$1$"						uriTemplateVariables.put(name, value);"
"AntPathMatcher.java:717"$1$"					}"
"AntPathMatcher.java:718"$0$"				}"
"AntPathMatcher.java:719"$0$"				return true;"
"AntPathMatcher.java:720"$0$"			}"
"AntPathMatcher.java:721"$1$"			else {"
"AntPathMatcher.java:722"$1$"				return false;"
"AntPathMatcher.java:723"$1$"			}"
"AntPathMatcher.java:724"$0$"		}"
"AntPathMatcher.java:725"$0$"	}"
"AntPathMatcher.java:726"$0$""
"AntPathMatcher.java:727"$0$""
"AntPathMatcher.java:728"$0$"	/**"
"AntPathMatcher.java:729"$1$"	 * The default {@link Comparator} implementation returned by"
"AntPathMatcher.java:730"$1$"	 * {@link #getPatternComparator(String)}."
"AntPathMatcher.java:731"$0$"	 * <p>In order, the most ""generic"" pattern is determined by the following:"
"AntPathMatcher.java:732"$0$"	 * <ul>"
"AntPathMatcher.java:733"$0$"	 * <li>if it's null or a capture all pattern (i.e. it is equal to ""/**"")</li>"
"AntPathMatcher.java:734"$0$"	 * <li>if the other pattern is an actual match</li>"
"AntPathMatcher.java:735"$0$"	 * <li>if it's a catch-all pattern (i.e. it ends with ""**""</li>"
"AntPathMatcher.java:736"$0$"	 * <li>if it's got more ""*"" than the other pattern</li>"
"AntPathMatcher.java:737"$1$"	 * <li>if it's got more ""{foo}"" than the other pattern</li>"
"AntPathMatcher.java:738"$0$"	 * <li>if it's shorter than the other pattern</li>"
"AntPathMatcher.java:739"$0$"	 * </ul>"
"AntPathMatcher.java:740"$0$"	 */"
"AntPathMatcher.java:741"$1$"	protected static class AntPatternComparator implements Comparator<String> {"
"AntPathMatcher.java:742"$1$""
"AntPathMatcher.java:743"$1$"		private final String path;"
"AntPathMatcher.java:744"$1$""
"AntPathMatcher.java:745"$1$"		public AntPatternComparator(String path) {"
"AntPathMatcher.java:746"$1$"			this.path = path;"
"AntPathMatcher.java:747"$1$"		}"
"AntPathMatcher.java:748"$0$""
"AntPathMatcher.java:749"$0$"		/**"
"AntPathMatcher.java:750"$0$"		 * Compare two patterns to determine which should match first, i.e. which"
"AntPathMatcher.java:751"$0$"		 * is the most specific regarding the current path."
"AntPathMatcher.java:752"$0$"		 * @return a negative integer, zero, or a positive integer as pattern1 is"
"AntPathMatcher.java:753"$0$"		 * more specific, equally specific, or less specific than pattern2."
"AntPathMatcher.java:754"$0$"		 */"
"AntPathMatcher.java:755"$0$"		@Override"
"AntPathMatcher.java:756"$1$"		public int compare(String pattern1, String pattern2) {"
"AntPathMatcher.java:757"$1$"			PatternInfo info1 = new PatternInfo(pattern1);"
"AntPathMatcher.java:758"$1$"			PatternInfo info2 = new PatternInfo(pattern2);"
"AntPathMatcher.java:759"$1$""
"AntPathMatcher.java:760"$1$"			if (info1.isLeastSpecific() && info2.isLeastSpecific()) {"
"AntPathMatcher.java:761"$1$"				return 0;"
"AntPathMatcher.java:762"$1$"			}"
"AntPathMatcher.java:763"$1$"			else if (info1.isLeastSpecific()) {"
"AntPathMatcher.java:764"$1$"				return 1;"
"AntPathMatcher.java:765"$1$"			}"
"AntPathMatcher.java:766"$1$"			else if (info2.isLeastSpecific()) {"
"AntPathMatcher.java:767"$1$"				return -1;"
"AntPathMatcher.java:768"$1$"			}"
"AntPathMatcher.java:769"$0$""
"AntPathMatcher.java:770"$0$"			boolean pattern1EqualsPath = pattern1.equals(this.path);"
"AntPathMatcher.java:771"$0$"			boolean pattern2EqualsPath = pattern2.equals(this.path);"
"AntPathMatcher.java:772"$1$"			if (pattern1EqualsPath && pattern2EqualsPath) {"
"AntPathMatcher.java:773"$1$"				return 0;"
"AntPathMatcher.java:774"$1$"			}"
"AntPathMatcher.java:775"$1$"			else if (pattern1EqualsPath) {"
"AntPathMatcher.java:776"$1$"				return -1;"
"AntPathMatcher.java:777"$1$"			}"
"AntPathMatcher.java:778"$1$"			else if (pattern2EqualsPath) {"
"AntPathMatcher.java:779"$1$"				return 1;"
"AntPathMatcher.java:780"$1$"			}"
"AntPathMatcher.java:781"$0$""
"AntPathMatcher.java:782"$1$"			if (info1.isPrefixPattern() && info2.isPrefixPattern()) {"
"AntPathMatcher.java:783"$1$"				return info2.getLength() - info1.getLength();"
"AntPathMatcher.java:784"$1$"			}"
"AntPathMatcher.java:785"$1$"			else if (info1.isPrefixPattern() && info2.getDoubleWildcards() == 0) {"
"AntPathMatcher.java:786"$1$"				return 1;"
"AntPathMatcher.java:787"$1$"			}"
"AntPathMatcher.java:788"$1$"			else if (info2.isPrefixPattern() && info1.getDoubleWildcards() == 0) {"
"AntPathMatcher.java:789"$1$"				return -1;"
"AntPathMatcher.java:790"$1$"			}"
"AntPathMatcher.java:791"$0$""
"AntPathMatcher.java:792"$1$"			if (info1.getTotalCount() != info2.getTotalCount()) {"
"AntPathMatcher.java:793"$1$"				return info1.getTotalCount() - info2.getTotalCount();"
"AntPathMatcher.java:794"$1$"			}"
"AntPathMatcher.java:795"$0$""
"AntPathMatcher.java:796"$1$"			if (info1.getLength() != info2.getLength()) {"
"AntPathMatcher.java:797"$1$"				return info2.getLength() - info1.getLength();"
"AntPathMatcher.java:798"$1$"			}"
"AntPathMatcher.java:799"$0$""
"AntPathMatcher.java:800"$1$"			if (info1.getSingleWildcards() < info2.getSingleWildcards()) {"
"AntPathMatcher.java:801"$1$"				return -1;"
"AntPathMatcher.java:802"$1$"			}"
"AntPathMatcher.java:803"$1$"			else if (info2.getSingleWildcards() < info1.getSingleWildcards()) {"
"AntPathMatcher.java:804"$1$"				return 1;"
"AntPathMatcher.java:805"$1$"			}"
"AntPathMatcher.java:806"$0$""
"AntPathMatcher.java:807"$1$"			if (info1.getUriVars() < info2.getUriVars()) {"
"AntPathMatcher.java:808"$1$"				return -1;"
"AntPathMatcher.java:809"$1$"			}"
"AntPathMatcher.java:810"$1$"			else if (info2.getUriVars() < info1.getUriVars()) {"
"AntPathMatcher.java:811"$1$"				return 1;"
"AntPathMatcher.java:812"$1$"			}"
"AntPathMatcher.java:813"$0$""
"AntPathMatcher.java:814"$0$"			return 0;"
"AntPathMatcher.java:815"$0$"		}"
"AntPathMatcher.java:816"$0$""
"AntPathMatcher.java:817"$0$""
"AntPathMatcher.java:818"$0$"		/**"
"AntPathMatcher.java:819"$0$"		 * Value class that holds information about the pattern, e.g. number of"
"AntPathMatcher.java:820"$1$"		 * occurrences of ""*"", ""**"", and ""{"" pattern elements."
"AntPathMatcher.java:821"$1$"		 */"
"AntPathMatcher.java:822"$1$"		private static class PatternInfo {"
"AntPathMatcher.java:823"$1$""
"AntPathMatcher.java:824"$1$"			@Nullable"
"AntPathMatcher.java:825"$1$"			private final String pattern;"
"AntPathMatcher.java:826"$1$""
"AntPathMatcher.java:827"$1$"			private int uriVars;"
"AntPathMatcher.java:828"$1$""
"AntPathMatcher.java:829"$1$"			private int singleWildcards;"
"AntPathMatcher.java:830"$1$""
"AntPathMatcher.java:831"$1$"			private int doubleWildcards;"
"AntPathMatcher.java:832"$1$""
"AntPathMatcher.java:833"$1$"			private boolean catchAllPattern;"
"AntPathMatcher.java:834"$1$""
"AntPathMatcher.java:835"$1$"			private boolean prefixPattern;"
"AntPathMatcher.java:836"$1$""
"AntPathMatcher.java:837"$1$"			@Nullable"
"AntPathMatcher.java:838"$1$"			private Integer length;"
"AntPathMatcher.java:839"$1$""
"AntPathMatcher.java:840"$1$"			public PatternInfo(@Nullable String pattern) {"
"AntPathMatcher.java:841"$1$"				this.pattern = pattern;"
"AntPathMatcher.java:842"$1$"				if (this.pattern != null) {"
"AntPathMatcher.java:843"$1$"					initCounters();"
"AntPathMatcher.java:844"$1$"					this.catchAllPattern = this.pattern.equals(""/**"");"
"AntPathMatcher.java:845"$1$"					this.prefixPattern = !this.catchAllPattern && this.pattern.endsWith(""/**"");"
"AntPathMatcher.java:846"$1$"				}"
"AntPathMatcher.java:847"$1$"				if (this.uriVars == 0) {"
"AntPathMatcher.java:848"$1$"					this.length = (this.pattern != null ? this.pattern.length() : 0);"
"AntPathMatcher.java:849"$1$"				}"
"AntPathMatcher.java:850"$0$"			}"
"AntPathMatcher.java:851"$0$""
"AntPathMatcher.java:852"$1$"			protected void initCounters() {"
"AntPathMatcher.java:853"$1$"				int pos = 0;"
"AntPathMatcher.java:854"$1$"				if (this.pattern != null) {"
"AntPathMatcher.java:855"$1$"					while (pos < this.pattern.length()) {"
"AntPathMatcher.java:856"$1$"						if (this.pattern.charAt(pos) == '{') {"
"AntPathMatcher.java:857"$1$"							this.uriVars++;"
"AntPathMatcher.java:858"$1$"							pos++;"
"AntPathMatcher.java:859"$1$"						}"
"AntPathMatcher.java:860"$1$"						else if (this.pattern.charAt(pos) == '*') {"
"AntPathMatcher.java:861"$1$"							if (pos + 1 < this.pattern.length() && this.pattern.charAt(pos + 1) == '*') {"
"AntPathMatcher.java:862"$1$"								this.doubleWildcards++;"
"AntPathMatcher.java:863"$1$"								pos += 2;"
"AntPathMatcher.java:864"$1$"							}"
"AntPathMatcher.java:865"$1$"							else if (pos > 0 && !this.pattern.substring(pos - 1).equals("".*"")) {"
"AntPathMatcher.java:866"$1$"								this.singleWildcards++;"
"AntPathMatcher.java:867"$1$"								pos++;"
"AntPathMatcher.java:868"$1$"							}"
"AntPathMatcher.java:869"$1$"							else {"
"AntPathMatcher.java:870"$1$"								pos++;"
"AntPathMatcher.java:871"$1$"							}"
"AntPathMatcher.java:872"$0$"						}"
"AntPathMatcher.java:873"$1$"						else {"
"AntPathMatcher.java:874"$1$"							pos++;"
"AntPathMatcher.java:875"$1$"						}"
"AntPathMatcher.java:876"$0$"					}"
"AntPathMatcher.java:877"$0$"				}"
"AntPathMatcher.java:878"$0$"			}"
"AntPathMatcher.java:879"$0$""
"AntPathMatcher.java:880"$1$"			public int getUriVars() {"
"AntPathMatcher.java:881"$1$"				return this.uriVars;"
"AntPathMatcher.java:882"$1$"			}"
"AntPathMatcher.java:883"$0$""
"AntPathMatcher.java:884"$1$"			public int getSingleWildcards() {"
"AntPathMatcher.java:885"$1$"				return this.singleWildcards;"
"AntPathMatcher.java:886"$1$"			}"
"AntPathMatcher.java:887"$0$""
"AntPathMatcher.java:888"$1$"			public int getDoubleWildcards() {"
"AntPathMatcher.java:889"$1$"				return this.doubleWildcards;"
"AntPathMatcher.java:890"$1$"			}"
"AntPathMatcher.java:891"$0$""
"AntPathMatcher.java:892"$1$"			public boolean isLeastSpecific() {"
"AntPathMatcher.java:893"$1$"				return (this.pattern == null || this.catchAllPattern);"
"AntPathMatcher.java:894"$1$"			}"
"AntPathMatcher.java:895"$0$""
"AntPathMatcher.java:896"$1$"			public boolean isPrefixPattern() {"
"AntPathMatcher.java:897"$1$"				return this.prefixPattern;"
"AntPathMatcher.java:898"$1$"			}"
"AntPathMatcher.java:899"$0$""
"AntPathMatcher.java:900"$1$"			public int getTotalCount() {"
"AntPathMatcher.java:901"$1$"				return this.uriVars + this.singleWildcards + (2 * this.doubleWildcards);"
"AntPathMatcher.java:902"$1$"			}"
"AntPathMatcher.java:903"$0$""
"AntPathMatcher.java:904"$0$"			/**"
"AntPathMatcher.java:905"$0$"			 * Returns the length of the given pattern, where template variables are considered to be 1 long."
"AntPathMatcher.java:906"$0$"			 */"
"AntPathMatcher.java:907"$1$"			public int getLength() {"
"AntPathMatcher.java:908"$1$"				if (this.length == null) {"
"AntPathMatcher.java:909"$1$"					this.length = (this.pattern != null ?"
"AntPathMatcher.java:910"$1$"							VARIABLE_PATTERN.matcher(this.pattern).replaceAll(""#"").length() : 0);"
"AntPathMatcher.java:911"$1$"				}"
"AntPathMatcher.java:912"$0$"				return this.length;"
"AntPathMatcher.java:913"$0$"			}"
"AntPathMatcher.java:914"$0$"		}"
"AntPathMatcher.java:915"$0$"	}"
"AntPathMatcher.java:916"$0$""
"AntPathMatcher.java:917"$0$""
"AntPathMatcher.java:918"$0$"	/**"
"AntPathMatcher.java:919"$0$"	 * A simple cache for patterns that depend on the configured path separator."
"AntPathMatcher.java:920"$0$"	 */"
"AntPathMatcher.java:921"$1$"	private static class PathSeparatorPatternCache {"
"AntPathMatcher.java:922"$1$""
"AntPathMatcher.java:923"$1$"		private final String endsOnWildCard;"
"AntPathMatcher.java:924"$1$""
"AntPathMatcher.java:925"$1$"		private final String endsOnDoubleWildCard;"
"AntPathMatcher.java:926"$1$""
"AntPathMatcher.java:927"$1$"		public PathSeparatorPatternCache(String pathSeparator) {"
"AntPathMatcher.java:928"$1$"			this.endsOnWildCard = pathSeparator + ""*"";"
"AntPathMatcher.java:929"$1$"			this.endsOnDoubleWildCard = pathSeparator + ""**"";"
"AntPathMatcher.java:930"$1$"		}"
"AntPathMatcher.java:931"$0$""
"AntPathMatcher.java:932"$1$"		public String getEndsOnWildCard() {"
"AntPathMatcher.java:933"$1$"			return this.endsOnWildCard;"
"AntPathMatcher.java:934"$1$"		}"
"AntPathMatcher.java:935"$0$""
"AntPathMatcher.java:936"$1$"		public String getEndsOnDoubleWildCard() {"
"AntPathMatcher.java:937"$1$"			return this.endsOnDoubleWildCard;"
"AntPathMatcher.java:938"$1$"		}"
"AntPathMatcher.java:939"$0$"	}"
"AntPathMatcher.java:940"$0$""
"AntPathMatcher.java:941"$0$"}"
"FastByteArrayOutputStream.java:1"$0$"/*"
"FastByteArrayOutputStream.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"FastByteArrayOutputStream.java:3"$0$" *"
"FastByteArrayOutputStream.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"FastByteArrayOutputStream.java:5"$0$" * you may not use this file except in compliance with the License."
"FastByteArrayOutputStream.java:6"$0$" * You may obtain a copy of the License at"
"FastByteArrayOutputStream.java:7"$0$" *"
"FastByteArrayOutputStream.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"FastByteArrayOutputStream.java:9"$0$" *"
"FastByteArrayOutputStream.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"FastByteArrayOutputStream.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"FastByteArrayOutputStream.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"FastByteArrayOutputStream.java:13"$0$" * See the License for the specific language governing permissions and"
"FastByteArrayOutputStream.java:14"$0$" * limitations under the License."
"FastByteArrayOutputStream.java:15"$0$" */"
"FastByteArrayOutputStream.java:16"$0$""
"FastByteArrayOutputStream.java:17"$0$"package org.springframework.util;"
"FastByteArrayOutputStream.java:18"$0$""
"FastByteArrayOutputStream.java:19"$0$"import java.io.IOException;"
"FastByteArrayOutputStream.java:20"$0$"import java.io.InputStream;"
"FastByteArrayOutputStream.java:21"$0$"import java.io.OutputStream;"
"FastByteArrayOutputStream.java:22"$0$"import java.security.MessageDigest;"
"FastByteArrayOutputStream.java:23"$0$"import java.util.Iterator;"
"FastByteArrayOutputStream.java:24"$0$"import java.util.LinkedList;"
"FastByteArrayOutputStream.java:25"$0$""
"FastByteArrayOutputStream.java:26"$0$"import org.springframework.lang.Nullable;"
"FastByteArrayOutputStream.java:27"$0$""
"FastByteArrayOutputStream.java:28"$0$"/**"
"FastByteArrayOutputStream.java:29"$1$" * A speedy alternative to {@link java.io.ByteArrayOutputStream}. Note that"
"FastByteArrayOutputStream.java:30"$1$" * this variant does <i>not</i> extend {@code ByteArrayOutputStream}, unlike"
"FastByteArrayOutputStream.java:31"$1$" * its sibling {@link ResizableByteArrayOutputStream}."
"FastByteArrayOutputStream.java:32"$0$" *"
"FastByteArrayOutputStream.java:33"$1$" * <p>Unlike {@link java.io.ByteArrayOutputStream}, this implementation is backed"
"FastByteArrayOutputStream.java:34"$1$" * by a {@link java.util.LinkedList} of {@code byte[]} instead of 1 constantly"
"FastByteArrayOutputStream.java:35"$1$" * resizing {@code byte[]}. It does not copy buffers when it gets expanded."
"FastByteArrayOutputStream.java:36"$0$" *"
"FastByteArrayOutputStream.java:37"$0$" * <p>The initial buffer is only created when the stream is first written."
"FastByteArrayOutputStream.java:38"$0$" * There is also no copying of the internal buffer if its contents is extracted"
"FastByteArrayOutputStream.java:39"$1$" * with the {@link #writeTo(OutputStream)} method."
"FastByteArrayOutputStream.java:40"$0$" *"
"FastByteArrayOutputStream.java:41"$0$" * @author Craig Andrews"
"FastByteArrayOutputStream.java:42"$0$" * @author Juergen Hoeller"
"FastByteArrayOutputStream.java:43"$0$" * @since 4.2"
"FastByteArrayOutputStream.java:44"$0$" * @see #resize"
"FastByteArrayOutputStream.java:45"$0$" * @see ResizableByteArrayOutputStream"
"FastByteArrayOutputStream.java:46"$0$" */"
"FastByteArrayOutputStream.java:47"$1$"public class FastByteArrayOutputStream extends OutputStream {"
"FastByteArrayOutputStream.java:48"$1$""
"FastByteArrayOutputStream.java:49"$1$"	private static final int DEFAULT_BLOCK_SIZE = 256;"
"FastByteArrayOutputStream.java:50"$1$""
"FastByteArrayOutputStream.java:51"$1$""
"FastByteArrayOutputStream.java:52"$0$"	// The buffers used to store the content bytes"
"FastByteArrayOutputStream.java:53"$1$"	private final LinkedList<byte[]> buffers = new LinkedList<>();"
"FastByteArrayOutputStream.java:54"$1$""
"FastByteArrayOutputStream.java:55"$0$"	// The size, in bytes, to use when allocating the first byte[]"
"FastByteArrayOutputStream.java:56"$1$"	private final int initialBlockSize;"
"FastByteArrayOutputStream.java:57"$1$""
"FastByteArrayOutputStream.java:58"$0$"	// The size, in bytes, to use when allocating the next byte[]"
"FastByteArrayOutputStream.java:59"$1$"	private int nextBlockSize = 0;"
"FastByteArrayOutputStream.java:60"$1$""
"FastByteArrayOutputStream.java:61"$0$"	// The number of bytes in previous buffers."
"FastByteArrayOutputStream.java:62"$0$"	// (The number of bytes in the current buffer is in 'index'.)"
"FastByteArrayOutputStream.java:63"$1$"	private int alreadyBufferedSize = 0;"
"FastByteArrayOutputStream.java:64"$1$""
"FastByteArrayOutputStream.java:65"$0$"	// The index in the byte[] found at buffers.getLast() to be written next"
"FastByteArrayOutputStream.java:66"$1$"	private int index = 0;"
"FastByteArrayOutputStream.java:67"$1$""
"FastByteArrayOutputStream.java:68"$0$"	// Is the stream closed?"
"FastByteArrayOutputStream.java:69"$1$"	private boolean closed = false;"
"FastByteArrayOutputStream.java:70"$1$""
"FastByteArrayOutputStream.java:71"$1$""
"FastByteArrayOutputStream.java:72"$1$"	/**"
"FastByteArrayOutputStream.java:73"$1$"	 * Create a new <code>FastByteArrayOutputStream</code>"
"FastByteArrayOutputStream.java:74"$1$"	 * with the default initial capacity of 256 bytes."
"FastByteArrayOutputStream.java:75"$1$"	 */"
"FastByteArrayOutputStream.java:76"$1$"	public FastByteArrayOutputStream() {"
"FastByteArrayOutputStream.java:77"$1$"		this(DEFAULT_BLOCK_SIZE);"
"FastByteArrayOutputStream.java:78"$1$"	}"
"FastByteArrayOutputStream.java:79"$0$""
"FastByteArrayOutputStream.java:80"$0$"	/**"
"FastByteArrayOutputStream.java:81"$0$"	 * Create a new <code>FastByteArrayOutputStream</code>"
"FastByteArrayOutputStream.java:82"$0$"	 * with the specified initial capacity."
"FastByteArrayOutputStream.java:83"$0$"	 * @param initialBlockSize the initial buffer size in bytes"
"FastByteArrayOutputStream.java:84"$0$"	 */"
"FastByteArrayOutputStream.java:85"$1$"	public FastByteArrayOutputStream(int initialBlockSize) {"
"FastByteArrayOutputStream.java:86"$1$"		Assert.isTrue(initialBlockSize > 0, ""Initial block size must be greater than 0"");"
"FastByteArrayOutputStream.java:87"$1$"		this.initialBlockSize = initialBlockSize;"
"FastByteArrayOutputStream.java:88"$1$"		this.nextBlockSize = initialBlockSize;"
"FastByteArrayOutputStream.java:89"$1$"	}"
"FastByteArrayOutputStream.java:90"$0$""
"FastByteArrayOutputStream.java:91"$0$""
"FastByteArrayOutputStream.java:92"$0$"	// Overridden methods"
"FastByteArrayOutputStream.java:93"$0$""
"FastByteArrayOutputStream.java:94"$0$"	@Override"
"FastByteArrayOutputStream.java:95"$1$"	public void write(int datum) throws IOException {"
"FastByteArrayOutputStream.java:96"$1$"		if (this.closed) {"
"FastByteArrayOutputStream.java:97"$1$"			throw new IOException(""Stream closed"");"
"FastByteArrayOutputStream.java:98"$1$"		}"
"FastByteArrayOutputStream.java:99"$1$"		else {"
"FastByteArrayOutputStream.java:100"$1$"			if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {"
"FastByteArrayOutputStream.java:101"$1$"				addBuffer(1);"
"FastByteArrayOutputStream.java:102"$1$"			}"
"FastByteArrayOutputStream.java:103"$0$"			// store the byte"
"FastByteArrayOutputStream.java:104"$0$"			this.buffers.getLast()[this.index++] = (byte) datum;"
"FastByteArrayOutputStream.java:105"$0$"		}"
"FastByteArrayOutputStream.java:106"$0$"	}"
"FastByteArrayOutputStream.java:107"$0$""
"FastByteArrayOutputStream.java:108"$0$"	@Override"
"FastByteArrayOutputStream.java:109"$1$"	public void write(byte[] data, int offset, int length) throws IOException {"
"FastByteArrayOutputStream.java:110"$1$"		if (offset < 0 || offset + length > data.length || length < 0) {"
"FastByteArrayOutputStream.java:111"$1$"			throw new IndexOutOfBoundsException();"
"FastByteArrayOutputStream.java:112"$1$"		}"
"FastByteArrayOutputStream.java:113"$1$"		else if (this.closed) {"
"FastByteArrayOutputStream.java:114"$1$"			throw new IOException(""Stream closed"");"
"FastByteArrayOutputStream.java:115"$1$"		}"
"FastByteArrayOutputStream.java:116"$1$"		else {"
"FastByteArrayOutputStream.java:117"$1$"			if (this.buffers.peekLast() == null || this.buffers.getLast().length == this.index) {"
"FastByteArrayOutputStream.java:118"$1$"				addBuffer(length);"
"FastByteArrayOutputStream.java:119"$1$"			}"
"FastByteArrayOutputStream.java:120"$1$"			if (this.index + length > this.buffers.getLast().length) {"
"FastByteArrayOutputStream.java:121"$1$"				int pos = offset;"
"FastByteArrayOutputStream.java:122"$1$"				do {"
"FastByteArrayOutputStream.java:123"$1$"					if (this.index == this.buffers.getLast().length) {"
"FastByteArrayOutputStream.java:124"$1$"						addBuffer(length);"
"FastByteArrayOutputStream.java:125"$1$"					}"
"FastByteArrayOutputStream.java:126"$0$"					int copyLength = this.buffers.getLast().length - this.index;"
"FastByteArrayOutputStream.java:127"$1$"					if (length < copyLength) {"
"FastByteArrayOutputStream.java:128"$1$"						copyLength = length;"
"FastByteArrayOutputStream.java:129"$1$"					}"
"FastByteArrayOutputStream.java:130"$0$"					System.arraycopy(data, pos, this.buffers.getLast(), this.index, copyLength);"
"FastByteArrayOutputStream.java:131"$0$"					pos += copyLength;"
"FastByteArrayOutputStream.java:132"$0$"					this.index += copyLength;"
"FastByteArrayOutputStream.java:133"$0$"					length -= copyLength;"
"FastByteArrayOutputStream.java:134"$0$"				}"
"FastByteArrayOutputStream.java:135"$0$"				while (length > 0);"
"FastByteArrayOutputStream.java:136"$0$"			}"
"FastByteArrayOutputStream.java:137"$1$"			else {"
"FastByteArrayOutputStream.java:138"$0$"				// copy in the sub-array"
"FastByteArrayOutputStream.java:139"$1$"				System.arraycopy(data, offset, this.buffers.getLast(), this.index, length);"
"FastByteArrayOutputStream.java:140"$1$"				this.index += length;"
"FastByteArrayOutputStream.java:141"$1$"			}"
"FastByteArrayOutputStream.java:142"$0$"		}"
"FastByteArrayOutputStream.java:143"$0$"	}"
"FastByteArrayOutputStream.java:144"$0$""
"FastByteArrayOutputStream.java:145"$0$"	@Override"
"FastByteArrayOutputStream.java:146"$1$"	public void close() {"
"FastByteArrayOutputStream.java:147"$1$"		this.closed = true;"
"FastByteArrayOutputStream.java:148"$1$"	}"
"FastByteArrayOutputStream.java:149"$0$""
"FastByteArrayOutputStream.java:150"$0$"	/**"
"FastByteArrayOutputStream.java:151"$0$"	 * Convert the buffer's contents into a string decoding bytes using the"
"FastByteArrayOutputStream.java:152"$0$"	 * platform's default character set. The length of the new <tt>String</tt>"
"FastByteArrayOutputStream.java:153"$0$"	 * is a function of the character set, and hence may not be equal to the"
"FastByteArrayOutputStream.java:154"$0$"	 * size of the buffer."
"FastByteArrayOutputStream.java:155"$0$"	 * <p>This method always replaces malformed-input and unmappable-character"
"FastByteArrayOutputStream.java:156"$0$"	 * sequences with the default replacement string for the platform's"
"FastByteArrayOutputStream.java:157"$1$"	 * default character set. The {@linkplain java.nio.charset.CharsetDecoder}"
"FastByteArrayOutputStream.java:158"$0$"	 * class should be used when more control over the decoding process is"
"FastByteArrayOutputStream.java:159"$0$"	 * required."
"FastByteArrayOutputStream.java:160"$0$"	 * @return a String decoded from the buffer's contents"
"FastByteArrayOutputStream.java:161"$0$"	 */"
"FastByteArrayOutputStream.java:162"$0$"	@Override"
"FastByteArrayOutputStream.java:163"$1$"	public String toString() {"
"FastByteArrayOutputStream.java:164"$1$"		return new String(toByteArrayUnsafe());"
"FastByteArrayOutputStream.java:165"$1$"	}"
"FastByteArrayOutputStream.java:166"$0$""
"FastByteArrayOutputStream.java:167"$0$""
"FastByteArrayOutputStream.java:168"$0$"	// Custom methods"
"FastByteArrayOutputStream.java:169"$0$""
"FastByteArrayOutputStream.java:170"$0$"	/**"
"FastByteArrayOutputStream.java:171"$0$"	 * Return the number of bytes stored in this <code>FastByteArrayOutputStream</code>."
"FastByteArrayOutputStream.java:172"$0$"	 */"
"FastByteArrayOutputStream.java:173"$1$"	public int size() {"
"FastByteArrayOutputStream.java:174"$1$"		return (this.alreadyBufferedSize + this.index);"
"FastByteArrayOutputStream.java:175"$1$"	}"
"FastByteArrayOutputStream.java:176"$0$""
"FastByteArrayOutputStream.java:177"$0$"	/**"
"FastByteArrayOutputStream.java:178"$0$"	 * Convert the stream's data to a byte array and return the byte array."
"FastByteArrayOutputStream.java:179"$0$"	 * <p>Also replaces the internal structures with the byte array to conserve memory:"
"FastByteArrayOutputStream.java:180"$0$"	 * if the byte array is being made anyways, mind as well as use it. This approach"
"FastByteArrayOutputStream.java:181"$0$"	 * also means that if this method is called twice without any writes in between,"
"FastByteArrayOutputStream.java:182"$0$"	 * the second call is a no-op."
"FastByteArrayOutputStream.java:183"$0$"	 * <p>This method is ""unsafe"" as it returns the internal buffer."
"FastByteArrayOutputStream.java:184"$0$"	 * Callers should not modify the returned buffer."
"FastByteArrayOutputStream.java:185"$0$"	 * @return the current contents of this output stream, as a byte array."
"FastByteArrayOutputStream.java:186"$0$"	 * @see #size()"
"FastByteArrayOutputStream.java:187"$0$"	 * @see #toByteArray()"
"FastByteArrayOutputStream.java:188"$0$"	 */"
"FastByteArrayOutputStream.java:189"$1$"	public byte[] toByteArrayUnsafe() {"
"FastByteArrayOutputStream.java:190"$1$"		int totalSize = size();"
"FastByteArrayOutputStream.java:191"$1$"		if (totalSize == 0) {"
"FastByteArrayOutputStream.java:192"$1$"			return new byte[0];"
"FastByteArrayOutputStream.java:193"$1$"		}"
"FastByteArrayOutputStream.java:194"$0$"		resize(totalSize);"
"FastByteArrayOutputStream.java:195"$0$"		return this.buffers.getFirst();"
"FastByteArrayOutputStream.java:196"$0$"	}"
"FastByteArrayOutputStream.java:197"$0$""
"FastByteArrayOutputStream.java:198"$0$"	/**"
"FastByteArrayOutputStream.java:199"$0$"	 * Creates a newly allocated byte array."
"FastByteArrayOutputStream.java:200"$0$"	 * <p>Its size is the current"
"FastByteArrayOutputStream.java:201"$0$"	 * size of this output stream and the valid contents of the buffer"
"FastByteArrayOutputStream.java:202"$0$"	 * have been copied into it.</p>"
"FastByteArrayOutputStream.java:203"$0$"	 * @return the current contents of this output stream, as a byte array."
"FastByteArrayOutputStream.java:204"$0$"	 * @see #size()"
"FastByteArrayOutputStream.java:205"$0$"	 * @see #toByteArrayUnsafe()"
"FastByteArrayOutputStream.java:206"$0$"	 */"
"FastByteArrayOutputStream.java:207"$1$"	public byte[] toByteArray() {"
"FastByteArrayOutputStream.java:208"$1$"		byte[] bytesUnsafe = toByteArrayUnsafe();"
"FastByteArrayOutputStream.java:209"$1$"		return bytesUnsafe.clone();"
"FastByteArrayOutputStream.java:210"$1$"	}"
"FastByteArrayOutputStream.java:211"$0$""
"FastByteArrayOutputStream.java:212"$0$"	/**"
"FastByteArrayOutputStream.java:213"$0$"	 * Reset the contents of this <code>FastByteArrayOutputStream</code>."
"FastByteArrayOutputStream.java:214"$0$"	 * <p>All currently accumulated output in the output stream is discarded."
"FastByteArrayOutputStream.java:215"$0$"	 * The output stream can be used again."
"FastByteArrayOutputStream.java:216"$0$"	 */"
"FastByteArrayOutputStream.java:217"$1$"	public void reset() {"
"FastByteArrayOutputStream.java:218"$1$"		this.buffers.clear();"
"FastByteArrayOutputStream.java:219"$1$"		this.nextBlockSize = this.initialBlockSize;"
"FastByteArrayOutputStream.java:220"$1$"		this.closed = false;"
"FastByteArrayOutputStream.java:221"$1$"		this.index = 0;"
"FastByteArrayOutputStream.java:222"$1$"		this.alreadyBufferedSize = 0;"
"FastByteArrayOutputStream.java:223"$1$"	}"
"FastByteArrayOutputStream.java:224"$0$""
"FastByteArrayOutputStream.java:225"$0$"	/**"
"FastByteArrayOutputStream.java:226"$1$"	 * Get an {@link InputStream} to retrieve the data in this OutputStream."
"FastByteArrayOutputStream.java:227"$0$"	 * <p>Note that if any methods are called on the OutputStream"
"FastByteArrayOutputStream.java:228"$1$"	 * (including, but not limited to, any of the write methods, {@link #reset()},"
"FastByteArrayOutputStream.java:229"$1$"	 * {@link #toByteArray()}, and {@link #toByteArrayUnsafe()}) then the"
"FastByteArrayOutputStream.java:230"$1$"	 * {@link java.io.InputStream}'s behavior is undefined."
"FastByteArrayOutputStream.java:231"$1$"	 * @return {@link InputStream} of the contents of this OutputStream"
"FastByteArrayOutputStream.java:232"$0$"	 */"
"FastByteArrayOutputStream.java:233"$1$"	public InputStream getInputStream() {"
"FastByteArrayOutputStream.java:234"$1$"		return new FastByteArrayInputStream(this);"
"FastByteArrayOutputStream.java:235"$1$"	}"
"FastByteArrayOutputStream.java:236"$0$""
"FastByteArrayOutputStream.java:237"$0$"	/**"
"FastByteArrayOutputStream.java:238"$0$"	 * Write the buffers content to the given OutputStream."
"FastByteArrayOutputStream.java:239"$0$"	 * @param out the OutputStream to write to"
"FastByteArrayOutputStream.java:240"$0$"	 */"
"FastByteArrayOutputStream.java:241"$1$"	public void writeTo(OutputStream out) throws IOException {"
"FastByteArrayOutputStream.java:242"$1$"		Iterator<byte[]> it = this.buffers.iterator();"
"FastByteArrayOutputStream.java:243"$1$"		while (it.hasNext()) {"
"FastByteArrayOutputStream.java:244"$1$"			byte[] bytes = it.next();"
"FastByteArrayOutputStream.java:245"$1$"			if (it.hasNext()) {"
"FastByteArrayOutputStream.java:246"$1$"				out.write(bytes, 0, bytes.length);"
"FastByteArrayOutputStream.java:247"$1$"			}"
"FastByteArrayOutputStream.java:248"$1$"			else {"
"FastByteArrayOutputStream.java:249"$1$"				out.write(bytes, 0, this.index);"
"FastByteArrayOutputStream.java:250"$1$"			}"
"FastByteArrayOutputStream.java:251"$0$"		}"
"FastByteArrayOutputStream.java:252"$0$"	}"
"FastByteArrayOutputStream.java:253"$0$""
"FastByteArrayOutputStream.java:254"$0$"	/**"
"FastByteArrayOutputStream.java:255"$0$"	 * Resize the internal buffer size to a specified capacity."
"FastByteArrayOutputStream.java:256"$0$"	 * @param targetCapacity the desired size of the buffer"
"FastByteArrayOutputStream.java:257"$0$"	 * @throws IllegalArgumentException if the given capacity is smaller than"
"FastByteArrayOutputStream.java:258"$0$"	 * the actual size of the content stored in the buffer already"
"FastByteArrayOutputStream.java:259"$0$"	 * @see FastByteArrayOutputStream#size()"
"FastByteArrayOutputStream.java:260"$0$"	 */"
"FastByteArrayOutputStream.java:261"$1$"	public void resize(int targetCapacity) {"
"FastByteArrayOutputStream.java:262"$1$"		Assert.isTrue(targetCapacity >= size(), ""New capacity must not be smaller than current size"");"
"FastByteArrayOutputStream.java:263"$1$"		if (this.buffers.peekFirst() == null) {"
"FastByteArrayOutputStream.java:264"$1$"			this.nextBlockSize = targetCapacity - size();"
"FastByteArrayOutputStream.java:265"$1$"		}"
"FastByteArrayOutputStream.java:266"$1$"		else if (size() == targetCapacity && this.buffers.getFirst().length == targetCapacity) {"
"FastByteArrayOutputStream.java:267"$0$"			// do nothing - already at the targetCapacity"
"FastByteArrayOutputStream.java:268"$1$"		}"
"FastByteArrayOutputStream.java:269"$1$"		else {"
"FastByteArrayOutputStream.java:270"$1$"			int totalSize = size();"
"FastByteArrayOutputStream.java:271"$1$"			byte[] data = new byte[targetCapacity];"
"FastByteArrayOutputStream.java:272"$1$"			int pos = 0;"
"FastByteArrayOutputStream.java:273"$1$"			Iterator<byte[]> it = this.buffers.iterator();"
"FastByteArrayOutputStream.java:274"$1$"			while (it.hasNext()) {"
"FastByteArrayOutputStream.java:275"$1$"				byte[] bytes = it.next();"
"FastByteArrayOutputStream.java:276"$1$"				if (it.hasNext()) {"
"FastByteArrayOutputStream.java:277"$1$"					System.arraycopy(bytes, 0, data, pos, bytes.length);"
"FastByteArrayOutputStream.java:278"$1$"					pos += bytes.length;"
"FastByteArrayOutputStream.java:279"$1$"				}"
"FastByteArrayOutputStream.java:280"$1$"				else {"
"FastByteArrayOutputStream.java:281"$1$"					System.arraycopy(bytes, 0, data, pos, this.index);"
"FastByteArrayOutputStream.java:282"$1$"				}"
"FastByteArrayOutputStream.java:283"$0$"			}"
"FastByteArrayOutputStream.java:284"$0$"			this.buffers.clear();"
"FastByteArrayOutputStream.java:285"$0$"			this.buffers.add(data);"
"FastByteArrayOutputStream.java:286"$0$"			this.index = totalSize;"
"FastByteArrayOutputStream.java:287"$0$"			this.alreadyBufferedSize = 0;"
"FastByteArrayOutputStream.java:288"$0$"		}"
"FastByteArrayOutputStream.java:289"$0$"	}"
"FastByteArrayOutputStream.java:290"$0$""
"FastByteArrayOutputStream.java:291"$0$"	/**"
"FastByteArrayOutputStream.java:292"$0$"	 * Create a new buffer and store it in the LinkedList"
"FastByteArrayOutputStream.java:293"$1$"	 * <p>Adds a new buffer that can store at least {@code minCapacity} bytes."
"FastByteArrayOutputStream.java:294"$0$"	 */"
"FastByteArrayOutputStream.java:295"$1$"	private void addBuffer(int minCapacity) {"
"FastByteArrayOutputStream.java:296"$1$"		if (this.buffers.peekLast() != null) {"
"FastByteArrayOutputStream.java:297"$1$"			this.alreadyBufferedSize += this.index;"
"FastByteArrayOutputStream.java:298"$1$"			this.index = 0;"
"FastByteArrayOutputStream.java:299"$1$"		}"
"FastByteArrayOutputStream.java:300"$1$"		if (this.nextBlockSize < minCapacity) {"
"FastByteArrayOutputStream.java:301"$1$"			this.nextBlockSize = nextPowerOf2(minCapacity);"
"FastByteArrayOutputStream.java:302"$1$"		}"
"FastByteArrayOutputStream.java:303"$0$"		this.buffers.add(new byte[this.nextBlockSize]);"
"FastByteArrayOutputStream.java:304"$0$"		this.nextBlockSize *= 2;  // block size doubles each time"
"FastByteArrayOutputStream.java:305"$0$"	}"
"FastByteArrayOutputStream.java:306"$0$""
"FastByteArrayOutputStream.java:307"$0$"	/**"
"FastByteArrayOutputStream.java:308"$0$"	 * Get the next power of 2 of a number (ex, the next power of 2 of 119 is 128)."
"FastByteArrayOutputStream.java:309"$0$"	 */"
"FastByteArrayOutputStream.java:310"$1$"	private static int nextPowerOf2(int val) {"
"FastByteArrayOutputStream.java:311"$1$"		val--;"
"FastByteArrayOutputStream.java:312"$1$"		val = (val >> 1) | val;"
"FastByteArrayOutputStream.java:313"$1$"		val = (val >> 2) | val;"
"FastByteArrayOutputStream.java:314"$1$"		val = (val >> 4) | val;"
"FastByteArrayOutputStream.java:315"$1$"		val = (val >> 8) | val;"
"FastByteArrayOutputStream.java:316"$1$"		val = (val >> 16) | val;"
"FastByteArrayOutputStream.java:317"$1$"		val++;"
"FastByteArrayOutputStream.java:318"$1$"		return val;"
"FastByteArrayOutputStream.java:319"$1$"	}"
"FastByteArrayOutputStream.java:320"$0$""
"FastByteArrayOutputStream.java:321"$0$""
"FastByteArrayOutputStream.java:322"$0$"	/**"
"FastByteArrayOutputStream.java:323"$1$"	 * An implementation of {@link java.io.InputStream} that reads from a given"
"FastByteArrayOutputStream.java:324"$0$"	 * <code>FastByteArrayOutputStream</code>."
"FastByteArrayOutputStream.java:325"$0$"	 */"
"FastByteArrayOutputStream.java:326"$1$"	private static final class FastByteArrayInputStream extends UpdateMessageDigestInputStream {"
"FastByteArrayOutputStream.java:327"$1$""
"FastByteArrayOutputStream.java:328"$1$"		private final FastByteArrayOutputStream fastByteArrayOutputStream;"
"FastByteArrayOutputStream.java:329"$1$""
"FastByteArrayOutputStream.java:330"$1$"		private final Iterator<byte[]> buffersIterator;"
"FastByteArrayOutputStream.java:331"$1$""
"FastByteArrayOutputStream.java:332"$1$"		@Nullable"
"FastByteArrayOutputStream.java:333"$1$"		private byte[] currentBuffer;"
"FastByteArrayOutputStream.java:334"$1$""
"FastByteArrayOutputStream.java:335"$1$"		private int currentBufferLength = 0;"
"FastByteArrayOutputStream.java:336"$1$""
"FastByteArrayOutputStream.java:337"$1$"		private int nextIndexInCurrentBuffer = 0;"
"FastByteArrayOutputStream.java:338"$1$""
"FastByteArrayOutputStream.java:339"$1$"		private int totalBytesRead = 0;"
"FastByteArrayOutputStream.java:340"$1$""
"FastByteArrayOutputStream.java:341"$1$"		/**"
"FastByteArrayOutputStream.java:342"$1$"		 * Create a new <code>FastByteArrayOutputStreamInputStream</code> backed"
"FastByteArrayOutputStream.java:343"$1$"		 * by the given <code>FastByteArrayOutputStream</code>."
"FastByteArrayOutputStream.java:344"$1$"		 */"
"FastByteArrayOutputStream.java:345"$1$"		public FastByteArrayInputStream(FastByteArrayOutputStream fastByteArrayOutputStream) {"
"FastByteArrayOutputStream.java:346"$1$"			this.fastByteArrayOutputStream = fastByteArrayOutputStream;"
"FastByteArrayOutputStream.java:347"$1$"			this.buffersIterator = fastByteArrayOutputStream.buffers.iterator();"
"FastByteArrayOutputStream.java:348"$1$"			if (this.buffersIterator.hasNext()) {"
"FastByteArrayOutputStream.java:349"$1$"				this.currentBuffer = this.buffersIterator.next();"
"FastByteArrayOutputStream.java:350"$1$"				if (this.currentBuffer == fastByteArrayOutputStream.buffers.getLast()) {"
"FastByteArrayOutputStream.java:351"$1$"					this.currentBufferLength = fastByteArrayOutputStream.index;"
"FastByteArrayOutputStream.java:352"$1$"				}"
"FastByteArrayOutputStream.java:353"$1$"				else {"
"FastByteArrayOutputStream.java:354"$1$"					this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);"
"FastByteArrayOutputStream.java:355"$1$"				}"
"FastByteArrayOutputStream.java:356"$0$"			}"
"FastByteArrayOutputStream.java:357"$0$"		}"
"FastByteArrayOutputStream.java:358"$0$""
"FastByteArrayOutputStream.java:359"$0$"		@Override"
"FastByteArrayOutputStream.java:360"$1$"		public int read() {"
"FastByteArrayOutputStream.java:361"$1$"			if (this.currentBuffer == null) {"
"FastByteArrayOutputStream.java:362"$0$"				// This stream doesn't have any data in it..."
"FastByteArrayOutputStream.java:363"$1$"				return -1;"
"FastByteArrayOutputStream.java:364"$1$"			}"
"FastByteArrayOutputStream.java:365"$1$"			else {"
"FastByteArrayOutputStream.java:366"$1$"				if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {"
"FastByteArrayOutputStream.java:367"$1$"					this.totalBytesRead++;"
"FastByteArrayOutputStream.java:368"$1$"					return this.currentBuffer[this.nextIndexInCurrentBuffer++] & 0xFF;"
"FastByteArrayOutputStream.java:369"$1$"				}"
"FastByteArrayOutputStream.java:370"$1$"				else {"
"FastByteArrayOutputStream.java:371"$1$"					if (this.buffersIterator.hasNext()) {"
"FastByteArrayOutputStream.java:372"$1$"						this.currentBuffer = this.buffersIterator.next();"
"FastByteArrayOutputStream.java:373"$1$"						updateCurrentBufferLength();"
"FastByteArrayOutputStream.java:374"$1$"						this.nextIndexInCurrentBuffer = 0;"
"FastByteArrayOutputStream.java:375"$1$"					}"
"FastByteArrayOutputStream.java:376"$1$"					else {"
"FastByteArrayOutputStream.java:377"$1$"						this.currentBuffer = null;"
"FastByteArrayOutputStream.java:378"$1$"					}"
"FastByteArrayOutputStream.java:379"$0$"					return read();"
"FastByteArrayOutputStream.java:380"$0$"				}"
"FastByteArrayOutputStream.java:381"$0$"			}"
"FastByteArrayOutputStream.java:382"$0$"		}"
"FastByteArrayOutputStream.java:383"$0$""
"FastByteArrayOutputStream.java:384"$0$"		@Override"
"FastByteArrayOutputStream.java:385"$1$"		public int read(byte[] b) {"
"FastByteArrayOutputStream.java:386"$1$"			return read(b, 0, b.length);"
"FastByteArrayOutputStream.java:387"$1$"		}"
"FastByteArrayOutputStream.java:388"$0$""
"FastByteArrayOutputStream.java:389"$0$"		@Override"
"FastByteArrayOutputStream.java:390"$1$"		public int read(byte[] b, int off, int len) {"
"FastByteArrayOutputStream.java:391"$1$"			if (off < 0 || len < 0 || len > b.length - off) {"
"FastByteArrayOutputStream.java:392"$1$"				throw new IndexOutOfBoundsException();"
"FastByteArrayOutputStream.java:393"$1$"			}"
"FastByteArrayOutputStream.java:394"$1$"			else if (len == 0) {"
"FastByteArrayOutputStream.java:395"$1$"				return 0;"
"FastByteArrayOutputStream.java:396"$1$"			}"
"FastByteArrayOutputStream.java:397"$1$"			else {"
"FastByteArrayOutputStream.java:398"$1$"				if (this.currentBuffer == null) {"
"FastByteArrayOutputStream.java:399"$0$"					// This stream doesn't have any data in it..."
"FastByteArrayOutputStream.java:400"$1$"					return -1;"
"FastByteArrayOutputStream.java:401"$1$"				}"
"FastByteArrayOutputStream.java:402"$1$"				else {"
"FastByteArrayOutputStream.java:403"$1$"					if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {"
"FastByteArrayOutputStream.java:404"$1$"						int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);"
"FastByteArrayOutputStream.java:405"$1$"						System.arraycopy(this.currentBuffer, this.nextIndexInCurrentBuffer, b, off, bytesToCopy);"
"FastByteArrayOutputStream.java:406"$1$"						this.totalBytesRead += bytesToCopy;"
"FastByteArrayOutputStream.java:407"$1$"						this.nextIndexInCurrentBuffer += bytesToCopy;"
"FastByteArrayOutputStream.java:408"$1$"						int remaining = read(b, off + bytesToCopy, len - bytesToCopy);"
"FastByteArrayOutputStream.java:409"$1$"						return bytesToCopy + Math.max(remaining, 0);"
"FastByteArrayOutputStream.java:410"$1$"					}"
"FastByteArrayOutputStream.java:411"$1$"					else {"
"FastByteArrayOutputStream.java:412"$1$"						if (this.buffersIterator.hasNext()) {"
"FastByteArrayOutputStream.java:413"$1$"							this.currentBuffer = this.buffersIterator.next();"
"FastByteArrayOutputStream.java:414"$1$"							updateCurrentBufferLength();"
"FastByteArrayOutputStream.java:415"$1$"							this.nextIndexInCurrentBuffer = 0;"
"FastByteArrayOutputStream.java:416"$1$"						}"
"FastByteArrayOutputStream.java:417"$1$"						else {"
"FastByteArrayOutputStream.java:418"$1$"							this.currentBuffer = null;"
"FastByteArrayOutputStream.java:419"$1$"						}"
"FastByteArrayOutputStream.java:420"$0$"						return read(b, off, len);"
"FastByteArrayOutputStream.java:421"$0$"					}"
"FastByteArrayOutputStream.java:422"$0$"				}"
"FastByteArrayOutputStream.java:423"$0$"			}"
"FastByteArrayOutputStream.java:424"$0$"		}"
"FastByteArrayOutputStream.java:425"$0$""
"FastByteArrayOutputStream.java:426"$0$"		@Override"
"FastByteArrayOutputStream.java:427"$1$"		public long skip(long n) throws IOException {"
"FastByteArrayOutputStream.java:428"$1$"			if (n > Integer.MAX_VALUE) {"
"FastByteArrayOutputStream.java:429"$1$"				throw new IllegalArgumentException(""n exceeds maximum ("" + Integer.MAX_VALUE + ""): "" + n);"
"FastByteArrayOutputStream.java:430"$1$"			}"
"FastByteArrayOutputStream.java:431"$1$"			else if (n == 0) {"
"FastByteArrayOutputStream.java:432"$1$"				return 0;"
"FastByteArrayOutputStream.java:433"$1$"			}"
"FastByteArrayOutputStream.java:434"$1$"			else if (n < 0) {"
"FastByteArrayOutputStream.java:435"$1$"				throw new IllegalArgumentException(""n must be 0 or greater: "" + n);"
"FastByteArrayOutputStream.java:436"$1$"			}"
"FastByteArrayOutputStream.java:437"$0$"			int len = (int) n;"
"FastByteArrayOutputStream.java:438"$1$"			if (this.currentBuffer == null) {"
"FastByteArrayOutputStream.java:439"$0$"				// This stream doesn't have any data in it..."
"FastByteArrayOutputStream.java:440"$1$"				return 0;"
"FastByteArrayOutputStream.java:441"$1$"			}"
"FastByteArrayOutputStream.java:442"$1$"			else {"
"FastByteArrayOutputStream.java:443"$1$"				if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {"
"FastByteArrayOutputStream.java:444"$1$"					int bytesToSkip = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);"
"FastByteArrayOutputStream.java:445"$1$"					this.totalBytesRead += bytesToSkip;"
"FastByteArrayOutputStream.java:446"$1$"					this.nextIndexInCurrentBuffer += bytesToSkip;"
"FastByteArrayOutputStream.java:447"$1$"					return (bytesToSkip + skip(len - bytesToSkip));"
"FastByteArrayOutputStream.java:448"$1$"				}"
"FastByteArrayOutputStream.java:449"$1$"				else {"
"FastByteArrayOutputStream.java:450"$1$"					if (this.buffersIterator.hasNext()) {"
"FastByteArrayOutputStream.java:451"$1$"						this.currentBuffer = this.buffersIterator.next();"
"FastByteArrayOutputStream.java:452"$1$"						updateCurrentBufferLength();"
"FastByteArrayOutputStream.java:453"$1$"						this.nextIndexInCurrentBuffer = 0;"
"FastByteArrayOutputStream.java:454"$1$"					}"
"FastByteArrayOutputStream.java:455"$1$"					else {"
"FastByteArrayOutputStream.java:456"$1$"						this.currentBuffer = null;"
"FastByteArrayOutputStream.java:457"$1$"					}"
"FastByteArrayOutputStream.java:458"$0$"					return skip(len);"
"FastByteArrayOutputStream.java:459"$0$"				}"
"FastByteArrayOutputStream.java:460"$0$"			}"
"FastByteArrayOutputStream.java:461"$0$"		}"
"FastByteArrayOutputStream.java:462"$0$""
"FastByteArrayOutputStream.java:463"$0$"		@Override"
"FastByteArrayOutputStream.java:464"$1$"		public int available() {"
"FastByteArrayOutputStream.java:465"$1$"			return (this.fastByteArrayOutputStream.size() - this.totalBytesRead);"
"FastByteArrayOutputStream.java:466"$1$"		}"
"FastByteArrayOutputStream.java:467"$0$""
"FastByteArrayOutputStream.java:468"$0$"		/**"
"FastByteArrayOutputStream.java:469"$0$"		 * Update the message digest with the remaining bytes in this stream."
"FastByteArrayOutputStream.java:470"$0$"		 * @param messageDigest the message digest to update"
"FastByteArrayOutputStream.java:471"$0$"		 */"
"FastByteArrayOutputStream.java:472"$0$"		@Override"
"FastByteArrayOutputStream.java:473"$1$"		public void updateMessageDigest(MessageDigest messageDigest) {"
"FastByteArrayOutputStream.java:474"$1$"			updateMessageDigest(messageDigest, available());"
"FastByteArrayOutputStream.java:475"$1$"		}"
"FastByteArrayOutputStream.java:476"$0$""
"FastByteArrayOutputStream.java:477"$0$"		/**"
"FastByteArrayOutputStream.java:478"$0$"		 * Update the message digest with the next len bytes in this stream."
"FastByteArrayOutputStream.java:479"$0$"		 * Avoids creating new byte arrays and use internal buffers for performance."
"FastByteArrayOutputStream.java:480"$0$"		 * @param messageDigest the message digest to update"
"FastByteArrayOutputStream.java:481"$0$"		 * @param len how many bytes to read from this stream and use to update the message digest"
"FastByteArrayOutputStream.java:482"$0$"		 */"
"FastByteArrayOutputStream.java:483"$0$"		@Override"
"FastByteArrayOutputStream.java:484"$1$"		public void updateMessageDigest(MessageDigest messageDigest, int len) {"
"FastByteArrayOutputStream.java:485"$1$"			if (this.currentBuffer == null) {"
"FastByteArrayOutputStream.java:486"$0$"				// This stream doesn't have any data in it..."
"FastByteArrayOutputStream.java:487"$1$"				return;"
"FastByteArrayOutputStream.java:488"$1$"			}"
"FastByteArrayOutputStream.java:489"$1$"			else if (len == 0) {"
"FastByteArrayOutputStream.java:490"$1$"				return;"
"FastByteArrayOutputStream.java:491"$1$"			}"
"FastByteArrayOutputStream.java:492"$1$"			else if (len < 0) {"
"FastByteArrayOutputStream.java:493"$1$"				throw new IllegalArgumentException(""len must be 0 or greater: "" + len);"
"FastByteArrayOutputStream.java:494"$1$"			}"
"FastByteArrayOutputStream.java:495"$1$"			else {"
"FastByteArrayOutputStream.java:496"$1$"				if (this.nextIndexInCurrentBuffer < this.currentBufferLength) {"
"FastByteArrayOutputStream.java:497"$1$"					int bytesToCopy = Math.min(len, this.currentBufferLength - this.nextIndexInCurrentBuffer);"
"FastByteArrayOutputStream.java:498"$1$"					messageDigest.update(this.currentBuffer, this.nextIndexInCurrentBuffer, bytesToCopy);"
"FastByteArrayOutputStream.java:499"$1$"					this.nextIndexInCurrentBuffer += bytesToCopy;"
"FastByteArrayOutputStream.java:500"$1$"					updateMessageDigest(messageDigest, len - bytesToCopy);"
"FastByteArrayOutputStream.java:501"$1$"				}"
"FastByteArrayOutputStream.java:502"$1$"				else {"
"FastByteArrayOutputStream.java:503"$1$"					if (this.buffersIterator.hasNext()) {"
"FastByteArrayOutputStream.java:504"$1$"						this.currentBuffer = this.buffersIterator.next();"
"FastByteArrayOutputStream.java:505"$1$"						updateCurrentBufferLength();"
"FastByteArrayOutputStream.java:506"$1$"						this.nextIndexInCurrentBuffer = 0;"
"FastByteArrayOutputStream.java:507"$1$"					}"
"FastByteArrayOutputStream.java:508"$1$"					else {"
"FastByteArrayOutputStream.java:509"$1$"						this.currentBuffer = null;"
"FastByteArrayOutputStream.java:510"$1$"					}"
"FastByteArrayOutputStream.java:511"$0$"					updateMessageDigest(messageDigest, len);"
"FastByteArrayOutputStream.java:512"$0$"				}"
"FastByteArrayOutputStream.java:513"$0$"			}"
"FastByteArrayOutputStream.java:514"$0$"		}"
"FastByteArrayOutputStream.java:515"$0$""
"FastByteArrayOutputStream.java:516"$1$"		private void updateCurrentBufferLength() {"
"FastByteArrayOutputStream.java:517"$1$"			if (this.currentBuffer == this.fastByteArrayOutputStream.buffers.getLast()) {"
"FastByteArrayOutputStream.java:518"$1$"				this.currentBufferLength = this.fastByteArrayOutputStream.index;"
"FastByteArrayOutputStream.java:519"$1$"			}"
"FastByteArrayOutputStream.java:520"$1$"			else {"
"FastByteArrayOutputStream.java:521"$1$"				this.currentBufferLength = (this.currentBuffer != null ? this.currentBuffer.length : 0);"
"FastByteArrayOutputStream.java:522"$1$"			}"
"FastByteArrayOutputStream.java:523"$0$"		}"
"FastByteArrayOutputStream.java:524"$0$"	}"
"FastByteArrayOutputStream.java:525"$0$""
"FastByteArrayOutputStream.java:526"$0$"}"
"ResizableByteArrayOutputStream.java:1"$0$"/*"
"ResizableByteArrayOutputStream.java:2"$0$" * Copyright 2002-2015 the original author or authors."
"ResizableByteArrayOutputStream.java:3"$0$" *"
"ResizableByteArrayOutputStream.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResizableByteArrayOutputStream.java:5"$0$" * you may not use this file except in compliance with the License."
"ResizableByteArrayOutputStream.java:6"$0$" * You may obtain a copy of the License at"
"ResizableByteArrayOutputStream.java:7"$0$" *"
"ResizableByteArrayOutputStream.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResizableByteArrayOutputStream.java:9"$0$" *"
"ResizableByteArrayOutputStream.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResizableByteArrayOutputStream.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResizableByteArrayOutputStream.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResizableByteArrayOutputStream.java:13"$0$" * See the License for the specific language governing permissions and"
"ResizableByteArrayOutputStream.java:14"$0$" * limitations under the License."
"ResizableByteArrayOutputStream.java:15"$0$" */"
"ResizableByteArrayOutputStream.java:16"$0$""
"ResizableByteArrayOutputStream.java:17"$0$"package org.springframework.util;"
"ResizableByteArrayOutputStream.java:18"$0$""
"ResizableByteArrayOutputStream.java:19"$0$"import java.io.ByteArrayOutputStream;"
"ResizableByteArrayOutputStream.java:20"$0$""
"ResizableByteArrayOutputStream.java:21"$0$"/**"
"ResizableByteArrayOutputStream.java:22"$1$" * An extension of {@link java.io.ByteArrayOutputStream} that:"
"ResizableByteArrayOutputStream.java:23"$0$" * <ul>"
"ResizableByteArrayOutputStream.java:24"$1$" * <li>has public {@link org.springframework.util.ResizableByteArrayOutputStream#grow(int)}"
"ResizableByteArrayOutputStream.java:25"$1$" * and {@link org.springframework.util.ResizableByteArrayOutputStream#resize(int)} methods"
"ResizableByteArrayOutputStream.java:26"$0$" * to get more control over the size of the internal buffer</li>"
"ResizableByteArrayOutputStream.java:27"$0$" * <li>has a higher initial capacity (256) by default</li>"
"ResizableByteArrayOutputStream.java:28"$0$" * </ul>"
"ResizableByteArrayOutputStream.java:29"$0$" *"
"ResizableByteArrayOutputStream.java:30"$1$" * <p>As of 4.2, this class has been superseded by {@link FastByteArrayOutputStream}"
"ResizableByteArrayOutputStream.java:31"$1$" * for Spring's internal use where no assignability to {@link ByteArrayOutputStream}"
"ResizableByteArrayOutputStream.java:32"$1$" * is needed (since {@link FastByteArrayOutputStream} is more efficient with buffer"
"ResizableByteArrayOutputStream.java:33"$1$" * resize management but doesn't extend the standard {@link ByteArrayOutputStream})."
"ResizableByteArrayOutputStream.java:34"$0$" *"
"ResizableByteArrayOutputStream.java:35"$0$" * @author Brian Clozel"
"ResizableByteArrayOutputStream.java:36"$0$" * @author Juergen Hoeller"
"ResizableByteArrayOutputStream.java:37"$0$" * @since 4.0.3"
"ResizableByteArrayOutputStream.java:38"$0$" * @see #resize"
"ResizableByteArrayOutputStream.java:39"$0$" * @see FastByteArrayOutputStream"
"ResizableByteArrayOutputStream.java:40"$0$" */"
"ResizableByteArrayOutputStream.java:41"$1$"public class ResizableByteArrayOutputStream extends ByteArrayOutputStream {"
"ResizableByteArrayOutputStream.java:42"$1$""
"ResizableByteArrayOutputStream.java:43"$1$"	private static final int DEFAULT_INITIAL_CAPACITY = 256;"
"ResizableByteArrayOutputStream.java:44"$1$""
"ResizableByteArrayOutputStream.java:45"$1$""
"ResizableByteArrayOutputStream.java:46"$1$"	/**"
"ResizableByteArrayOutputStream.java:47"$1$"	 * Create a new <code>ResizableByteArrayOutputStream</code>"
"ResizableByteArrayOutputStream.java:48"$1$"	 * with the default initial capacity of 256 bytes."
"ResizableByteArrayOutputStream.java:49"$1$"	 */"
"ResizableByteArrayOutputStream.java:50"$1$"	public ResizableByteArrayOutputStream() {"
"ResizableByteArrayOutputStream.java:51"$1$"		super(DEFAULT_INITIAL_CAPACITY);"
"ResizableByteArrayOutputStream.java:52"$1$"	}"
"ResizableByteArrayOutputStream.java:53"$0$""
"ResizableByteArrayOutputStream.java:54"$0$"	/**"
"ResizableByteArrayOutputStream.java:55"$0$"	 * Create a new <code>ResizableByteArrayOutputStream</code>"
"ResizableByteArrayOutputStream.java:56"$0$"	 * with the specified initial capacity."
"ResizableByteArrayOutputStream.java:57"$0$"	 * @param initialCapacity the initial buffer size in bytes"
"ResizableByteArrayOutputStream.java:58"$0$"	 */"
"ResizableByteArrayOutputStream.java:59"$1$"	public ResizableByteArrayOutputStream(int initialCapacity) {"
"ResizableByteArrayOutputStream.java:60"$1$"		super(initialCapacity);"
"ResizableByteArrayOutputStream.java:61"$1$"	}"
"ResizableByteArrayOutputStream.java:62"$0$""
"ResizableByteArrayOutputStream.java:63"$0$""
"ResizableByteArrayOutputStream.java:64"$0$"	/**"
"ResizableByteArrayOutputStream.java:65"$0$"	 * Resize the internal buffer size to a specified capacity."
"ResizableByteArrayOutputStream.java:66"$0$"	 * @param targetCapacity the desired size of the buffer"
"ResizableByteArrayOutputStream.java:67"$0$"	 * @throws IllegalArgumentException if the given capacity is smaller than"
"ResizableByteArrayOutputStream.java:68"$0$"	 * the actual size of the content stored in the buffer already"
"ResizableByteArrayOutputStream.java:69"$0$"	 * @see ResizableByteArrayOutputStream#size()"
"ResizableByteArrayOutputStream.java:70"$0$"	 */"
"ResizableByteArrayOutputStream.java:71"$1$"	public synchronized void resize(int targetCapacity) {"
"ResizableByteArrayOutputStream.java:72"$1$"		Assert.isTrue(targetCapacity >= this.count, ""New capacity must not be smaller than current size"");"
"ResizableByteArrayOutputStream.java:73"$1$"		byte[] resizedBuffer = new byte[targetCapacity];"
"ResizableByteArrayOutputStream.java:74"$1$"		System.arraycopy(this.buf, 0, resizedBuffer, 0, this.count);"
"ResizableByteArrayOutputStream.java:75"$1$"		this.buf = resizedBuffer;"
"ResizableByteArrayOutputStream.java:76"$1$"	}"
"ResizableByteArrayOutputStream.java:77"$0$""
"ResizableByteArrayOutputStream.java:78"$0$"	/**"
"ResizableByteArrayOutputStream.java:79"$0$"	 * Grow the internal buffer size."
"ResizableByteArrayOutputStream.java:80"$0$"	 * @param additionalCapacity the number of bytes to add to the current buffer size"
"ResizableByteArrayOutputStream.java:81"$0$"	 * @see ResizableByteArrayOutputStream#size()"
"ResizableByteArrayOutputStream.java:82"$0$"	 */"
"ResizableByteArrayOutputStream.java:83"$1$"	public synchronized void grow(int additionalCapacity) {"
"ResizableByteArrayOutputStream.java:84"$1$"		Assert.isTrue(additionalCapacity >= 0, ""Additional capacity must be 0 or higher"");"
"ResizableByteArrayOutputStream.java:85"$1$"		if (this.count + additionalCapacity > this.buf.length) {"
"ResizableByteArrayOutputStream.java:86"$1$"			int newCapacity = Math.max(this.buf.length * 2, this.count + additionalCapacity);"
"ResizableByteArrayOutputStream.java:87"$1$"			resize(newCapacity);"
"ResizableByteArrayOutputStream.java:88"$1$"		}"
"ResizableByteArrayOutputStream.java:89"$0$"	}"
"ResizableByteArrayOutputStream.java:90"$0$""
"ResizableByteArrayOutputStream.java:91"$0$"	/**"
"ResizableByteArrayOutputStream.java:92"$0$"	 * Return the current size of this stream's internal buffer."
"ResizableByteArrayOutputStream.java:93"$0$"	 */"
"ResizableByteArrayOutputStream.java:94"$1$"	public synchronized int capacity() {"
"ResizableByteArrayOutputStream.java:95"$1$"		return this.buf.length;"
"ResizableByteArrayOutputStream.java:96"$1$"	}"
"ResizableByteArrayOutputStream.java:97"$0$""
"ResizableByteArrayOutputStream.java:98"$0$"}"
"SerializationUtils.java:1"$0$"/*"
"SerializationUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SerializationUtils.java:3"$0$" *"
"SerializationUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SerializationUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"SerializationUtils.java:6"$0$" * You may obtain a copy of the License at"
"SerializationUtils.java:7"$0$" *"
"SerializationUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SerializationUtils.java:9"$0$" *"
"SerializationUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SerializationUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SerializationUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SerializationUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"SerializationUtils.java:14"$0$" * limitations under the License."
"SerializationUtils.java:15"$0$" */"
"SerializationUtils.java:16"$0$""
"SerializationUtils.java:17"$0$"package org.springframework.util;"
"SerializationUtils.java:18"$0$""
"SerializationUtils.java:19"$0$"import java.io.ByteArrayInputStream;"
"SerializationUtils.java:20"$0$"import java.io.ByteArrayOutputStream;"
"SerializationUtils.java:21"$0$"import java.io.IOException;"
"SerializationUtils.java:22"$0$"import java.io.ObjectInputStream;"
"SerializationUtils.java:23"$0$"import java.io.ObjectOutputStream;"
"SerializationUtils.java:24"$0$""
"SerializationUtils.java:25"$0$"import org.springframework.lang.Nullable;"
"SerializationUtils.java:26"$0$""
"SerializationUtils.java:27"$0$"/**"
"SerializationUtils.java:28"$0$" * Static utilities for serialization and deserialization."
"SerializationUtils.java:29"$0$" *"
"SerializationUtils.java:30"$0$" * @author Dave Syer"
"SerializationUtils.java:31"$0$" * @since 3.0.5"
"SerializationUtils.java:32"$0$" */"
"SerializationUtils.java:33"$1$"public abstract class SerializationUtils {"
"SerializationUtils.java:34"$1$""
"SerializationUtils.java:35"$1$"	/**"
"SerializationUtils.java:36"$1$"	 * Serialize the given object to a byte array."
"SerializationUtils.java:37"$1$"	 * @param object the object to serialize"
"SerializationUtils.java:38"$1$"	 * @return an array of bytes representing the object in a portable fashion"
"SerializationUtils.java:39"$1$"	 */"
"SerializationUtils.java:40"$1$"	@Nullable"
"SerializationUtils.java:41"$1$"	public static byte[] serialize(@Nullable Object object) {"
"SerializationUtils.java:42"$1$"		if (object == null) {"
"SerializationUtils.java:43"$1$"			return null;"
"SerializationUtils.java:44"$1$"		}"
"SerializationUtils.java:45"$0$"		ByteArrayOutputStream baos = new ByteArrayOutputStream(1024);"
"SerializationUtils.java:46"$1$"		try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {"
"SerializationUtils.java:47"$1$"			oos.writeObject(object);"
"SerializationUtils.java:48"$1$"			oos.flush();"
"SerializationUtils.java:49"$1$"		}"
"SerializationUtils.java:50"$1$"		catch (IOException ex) {"
"SerializationUtils.java:51"$1$"			throw new IllegalArgumentException(""Failed to serialize object of type: "" + object.getClass(), ex);"
"SerializationUtils.java:52"$1$"		}"
"SerializationUtils.java:53"$0$"		return baos.toByteArray();"
"SerializationUtils.java:54"$0$"	}"
"SerializationUtils.java:55"$0$""
"SerializationUtils.java:56"$0$"	/**"
"SerializationUtils.java:57"$0$"	 * Deserialize the byte array into an object."
"SerializationUtils.java:58"$0$"	 * @param bytes a serialized object"
"SerializationUtils.java:59"$0$"	 * @return the result of deserializing the bytes"
"SerializationUtils.java:60"$0$"	 */"
"SerializationUtils.java:61"$0$"	@Nullable"
"SerializationUtils.java:62"$1$"	public static Object deserialize(@Nullable byte[] bytes) {"
"SerializationUtils.java:63"$1$"		if (bytes == null) {"
"SerializationUtils.java:64"$1$"			return null;"
"SerializationUtils.java:65"$1$"		}"
"SerializationUtils.java:66"$1$"		try (ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes))) {"
"SerializationUtils.java:67"$1$"			return ois.readObject();"
"SerializationUtils.java:68"$1$"		}"
"SerializationUtils.java:69"$1$"		catch (IOException ex) {"
"SerializationUtils.java:70"$1$"			throw new IllegalArgumentException(""Failed to deserialize object"", ex);"
"SerializationUtils.java:71"$1$"		}"
"SerializationUtils.java:72"$1$"		catch (ClassNotFoundException ex) {"
"SerializationUtils.java:73"$1$"			throw new IllegalStateException(""Failed to deserialize object type"", ex);"
"SerializationUtils.java:74"$1$"		}"
"SerializationUtils.java:75"$0$"	}"
"SerializationUtils.java:76"$0$""
"SerializationUtils.java:77"$0$"}"
"StringUtils.java:1"$0$"/*"
"StringUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"StringUtils.java:3"$0$" *"
"StringUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StringUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"StringUtils.java:6"$0$" * You may obtain a copy of the License at"
"StringUtils.java:7"$0$" *"
"StringUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StringUtils.java:9"$0$" *"
"StringUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StringUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StringUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StringUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"StringUtils.java:14"$0$" * limitations under the License."
"StringUtils.java:15"$0$" */"
"StringUtils.java:16"$0$""
"StringUtils.java:17"$0$"package org.springframework.util;"
"StringUtils.java:18"$0$""
"StringUtils.java:19"$0$"import java.io.ByteArrayOutputStream;"
"StringUtils.java:20"$0$"import java.nio.charset.Charset;"
"StringUtils.java:21"$0$"import java.util.ArrayList;"
"StringUtils.java:22"$0$"import java.util.Arrays;"
"StringUtils.java:23"$0$"import java.util.Collection;"
"StringUtils.java:24"$0$"import java.util.Collections;"
"StringUtils.java:25"$0$"import java.util.Enumeration;"
"StringUtils.java:26"$0$"import java.util.Iterator;"
"StringUtils.java:27"$0$"import java.util.LinkedHashSet;"
"StringUtils.java:28"$0$"import java.util.LinkedList;"
"StringUtils.java:29"$0$"import java.util.List;"
"StringUtils.java:30"$0$"import java.util.Locale;"
"StringUtils.java:31"$0$"import java.util.Properties;"
"StringUtils.java:32"$0$"import java.util.Set;"
"StringUtils.java:33"$0$"import java.util.StringJoiner;"
"StringUtils.java:34"$0$"import java.util.StringTokenizer;"
"StringUtils.java:35"$0$"import java.util.TimeZone;"
"StringUtils.java:36"$0$""
"StringUtils.java:37"$0$"import org.springframework.lang.Nullable;"
"StringUtils.java:38"$0$""
"StringUtils.java:39"$0$"/**"
"StringUtils.java:40"$1$" * Miscellaneous {@link String} utility methods."
"StringUtils.java:41"$0$" *"
"StringUtils.java:42"$0$" * <p>Mainly for internal use within the framework; consider"
"StringUtils.java:43"$0$" * <a href=""https://commons.apache.org/proper/commons-lang/"">Apache's Commons Lang</a>"
"StringUtils.java:44"$1$" * for a more comprehensive suite of {@code String} utilities."
"StringUtils.java:45"$0$" *"
"StringUtils.java:46"$0$" * <p>This class delivers some simple functionality that should really be"
"StringUtils.java:47"$1$" * provided by the core Java {@link String} and {@link StringBuilder}"
"StringUtils.java:48"$0$" * classes. It also provides easy-to-use methods to convert between"
"StringUtils.java:49"$0$" * delimited strings, such as CSV strings, and collections and arrays."
"StringUtils.java:50"$0$" *"
"StringUtils.java:51"$0$" * @author Rod Johnson"
"StringUtils.java:52"$0$" * @author Juergen Hoeller"
"StringUtils.java:53"$0$" * @author Keith Donald"
"StringUtils.java:54"$0$" * @author Rob Harrop"
"StringUtils.java:55"$0$" * @author Rick Evans"
"StringUtils.java:56"$0$" * @author Arjen Poutsma"
"StringUtils.java:57"$0$" * @author Sam Brannen"
"StringUtils.java:58"$0$" * @author Brian Clozel"
"StringUtils.java:59"$0$" * @since 16 April 2001"
"StringUtils.java:60"$0$" */"
"StringUtils.java:61"$1$"public abstract class StringUtils {"
"StringUtils.java:62"$1$""
"StringUtils.java:63"$1$"	private static final String[] EMPTY_STRING_ARRAY = {};"
"StringUtils.java:64"$1$""
"StringUtils.java:65"$1$"	private static final String FOLDER_SEPARATOR = ""/"";"
"StringUtils.java:66"$1$""
"StringUtils.java:67"$1$"	private static final String WINDOWS_FOLDER_SEPARATOR = ""\\"";"
"StringUtils.java:68"$1$""
"StringUtils.java:69"$1$"	private static final String TOP_PATH = "".."";"
"StringUtils.java:70"$1$""
"StringUtils.java:71"$1$"	private static final String CURRENT_PATH = ""."";"
"StringUtils.java:72"$1$""
"StringUtils.java:73"$1$"	private static final char EXTENSION_SEPARATOR = '.';"
"StringUtils.java:74"$1$""
"StringUtils.java:75"$1$""
"StringUtils.java:76"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:77"$0$"	// General convenience methods for working with Strings"
"StringUtils.java:78"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:79"$1$""
"StringUtils.java:80"$1$"	/**"
"StringUtils.java:81"$1$"	 * Check whether the given object (possibly a {@code String}) is empty."
"StringUtils.java:82"$1$"	 * This is effectively a shortcut for {@code !hasLength(String)}."
"StringUtils.java:83"$1$"	 * <p>This method accepts any Object as an argument, comparing it to"
"StringUtils.java:84"$1$"	 * {@code null} and the empty String. As a consequence, this method"
"StringUtils.java:85"$1$"	 * will never return {@code true} for a non-null non-String object."
"StringUtils.java:86"$1$"	 * <p>The Object signature is useful for general attribute handling code"
"StringUtils.java:87"$1$"	 * that commonly deals with Strings but generally has to iterate over"
"StringUtils.java:88"$1$"	 * Objects since attributes may e.g. be primitive value objects as well."
"StringUtils.java:89"$1$"	 * <p><b>Note: If the object is typed to {@code String} upfront, prefer"
"StringUtils.java:90"$1$"	 * {@link #hasLength(String)} or {@link #hasText(String)} instead.</b>"
"StringUtils.java:91"$1$"	 * @param str the candidate object (possibly a {@code String})"
"StringUtils.java:92"$1$"	 * @since 3.2.1"
"StringUtils.java:93"$1$"	 * @see #hasLength(String)"
"StringUtils.java:94"$1$"	 * @see #hasText(String)"
"StringUtils.java:95"$1$"	 */"
"StringUtils.java:96"$1$"	public static boolean isEmpty(@Nullable Object str) {"
"StringUtils.java:97"$1$"		return (str == null || """".equals(str));"
"StringUtils.java:98"$1$"	}"
"StringUtils.java:99"$0$""
"StringUtils.java:100"$0$"	/**"
"StringUtils.java:101"$1$"	 * Check that the given {@code CharSequence} is neither {@code null} nor"
"StringUtils.java:102"$0$"	 * of length 0."
"StringUtils.java:103"$1$"	 * <p>Note: this method returns {@code true} for a {@code CharSequence}"
"StringUtils.java:104"$0$"	 * that purely consists of whitespace."
"StringUtils.java:105"$0$"	 * <p><pre class=""code"">"
"StringUtils.java:106"$0$"	 * StringUtils.hasLength(null) = false"
"StringUtils.java:107"$0$"	 * StringUtils.hasLength("""") = false"
"StringUtils.java:108"$0$"	 * StringUtils.hasLength("" "") = true"
"StringUtils.java:109"$0$"	 * StringUtils.hasLength(""Hello"") = true"
"StringUtils.java:110"$0$"	 * </pre>"
"StringUtils.java:111"$1$"	 * @param str the {@code CharSequence} to check (may be {@code null})"
"StringUtils.java:112"$1$"	 * @return {@code true} if the {@code CharSequence} is not {@code null} and has length"
"StringUtils.java:113"$0$"	 * @see #hasLength(String)"
"StringUtils.java:114"$0$"	 * @see #hasText(CharSequence)"
"StringUtils.java:115"$0$"	 */"
"StringUtils.java:116"$1$"	public static boolean hasLength(@Nullable CharSequence str) {"
"StringUtils.java:117"$1$"		return (str != null && str.length() > 0);"
"StringUtils.java:118"$1$"	}"
"StringUtils.java:119"$0$""
"StringUtils.java:120"$0$"	/**"
"StringUtils.java:121"$1$"	 * Check that the given {@code String} is neither {@code null} nor of length 0."
"StringUtils.java:122"$1$"	 * <p>Note: this method returns {@code true} for a {@code String} that"
"StringUtils.java:123"$0$"	 * purely consists of whitespace."
"StringUtils.java:124"$1$"	 * @param str the {@code String} to check (may be {@code null})"
"StringUtils.java:125"$1$"	 * @return {@code true} if the {@code String} is not {@code null} and has length"
"StringUtils.java:126"$0$"	 * @see #hasLength(CharSequence)"
"StringUtils.java:127"$0$"	 * @see #hasText(String)"
"StringUtils.java:128"$0$"	 */"
"StringUtils.java:129"$1$"	public static boolean hasLength(@Nullable String str) {"
"StringUtils.java:130"$1$"		return (str != null && !str.isEmpty());"
"StringUtils.java:131"$1$"	}"
"StringUtils.java:132"$0$""
"StringUtils.java:133"$0$"	/**"
"StringUtils.java:134"$1$"	 * Check whether the given {@code CharSequence} contains actual <em>text</em>."
"StringUtils.java:135"$1$"	 * <p>More specifically, this method returns {@code true} if the"
"StringUtils.java:136"$1$"	 * {@code CharSequence} is not {@code null}, its length is greater than"
"StringUtils.java:137"$0$"	 * 0, and it contains at least one non-whitespace character."
"StringUtils.java:138"$0$"	 * <p><pre class=""code"">"
"StringUtils.java:139"$0$"	 * StringUtils.hasText(null) = false"
"StringUtils.java:140"$0$"	 * StringUtils.hasText("""") = false"
"StringUtils.java:141"$0$"	 * StringUtils.hasText("" "") = false"
"StringUtils.java:142"$0$"	 * StringUtils.hasText(""12345"") = true"
"StringUtils.java:143"$0$"	 * StringUtils.hasText("" 12345 "") = true"
"StringUtils.java:144"$0$"	 * </pre>"
"StringUtils.java:145"$1$"	 * @param str the {@code CharSequence} to check (may be {@code null})"
"StringUtils.java:146"$1$"	 * @return {@code true} if the {@code CharSequence} is not {@code null},"
"StringUtils.java:147"$0$"	 * its length is greater than 0, and it does not contain whitespace only"
"StringUtils.java:148"$0$"	 * @see #hasText(String)"
"StringUtils.java:149"$0$"	 * @see #hasLength(CharSequence)"
"StringUtils.java:150"$0$"	 * @see Character#isWhitespace"
"StringUtils.java:151"$0$"	 */"
"StringUtils.java:152"$1$"	public static boolean hasText(@Nullable CharSequence str) {"
"StringUtils.java:153"$1$"		return (str != null && str.length() > 0 && containsText(str));"
"StringUtils.java:154"$1$"	}"
"StringUtils.java:155"$0$""
"StringUtils.java:156"$0$"	/**"
"StringUtils.java:157"$1$"	 * Check whether the given {@code String} contains actual <em>text</em>."
"StringUtils.java:158"$1$"	 * <p>More specifically, this method returns {@code true} if the"
"StringUtils.java:159"$1$"	 * {@code String} is not {@code null}, its length is greater than 0,"
"StringUtils.java:160"$0$"	 * and it contains at least one non-whitespace character."
"StringUtils.java:161"$1$"	 * @param str the {@code String} to check (may be {@code null})"
"StringUtils.java:162"$1$"	 * @return {@code true} if the {@code String} is not {@code null}, its"
"StringUtils.java:163"$0$"	 * length is greater than 0, and it does not contain whitespace only"
"StringUtils.java:164"$0$"	 * @see #hasText(CharSequence)"
"StringUtils.java:165"$0$"	 * @see #hasLength(String)"
"StringUtils.java:166"$0$"	 * @see Character#isWhitespace"
"StringUtils.java:167"$0$"	 */"
"StringUtils.java:168"$1$"	public static boolean hasText(@Nullable String str) {"
"StringUtils.java:169"$1$"		return (str != null && !str.isEmpty() && containsText(str));"
"StringUtils.java:170"$1$"	}"
"StringUtils.java:171"$0$""
"StringUtils.java:172"$1$"	private static boolean containsText(CharSequence str) {"
"StringUtils.java:173"$1$"		int strLen = str.length();"
"StringUtils.java:174"$1$"		for (int i = 0; i < strLen; i++) {"
"StringUtils.java:175"$1$"			if (!Character.isWhitespace(str.charAt(i))) {"
"StringUtils.java:176"$1$"				return true;"
"StringUtils.java:177"$1$"			}"
"StringUtils.java:178"$0$"		}"
"StringUtils.java:179"$0$"		return false;"
"StringUtils.java:180"$0$"	}"
"StringUtils.java:181"$0$""
"StringUtils.java:182"$0$"	/**"
"StringUtils.java:183"$1$"	 * Check whether the given {@code CharSequence} contains any whitespace characters."
"StringUtils.java:184"$1$"	 * @param str the {@code CharSequence} to check (may be {@code null})"
"StringUtils.java:185"$1$"	 * @return {@code true} if the {@code CharSequence} is not empty and"
"StringUtils.java:186"$0$"	 * contains at least 1 whitespace character"
"StringUtils.java:187"$0$"	 * @see Character#isWhitespace"
"StringUtils.java:188"$0$"	 */"
"StringUtils.java:189"$1$"	public static boolean containsWhitespace(@Nullable CharSequence str) {"
"StringUtils.java:190"$1$"		if (!hasLength(str)) {"
"StringUtils.java:191"$1$"			return false;"
"StringUtils.java:192"$1$"		}"
"StringUtils.java:193"$0$""
"StringUtils.java:194"$0$"		int strLen = str.length();"
"StringUtils.java:195"$1$"		for (int i = 0; i < strLen; i++) {"
"StringUtils.java:196"$1$"			if (Character.isWhitespace(str.charAt(i))) {"
"StringUtils.java:197"$1$"				return true;"
"StringUtils.java:198"$1$"			}"
"StringUtils.java:199"$0$"		}"
"StringUtils.java:200"$0$"		return false;"
"StringUtils.java:201"$0$"	}"
"StringUtils.java:202"$0$""
"StringUtils.java:203"$0$"	/**"
"StringUtils.java:204"$1$"	 * Check whether the given {@code String} contains any whitespace characters."
"StringUtils.java:205"$1$"	 * @param str the {@code String} to check (may be {@code null})"
"StringUtils.java:206"$1$"	 * @return {@code true} if the {@code String} is not empty and"
"StringUtils.java:207"$0$"	 * contains at least 1 whitespace character"
"StringUtils.java:208"$0$"	 * @see #containsWhitespace(CharSequence)"
"StringUtils.java:209"$0$"	 */"
"StringUtils.java:210"$1$"	public static boolean containsWhitespace(@Nullable String str) {"
"StringUtils.java:211"$1$"		return containsWhitespace((CharSequence) str);"
"StringUtils.java:212"$1$"	}"
"StringUtils.java:213"$0$""
"StringUtils.java:214"$0$"	/**"
"StringUtils.java:215"$1$"	 * Trim leading and trailing whitespace from the given {@code String}."
"StringUtils.java:216"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:217"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:218"$0$"	 * @see java.lang.Character#isWhitespace"
"StringUtils.java:219"$0$"	 */"
"StringUtils.java:220"$1$"	public static String trimWhitespace(String str) {"
"StringUtils.java:221"$1$"		if (!hasLength(str)) {"
"StringUtils.java:222"$1$"			return str;"
"StringUtils.java:223"$1$"		}"
"StringUtils.java:224"$0$""
"StringUtils.java:225"$0$"		int beginIndex = 0;"
"StringUtils.java:226"$0$"		int endIndex = str.length() - 1;"
"StringUtils.java:227"$0$""
"StringUtils.java:228"$1$"		while (beginIndex <= endIndex && Character.isWhitespace(str.charAt(beginIndex))) {"
"StringUtils.java:229"$1$"			beginIndex++;"
"StringUtils.java:230"$1$"		}"
"StringUtils.java:231"$0$""
"StringUtils.java:232"$1$"		while (endIndex > beginIndex && Character.isWhitespace(str.charAt(endIndex))) {"
"StringUtils.java:233"$1$"			endIndex--;"
"StringUtils.java:234"$1$"		}"
"StringUtils.java:235"$0$""
"StringUtils.java:236"$0$"		return str.substring(beginIndex, endIndex + 1);"
"StringUtils.java:237"$0$"	}"
"StringUtils.java:238"$0$""
"StringUtils.java:239"$0$"	/**"
"StringUtils.java:240"$1$"	 * Trim <i>all</i> whitespace from the given {@code String}:"
"StringUtils.java:241"$0$"	 * leading, trailing, and in between characters."
"StringUtils.java:242"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:243"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:244"$0$"	 * @see java.lang.Character#isWhitespace"
"StringUtils.java:245"$0$"	 */"
"StringUtils.java:246"$1$"	public static String trimAllWhitespace(String str) {"
"StringUtils.java:247"$1$"		if (!hasLength(str)) {"
"StringUtils.java:248"$1$"			return str;"
"StringUtils.java:249"$1$"		}"
"StringUtils.java:250"$0$""
"StringUtils.java:251"$0$"		int len = str.length();"
"StringUtils.java:252"$0$"		StringBuilder sb = new StringBuilder(str.length());"
"StringUtils.java:253"$1$"		for (int i = 0; i < len; i++) {"
"StringUtils.java:254"$1$"			char c = str.charAt(i);"
"StringUtils.java:255"$1$"			if (!Character.isWhitespace(c)) {"
"StringUtils.java:256"$1$"				sb.append(c);"
"StringUtils.java:257"$1$"			}"
"StringUtils.java:258"$0$"		}"
"StringUtils.java:259"$0$"		return sb.toString();"
"StringUtils.java:260"$0$"	}"
"StringUtils.java:261"$0$""
"StringUtils.java:262"$0$"	/**"
"StringUtils.java:263"$1$"	 * Trim leading whitespace from the given {@code String}."
"StringUtils.java:264"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:265"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:266"$0$"	 * @see java.lang.Character#isWhitespace"
"StringUtils.java:267"$0$"	 */"
"StringUtils.java:268"$1$"	public static String trimLeadingWhitespace(String str) {"
"StringUtils.java:269"$1$"		if (!hasLength(str)) {"
"StringUtils.java:270"$1$"			return str;"
"StringUtils.java:271"$1$"		}"
"StringUtils.java:272"$0$""
"StringUtils.java:273"$0$"		StringBuilder sb = new StringBuilder(str);"
"StringUtils.java:274"$1$"		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {"
"StringUtils.java:275"$1$"			sb.deleteCharAt(0);"
"StringUtils.java:276"$1$"		}"
"StringUtils.java:277"$0$"		return sb.toString();"
"StringUtils.java:278"$0$"	}"
"StringUtils.java:279"$0$""
"StringUtils.java:280"$0$"	/**"
"StringUtils.java:281"$1$"	 * Trim trailing whitespace from the given {@code String}."
"StringUtils.java:282"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:283"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:284"$0$"	 * @see java.lang.Character#isWhitespace"
"StringUtils.java:285"$0$"	 */"
"StringUtils.java:286"$1$"	public static String trimTrailingWhitespace(String str) {"
"StringUtils.java:287"$1$"		if (!hasLength(str)) {"
"StringUtils.java:288"$1$"			return str;"
"StringUtils.java:289"$1$"		}"
"StringUtils.java:290"$0$""
"StringUtils.java:291"$0$"		StringBuilder sb = new StringBuilder(str);"
"StringUtils.java:292"$1$"		while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {"
"StringUtils.java:293"$1$"			sb.deleteCharAt(sb.length() - 1);"
"StringUtils.java:294"$1$"		}"
"StringUtils.java:295"$0$"		return sb.toString();"
"StringUtils.java:296"$0$"	}"
"StringUtils.java:297"$0$""
"StringUtils.java:298"$0$"	/**"
"StringUtils.java:299"$1$"	 * Trim all occurrences of the supplied leading character from the given {@code String}."
"StringUtils.java:300"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:301"$0$"	 * @param leadingCharacter the leading character to be trimmed"
"StringUtils.java:302"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:303"$0$"	 */"
"StringUtils.java:304"$1$"	public static String trimLeadingCharacter(String str, char leadingCharacter) {"
"StringUtils.java:305"$1$"		if (!hasLength(str)) {"
"StringUtils.java:306"$1$"			return str;"
"StringUtils.java:307"$1$"		}"
"StringUtils.java:308"$0$""
"StringUtils.java:309"$0$"		StringBuilder sb = new StringBuilder(str);"
"StringUtils.java:310"$1$"		while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {"
"StringUtils.java:311"$1$"			sb.deleteCharAt(0);"
"StringUtils.java:312"$1$"		}"
"StringUtils.java:313"$0$"		return sb.toString();"
"StringUtils.java:314"$0$"	}"
"StringUtils.java:315"$0$""
"StringUtils.java:316"$0$"	/**"
"StringUtils.java:317"$1$"	 * Trim all occurrences of the supplied trailing character from the given {@code String}."
"StringUtils.java:318"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:319"$0$"	 * @param trailingCharacter the trailing character to be trimmed"
"StringUtils.java:320"$1$"	 * @return the trimmed {@code String}"
"StringUtils.java:321"$0$"	 */"
"StringUtils.java:322"$1$"	public static String trimTrailingCharacter(String str, char trailingCharacter) {"
"StringUtils.java:323"$1$"		if (!hasLength(str)) {"
"StringUtils.java:324"$1$"			return str;"
"StringUtils.java:325"$1$"		}"
"StringUtils.java:326"$0$""
"StringUtils.java:327"$0$"		StringBuilder sb = new StringBuilder(str);"
"StringUtils.java:328"$1$"		while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {"
"StringUtils.java:329"$1$"			sb.deleteCharAt(sb.length() - 1);"
"StringUtils.java:330"$1$"		}"
"StringUtils.java:331"$0$"		return sb.toString();"
"StringUtils.java:332"$0$"	}"
"StringUtils.java:333"$0$""
"StringUtils.java:334"$0$"	/**"
"StringUtils.java:335"$1$"	 * Test if the given {@code String} starts with the specified prefix,"
"StringUtils.java:336"$0$"	 * ignoring upper/lower case."
"StringUtils.java:337"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:338"$0$"	 * @param prefix the prefix to look for"
"StringUtils.java:339"$0$"	 * @see java.lang.String#startsWith"
"StringUtils.java:340"$0$"	 */"
"StringUtils.java:341"$1$"	public static boolean startsWithIgnoreCase(@Nullable String str, @Nullable String prefix) {"
"StringUtils.java:342"$1$"		return (str != null && prefix != null && str.length() >= prefix.length() &&"
"StringUtils.java:343"$1$"				str.regionMatches(true, 0, prefix, 0, prefix.length()));"
"StringUtils.java:344"$1$"	}"
"StringUtils.java:345"$0$""
"StringUtils.java:346"$0$"	/**"
"StringUtils.java:347"$1$"	 * Test if the given {@code String} ends with the specified suffix,"
"StringUtils.java:348"$0$"	 * ignoring upper/lower case."
"StringUtils.java:349"$1$"	 * @param str the {@code String} to check"
"StringUtils.java:350"$0$"	 * @param suffix the suffix to look for"
"StringUtils.java:351"$0$"	 * @see java.lang.String#endsWith"
"StringUtils.java:352"$0$"	 */"
"StringUtils.java:353"$1$"	public static boolean endsWithIgnoreCase(@Nullable String str, @Nullable String suffix) {"
"StringUtils.java:354"$1$"		return (str != null && suffix != null && str.length() >= suffix.length() &&"
"StringUtils.java:355"$1$"				str.regionMatches(true, str.length() - suffix.length(), suffix, 0, suffix.length()));"
"StringUtils.java:356"$1$"	}"
"StringUtils.java:357"$0$""
"StringUtils.java:358"$0$"	/**"
"StringUtils.java:359"$0$"	 * Test whether the given string matches the given substring"
"StringUtils.java:360"$0$"	 * at the given index."
"StringUtils.java:361"$0$"	 * @param str the original string (or StringBuilder)"
"StringUtils.java:362"$0$"	 * @param index the index in the original string to start matching against"
"StringUtils.java:363"$0$"	 * @param substring the substring to match at the given index"
"StringUtils.java:364"$0$"	 */"
"StringUtils.java:365"$1$"	public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {"
"StringUtils.java:366"$1$"		if (index + substring.length() > str.length()) {"
"StringUtils.java:367"$1$"			return false;"
"StringUtils.java:368"$1$"		}"
"StringUtils.java:369"$1$"		for (int i = 0; i < substring.length(); i++) {"
"StringUtils.java:370"$1$"			if (str.charAt(index + i) != substring.charAt(i)) {"
"StringUtils.java:371"$1$"				return false;"
"StringUtils.java:372"$1$"			}"
"StringUtils.java:373"$0$"		}"
"StringUtils.java:374"$0$"		return true;"
"StringUtils.java:375"$0$"	}"
"StringUtils.java:376"$0$""
"StringUtils.java:377"$0$"	/**"
"StringUtils.java:378"$1$"	 * Count the occurrences of the substring {@code sub} in string {@code str}."
"StringUtils.java:379"$0$"	 * @param str string to search in"
"StringUtils.java:380"$0$"	 * @param sub string to search for"
"StringUtils.java:381"$0$"	 */"
"StringUtils.java:382"$1$"	public static int countOccurrencesOf(String str, String sub) {"
"StringUtils.java:383"$1$"		if (!hasLength(str) || !hasLength(sub)) {"
"StringUtils.java:384"$1$"			return 0;"
"StringUtils.java:385"$1$"		}"
"StringUtils.java:386"$0$""
"StringUtils.java:387"$0$"		int count = 0;"
"StringUtils.java:388"$0$"		int pos = 0;"
"StringUtils.java:389"$0$"		int idx;"
"StringUtils.java:390"$1$"		while ((idx = str.indexOf(sub, pos)) != -1) {"
"StringUtils.java:391"$1$"			++count;"
"StringUtils.java:392"$1$"			pos = idx + sub.length();"
"StringUtils.java:393"$1$"		}"
"StringUtils.java:394"$0$"		return count;"
"StringUtils.java:395"$0$"	}"
"StringUtils.java:396"$0$""
"StringUtils.java:397"$0$"	/**"
"StringUtils.java:398"$0$"	 * Replace all occurrences of a substring within a string with another string."
"StringUtils.java:399"$1$"	 * @param inString {@code String} to examine"
"StringUtils.java:400"$1$"	 * @param oldPattern {@code String} to replace"
"StringUtils.java:401"$1$"	 * @param newPattern {@code String} to insert"
"StringUtils.java:402"$1$"	 * @return a {@code String} with the replacements"
"StringUtils.java:403"$0$"	 */"
"StringUtils.java:404"$1$"	public static String replace(String inString, String oldPattern, @Nullable String newPattern) {"
"StringUtils.java:405"$1$"		if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {"
"StringUtils.java:406"$1$"			return inString;"
"StringUtils.java:407"$1$"		}"
"StringUtils.java:408"$0$"		int index = inString.indexOf(oldPattern);"
"StringUtils.java:409"$1$"		if (index == -1) {"
"StringUtils.java:410"$0$"			// no occurrence -> can return input as-is"
"StringUtils.java:411"$1$"			return inString;"
"StringUtils.java:412"$1$"		}"
"StringUtils.java:413"$0$""
"StringUtils.java:414"$0$"		int capacity = inString.length();"
"StringUtils.java:415"$1$"		if (newPattern.length() > oldPattern.length()) {"
"StringUtils.java:416"$1$"			capacity += 16;"
"StringUtils.java:417"$1$"		}"
"StringUtils.java:418"$0$"		StringBuilder sb = new StringBuilder(capacity);"
"StringUtils.java:419"$0$""
"StringUtils.java:420"$0$"		int pos = 0;  // our position in the old string"
"StringUtils.java:421"$0$"		int patLen = oldPattern.length();"
"StringUtils.java:422"$1$"		while (index >= 0) {"
"StringUtils.java:423"$1$"			sb.append(inString, pos, index);"
"StringUtils.java:424"$1$"			sb.append(newPattern);"
"StringUtils.java:425"$1$"			pos = index + patLen;"
"StringUtils.java:426"$1$"			index = inString.indexOf(oldPattern, pos);"
"StringUtils.java:427"$1$"		}"
"StringUtils.java:428"$0$""
"StringUtils.java:429"$0$"		// append any characters to the right of a match"
"StringUtils.java:430"$0$"		sb.append(inString, pos, inString.length());"
"StringUtils.java:431"$0$"		return sb.toString();"
"StringUtils.java:432"$0$"	}"
"StringUtils.java:433"$0$""
"StringUtils.java:434"$0$"	/**"
"StringUtils.java:435"$0$"	 * Delete all occurrences of the given substring."
"StringUtils.java:436"$1$"	 * @param inString the original {@code String}"
"StringUtils.java:437"$0$"	 * @param pattern the pattern to delete all occurrences of"
"StringUtils.java:438"$1$"	 * @return the resulting {@code String}"
"StringUtils.java:439"$0$"	 */"
"StringUtils.java:440"$1$"	public static String delete(String inString, String pattern) {"
"StringUtils.java:441"$1$"		return replace(inString, pattern, """");"
"StringUtils.java:442"$1$"	}"
"StringUtils.java:443"$0$""
"StringUtils.java:444"$0$"	/**"
"StringUtils.java:445"$1$"	 * Delete any character in a given {@code String}."
"StringUtils.java:446"$1$"	 * @param inString the original {@code String}"
"StringUtils.java:447"$0$"	 * @param charsToDelete a set of characters to delete."
"StringUtils.java:448"$0$"	 * E.g. ""az\n"" will delete 'a's, 'z's and new lines."
"StringUtils.java:449"$1$"	 * @return the resulting {@code String}"
"StringUtils.java:450"$0$"	 */"
"StringUtils.java:451"$1$"	public static String deleteAny(String inString, @Nullable String charsToDelete) {"
"StringUtils.java:452"$1$"		if (!hasLength(inString) || !hasLength(charsToDelete)) {"
"StringUtils.java:453"$1$"			return inString;"
"StringUtils.java:454"$1$"		}"
"StringUtils.java:455"$0$""
"StringUtils.java:456"$0$"		StringBuilder sb = new StringBuilder(inString.length());"
"StringUtils.java:457"$1$"		for (int i = 0; i < inString.length(); i++) {"
"StringUtils.java:458"$1$"			char c = inString.charAt(i);"
"StringUtils.java:459"$1$"			if (charsToDelete.indexOf(c) == -1) {"
"StringUtils.java:460"$1$"				sb.append(c);"
"StringUtils.java:461"$1$"			}"
"StringUtils.java:462"$0$"		}"
"StringUtils.java:463"$0$"		return sb.toString();"
"StringUtils.java:464"$0$"	}"
"StringUtils.java:465"$0$""
"StringUtils.java:466"$0$""
"StringUtils.java:467"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:468"$0$"	// Convenience methods for working with formatted Strings"
"StringUtils.java:469"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:470"$0$""
"StringUtils.java:471"$0$"	/**"
"StringUtils.java:472"$1$"	 * Quote the given {@code String} with single quotes."
"StringUtils.java:473"$1$"	 * @param str the input {@code String} (e.g. ""myString"")"
"StringUtils.java:474"$1$"	 * @return the quoted {@code String} (e.g. ""'myString'""),"
"StringUtils.java:475"$1$"	 * or {@code null} if the input was {@code null}"
"StringUtils.java:476"$0$"	 */"
"StringUtils.java:477"$0$"	@Nullable"
"StringUtils.java:478"$1$"	public static String quote(@Nullable String str) {"
"StringUtils.java:479"$1$"		return (str != null ? ""'"" + str + ""'"" : null);"
"StringUtils.java:480"$1$"	}"
"StringUtils.java:481"$0$""
"StringUtils.java:482"$0$"	/**"
"StringUtils.java:483"$1$"	 * Turn the given Object into a {@code String} with single quotes"
"StringUtils.java:484"$1$"	 * if it is a {@code String}; keeping the Object as-is else."
"StringUtils.java:485"$0$"	 * @param obj the input Object (e.g. ""myString"")"
"StringUtils.java:486"$1$"	 * @return the quoted {@code String} (e.g. ""'myString'""),"
"StringUtils.java:487"$1$"	 * or the input object as-is if not a {@code String}"
"StringUtils.java:488"$0$"	 */"
"StringUtils.java:489"$0$"	@Nullable"
"StringUtils.java:490"$1$"	public static Object quoteIfString(@Nullable Object obj) {"
"StringUtils.java:491"$1$"		return (obj instanceof String ? quote((String) obj) : obj);"
"StringUtils.java:492"$1$"	}"
"StringUtils.java:493"$0$""
"StringUtils.java:494"$0$"	/**"
"StringUtils.java:495"$0$"	 * Unqualify a string qualified by a '.' dot character. For example,"
"StringUtils.java:496"$0$"	 * ""this.name.is.qualified"", returns ""qualified""."
"StringUtils.java:497"$0$"	 * @param qualifiedName the qualified name"
"StringUtils.java:498"$0$"	 */"
"StringUtils.java:499"$1$"	public static String unqualify(String qualifiedName) {"
"StringUtils.java:500"$1$"		return unqualify(qualifiedName, '.');"
"StringUtils.java:501"$1$"	}"
"StringUtils.java:502"$0$""
"StringUtils.java:503"$0$"	/**"
"StringUtils.java:504"$0$"	 * Unqualify a string qualified by a separator character. For example,"
"StringUtils.java:505"$0$"	 * ""this:name:is:qualified"" returns ""qualified"" if using a ':' separator."
"StringUtils.java:506"$0$"	 * @param qualifiedName the qualified name"
"StringUtils.java:507"$0$"	 * @param separator the separator"
"StringUtils.java:508"$0$"	 */"
"StringUtils.java:509"$1$"	public static String unqualify(String qualifiedName, char separator) {"
"StringUtils.java:510"$1$"		return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);"
"StringUtils.java:511"$1$"	}"
"StringUtils.java:512"$0$""
"StringUtils.java:513"$0$"	/**"
"StringUtils.java:514"$1$"	 * Capitalize a {@code String}, changing the first letter to"
"StringUtils.java:515"$1$"	 * upper case as per {@link Character#toUpperCase(char)}."
"StringUtils.java:516"$0$"	 * No other letters are changed."
"StringUtils.java:517"$1$"	 * @param str the {@code String} to capitalize"
"StringUtils.java:518"$1$"	 * @return the capitalized {@code String}"
"StringUtils.java:519"$0$"	 */"
"StringUtils.java:520"$1$"	public static String capitalize(String str) {"
"StringUtils.java:521"$1$"		return changeFirstCharacterCase(str, true);"
"StringUtils.java:522"$1$"	}"
"StringUtils.java:523"$0$""
"StringUtils.java:524"$0$"	/**"
"StringUtils.java:525"$1$"	 * Uncapitalize a {@code String}, changing the first letter to"
"StringUtils.java:526"$1$"	 * lower case as per {@link Character#toLowerCase(char)}."
"StringUtils.java:527"$0$"	 * No other letters are changed."
"StringUtils.java:528"$1$"	 * @param str the {@code String} to uncapitalize"
"StringUtils.java:529"$1$"	 * @return the uncapitalized {@code String}"
"StringUtils.java:530"$0$"	 */"
"StringUtils.java:531"$1$"	public static String uncapitalize(String str) {"
"StringUtils.java:532"$1$"		return changeFirstCharacterCase(str, false);"
"StringUtils.java:533"$1$"	}"
"StringUtils.java:534"$0$""
"StringUtils.java:535"$1$"	private static String changeFirstCharacterCase(String str, boolean capitalize) {"
"StringUtils.java:536"$1$"		if (!hasLength(str)) {"
"StringUtils.java:537"$1$"			return str;"
"StringUtils.java:538"$1$"		}"
"StringUtils.java:539"$0$""
"StringUtils.java:540"$0$"		char baseChar = str.charAt(0);"
"StringUtils.java:541"$0$"		char updatedChar;"
"StringUtils.java:542"$1$"		if (capitalize) {"
"StringUtils.java:543"$1$"			updatedChar = Character.toUpperCase(baseChar);"
"StringUtils.java:544"$1$"		}"
"StringUtils.java:545"$1$"		else {"
"StringUtils.java:546"$1$"			updatedChar = Character.toLowerCase(baseChar);"
"StringUtils.java:547"$1$"		}"
"StringUtils.java:548"$1$"		if (baseChar == updatedChar) {"
"StringUtils.java:549"$1$"			return str;"
"StringUtils.java:550"$1$"		}"
"StringUtils.java:551"$0$""
"StringUtils.java:552"$0$"		char[] chars = str.toCharArray();"
"StringUtils.java:553"$0$"		chars[0] = updatedChar;"
"StringUtils.java:554"$0$"		return new String(chars, 0, chars.length);"
"StringUtils.java:555"$0$"	}"
"StringUtils.java:556"$0$""
"StringUtils.java:557"$0$"	/**"
"StringUtils.java:558"$0$"	 * Extract the filename from the given Java resource path,"
"StringUtils.java:559"$1$"	 * e.g. {@code ""mypath/myfile.txt"" -> ""myfile.txt""}."
"StringUtils.java:560"$1$"	 * @param path the file path (may be {@code null})"
"StringUtils.java:561"$1$"	 * @return the extracted filename, or {@code null} if none"
"StringUtils.java:562"$0$"	 */"
"StringUtils.java:563"$0$"	@Nullable"
"StringUtils.java:564"$1$"	public static String getFilename(@Nullable String path) {"
"StringUtils.java:565"$1$"		if (path == null) {"
"StringUtils.java:566"$1$"			return null;"
"StringUtils.java:567"$1$"		}"
"StringUtils.java:568"$0$""
"StringUtils.java:569"$0$"		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);"
"StringUtils.java:570"$0$"		return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);"
"StringUtils.java:571"$0$"	}"
"StringUtils.java:572"$0$""
"StringUtils.java:573"$0$"	/**"
"StringUtils.java:574"$0$"	 * Extract the filename extension from the given Java resource path,"
"StringUtils.java:575"$0$"	 * e.g. ""mypath/myfile.txt"" -> ""txt""."
"StringUtils.java:576"$1$"	 * @param path the file path (may be {@code null})"
"StringUtils.java:577"$1$"	 * @return the extracted filename extension, or {@code null} if none"
"StringUtils.java:578"$0$"	 */"
"StringUtils.java:579"$0$"	@Nullable"
"StringUtils.java:580"$1$"	public static String getFilenameExtension(@Nullable String path) {"
"StringUtils.java:581"$1$"		if (path == null) {"
"StringUtils.java:582"$1$"			return null;"
"StringUtils.java:583"$1$"		}"
"StringUtils.java:584"$0$""
"StringUtils.java:585"$0$"		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);"
"StringUtils.java:586"$1$"		if (extIndex == -1) {"
"StringUtils.java:587"$1$"			return null;"
"StringUtils.java:588"$1$"		}"
"StringUtils.java:589"$0$""
"StringUtils.java:590"$0$"		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);"
"StringUtils.java:591"$1$"		if (folderIndex > extIndex) {"
"StringUtils.java:592"$1$"			return null;"
"StringUtils.java:593"$1$"		}"
"StringUtils.java:594"$0$""
"StringUtils.java:595"$0$"		return path.substring(extIndex + 1);"
"StringUtils.java:596"$0$"	}"
"StringUtils.java:597"$0$""
"StringUtils.java:598"$0$"	/**"
"StringUtils.java:599"$0$"	 * Strip the filename extension from the given Java resource path,"
"StringUtils.java:600"$0$"	 * e.g. ""mypath/myfile.txt"" -> ""mypath/myfile""."
"StringUtils.java:601"$0$"	 * @param path the file path"
"StringUtils.java:602"$0$"	 * @return the path with stripped filename extension"
"StringUtils.java:603"$0$"	 */"
"StringUtils.java:604"$1$"	public static String stripFilenameExtension(String path) {"
"StringUtils.java:605"$1$"		int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);"
"StringUtils.java:606"$1$"		if (extIndex == -1) {"
"StringUtils.java:607"$1$"			return path;"
"StringUtils.java:608"$1$"		}"
"StringUtils.java:609"$0$""
"StringUtils.java:610"$0$"		int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);"
"StringUtils.java:611"$1$"		if (folderIndex > extIndex) {"
"StringUtils.java:612"$1$"			return path;"
"StringUtils.java:613"$1$"		}"
"StringUtils.java:614"$0$""
"StringUtils.java:615"$0$"		return path.substring(0, extIndex);"
"StringUtils.java:616"$0$"	}"
"StringUtils.java:617"$0$""
"StringUtils.java:618"$0$"	/**"
"StringUtils.java:619"$0$"	 * Apply the given relative path to the given Java resource path,"
"StringUtils.java:620"$0$"	 * assuming standard Java folder separation (i.e. ""/"" separators)."
"StringUtils.java:621"$0$"	 * @param path the path to start from (usually a full file path)"
"StringUtils.java:622"$0$"	 * @param relativePath the relative path to apply"
"StringUtils.java:623"$0$"	 * (relative to the full file path above)"
"StringUtils.java:624"$0$"	 * @return the full file path that results from applying the relative path"
"StringUtils.java:625"$0$"	 */"
"StringUtils.java:626"$1$"	public static String applyRelativePath(String path, String relativePath) {"
"StringUtils.java:627"$1$"		int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);"
"StringUtils.java:628"$1$"		if (separatorIndex != -1) {"
"StringUtils.java:629"$1$"			String newPath = path.substring(0, separatorIndex);"
"StringUtils.java:630"$1$"			if (!relativePath.startsWith(FOLDER_SEPARATOR)) {"
"StringUtils.java:631"$1$"				newPath += FOLDER_SEPARATOR;"
"StringUtils.java:632"$1$"			}"
"StringUtils.java:633"$0$"			return newPath + relativePath;"
"StringUtils.java:634"$0$"		}"
"StringUtils.java:635"$1$"		else {"
"StringUtils.java:636"$1$"			return relativePath;"
"StringUtils.java:637"$1$"		}"
"StringUtils.java:638"$0$"	}"
"StringUtils.java:639"$0$""
"StringUtils.java:640"$0$"	/**"
"StringUtils.java:641"$0$"	 * Normalize the path by suppressing sequences like ""path/.."" and"
"StringUtils.java:642"$0$"	 * inner simple dots."
"StringUtils.java:643"$0$"	 * <p>The result is convenient for path comparison. For other uses,"
"StringUtils.java:644"$0$"	 * notice that Windows separators (""\"") are replaced by simple slashes."
"StringUtils.java:645"$0$"	 * @param path the original path"
"StringUtils.java:646"$0$"	 * @return the normalized path"
"StringUtils.java:647"$0$"	 */"
"StringUtils.java:648"$1$"	public static String cleanPath(String path) {"
"StringUtils.java:649"$1$"		if (!hasLength(path)) {"
"StringUtils.java:650"$1$"			return path;"
"StringUtils.java:651"$1$"		}"
"StringUtils.java:652"$0$"		String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);"
"StringUtils.java:653"$0$""
"StringUtils.java:654"$0$"		// Shortcut if there is no work to do"
"StringUtils.java:655"$1$"		if (pathToUse.indexOf('.') == -1) {"
"StringUtils.java:656"$1$"			return pathToUse;"
"StringUtils.java:657"$1$"		}"
"StringUtils.java:658"$0$""
"StringUtils.java:659"$0$"		// Strip prefix from path to analyze, to not treat it as part of the"
"StringUtils.java:660"$0$"		// first path element. This is necessary to correctly parse paths like"
"StringUtils.java:661"$0$"		// ""file:core/../core/io/Resource.class"", where the "".."" should just"
"StringUtils.java:662"$0$"		// strip the first ""core"" directory while keeping the ""file:"" prefix."
"StringUtils.java:663"$0$"		int prefixIndex = pathToUse.indexOf(':');"
"StringUtils.java:664"$0$"		String prefix = """";"
"StringUtils.java:665"$1$"		if (prefixIndex != -1) {"
"StringUtils.java:666"$1$"			prefix = pathToUse.substring(0, prefixIndex + 1);"
"StringUtils.java:667"$1$"			if (prefix.contains(FOLDER_SEPARATOR)) {"
"StringUtils.java:668"$1$"				prefix = """";"
"StringUtils.java:669"$1$"			}"
"StringUtils.java:670"$1$"			else {"
"StringUtils.java:671"$1$"				pathToUse = pathToUse.substring(prefixIndex + 1);"
"StringUtils.java:672"$1$"			}"
"StringUtils.java:673"$0$"		}"
"StringUtils.java:674"$1$"		if (pathToUse.startsWith(FOLDER_SEPARATOR)) {"
"StringUtils.java:675"$1$"			prefix = prefix + FOLDER_SEPARATOR;"
"StringUtils.java:676"$1$"			pathToUse = pathToUse.substring(1);"
"StringUtils.java:677"$1$"		}"
"StringUtils.java:678"$0$""
"StringUtils.java:679"$0$"		String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);"
"StringUtils.java:680"$0$"		LinkedList<String> pathElements = new LinkedList<>();"
"StringUtils.java:681"$0$"		int tops = 0;"
"StringUtils.java:682"$0$""
"StringUtils.java:683"$1$"		for (int i = pathArray.length - 1; i >= 0; i--) {"
"StringUtils.java:684"$1$"			String element = pathArray[i];"
"StringUtils.java:685"$1$"			if (CURRENT_PATH.equals(element)) {"
"StringUtils.java:686"$0$"				// Points to current directory - drop it."
"StringUtils.java:687"$1$"			}"
"StringUtils.java:688"$1$"			else if (TOP_PATH.equals(element)) {"
"StringUtils.java:689"$0$"				// Registering top path found."
"StringUtils.java:690"$1$"				tops++;"
"StringUtils.java:691"$1$"			}"
"StringUtils.java:692"$1$"			else {"
"StringUtils.java:693"$1$"				if (tops > 0) {"
"StringUtils.java:694"$0$"					// Merging path element with element corresponding to top path."
"StringUtils.java:695"$1$"					tops--;"
"StringUtils.java:696"$1$"				}"
"StringUtils.java:697"$1$"				else {"
"StringUtils.java:698"$0$"					// Normal path element found."
"StringUtils.java:699"$1$"					pathElements.add(0, element);"
"StringUtils.java:700"$1$"				}"
"StringUtils.java:701"$0$"			}"
"StringUtils.java:702"$0$"		}"
"StringUtils.java:703"$0$""
"StringUtils.java:704"$0$"		// All path elements stayed the same - shortcut"
"StringUtils.java:705"$1$"		if (pathArray.length == pathElements.size()) {"
"StringUtils.java:706"$1$"			return prefix + pathToUse;"
"StringUtils.java:707"$1$"		}"
"StringUtils.java:708"$0$"		// Remaining top paths need to be retained."
"StringUtils.java:709"$1$"		for (int i = 0; i < tops; i++) {"
"StringUtils.java:710"$1$"			pathElements.add(0, TOP_PATH);"
"StringUtils.java:711"$1$"		}"
"StringUtils.java:712"$0$"		// If nothing else left, at least explicitly point to current path."
"StringUtils.java:713"$1$"		if (pathElements.size() == 1 && """".equals(pathElements.getLast()) && !prefix.endsWith(FOLDER_SEPARATOR)) {"
"StringUtils.java:714"$1$"			pathElements.add(0, CURRENT_PATH);"
"StringUtils.java:715"$1$"		}"
"StringUtils.java:716"$0$""
"StringUtils.java:717"$0$"		return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);"
"StringUtils.java:718"$0$"	}"
"StringUtils.java:719"$0$""
"StringUtils.java:720"$0$"	/**"
"StringUtils.java:721"$0$"	 * Compare two paths after normalization of them."
"StringUtils.java:722"$0$"	 * @param path1 first path for comparison"
"StringUtils.java:723"$0$"	 * @param path2 second path for comparison"
"StringUtils.java:724"$0$"	 * @return whether the two paths are equivalent after normalization"
"StringUtils.java:725"$0$"	 */"
"StringUtils.java:726"$1$"	public static boolean pathEquals(String path1, String path2) {"
"StringUtils.java:727"$1$"		return cleanPath(path1).equals(cleanPath(path2));"
"StringUtils.java:728"$1$"	}"
"StringUtils.java:729"$0$""
"StringUtils.java:730"$0$"	/**"
"StringUtils.java:731"$0$"	 * Decode the given encoded URI component value. Based on the following rules:"
"StringUtils.java:732"$0$"	 * <ul>"
"StringUtils.java:733"$1$"	 * <li>Alphanumeric characters {@code ""a""} through {@code ""z""}, {@code ""A""} through {@code ""Z""},"
"StringUtils.java:734"$1$"	 * and {@code ""0""} through {@code ""9""} stay the same.</li>"
"StringUtils.java:735"$1$"	 * <li>Special characters {@code ""-""}, {@code ""_""}, {@code "".""}, and {@code ""*""} stay the same.</li>"
"StringUtils.java:736"$1$"	 * <li>A sequence ""{@code %<i>xy</i>}"" is interpreted as a hexadecimal representation of the character.</li>"
"StringUtils.java:737"$0$"	 * </ul>"
"StringUtils.java:738"$0$"	 * @param source the encoded String"
"StringUtils.java:739"$0$"	 * @param charset the character set"
"StringUtils.java:740"$0$"	 * @return the decoded value"
"StringUtils.java:741"$0$"	 * @throws IllegalArgumentException when the given source contains invalid encoded sequences"
"StringUtils.java:742"$0$"	 * @since 5.0"
"StringUtils.java:743"$0$"	 * @see java.net.URLDecoder#decode(String, String)"
"StringUtils.java:744"$0$"	 */"
"StringUtils.java:745"$1$"	public static String uriDecode(String source, Charset charset) {"
"StringUtils.java:746"$1$"		int length = source.length();"
"StringUtils.java:747"$1$"		if (length == 0) {"
"StringUtils.java:748"$1$"			return source;"
"StringUtils.java:749"$1$"		}"
"StringUtils.java:750"$0$"		Assert.notNull(charset, ""Charset must not be null"");"
"StringUtils.java:751"$0$""
"StringUtils.java:752"$0$"		ByteArrayOutputStream baos = new ByteArrayOutputStream(length);"
"StringUtils.java:753"$0$"		boolean changed = false;"
"StringUtils.java:754"$1$"		for (int i = 0; i < length; i++) {"
"StringUtils.java:755"$1$"			int ch = source.charAt(i);"
"StringUtils.java:756"$1$"			if (ch == '%') {"
"StringUtils.java:757"$1$"				if (i + 2 < length) {"
"StringUtils.java:758"$1$"					char hex1 = source.charAt(i + 1);"
"StringUtils.java:759"$1$"					char hex2 = source.charAt(i + 2);"
"StringUtils.java:760"$1$"					int u = Character.digit(hex1, 16);"
"StringUtils.java:761"$1$"					int l = Character.digit(hex2, 16);"
"StringUtils.java:762"$1$"					if (u == -1 || l == -1) {"
"StringUtils.java:763"$1$"						throw new IllegalArgumentException(""Invalid encoded sequence \"""" + source.substring(i) + ""\"""");"
"StringUtils.java:764"$1$"					}"
"StringUtils.java:765"$0$"					baos.write((char) ((u << 4) + l));"
"StringUtils.java:766"$0$"					i += 2;"
"StringUtils.java:767"$0$"					changed = true;"
"StringUtils.java:768"$0$"				}"
"StringUtils.java:769"$1$"				else {"
"StringUtils.java:770"$1$"					throw new IllegalArgumentException(""Invalid encoded sequence \"""" + source.substring(i) + ""\"""");"
"StringUtils.java:771"$1$"				}"
"StringUtils.java:772"$0$"			}"
"StringUtils.java:773"$1$"			else {"
"StringUtils.java:774"$1$"				baos.write(ch);"
"StringUtils.java:775"$1$"			}"
"StringUtils.java:776"$0$"		}"
"StringUtils.java:777"$0$"		return (changed ? StreamUtils.copyToString(baos, charset) : source);"
"StringUtils.java:778"$0$"	}"
"StringUtils.java:779"$0$""
"StringUtils.java:780"$0$"	/**"
"StringUtils.java:781"$1$"	 * Parse the given {@code String} value into a {@link Locale}, accepting"
"StringUtils.java:782"$1$"	 * the {@link Locale#toString} format as well as BCP 47 language tags."
"StringUtils.java:783"$1$"	 * @param localeValue the locale value: following either {@code Locale's}"
"StringUtils.java:784"$1$"	 * {@code toString()} format (""en"", ""en_UK"", etc), also accepting spaces as"
"StringUtils.java:785"$0$"	 * separators (as an alternative to underscores), or BCP 47 (e.g. ""en-UK"")"
"StringUtils.java:786"$1$"	 * as specified by {@link Locale#forLanguageTag} on Java 7+"
"StringUtils.java:787"$1$"	 * @return a corresponding {@code Locale} instance, or {@code null} if none"
"StringUtils.java:788"$0$"	 * @throws IllegalArgumentException in case of an invalid locale specification"
"StringUtils.java:789"$0$"	 * @since 5.0.4"
"StringUtils.java:790"$0$"	 * @see #parseLocaleString"
"StringUtils.java:791"$0$"	 * @see Locale#forLanguageTag"
"StringUtils.java:792"$0$"	 */"
"StringUtils.java:793"$0$"	@Nullable"
"StringUtils.java:794"$1$"	public static Locale parseLocale(String localeValue) {"
"StringUtils.java:795"$1$"		String[] tokens = tokenizeLocaleSource(localeValue);"
"StringUtils.java:796"$1$"		if (tokens.length == 1) {"
"StringUtils.java:797"$1$"			validateLocalePart(localeValue);"
"StringUtils.java:798"$1$"			Locale resolved = Locale.forLanguageTag(localeValue);"
"StringUtils.java:799"$1$"			if (resolved.getLanguage().length() > 0) {"
"StringUtils.java:800"$1$"				return resolved;"
"StringUtils.java:801"$1$"			}"
"StringUtils.java:802"$0$"		}"
"StringUtils.java:803"$0$"		return parseLocaleTokens(localeValue, tokens);"
"StringUtils.java:804"$0$"	}"
"StringUtils.java:805"$0$""
"StringUtils.java:806"$0$"	/**"
"StringUtils.java:807"$1$"	 * Parse the given {@code String} representation into a {@link Locale}."
"StringUtils.java:808"$0$"	 * <p>For many parsing scenarios, this is an inverse operation of"
"StringUtils.java:809"$1$"	 * {@link Locale#toString Locale's toString}, in a lenient sense."
"StringUtils.java:810"$1$"	 * This method does not aim for strict {@code Locale} design compliance;"
"StringUtils.java:811"$0$"	 * it is rather specifically tailored for typical Spring parsing needs."
"StringUtils.java:812"$0$"	 * <p><b>Note: This delegate does not accept the BCP 47 language tag format."
"StringUtils.java:813"$1$"	 * Please use {@link #parseLocale} for lenient parsing of both formats.</b>"
"StringUtils.java:814"$1$"	 * @param localeString the locale {@code String}: following {@code Locale's}"
"StringUtils.java:815"$1$"	 * {@code toString()} format (""en"", ""en_UK"", etc), also accepting spaces as"
"StringUtils.java:816"$0$"	 * separators (as an alternative to underscores)"
"StringUtils.java:817"$1$"	 * @return a corresponding {@code Locale} instance, or {@code null} if none"
"StringUtils.java:818"$0$"	 * @throws IllegalArgumentException in case of an invalid locale specification"
"StringUtils.java:819"$0$"	 */"
"StringUtils.java:820"$0$"	@Nullable"
"StringUtils.java:821"$1$"	public static Locale parseLocaleString(String localeString) {"
"StringUtils.java:822"$1$"		return parseLocaleTokens(localeString, tokenizeLocaleSource(localeString));"
"StringUtils.java:823"$1$"	}"
"StringUtils.java:824"$0$""
"StringUtils.java:825"$1$"	private static String[] tokenizeLocaleSource(String localeSource) {"
"StringUtils.java:826"$1$"		return tokenizeToStringArray(localeSource, ""_ "", false, false);"
"StringUtils.java:827"$1$"	}"
"StringUtils.java:828"$0$""
"StringUtils.java:829"$0$"	@Nullable"
"StringUtils.java:830"$1$"	private static Locale parseLocaleTokens(String localeString, String[] tokens) {"
"StringUtils.java:831"$1$"		String language = (tokens.length > 0 ? tokens[0] : """");"
"StringUtils.java:832"$1$"		String country = (tokens.length > 1 ? tokens[1] : """");"
"StringUtils.java:833"$1$"		validateLocalePart(language);"
"StringUtils.java:834"$1$"		validateLocalePart(country);"
"StringUtils.java:835"$1$""
"StringUtils.java:836"$1$"		String variant = """";"
"StringUtils.java:837"$1$"		if (tokens.length > 2) {"
"StringUtils.java:838"$0$"			// There is definitely a variant, and it is everything after the country"
"StringUtils.java:839"$0$"			// code sans the separator between the country code and the variant."
"StringUtils.java:840"$1$"			int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length();"
"StringUtils.java:841"$0$"			// Strip off any leading '_' and whitespace, what's left is the variant."
"StringUtils.java:842"$1$"			variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));"
"StringUtils.java:843"$1$"			if (variant.startsWith(""_"")) {"
"StringUtils.java:844"$1$"				variant = trimLeadingCharacter(variant, '_');"
"StringUtils.java:845"$1$"			}"
"StringUtils.java:846"$0$"		}"
"StringUtils.java:847"$0$""
"StringUtils.java:848"$1$"		if (variant.isEmpty() && country.startsWith(""#"")) {"
"StringUtils.java:849"$1$"			variant = country;"
"StringUtils.java:850"$1$"			country = """";"
"StringUtils.java:851"$1$"		}"
"StringUtils.java:852"$0$""
"StringUtils.java:853"$0$"		return (language.length() > 0 ? new Locale(language, country, variant) : null);"
"StringUtils.java:854"$0$"	}"
"StringUtils.java:855"$0$""
"StringUtils.java:856"$1$"	private static void validateLocalePart(String localePart) {"
"StringUtils.java:857"$1$"		for (int i = 0; i < localePart.length(); i++) {"
"StringUtils.java:858"$1$"			char ch = localePart.charAt(i);"
"StringUtils.java:859"$1$"			if (ch != ' ' && ch != '_' && ch != '-' && ch != '#' && !Character.isLetterOrDigit(ch)) {"
"StringUtils.java:860"$1$"				throw new IllegalArgumentException("
"StringUtils.java:861"$1$"						""Locale part \"""" + localePart + ""\"" contains invalid characters"");"
"StringUtils.java:862"$1$"			}"
"StringUtils.java:863"$0$"		}"
"StringUtils.java:864"$0$"	}"
"StringUtils.java:865"$0$""
"StringUtils.java:866"$0$"	/**"
"StringUtils.java:867"$0$"	 * Determine the RFC 3066 compliant language tag,"
"StringUtils.java:868"$0$"	 * as used for the HTTP ""Accept-Language"" header."
"StringUtils.java:869"$0$"	 * @param locale the Locale to transform to a language tag"
"StringUtils.java:870"$1$"	 * @return the RFC 3066 compliant language tag as {@code String}"
"StringUtils.java:871"$1$"	 * @deprecated as of 5.0.4, in favor of {@link Locale#toLanguageTag()}"
"StringUtils.java:872"$0$"	 */"
"StringUtils.java:873"$0$"	@Deprecated"
"StringUtils.java:874"$1$"	public static String toLanguageTag(Locale locale) {"
"StringUtils.java:875"$1$"		return locale.getLanguage() + (hasText(locale.getCountry()) ? ""-"" + locale.getCountry() : """");"
"StringUtils.java:876"$1$"	}"
"StringUtils.java:877"$0$""
"StringUtils.java:878"$0$"	/**"
"StringUtils.java:879"$1$"	 * Parse the given {@code timeZoneString} value into a {@link TimeZone}."
"StringUtils.java:880"$1$"	 * @param timeZoneString the time zone {@code String}, following {@link TimeZone#getTimeZone(String)}"
"StringUtils.java:881"$1$"	 * but throwing {@link IllegalArgumentException} in case of an invalid time zone specification"
"StringUtils.java:882"$1$"	 * @return a corresponding {@link TimeZone} instance"
"StringUtils.java:883"$0$"	 * @throws IllegalArgumentException in case of an invalid time zone specification"
"StringUtils.java:884"$0$"	 */"
"StringUtils.java:885"$1$"	public static TimeZone parseTimeZoneString(String timeZoneString) {"
"StringUtils.java:886"$1$"		TimeZone timeZone = TimeZone.getTimeZone(timeZoneString);"
"StringUtils.java:887"$1$"		if (""GMT"".equals(timeZone.getID()) && !timeZoneString.startsWith(""GMT"")) {"
"StringUtils.java:888"$0$"			// We don't want that GMT fallback..."
"StringUtils.java:889"$1$"			throw new IllegalArgumentException(""Invalid time zone specification '"" + timeZoneString + ""'"");"
"StringUtils.java:890"$1$"		}"
"StringUtils.java:891"$0$"		return timeZone;"
"StringUtils.java:892"$0$"	}"
"StringUtils.java:893"$0$""
"StringUtils.java:894"$0$""
"StringUtils.java:895"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:896"$0$"	// Convenience methods for working with String arrays"
"StringUtils.java:897"$0$"	//---------------------------------------------------------------------"
"StringUtils.java:898"$0$""
"StringUtils.java:899"$0$"	/**"
"StringUtils.java:900"$1$"	 * Copy the given {@link Collection} into a {@code String} array."
"StringUtils.java:901"$1$"	 * <p>The {@code Collection} must contain {@code String} elements only."
"StringUtils.java:902"$1$"	 * @param collection the {@code Collection} to copy"
"StringUtils.java:903"$1$"	 * (potentially {@code null} or empty)"
"StringUtils.java:904"$1$"	 * @return the resulting {@code String} array"
"StringUtils.java:905"$0$"	 */"
"StringUtils.java:906"$1$"	public static String[] toStringArray(@Nullable Collection<String> collection) {"
"StringUtils.java:907"$1$"		return (!CollectionUtils.isEmpty(collection) ? collection.toArray(EMPTY_STRING_ARRAY) : EMPTY_STRING_ARRAY);"
"StringUtils.java:908"$1$"	}"
"StringUtils.java:909"$0$""
"StringUtils.java:910"$0$"	/**"
"StringUtils.java:911"$1$"	 * Copy the given {@link Enumeration} into a {@code String} array."
"StringUtils.java:912"$1$"	 * <p>The {@code Enumeration} must contain {@code String} elements only."
"StringUtils.java:913"$1$"	 * @param enumeration the {@code Enumeration} to copy"
"StringUtils.java:914"$1$"	 * (potentially {@code null} or empty)"
"StringUtils.java:915"$1$"	 * @return the resulting {@code String} array"
"StringUtils.java:916"$0$"	 */"
"StringUtils.java:917"$1$"	public static String[] toStringArray(@Nullable Enumeration<String> enumeration) {"
"StringUtils.java:918"$1$"		return (enumeration != null ? toStringArray(Collections.list(enumeration)) : EMPTY_STRING_ARRAY);"
"StringUtils.java:919"$1$"	}"
"StringUtils.java:920"$0$""
"StringUtils.java:921"$0$"	/**"
"StringUtils.java:922"$1$"	 * Append the given {@code String} to the given {@code String} array,"
"StringUtils.java:923"$0$"	 * returning a new array consisting of the input array contents plus"
"StringUtils.java:924"$1$"	 * the given {@code String}."
"StringUtils.java:925"$1$"	 * @param array the array to append to (can be {@code null})"
"StringUtils.java:926"$1$"	 * @param str the {@code String} to append"
"StringUtils.java:927"$1$"	 * @return the new array (never {@code null})"
"StringUtils.java:928"$0$"	 */"
"StringUtils.java:929"$1$"	public static String[] addStringToArray(@Nullable String[] array, String str) {"
"StringUtils.java:930"$1$"		if (ObjectUtils.isEmpty(array)) {"
"StringUtils.java:931"$1$"			return new String[] {str};"
"StringUtils.java:932"$1$"		}"
"StringUtils.java:933"$0$""
"StringUtils.java:934"$0$"		String[] newArr = new String[array.length + 1];"
"StringUtils.java:935"$0$"		System.arraycopy(array, 0, newArr, 0, array.length);"
"StringUtils.java:936"$0$"		newArr[array.length] = str;"
"StringUtils.java:937"$0$"		return newArr;"
"StringUtils.java:938"$0$"	}"
"StringUtils.java:939"$0$""
"StringUtils.java:940"$0$"	/**"
"StringUtils.java:941"$1$"	 * Concatenate the given {@code String} arrays into one,"
"StringUtils.java:942"$0$"	 * with overlapping array elements included twice."
"StringUtils.java:943"$0$"	 * <p>The order of elements in the original arrays is preserved."
"StringUtils.java:944"$1$"	 * @param array1 the first array (can be {@code null})"
"StringUtils.java:945"$1$"	 * @param array2 the second array (can be {@code null})"
"StringUtils.java:946"$1$"	 * @return the new array ({@code null} if both given arrays were {@code null})"
"StringUtils.java:947"$0$"	 */"
"StringUtils.java:948"$0$"	@Nullable"
"StringUtils.java:949"$1$"	public static String[] concatenateStringArrays(@Nullable String[] array1, @Nullable String[] array2) {"
"StringUtils.java:950"$1$"		if (ObjectUtils.isEmpty(array1)) {"
"StringUtils.java:951"$1$"			return array2;"
"StringUtils.java:952"$1$"		}"
"StringUtils.java:953"$1$"		if (ObjectUtils.isEmpty(array2)) {"
"StringUtils.java:954"$1$"			return array1;"
"StringUtils.java:955"$1$"		}"
"StringUtils.java:956"$0$""
"StringUtils.java:957"$0$"		String[] newArr = new String[array1.length + array2.length];"
"StringUtils.java:958"$0$"		System.arraycopy(array1, 0, newArr, 0, array1.length);"
"StringUtils.java:959"$0$"		System.arraycopy(array2, 0, newArr, array1.length, array2.length);"
"StringUtils.java:960"$0$"		return newArr;"
"StringUtils.java:961"$0$"	}"
"StringUtils.java:962"$0$""
"StringUtils.java:963"$0$"	/**"
"StringUtils.java:964"$1$"	 * Merge the given {@code String} arrays into one, with overlapping"
"StringUtils.java:965"$0$"	 * array elements only included once."
"StringUtils.java:966"$0$"	 * <p>The order of elements in the original arrays is preserved"
"StringUtils.java:967"$0$"	 * (with the exception of overlapping elements, which are only"
"StringUtils.java:968"$0$"	 * included on their first occurrence)."
"StringUtils.java:969"$1$"	 * @param array1 the first array (can be {@code null})"
"StringUtils.java:970"$1$"	 * @param array2 the second array (can be {@code null})"
"StringUtils.java:971"$1$"	 * @return the new array ({@code null} if both given arrays were {@code null})"
"StringUtils.java:972"$1$"	 * @deprecated as of 4.3.15, in favor of manual merging via {@link LinkedHashSet}"
"StringUtils.java:973"$0$"	 * (with every entry included at most once, even entries within the first array)"
"StringUtils.java:974"$0$"	 */"
"StringUtils.java:975"$0$"	@Deprecated"
"StringUtils.java:976"$0$"	@Nullable"
"StringUtils.java:977"$1$"	public static String[] mergeStringArrays(@Nullable String[] array1, @Nullable String[] array2) {"
"StringUtils.java:978"$1$"		if (ObjectUtils.isEmpty(array1)) {"
"StringUtils.java:979"$1$"			return array2;"
"StringUtils.java:980"$1$"		}"
"StringUtils.java:981"$1$"		if (ObjectUtils.isEmpty(array2)) {"
"StringUtils.java:982"$1$"			return array1;"
"StringUtils.java:983"$1$"		}"
"StringUtils.java:984"$0$""
"StringUtils.java:985"$0$"		List<String> result = new ArrayList<>(Arrays.asList(array1));"
"StringUtils.java:986"$1$"		for (String str : array2) {"
"StringUtils.java:987"$1$"			if (!result.contains(str)) {"
"StringUtils.java:988"$1$"				result.add(str);"
"StringUtils.java:989"$1$"			}"
"StringUtils.java:990"$0$"		}"
"StringUtils.java:991"$0$"		return toStringArray(result);"
"StringUtils.java:992"$0$"	}"
"StringUtils.java:993"$0$""
"StringUtils.java:994"$0$"	/**"
"StringUtils.java:995"$1$"	 * Sort the given {@code String} array if necessary."
"StringUtils.java:996"$0$"	 * @param array the original array (potentially empty)"
"StringUtils.java:997"$1$"	 * @return the array in sorted form (never {@code null})"
"StringUtils.java:998"$0$"	 */"
"StringUtils.java:999"$1$"	public static String[] sortStringArray(String[] array) {"
"StringUtils.java:1000"$1$"		if (ObjectUtils.isEmpty(array)) {"
"StringUtils.java:1001"$1$"			return array;"
"StringUtils.java:1002"$1$"		}"
"StringUtils.java:1003"$0$""
"StringUtils.java:1004"$0$"		Arrays.sort(array);"
"StringUtils.java:1005"$0$"		return array;"
"StringUtils.java:1006"$0$"	}"
"StringUtils.java:1007"$0$""
"StringUtils.java:1008"$0$"	/**"
"StringUtils.java:1009"$1$"	 * Trim the elements of the given {@code String} array, calling"
"StringUtils.java:1010"$1$"	 * {@code String.trim()} on each non-null element."
"StringUtils.java:1011"$1$"	 * @param array the original {@code String} array (potentially empty)"
"StringUtils.java:1012"$0$"	 * @return the resulting array (of the same size) with trimmed elements"
"StringUtils.java:1013"$0$"	 */"
"StringUtils.java:1014"$1$"	public static String[] trimArrayElements(String[] array) {"
"StringUtils.java:1015"$1$"		if (ObjectUtils.isEmpty(array)) {"
"StringUtils.java:1016"$1$"			return array;"
"StringUtils.java:1017"$1$"		}"
"StringUtils.java:1018"$0$""
"StringUtils.java:1019"$0$"		String[] result = new String[array.length];"
"StringUtils.java:1020"$1$"		for (int i = 0; i < array.length; i++) {"
"StringUtils.java:1021"$1$"			String element = array[i];"
"StringUtils.java:1022"$1$"			result[i] = (element != null ? element.trim() : null);"
"StringUtils.java:1023"$1$"		}"
"StringUtils.java:1024"$0$"		return result;"
"StringUtils.java:1025"$0$"	}"
"StringUtils.java:1026"$0$""
"StringUtils.java:1027"$0$"	/**"
"StringUtils.java:1028"$0$"	 * Remove duplicate strings from the given array."
"StringUtils.java:1029"$1$"	 * <p>As of 4.2, it preserves the original order, as it uses a {@link LinkedHashSet}."
"StringUtils.java:1030"$1$"	 * @param array the {@code String} array (potentially empty)"
"StringUtils.java:1031"$0$"	 * @return an array without duplicates, in natural sort order"
"StringUtils.java:1032"$0$"	 */"
"StringUtils.java:1033"$1$"	public static String[] removeDuplicateStrings(String[] array) {"
"StringUtils.java:1034"$1$"		if (ObjectUtils.isEmpty(array)) {"
"StringUtils.java:1035"$1$"			return array;"
"StringUtils.java:1036"$1$"		}"
"StringUtils.java:1037"$0$""
"StringUtils.java:1038"$0$"		Set<String> set = new LinkedHashSet<>(Arrays.asList(array));"
"StringUtils.java:1039"$0$"		return toStringArray(set);"
"StringUtils.java:1040"$0$"	}"
"StringUtils.java:1041"$0$""
"StringUtils.java:1042"$0$"	/**"
"StringUtils.java:1043"$1$"	 * Split a {@code String} at the first occurrence of the delimiter."
"StringUtils.java:1044"$0$"	 * Does not include the delimiter in the result."
"StringUtils.java:1045"$1$"	 * @param toSplit the string to split (potentially {@code null} or empty)"
"StringUtils.java:1046"$1$"	 * @param delimiter to split the string up with (potentially {@code null} or empty)"
"StringUtils.java:1047"$0$"	 * @return a two element array with index 0 being before the delimiter, and"
"StringUtils.java:1048"$0$"	 * index 1 being after the delimiter (neither element includes the delimiter);"
"StringUtils.java:1049"$1$"	 * or {@code null} if the delimiter wasn't found in the given input {@code String}"
"StringUtils.java:1050"$0$"	 */"
"StringUtils.java:1051"$0$"	@Nullable"
"StringUtils.java:1052"$1$"	public static String[] split(@Nullable String toSplit, @Nullable String delimiter) {"
"StringUtils.java:1053"$1$"		if (!hasLength(toSplit) || !hasLength(delimiter)) {"
"StringUtils.java:1054"$1$"			return null;"
"StringUtils.java:1055"$1$"		}"
"StringUtils.java:1056"$0$"		int offset = toSplit.indexOf(delimiter);"
"StringUtils.java:1057"$1$"		if (offset < 0) {"
"StringUtils.java:1058"$1$"			return null;"
"StringUtils.java:1059"$1$"		}"
"StringUtils.java:1060"$0$""
"StringUtils.java:1061"$0$"		String beforeDelimiter = toSplit.substring(0, offset);"
"StringUtils.java:1062"$0$"		String afterDelimiter = toSplit.substring(offset + delimiter.length());"
"StringUtils.java:1063"$1$"		return new String[] {beforeDelimiter, afterDelimiter};"
"StringUtils.java:1064"$0$"	}"
"StringUtils.java:1065"$0$""
"StringUtils.java:1066"$0$"	/**"
"StringUtils.java:1067"$0$"	 * Take an array of strings and split each element based on the given delimiter."
"StringUtils.java:1068"$1$"	 * A {@code Properties} instance is then generated, with the left of the delimiter"
"StringUtils.java:1069"$0$"	 * providing the key, and the right of the delimiter providing the value."
"StringUtils.java:1070"$1$"	 * <p>Will trim both the key and value before adding them to the {@code Properties}."
"StringUtils.java:1071"$0$"	 * @param array the array to process"
"StringUtils.java:1072"$0$"	 * @param delimiter to split each element using (typically the equals symbol)"
"StringUtils.java:1073"$1$"	 * @return a {@code Properties} instance representing the array contents,"
"StringUtils.java:1074"$1$"	 * or {@code null} if the array to process was {@code null} or empty"
"StringUtils.java:1075"$0$"	 */"
"StringUtils.java:1076"$0$"	@Nullable"
"StringUtils.java:1077"$1$"	public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {"
"StringUtils.java:1078"$1$"		return splitArrayElementsIntoProperties(array, delimiter, null);"
"StringUtils.java:1079"$1$"	}"
"StringUtils.java:1080"$0$""
"StringUtils.java:1081"$0$"	/**"
"StringUtils.java:1082"$0$"	 * Take an array of strings and split each element based on the given delimiter."
"StringUtils.java:1083"$1$"	 * A {@code Properties} instance is then generated, with the left of the"
"StringUtils.java:1084"$0$"	 * delimiter providing the key, and the right of the delimiter providing the value."
"StringUtils.java:1085"$0$"	 * <p>Will trim both the key and value before adding them to the"
"StringUtils.java:1086"$1$"	 * {@code Properties} instance."
"StringUtils.java:1087"$0$"	 * @param array the array to process"
"StringUtils.java:1088"$0$"	 * @param delimiter to split each element using (typically the equals symbol)"
"StringUtils.java:1089"$0$"	 * @param charsToDelete one or more characters to remove from each element"
"StringUtils.java:1090"$0$"	 * prior to attempting the split operation (typically the quotation mark"
"StringUtils.java:1091"$1$"	 * symbol), or {@code null} if no removal should occur"
"StringUtils.java:1092"$1$"	 * @return a {@code Properties} instance representing the array contents,"
"StringUtils.java:1093"$1$"	 * or {@code null} if the array to process was {@code null} or empty"
"StringUtils.java:1094"$0$"	 */"
"StringUtils.java:1095"$0$"	@Nullable"
"StringUtils.java:1096"$0$"	public static Properties splitArrayElementsIntoProperties("
"StringUtils.java:1097"$1$"			String[] array, String delimiter, @Nullable String charsToDelete) {"
"StringUtils.java:1098"$1$""
"StringUtils.java:1099"$1$"		if (ObjectUtils.isEmpty(array)) {"
"StringUtils.java:1100"$1$"			return null;"
"StringUtils.java:1101"$1$"		}"
"StringUtils.java:1102"$0$""
"StringUtils.java:1103"$0$"		Properties result = new Properties();"
"StringUtils.java:1104"$1$"		for (String element : array) {"
"StringUtils.java:1105"$1$"			if (charsToDelete != null) {"
"StringUtils.java:1106"$1$"				element = deleteAny(element, charsToDelete);"
"StringUtils.java:1107"$1$"			}"
"StringUtils.java:1108"$0$"			String[] splittedElement = split(element, delimiter);"
"StringUtils.java:1109"$1$"			if (splittedElement == null) {"
"StringUtils.java:1110"$1$"				continue;"
"StringUtils.java:1111"$1$"			}"
"StringUtils.java:1112"$0$"			result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());"
"StringUtils.java:1113"$0$"		}"
"StringUtils.java:1114"$0$"		return result;"
"StringUtils.java:1115"$0$"	}"
"StringUtils.java:1116"$0$""
"StringUtils.java:1117"$0$"	/**"
"StringUtils.java:1118"$1$"	 * Tokenize the given {@code String} into a {@code String} array via a"
"StringUtils.java:1119"$1$"	 * {@link StringTokenizer}."
"StringUtils.java:1120"$0$"	 * <p>Trims tokens and omits empty tokens."
"StringUtils.java:1121"$1$"	 * <p>The given {@code delimiters} string can consist of any number of"
"StringUtils.java:1122"$0$"	 * delimiter characters. Each of those characters can be used to separate"
"StringUtils.java:1123"$0$"	 * tokens. A delimiter is always a single character; for multi-character"
"StringUtils.java:1124"$1$"	 * delimiters, consider using {@link #delimitedListToStringArray}."
"StringUtils.java:1125"$1$"	 * @param str the {@code String} to tokenize (potentially {@code null} or empty)"
"StringUtils.java:1126"$1$"	 * @param delimiters the delimiter characters, assembled as a {@code String}"
"StringUtils.java:1127"$0$"	 * (each of the characters is individually considered as a delimiter)"
"StringUtils.java:1128"$0$"	 * @return an array of the tokens"
"StringUtils.java:1129"$0$"	 * @see java.util.StringTokenizer"
"StringUtils.java:1130"$0$"	 * @see String#trim()"
"StringUtils.java:1131"$0$"	 * @see #delimitedListToStringArray"
"StringUtils.java:1132"$0$"	 */"
"StringUtils.java:1133"$1$"	public static String[] tokenizeToStringArray(@Nullable String str, String delimiters) {"
"StringUtils.java:1134"$1$"		return tokenizeToStringArray(str, delimiters, true, true);"
"StringUtils.java:1135"$1$"	}"
"StringUtils.java:1136"$0$""
"StringUtils.java:1137"$0$"	/**"
"StringUtils.java:1138"$1$"	 * Tokenize the given {@code String} into a {@code String} array via a"
"StringUtils.java:1139"$1$"	 * {@link StringTokenizer}."
"StringUtils.java:1140"$1$"	 * <p>The given {@code delimiters} string can consist of any number of"
"StringUtils.java:1141"$0$"	 * delimiter characters. Each of those characters can be used to separate"
"StringUtils.java:1142"$0$"	 * tokens. A delimiter is always a single character; for multi-character"
"StringUtils.java:1143"$1$"	 * delimiters, consider using {@link #delimitedListToStringArray}."
"StringUtils.java:1144"$1$"	 * @param str the {@code String} to tokenize (potentially {@code null} or empty)"
"StringUtils.java:1145"$1$"	 * @param delimiters the delimiter characters, assembled as a {@code String}"
"StringUtils.java:1146"$0$"	 * (each of the characters is individually considered as a delimiter)"
"StringUtils.java:1147"$1$"	 * @param trimTokens trim the tokens via {@link String#trim()}"
"StringUtils.java:1148"$0$"	 * @param ignoreEmptyTokens omit empty tokens from the result array"
"StringUtils.java:1149"$0$"	 * (only applies to tokens that are empty after trimming; StringTokenizer"
"StringUtils.java:1150"$0$"	 * will not consider subsequent delimiters as token in the first place)."
"StringUtils.java:1151"$0$"	 * @return an array of the tokens"
"StringUtils.java:1152"$0$"	 * @see java.util.StringTokenizer"
"StringUtils.java:1153"$0$"	 * @see String#trim()"
"StringUtils.java:1154"$0$"	 * @see #delimitedListToStringArray"
"StringUtils.java:1155"$0$"	 */"
"StringUtils.java:1156"$0$"	public static String[] tokenizeToStringArray("
"StringUtils.java:1157"$1$"			@Nullable String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {"
"StringUtils.java:1158"$1$""
"StringUtils.java:1159"$1$"		if (str == null) {"
"StringUtils.java:1160"$1$"			return EMPTY_STRING_ARRAY;"
"StringUtils.java:1161"$1$"		}"
"StringUtils.java:1162"$0$""
"StringUtils.java:1163"$0$"		StringTokenizer st = new StringTokenizer(str, delimiters);"
"StringUtils.java:1164"$0$"		List<String> tokens = new ArrayList<>();"
"StringUtils.java:1165"$1$"		while (st.hasMoreTokens()) {"
"StringUtils.java:1166"$1$"			String token = st.nextToken();"
"StringUtils.java:1167"$1$"			if (trimTokens) {"
"StringUtils.java:1168"$1$"				token = token.trim();"
"StringUtils.java:1169"$1$"			}"
"StringUtils.java:1170"$1$"			if (!ignoreEmptyTokens || token.length() > 0) {"
"StringUtils.java:1171"$1$"				tokens.add(token);"
"StringUtils.java:1172"$1$"			}"
"StringUtils.java:1173"$0$"		}"
"StringUtils.java:1174"$0$"		return toStringArray(tokens);"
"StringUtils.java:1175"$0$"	}"
"StringUtils.java:1176"$0$""
"StringUtils.java:1177"$0$"	/**"
"StringUtils.java:1178"$1$"	 * Take a {@code String} that is a delimited list and convert it into a"
"StringUtils.java:1179"$1$"	 * {@code String} array."
"StringUtils.java:1180"$1$"	 * <p>A single {@code delimiter} may consist of more than one character,"
"StringUtils.java:1181"$0$"	 * but it will still be considered as a single delimiter string, rather"
"StringUtils.java:1182"$0$"	 * than as bunch of potential delimiter characters, in contrast to"
"StringUtils.java:1183"$1$"	 * {@link #tokenizeToStringArray}."
"StringUtils.java:1184"$1$"	 * @param str the input {@code String} (potentially {@code null} or empty)"
"StringUtils.java:1185"$0$"	 * @param delimiter the delimiter between elements (this is a single delimiter,"
"StringUtils.java:1186"$0$"	 * rather than a bunch individual delimiter characters)"
"StringUtils.java:1187"$0$"	 * @return an array of the tokens in the list"
"StringUtils.java:1188"$0$"	 * @see #tokenizeToStringArray"
"StringUtils.java:1189"$0$"	 */"
"StringUtils.java:1190"$1$"	public static String[] delimitedListToStringArray(@Nullable String str, @Nullable String delimiter) {"
"StringUtils.java:1191"$1$"		return delimitedListToStringArray(str, delimiter, null);"
"StringUtils.java:1192"$1$"	}"
"StringUtils.java:1193"$0$""
"StringUtils.java:1194"$0$"	/**"
"StringUtils.java:1195"$1$"	 * Take a {@code String} that is a delimited list and convert it into"
"StringUtils.java:1196"$1$"	 * a {@code String} array."
"StringUtils.java:1197"$1$"	 * <p>A single {@code delimiter} may consist of more than one character,"
"StringUtils.java:1198"$0$"	 * but it will still be considered as a single delimiter string, rather"
"StringUtils.java:1199"$0$"	 * than as bunch of potential delimiter characters, in contrast to"
"StringUtils.java:1200"$1$"	 * {@link #tokenizeToStringArray}."
"StringUtils.java:1201"$1$"	 * @param str the input {@code String} (potentially {@code null} or empty)"
"StringUtils.java:1202"$0$"	 * @param delimiter the delimiter between elements (this is a single delimiter,"
"StringUtils.java:1203"$0$"	 * rather than a bunch individual delimiter characters)"
"StringUtils.java:1204"$0$"	 * @param charsToDelete a set of characters to delete; useful for deleting unwanted"
"StringUtils.java:1205"$1$"	 * line breaks: e.g. ""\r\n\f"" will delete all new lines and line feeds in a {@code String}"
"StringUtils.java:1206"$0$"	 * @return an array of the tokens in the list"
"StringUtils.java:1207"$0$"	 * @see #tokenizeToStringArray"
"StringUtils.java:1208"$0$"	 */"
"StringUtils.java:1209"$0$"	public static String[] delimitedListToStringArray("
"StringUtils.java:1210"$1$"			@Nullable String str, @Nullable String delimiter, @Nullable String charsToDelete) {"
"StringUtils.java:1211"$1$""
"StringUtils.java:1212"$1$"		if (str == null) {"
"StringUtils.java:1213"$1$"			return EMPTY_STRING_ARRAY;"
"StringUtils.java:1214"$1$"		}"
"StringUtils.java:1215"$1$"		if (delimiter == null) {"
"StringUtils.java:1216"$1$"			return new String[] {str};"
"StringUtils.java:1217"$1$"		}"
"StringUtils.java:1218"$0$""
"StringUtils.java:1219"$0$"		List<String> result = new ArrayList<>();"
"StringUtils.java:1220"$1$"		if (delimiter.isEmpty()) {"
"StringUtils.java:1221"$1$"			for (int i = 0; i < str.length(); i++) {"
"StringUtils.java:1222"$1$"				result.add(deleteAny(str.substring(i, i + 1), charsToDelete));"
"StringUtils.java:1223"$1$"			}"
"StringUtils.java:1224"$0$"		}"
"StringUtils.java:1225"$1$"		else {"
"StringUtils.java:1226"$1$"			int pos = 0;"
"StringUtils.java:1227"$1$"			int delPos;"
"StringUtils.java:1228"$1$"			while ((delPos = str.indexOf(delimiter, pos)) != -1) {"
"StringUtils.java:1229"$1$"				result.add(deleteAny(str.substring(pos, delPos), charsToDelete));"
"StringUtils.java:1230"$1$"				pos = delPos + delimiter.length();"
"StringUtils.java:1231"$1$"			}"
"StringUtils.java:1232"$1$"			if (str.length() > 0 && pos <= str.length()) {"
"StringUtils.java:1233"$0$"				// Add rest of String, but not in case of empty input."
"StringUtils.java:1234"$1$"				result.add(deleteAny(str.substring(pos), charsToDelete));"
"StringUtils.java:1235"$1$"			}"
"StringUtils.java:1236"$0$"		}"
"StringUtils.java:1237"$0$"		return toStringArray(result);"
"StringUtils.java:1238"$0$"	}"
"StringUtils.java:1239"$0$""
"StringUtils.java:1240"$0$"	/**"
"StringUtils.java:1241"$0$"	 * Convert a comma delimited list (e.g., a row from a CSV file) into an"
"StringUtils.java:1242"$0$"	 * array of strings."
"StringUtils.java:1243"$1$"	 * @param str the input {@code String} (potentially {@code null} or empty)"
"StringUtils.java:1244"$0$"	 * @return an array of strings, or the empty array in case of empty input"
"StringUtils.java:1245"$0$"	 */"
"StringUtils.java:1246"$1$"	public static String[] commaDelimitedListToStringArray(@Nullable String str) {"
"StringUtils.java:1247"$1$"		return delimitedListToStringArray(str, "","");"
"StringUtils.java:1248"$1$"	}"
"StringUtils.java:1249"$0$""
"StringUtils.java:1250"$0$"	/**"
"StringUtils.java:1251"$0$"	 * Convert a comma delimited list (e.g., a row from a CSV file) into a set."
"StringUtils.java:1252"$0$"	 * <p>Note that this will suppress duplicates, and as of 4.2, the elements in"
"StringUtils.java:1253"$1$"	 * the returned set will preserve the original order in a {@link LinkedHashSet}."
"StringUtils.java:1254"$1$"	 * @param str the input {@code String} (potentially {@code null} or empty)"
"StringUtils.java:1255"$1$"	 * @return a set of {@code String} entries in the list"
"StringUtils.java:1256"$0$"	 * @see #removeDuplicateStrings(String[])"
"StringUtils.java:1257"$0$"	 */"
"StringUtils.java:1258"$1$"	public static Set<String> commaDelimitedListToSet(@Nullable String str) {"
"StringUtils.java:1259"$1$"		String[] tokens = commaDelimitedListToStringArray(str);"
"StringUtils.java:1260"$1$"		return new LinkedHashSet<>(Arrays.asList(tokens));"
"StringUtils.java:1261"$1$"	}"
"StringUtils.java:1262"$0$""
"StringUtils.java:1263"$0$"	/**"
"StringUtils.java:1264"$1$"	 * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV)."
"StringUtils.java:1265"$1$"	 * <p>Useful for {@code toString()} implementations."
"StringUtils.java:1266"$1$"	 * @param coll the {@code Collection} to convert (potentially {@code null} or empty)"
"StringUtils.java:1267"$0$"	 * @param delim the delimiter to use (typically a "","")"
"StringUtils.java:1268"$1$"	 * @param prefix the {@code String} to start each element with"
"StringUtils.java:1269"$1$"	 * @param suffix the {@code String} to end each element with"
"StringUtils.java:1270"$1$"	 * @return the delimited {@code String}"
"StringUtils.java:1271"$0$"	 */"
"StringUtils.java:1272"$0$"	public static String collectionToDelimitedString("
"StringUtils.java:1273"$1$"			@Nullable Collection<?> coll, String delim, String prefix, String suffix) {"
"StringUtils.java:1274"$1$""
"StringUtils.java:1275"$1$"		if (CollectionUtils.isEmpty(coll)) {"
"StringUtils.java:1276"$1$"			return """";"
"StringUtils.java:1277"$1$"		}"
"StringUtils.java:1278"$0$""
"StringUtils.java:1279"$0$"		StringBuilder sb = new StringBuilder();"
"StringUtils.java:1280"$0$"		Iterator<?> it = coll.iterator();"
"StringUtils.java:1281"$1$"		while (it.hasNext()) {"
"StringUtils.java:1282"$1$"			sb.append(prefix).append(it.next()).append(suffix);"
"StringUtils.java:1283"$1$"			if (it.hasNext()) {"
"StringUtils.java:1284"$1$"				sb.append(delim);"
"StringUtils.java:1285"$1$"			}"
"StringUtils.java:1286"$0$"		}"
"StringUtils.java:1287"$0$"		return sb.toString();"
"StringUtils.java:1288"$0$"	}"
"StringUtils.java:1289"$0$""
"StringUtils.java:1290"$0$"	/**"
"StringUtils.java:1291"$1$"	 * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV)."
"StringUtils.java:1292"$1$"	 * <p>Useful for {@code toString()} implementations."
"StringUtils.java:1293"$1$"	 * @param coll the {@code Collection} to convert (potentially {@code null} or empty)"
"StringUtils.java:1294"$0$"	 * @param delim the delimiter to use (typically a "","")"
"StringUtils.java:1295"$1$"	 * @return the delimited {@code String}"
"StringUtils.java:1296"$0$"	 */"
"StringUtils.java:1297"$1$"	public static String collectionToDelimitedString(@Nullable Collection<?> coll, String delim) {"
"StringUtils.java:1298"$1$"		return collectionToDelimitedString(coll, delim, """", """");"
"StringUtils.java:1299"$1$"	}"
"StringUtils.java:1300"$0$""
"StringUtils.java:1301"$0$"	/**"
"StringUtils.java:1302"$1$"	 * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV)."
"StringUtils.java:1303"$1$"	 * <p>Useful for {@code toString()} implementations."
"StringUtils.java:1304"$1$"	 * @param coll the {@code Collection} to convert (potentially {@code null} or empty)"
"StringUtils.java:1305"$1$"	 * @return the delimited {@code String}"
"StringUtils.java:1306"$0$"	 */"
"StringUtils.java:1307"$1$"	public static String collectionToCommaDelimitedString(@Nullable Collection<?> coll) {"
"StringUtils.java:1308"$1$"		return collectionToDelimitedString(coll, "","");"
"StringUtils.java:1309"$1$"	}"
"StringUtils.java:1310"$0$""
"StringUtils.java:1311"$0$"	/**"
"StringUtils.java:1312"$1$"	 * Convert a {@code String} array into a delimited {@code String} (e.g. CSV)."
"StringUtils.java:1313"$1$"	 * <p>Useful for {@code toString()} implementations."
"StringUtils.java:1314"$1$"	 * @param arr the array to display (potentially {@code null} or empty)"
"StringUtils.java:1315"$0$"	 * @param delim the delimiter to use (typically a "","")"
"StringUtils.java:1316"$1$"	 * @return the delimited {@code String}"
"StringUtils.java:1317"$0$"	 */"
"StringUtils.java:1318"$1$"	public static String arrayToDelimitedString(@Nullable Object[] arr, String delim) {"
"StringUtils.java:1319"$1$"		if (ObjectUtils.isEmpty(arr)) {"
"StringUtils.java:1320"$1$"			return """";"
"StringUtils.java:1321"$1$"		}"
"StringUtils.java:1322"$1$"		if (arr.length == 1) {"
"StringUtils.java:1323"$1$"			return ObjectUtils.nullSafeToString(arr[0]);"
"StringUtils.java:1324"$1$"		}"
"StringUtils.java:1325"$0$""
"StringUtils.java:1326"$0$"		StringJoiner sj = new StringJoiner(delim);"
"StringUtils.java:1327"$1$"		for (Object o : arr) {"
"StringUtils.java:1328"$1$"			sj.add(String.valueOf(o));"
"StringUtils.java:1329"$1$"		}"
"StringUtils.java:1330"$0$"		return sj.toString();"
"StringUtils.java:1331"$0$"	}"
"StringUtils.java:1332"$0$""
"StringUtils.java:1333"$0$"	/**"
"StringUtils.java:1334"$1$"	 * Convert a {@code String} array into a comma delimited {@code String}"
"StringUtils.java:1335"$0$"	 * (i.e., CSV)."
"StringUtils.java:1336"$1$"	 * <p>Useful for {@code toString()} implementations."
"StringUtils.java:1337"$1$"	 * @param arr the array to display (potentially {@code null} or empty)"
"StringUtils.java:1338"$1$"	 * @return the delimited {@code String}"
"StringUtils.java:1339"$0$"	 */"
"StringUtils.java:1340"$1$"	public static String arrayToCommaDelimitedString(@Nullable Object[] arr) {"
"StringUtils.java:1341"$1$"		return arrayToDelimitedString(arr, "","");"
"StringUtils.java:1342"$1$"	}"
"StringUtils.java:1343"$0$""
"StringUtils.java:1344"$0$"}"
"FutureAdapter.java:1"$0$"/*"
"FutureAdapter.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"FutureAdapter.java:3"$0$" *"
"FutureAdapter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"FutureAdapter.java:5"$0$" * you may not use this file except in compliance with the License."
"FutureAdapter.java:6"$0$" * You may obtain a copy of the License at"
"FutureAdapter.java:7"$0$" *"
"FutureAdapter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"FutureAdapter.java:9"$0$" *"
"FutureAdapter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"FutureAdapter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"FutureAdapter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"FutureAdapter.java:13"$0$" * See the License for the specific language governing permissions and"
"FutureAdapter.java:14"$0$" * limitations under the License."
"FutureAdapter.java:15"$0$" */"
"FutureAdapter.java:16"$0$""
"FutureAdapter.java:17"$0$"package org.springframework.util.concurrent;"
"FutureAdapter.java:18"$0$""
"FutureAdapter.java:19"$0$"import java.util.concurrent.ExecutionException;"
"FutureAdapter.java:20"$0$"import java.util.concurrent.Future;"
"FutureAdapter.java:21"$0$"import java.util.concurrent.TimeUnit;"
"FutureAdapter.java:22"$0$"import java.util.concurrent.TimeoutException;"
"FutureAdapter.java:23"$0$""
"FutureAdapter.java:24"$0$"import org.springframework.lang.Nullable;"
"FutureAdapter.java:25"$0$"import org.springframework.util.Assert;"
"FutureAdapter.java:26"$0$""
"FutureAdapter.java:27"$0$"/**"
"FutureAdapter.java:28"$1$" * Abstract class that adapts a {@link Future} parameterized over S into a {@code Future}"
"FutureAdapter.java:29"$1$" * parameterized over T. All methods are delegated to the adaptee, where {@link #get()}"
"FutureAdapter.java:30"$1$" * and {@link #get(long, TimeUnit)} call {@link #adapt(Object)} on the adaptee's result."
"FutureAdapter.java:31"$0$" *"
"FutureAdapter.java:32"$0$" * @author Arjen Poutsma"
"FutureAdapter.java:33"$0$" * @since 4.0"
"FutureAdapter.java:34"$1$" * @param <T> the type of this {@code Future}"
"FutureAdapter.java:35"$1$" * @param <S> the type of the adaptee's {@code Future}"
"FutureAdapter.java:36"$0$" */"
"FutureAdapter.java:37"$1$"public abstract class FutureAdapter<T, S> implements Future<T> {"
"FutureAdapter.java:38"$1$""
"FutureAdapter.java:39"$1$"	private final Future<S> adaptee;"
"FutureAdapter.java:40"$1$""
"FutureAdapter.java:41"$1$"	@Nullable"
"FutureAdapter.java:42"$1$"	private Object result;"
"FutureAdapter.java:43"$1$""
"FutureAdapter.java:44"$1$"	private State state = State.NEW;"
"FutureAdapter.java:45"$1$""
"FutureAdapter.java:46"$1$"	private final Object mutex = new Object();"
"FutureAdapter.java:47"$1$""
"FutureAdapter.java:48"$1$""
"FutureAdapter.java:49"$1$"	/**"
"FutureAdapter.java:50"$1$"	 * Constructs a new {@code FutureAdapter} with the given adaptee."
"FutureAdapter.java:51"$1$"	 * @param adaptee the future to delegate to"
"FutureAdapter.java:52"$1$"	 */"
"FutureAdapter.java:53"$1$"	protected FutureAdapter(Future<S> adaptee) {"
"FutureAdapter.java:54"$1$"		Assert.notNull(adaptee, ""Delegate must not be null"");"
"FutureAdapter.java:55"$1$"		this.adaptee = adaptee;"
"FutureAdapter.java:56"$1$"	}"
"FutureAdapter.java:57"$0$""
"FutureAdapter.java:58"$0$""
"FutureAdapter.java:59"$0$"	/**"
"FutureAdapter.java:60"$0$"	 * Returns the adaptee."
"FutureAdapter.java:61"$0$"	 */"
"FutureAdapter.java:62"$1$"	protected Future<S> getAdaptee() {"
"FutureAdapter.java:63"$1$"		return this.adaptee;"
"FutureAdapter.java:64"$1$"	}"
"FutureAdapter.java:65"$0$""
"FutureAdapter.java:66"$0$"	@Override"
"FutureAdapter.java:67"$1$"	public boolean cancel(boolean mayInterruptIfRunning) {"
"FutureAdapter.java:68"$1$"		return this.adaptee.cancel(mayInterruptIfRunning);"
"FutureAdapter.java:69"$1$"	}"
"FutureAdapter.java:70"$0$""
"FutureAdapter.java:71"$0$"	@Override"
"FutureAdapter.java:72"$1$"	public boolean isCancelled() {"
"FutureAdapter.java:73"$1$"		return this.adaptee.isCancelled();"
"FutureAdapter.java:74"$1$"	}"
"FutureAdapter.java:75"$0$""
"FutureAdapter.java:76"$0$"	@Override"
"FutureAdapter.java:77"$1$"	public boolean isDone() {"
"FutureAdapter.java:78"$1$"		return this.adaptee.isDone();"
"FutureAdapter.java:79"$1$"	}"
"FutureAdapter.java:80"$0$""
"FutureAdapter.java:81"$0$"	@Override"
"FutureAdapter.java:82"$0$"	@Nullable"
"FutureAdapter.java:83"$1$"	public T get() throws InterruptedException, ExecutionException {"
"FutureAdapter.java:84"$1$"		return adaptInternal(this.adaptee.get());"
"FutureAdapter.java:85"$1$"	}"
"FutureAdapter.java:86"$0$""
"FutureAdapter.java:87"$0$"	@Override"
"FutureAdapter.java:88"$0$"	@Nullable"
"FutureAdapter.java:89"$1$"	public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {"
"FutureAdapter.java:90"$1$"		return adaptInternal(this.adaptee.get(timeout, unit));"
"FutureAdapter.java:91"$1$"	}"
"FutureAdapter.java:92"$0$""
"FutureAdapter.java:93"$0$"	@SuppressWarnings(""unchecked"")"
"FutureAdapter.java:94"$0$"	@Nullable"
"FutureAdapter.java:95"$1$"	final T adaptInternal(S adapteeResult) throws ExecutionException {"
"FutureAdapter.java:96"$1$"		synchronized (this.mutex) {"
"FutureAdapter.java:97"$1$"			switch (this.state) {"
"FutureAdapter.java:98"$1$"				case SUCCESS:"
"FutureAdapter.java:99"$1$"					return (T) this.result;"
"FutureAdapter.java:100"$1$"				case FAILURE:"
"FutureAdapter.java:101"$1$"					Assert.state(this.result instanceof ExecutionException, ""Failure without exception"");"
"FutureAdapter.java:102"$1$"					throw (ExecutionException) this.result;"
"FutureAdapter.java:103"$1$"				case NEW:"
"FutureAdapter.java:104"$1$"					try {"
"FutureAdapter.java:105"$1$"						T adapted = adapt(adapteeResult);"
"FutureAdapter.java:106"$1$"						this.result = adapted;"
"FutureAdapter.java:107"$1$"						this.state = State.SUCCESS;"
"FutureAdapter.java:108"$1$"						return adapted;"
"FutureAdapter.java:109"$1$"					}"
"FutureAdapter.java:110"$1$"					catch (ExecutionException ex) {"
"FutureAdapter.java:111"$1$"						this.result = ex;"
"FutureAdapter.java:112"$1$"						this.state = State.FAILURE;"
"FutureAdapter.java:113"$1$"						throw ex;"
"FutureAdapter.java:114"$1$"					}"
"FutureAdapter.java:115"$1$"					catch (Throwable ex) {"
"FutureAdapter.java:116"$1$"						ExecutionException execEx = new ExecutionException(ex);"
"FutureAdapter.java:117"$1$"						this.result = execEx;"
"FutureAdapter.java:118"$1$"						this.state = State.FAILURE;"
"FutureAdapter.java:119"$1$"						throw execEx;"
"FutureAdapter.java:120"$1$"					}"
"FutureAdapter.java:121"$0$"				default:"
"FutureAdapter.java:122"$0$"					throw new IllegalStateException();"
"FutureAdapter.java:123"$0$"			}"
"FutureAdapter.java:124"$0$"		}"
"FutureAdapter.java:125"$0$"	}"
"FutureAdapter.java:126"$0$""
"FutureAdapter.java:127"$0$"	/**"
"FutureAdapter.java:128"$0$"	 * Adapts the given adaptee's result into T."
"FutureAdapter.java:129"$0$"	 * @return the adapted result"
"FutureAdapter.java:130"$0$"	 */"
"FutureAdapter.java:131"$0$"	@Nullable"
"FutureAdapter.java:132"$0$"	protected abstract T adapt(S adapteeResult) throws ExecutionException;"
"FutureAdapter.java:133"$0$""
"FutureAdapter.java:134"$0$""
"FutureAdapter.java:135"$1$"	private enum State {NEW, SUCCESS, FAILURE}"
"FutureAdapter.java:136"$0$""
"FutureAdapter.java:137"$0$"}"
"StaxStreamHandler.java:1"$0$"/*"
"StaxStreamHandler.java:2"$0$" * Copyright 2002-2014 the original author or authors."
"StaxStreamHandler.java:3"$0$" *"
"StaxStreamHandler.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxStreamHandler.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxStreamHandler.java:6"$0$" * You may obtain a copy of the License at"
"StaxStreamHandler.java:7"$0$" *"
"StaxStreamHandler.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxStreamHandler.java:9"$0$" *"
"StaxStreamHandler.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxStreamHandler.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxStreamHandler.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxStreamHandler.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxStreamHandler.java:14"$0$" * limitations under the License."
"StaxStreamHandler.java:15"$0$" */"
"StaxStreamHandler.java:16"$0$""
"StaxStreamHandler.java:17"$0$"package org.springframework.util.xml;"
"StaxStreamHandler.java:18"$0$""
"StaxStreamHandler.java:19"$0$"import java.util.Map;"
"StaxStreamHandler.java:20"$0$""
"StaxStreamHandler.java:21"$0$"import javax.xml.XMLConstants;"
"StaxStreamHandler.java:22"$0$"import javax.xml.namespace.QName;"
"StaxStreamHandler.java:23"$0$"import javax.xml.stream.XMLStreamException;"
"StaxStreamHandler.java:24"$0$"import javax.xml.stream.XMLStreamWriter;"
"StaxStreamHandler.java:25"$0$""
"StaxStreamHandler.java:26"$0$"import org.xml.sax.Attributes;"
"StaxStreamHandler.java:27"$0$"import org.xml.sax.Locator;"
"StaxStreamHandler.java:28"$0$"import org.xml.sax.SAXException;"
"StaxStreamHandler.java:29"$0$"import org.xml.sax.ext.LexicalHandler;"
"StaxStreamHandler.java:30"$0$""
"StaxStreamHandler.java:31"$0$"/**"
"StaxStreamHandler.java:32"$1$" * SAX {@link org.xml.sax.ContentHandler} and {@link LexicalHandler}"
"StaxStreamHandler.java:33"$1$" * that writes to an {@link XMLStreamWriter}."
"StaxStreamHandler.java:34"$0$" *"
"StaxStreamHandler.java:35"$0$" * @author Arjen Poutsma"
"StaxStreamHandler.java:36"$0$" * @since 4.0.3"
"StaxStreamHandler.java:37"$0$" */"
"StaxStreamHandler.java:38"$1$"class StaxStreamHandler extends AbstractStaxHandler {"
"StaxStreamHandler.java:39"$1$""
"StaxStreamHandler.java:40"$1$"	private final XMLStreamWriter streamWriter;"
"StaxStreamHandler.java:41"$1$""
"StaxStreamHandler.java:42"$1$""
"StaxStreamHandler.java:43"$1$"	public StaxStreamHandler(XMLStreamWriter streamWriter) {"
"StaxStreamHandler.java:44"$1$"		this.streamWriter = streamWriter;"
"StaxStreamHandler.java:45"$1$"	}"
"StaxStreamHandler.java:46"$0$""
"StaxStreamHandler.java:47"$0$""
"StaxStreamHandler.java:48"$0$"	@Override"
"StaxStreamHandler.java:49"$1$"	protected void startDocumentInternal() throws XMLStreamException {"
"StaxStreamHandler.java:50"$1$"		this.streamWriter.writeStartDocument();"
"StaxStreamHandler.java:51"$1$"	}"
"StaxStreamHandler.java:52"$0$""
"StaxStreamHandler.java:53"$0$"	@Override"
"StaxStreamHandler.java:54"$1$"	protected void endDocumentInternal() throws XMLStreamException {"
"StaxStreamHandler.java:55"$1$"		this.streamWriter.writeEndDocument();"
"StaxStreamHandler.java:56"$1$"	}"
"StaxStreamHandler.java:57"$0$""
"StaxStreamHandler.java:58"$0$"	@Override"
"StaxStreamHandler.java:59"$0$"	protected void startElementInternal(QName name, Attributes attributes,"
"StaxStreamHandler.java:60"$1$"			Map<String, String> namespaceMapping) throws XMLStreamException {"
"StaxStreamHandler.java:61"$1$""
"StaxStreamHandler.java:62"$1$"		this.streamWriter.writeStartElement(name.getPrefix(), name.getLocalPart(), name.getNamespaceURI());"
"StaxStreamHandler.java:63"$1$""
"StaxStreamHandler.java:64"$1$"		for (Map.Entry<String, String> entry : namespaceMapping.entrySet()) {"
"StaxStreamHandler.java:65"$1$"			String prefix = entry.getKey();"
"StaxStreamHandler.java:66"$1$"			String namespaceUri = entry.getValue();"
"StaxStreamHandler.java:67"$1$"			this.streamWriter.writeNamespace(prefix, namespaceUri);"
"StaxStreamHandler.java:68"$1$"			if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {"
"StaxStreamHandler.java:69"$1$"				this.streamWriter.setDefaultNamespace(namespaceUri);"
"StaxStreamHandler.java:70"$1$"			}"
"StaxStreamHandler.java:71"$1$"			else {"
"StaxStreamHandler.java:72"$1$"				this.streamWriter.setPrefix(prefix, namespaceUri);"
"StaxStreamHandler.java:73"$1$"			}"
"StaxStreamHandler.java:74"$0$"		}"
"StaxStreamHandler.java:75"$1$"		for (int i = 0; i < attributes.getLength(); i++) {"
"StaxStreamHandler.java:76"$1$"			QName attrName = toQName(attributes.getURI(i), attributes.getQName(i));"
"StaxStreamHandler.java:77"$1$"			if (!isNamespaceDeclaration(attrName)) {"
"StaxStreamHandler.java:78"$1$"				this.streamWriter.writeAttribute(attrName.getPrefix(), attrName.getNamespaceURI(),"
"StaxStreamHandler.java:79"$1$"						attrName.getLocalPart(), attributes.getValue(i));"
"StaxStreamHandler.java:80"$1$"			}"
"StaxStreamHandler.java:81"$0$"		}"
"StaxStreamHandler.java:82"$0$"	}"
"StaxStreamHandler.java:83"$0$""
"StaxStreamHandler.java:84"$0$"	@Override"
"StaxStreamHandler.java:85"$1$"	protected void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException {"
"StaxStreamHandler.java:86"$1$"		this.streamWriter.writeEndElement();"
"StaxStreamHandler.java:87"$1$"	}"
"StaxStreamHandler.java:88"$0$""
"StaxStreamHandler.java:89"$0$"	@Override"
"StaxStreamHandler.java:90"$1$"	protected void charactersInternal(String data) throws XMLStreamException {"
"StaxStreamHandler.java:91"$1$"		this.streamWriter.writeCharacters(data);"
"StaxStreamHandler.java:92"$1$"	}"
"StaxStreamHandler.java:93"$0$""
"StaxStreamHandler.java:94"$0$"	@Override"
"StaxStreamHandler.java:95"$1$"	protected void cDataInternal(String data) throws XMLStreamException {"
"StaxStreamHandler.java:96"$1$"		this.streamWriter.writeCData(data);"
"StaxStreamHandler.java:97"$1$"	}"
"StaxStreamHandler.java:98"$0$""
"StaxStreamHandler.java:99"$0$"	@Override"
"StaxStreamHandler.java:100"$1$"	protected void ignorableWhitespaceInternal(String data) throws XMLStreamException {"
"StaxStreamHandler.java:101"$1$"		this.streamWriter.writeCharacters(data);"
"StaxStreamHandler.java:102"$1$"	}"
"StaxStreamHandler.java:103"$0$""
"StaxStreamHandler.java:104"$0$"	@Override"
"StaxStreamHandler.java:105"$1$"	protected void processingInstructionInternal(String target, String data) throws XMLStreamException {"
"StaxStreamHandler.java:106"$1$"		this.streamWriter.writeProcessingInstruction(target, data);"
"StaxStreamHandler.java:107"$1$"	}"
"StaxStreamHandler.java:108"$0$""
"StaxStreamHandler.java:109"$0$"	@Override"
"StaxStreamHandler.java:110"$1$"	protected void dtdInternal(String dtd) throws XMLStreamException {"
"StaxStreamHandler.java:111"$1$"		this.streamWriter.writeDTD(dtd);"
"StaxStreamHandler.java:112"$1$"	}"
"StaxStreamHandler.java:113"$0$""
"StaxStreamHandler.java:114"$0$"	@Override"
"StaxStreamHandler.java:115"$1$"	protected void commentInternal(String comment) throws XMLStreamException {"
"StaxStreamHandler.java:116"$1$"		this.streamWriter.writeComment(comment);"
"StaxStreamHandler.java:117"$1$"	}"
"StaxStreamHandler.java:118"$0$""
"StaxStreamHandler.java:119"$0$"	// Ignored"
"StaxStreamHandler.java:120"$0$""
"StaxStreamHandler.java:121"$0$"	@Override"
"StaxStreamHandler.java:122"$1$"	public void setDocumentLocator(Locator locator) {"
"StaxStreamHandler.java:123"$1$"	}"
"StaxStreamHandler.java:124"$0$""
"StaxStreamHandler.java:125"$0$"	@Override"
"StaxStreamHandler.java:126"$1$"	public void startEntity(String name) throws SAXException {"
"StaxStreamHandler.java:127"$1$"	}"
"StaxStreamHandler.java:128"$0$""
"StaxStreamHandler.java:129"$0$"	@Override"
"StaxStreamHandler.java:130"$1$"	public void endEntity(String name) throws SAXException {"
"StaxStreamHandler.java:131"$1$"	}"
"StaxStreamHandler.java:132"$0$""
"StaxStreamHandler.java:133"$0$"	@Override"
"StaxStreamHandler.java:134"$1$"	protected void skippedEntityInternal(String name) throws XMLStreamException {"
"StaxStreamHandler.java:135"$1$"	}"
"StaxStreamHandler.java:136"$0$""
"StaxStreamHandler.java:137"$0$"}"
"SystemPropertyUtils.java:1"$0$"/*"
"SystemPropertyUtils.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"SystemPropertyUtils.java:3"$0$" *"
"SystemPropertyUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SystemPropertyUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"SystemPropertyUtils.java:6"$0$" * You may obtain a copy of the License at"
"SystemPropertyUtils.java:7"$0$" *"
"SystemPropertyUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SystemPropertyUtils.java:9"$0$" *"
"SystemPropertyUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SystemPropertyUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SystemPropertyUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SystemPropertyUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"SystemPropertyUtils.java:14"$0$" * limitations under the License."
"SystemPropertyUtils.java:15"$0$" */"
"SystemPropertyUtils.java:16"$0$""
"SystemPropertyUtils.java:17"$0$"package org.springframework.util;"
"SystemPropertyUtils.java:18"$0$""
"SystemPropertyUtils.java:19"$0$"import org.springframework.lang.Nullable;"
"SystemPropertyUtils.java:20"$0$""
"SystemPropertyUtils.java:21"$0$"/**"
"SystemPropertyUtils.java:22"$0$" * Helper class for resolving placeholders in texts. Usually applied to file paths."
"SystemPropertyUtils.java:23"$0$" *"
"SystemPropertyUtils.java:24"$1$" * <p>A text may contain {@code ${...}} placeholders, to be resolved as system properties:"
"SystemPropertyUtils.java:25"$1$" * e.g. {@code ${user.dir}}. Default values can be supplied using the "":"" separator"
"SystemPropertyUtils.java:26"$0$" * between key and value."
"SystemPropertyUtils.java:27"$0$" *"
"SystemPropertyUtils.java:28"$0$" * @author Juergen Hoeller"
"SystemPropertyUtils.java:29"$0$" * @author Rob Harrop"
"SystemPropertyUtils.java:30"$0$" * @author Dave Syer"
"SystemPropertyUtils.java:31"$0$" * @since 1.2.5"
"SystemPropertyUtils.java:32"$0$" * @see #PLACEHOLDER_PREFIX"
"SystemPropertyUtils.java:33"$0$" * @see #PLACEHOLDER_SUFFIX"
"SystemPropertyUtils.java:34"$0$" * @see System#getProperty(String)"
"SystemPropertyUtils.java:35"$0$" */"
"SystemPropertyUtils.java:36"$1$"public abstract class SystemPropertyUtils {"
"SystemPropertyUtils.java:37"$1$""
"SystemPropertyUtils.java:38"$1$"	/** Prefix for system property placeholders: ""${"". */"
"SystemPropertyUtils.java:39"$1$"	public static final String PLACEHOLDER_PREFIX = ""${"";"
"SystemPropertyUtils.java:40"$1$""
"SystemPropertyUtils.java:41"$1$"	/** Suffix for system property placeholders: ""}"". */"
"SystemPropertyUtils.java:42"$0$"	public static final String PLACEHOLDER_SUFFIX = ""}"";"
"SystemPropertyUtils.java:43"$0$""
"SystemPropertyUtils.java:44"$0$"	/** Value separator for system property placeholders: "":"". */"
"SystemPropertyUtils.java:45"$0$"	public static final String VALUE_SEPARATOR = "":"";"
"SystemPropertyUtils.java:46"$0$""
"SystemPropertyUtils.java:47"$0$""
"SystemPropertyUtils.java:48"$0$"	private static final PropertyPlaceholderHelper strictHelper ="
"SystemPropertyUtils.java:49"$0$"			new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, false);"
"SystemPropertyUtils.java:50"$0$""
"SystemPropertyUtils.java:51"$0$"	private static final PropertyPlaceholderHelper nonStrictHelper ="
"SystemPropertyUtils.java:52"$0$"			new PropertyPlaceholderHelper(PLACEHOLDER_PREFIX, PLACEHOLDER_SUFFIX, VALUE_SEPARATOR, true);"
"SystemPropertyUtils.java:53"$0$""
"SystemPropertyUtils.java:54"$0$""
"SystemPropertyUtils.java:55"$0$"	/**"
"SystemPropertyUtils.java:56"$1$"	 * Resolve {@code ${...}} placeholders in the given text, replacing them with"
"SystemPropertyUtils.java:57"$0$"	 * corresponding system property values."
"SystemPropertyUtils.java:58"$0$"	 * @param text the String to resolve"
"SystemPropertyUtils.java:59"$0$"	 * @return the resolved String"
"SystemPropertyUtils.java:60"$0$"	 * @throws IllegalArgumentException if there is an unresolvable placeholder"
"SystemPropertyUtils.java:61"$0$"	 * @see #PLACEHOLDER_PREFIX"
"SystemPropertyUtils.java:62"$0$"	 * @see #PLACEHOLDER_SUFFIX"
"SystemPropertyUtils.java:63"$0$"	 */"
"SystemPropertyUtils.java:64"$1$"	public static String resolvePlaceholders(String text) {"
"SystemPropertyUtils.java:65"$1$"		return resolvePlaceholders(text, false);"
"SystemPropertyUtils.java:66"$1$"	}"
"SystemPropertyUtils.java:67"$0$""
"SystemPropertyUtils.java:68"$0$"	/**"
"SystemPropertyUtils.java:69"$1$"	 * Resolve {@code ${...}} placeholders in the given text, replacing them with"
"SystemPropertyUtils.java:70"$0$"	 * corresponding system property values. Unresolvable placeholders with no default"
"SystemPropertyUtils.java:71"$1$"	 * value are ignored and passed through unchanged if the flag is set to {@code true}."
"SystemPropertyUtils.java:72"$0$"	 * @param text the String to resolve"
"SystemPropertyUtils.java:73"$0$"	 * @param ignoreUnresolvablePlaceholders whether unresolved placeholders are to be ignored"
"SystemPropertyUtils.java:74"$0$"	 * @return the resolved String"
"SystemPropertyUtils.java:75"$0$"	 * @throws IllegalArgumentException if there is an unresolvable placeholder"
"SystemPropertyUtils.java:76"$0$"	 * @see #PLACEHOLDER_PREFIX"
"SystemPropertyUtils.java:77"$0$"	 * @see #PLACEHOLDER_SUFFIX"
"SystemPropertyUtils.java:78"$1$"	 * and the ""ignoreUnresolvablePlaceholders"" flag is {@code false}"
"SystemPropertyUtils.java:79"$0$"	 */"
"SystemPropertyUtils.java:80"$1$"	public static String resolvePlaceholders(String text, boolean ignoreUnresolvablePlaceholders) {"
"SystemPropertyUtils.java:81"$1$"		PropertyPlaceholderHelper helper = (ignoreUnresolvablePlaceholders ? nonStrictHelper : strictHelper);"
"SystemPropertyUtils.java:82"$1$"		return helper.replacePlaceholders(text, new SystemPropertyPlaceholderResolver(text));"
"SystemPropertyUtils.java:83"$1$"	}"
"SystemPropertyUtils.java:84"$0$""
"SystemPropertyUtils.java:85"$0$""
"SystemPropertyUtils.java:86"$0$"	/**"
"SystemPropertyUtils.java:87"$0$"	 * PlaceholderResolver implementation that resolves against system properties"
"SystemPropertyUtils.java:88"$0$"	 * and system environment variables."
"SystemPropertyUtils.java:89"$0$"	 */"
"SystemPropertyUtils.java:90"$1$"	private static class SystemPropertyPlaceholderResolver implements PropertyPlaceholderHelper.PlaceholderResolver {"
"SystemPropertyUtils.java:91"$1$""
"SystemPropertyUtils.java:92"$1$"		private final String text;"
"SystemPropertyUtils.java:93"$1$""
"SystemPropertyUtils.java:94"$1$"		public SystemPropertyPlaceholderResolver(String text) {"
"SystemPropertyUtils.java:95"$1$"			this.text = text;"
"SystemPropertyUtils.java:96"$1$"		}"
"SystemPropertyUtils.java:97"$0$""
"SystemPropertyUtils.java:98"$0$"		@Override"
"SystemPropertyUtils.java:99"$0$"		@Nullable"
"SystemPropertyUtils.java:100"$1$"		public String resolvePlaceholder(String placeholderName) {"
"SystemPropertyUtils.java:101"$1$"			try {"
"SystemPropertyUtils.java:102"$1$"				String propVal = System.getProperty(placeholderName);"
"SystemPropertyUtils.java:103"$1$"				if (propVal == null) {"
"SystemPropertyUtils.java:104"$0$"					// Fall back to searching the system environment."
"SystemPropertyUtils.java:105"$1$"					propVal = System.getenv(placeholderName);"
"SystemPropertyUtils.java:106"$1$"				}"
"SystemPropertyUtils.java:107"$0$"				return propVal;"
"SystemPropertyUtils.java:108"$0$"			}"
"SystemPropertyUtils.java:109"$1$"			catch (Throwable ex) {"
"SystemPropertyUtils.java:110"$1$"				System.err.println(""Could not resolve placeholder '"" + placeholderName + ""' in ["" +"
"SystemPropertyUtils.java:111"$1$"						this.text + ""] as system property: "" + ex);"
"SystemPropertyUtils.java:112"$1$"				return null;"
"SystemPropertyUtils.java:113"$1$"			}"
"SystemPropertyUtils.java:114"$0$"		}"
"SystemPropertyUtils.java:115"$0$"	}"
"SystemPropertyUtils.java:116"$0$""
"SystemPropertyUtils.java:117"$0$"}"
"AnnotationMetadata.java:1"$0$"/*"
"AnnotationMetadata.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotationMetadata.java:3"$0$" *"
"AnnotationMetadata.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationMetadata.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationMetadata.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationMetadata.java:7"$0$" *"
"AnnotationMetadata.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationMetadata.java:9"$0$" *"
"AnnotationMetadata.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationMetadata.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationMetadata.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationMetadata.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationMetadata.java:14"$0$" * limitations under the License."
"AnnotationMetadata.java:15"$0$" */"
"AnnotationMetadata.java:16"$0$""
"AnnotationMetadata.java:17"$0$"package org.springframework.core.type;"
"AnnotationMetadata.java:18"$0$""
"AnnotationMetadata.java:19"$0$"import java.util.Collections;"
"AnnotationMetadata.java:20"$0$"import java.util.LinkedHashSet;"
"AnnotationMetadata.java:21"$0$"import java.util.Set;"
"AnnotationMetadata.java:22"$0$"import java.util.stream.Collectors;"
"AnnotationMetadata.java:23"$0$""
"AnnotationMetadata.java:24"$0$"import org.springframework.core.annotation.MergedAnnotation;"
"AnnotationMetadata.java:25"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"AnnotationMetadata.java:26"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"AnnotationMetadata.java:27"$0$""
"AnnotationMetadata.java:28"$0$"/**"
"AnnotationMetadata.java:29"$0$" * Interface that defines abstract access to the annotations of a specific"
"AnnotationMetadata.java:30"$0$" * class, in a form that does not require that class to be loaded yet."
"AnnotationMetadata.java:31"$0$" *"
"AnnotationMetadata.java:32"$0$" * @author Juergen Hoeller"
"AnnotationMetadata.java:33"$0$" * @author Mark Fisher"
"AnnotationMetadata.java:34"$0$" * @author Phillip Webb"
"AnnotationMetadata.java:35"$0$" * @author Sam Brannen"
"AnnotationMetadata.java:36"$0$" * @since 2.5"
"AnnotationMetadata.java:37"$0$" * @see StandardAnnotationMetadata"
"AnnotationMetadata.java:38"$0$" * @see org.springframework.core.type.classreading.MetadataReader#getAnnotationMetadata()"
"AnnotationMetadata.java:39"$0$" * @see AnnotatedTypeMetadata"
"AnnotationMetadata.java:40"$0$" */"
"AnnotationMetadata.java:41"$1$"public interface AnnotationMetadata extends ClassMetadata, AnnotatedTypeMetadata {"
"AnnotationMetadata.java:42"$1$""
"AnnotationMetadata.java:43"$1$"	/**"
"AnnotationMetadata.java:44"$1$"	 * Get the fully qualified class names of all annotation types that"
"AnnotationMetadata.java:45"$1$"	 * are <em>present</em> on the underlying class."
"AnnotationMetadata.java:46"$1$"	 * @return the annotation type names"
"AnnotationMetadata.java:47"$1$"	 */"
"AnnotationMetadata.java:48"$1$"	default Set<String> getAnnotationTypes() {"
"AnnotationMetadata.java:49"$1$"		return getAnnotations().stream()"
"AnnotationMetadata.java:50"$1$"				.filter(MergedAnnotation::isDirectlyPresent)"
"AnnotationMetadata.java:51"$1$"				.map(annotation -> annotation.getType().getName())"
"AnnotationMetadata.java:52"$1$"				.collect(Collectors.toCollection(LinkedHashSet::new));"
"AnnotationMetadata.java:53"$1$"	}"
"AnnotationMetadata.java:54"$0$""
"AnnotationMetadata.java:55"$0$"	/**"
"AnnotationMetadata.java:56"$0$"	 * Get the fully qualified class names of all meta-annotation types that"
"AnnotationMetadata.java:57"$0$"	 * are <em>present</em> on the given annotation type on the underlying class."
"AnnotationMetadata.java:58"$0$"	 * @param annotationName the fully qualified class name of the meta-annotation"
"AnnotationMetadata.java:59"$0$"	 * type to look for"
"AnnotationMetadata.java:60"$0$"	 * @return the meta-annotation type names, or an empty set if none found"
"AnnotationMetadata.java:61"$0$"	 */"
"AnnotationMetadata.java:62"$1$"	default Set<String> getMetaAnnotationTypes(String annotationName) {"
"AnnotationMetadata.java:63"$1$"		MergedAnnotation<?> annotation = getAnnotations().get(annotationName, MergedAnnotation::isDirectlyPresent);"
"AnnotationMetadata.java:64"$1$"		if (!annotation.isPresent()) {"
"AnnotationMetadata.java:65"$1$"			return Collections.emptySet();"
"AnnotationMetadata.java:66"$1$"		}"
"AnnotationMetadata.java:67"$0$"		return MergedAnnotations.from(annotation.getType(), SearchStrategy.INHERITED_ANNOTATIONS).stream()"
"AnnotationMetadata.java:68"$0$"				.map(mergedAnnotation -> mergedAnnotation.getType().getName())"
"AnnotationMetadata.java:69"$0$"				.collect(Collectors.toCollection(LinkedHashSet::new));"
"AnnotationMetadata.java:70"$0$"	}"
"AnnotationMetadata.java:71"$0$""
"AnnotationMetadata.java:72"$0$"	/**"
"AnnotationMetadata.java:73"$0$"	 * Determine whether an annotation of the given type is <em>present</em> on"
"AnnotationMetadata.java:74"$0$"	 * the underlying class."
"AnnotationMetadata.java:75"$0$"	 * @param annotationName the fully qualified class name of the annotation"
"AnnotationMetadata.java:76"$0$"	 * type to look for"
"AnnotationMetadata.java:77"$1$"	 * @return {@code true} if a matching annotation is present"
"AnnotationMetadata.java:78"$0$"	 */"
"AnnotationMetadata.java:79"$1$"	default boolean hasAnnotation(String annotationName) {"
"AnnotationMetadata.java:80"$1$"		return getAnnotations().isDirectlyPresent(annotationName);"
"AnnotationMetadata.java:81"$1$"	}"
"AnnotationMetadata.java:82"$0$""
"AnnotationMetadata.java:83"$0$"	/**"
"AnnotationMetadata.java:84"$0$"	 * Determine whether the underlying class has an annotation that is itself"
"AnnotationMetadata.java:85"$0$"	 * annotated with the meta-annotation of the given type."
"AnnotationMetadata.java:86"$0$"	 * @param metaAnnotationName the fully qualified class name of the"
"AnnotationMetadata.java:87"$0$"	 * meta-annotation type to look for"
"AnnotationMetadata.java:88"$1$"	 * @return {@code true} if a matching meta-annotation is present"
"AnnotationMetadata.java:89"$0$"	 */"
"AnnotationMetadata.java:90"$1$"	default boolean hasMetaAnnotation(String metaAnnotationName) {"
"AnnotationMetadata.java:91"$1$"		return getAnnotations().get(metaAnnotationName,"
"AnnotationMetadata.java:92"$1$"				MergedAnnotation::isMetaPresent).isPresent();"
"AnnotationMetadata.java:93"$1$"	}"
"AnnotationMetadata.java:94"$0$""
"AnnotationMetadata.java:95"$0$"	/**"
"AnnotationMetadata.java:96"$0$"	 * Determine whether the underlying class has any methods that are"
"AnnotationMetadata.java:97"$0$"	 * annotated (or meta-annotated) with the given annotation type."
"AnnotationMetadata.java:98"$0$"	 * @param annotationName the fully qualified class name of the annotation"
"AnnotationMetadata.java:99"$0$"	 * type to look for"
"AnnotationMetadata.java:100"$0$"	 */"
"AnnotationMetadata.java:101"$1$"	default boolean hasAnnotatedMethods(String annotationName) {"
"AnnotationMetadata.java:102"$1$"		return !getAnnotatedMethods(annotationName).isEmpty();"
"AnnotationMetadata.java:103"$1$"	}"
"AnnotationMetadata.java:104"$0$""
"AnnotationMetadata.java:105"$0$"	/**"
"AnnotationMetadata.java:106"$0$"	 * Retrieve the method metadata for all methods that are annotated"
"AnnotationMetadata.java:107"$0$"	 * (or meta-annotated) with the given annotation type."
"AnnotationMetadata.java:108"$1$"	 * <p>For any returned method, {@link MethodMetadata#isAnnotated} will"
"AnnotationMetadata.java:109"$1$"	 * return {@code true} for the given annotation type."
"AnnotationMetadata.java:110"$0$"	 * @param annotationName the fully qualified class name of the annotation"
"AnnotationMetadata.java:111"$0$"	 * type to look for"
"AnnotationMetadata.java:112"$1$"	 * @return a set of {@link MethodMetadata} for methods that have a matching"
"AnnotationMetadata.java:113"$0$"	 * annotation. The return value will be an empty set if no methods match"
"AnnotationMetadata.java:114"$0$"	 * the annotation type."
"AnnotationMetadata.java:115"$0$"	 */"
"AnnotationMetadata.java:116"$0$"	Set<MethodMetadata> getAnnotatedMethods(String annotationName);"
"AnnotationMetadata.java:117"$0$""
"AnnotationMetadata.java:118"$0$""
"AnnotationMetadata.java:119"$0$"	/**"
"AnnotationMetadata.java:120"$1$"	 * Factory method to create a new {@link AnnotationMetadata} instance"
"AnnotationMetadata.java:121"$0$"	 * for the given class using standard reflection."
"AnnotationMetadata.java:122"$0$"	 * @param type the class to introspect"
"AnnotationMetadata.java:123"$1$"	 * @return a new {@link AnnotationMetadata} instance"
"AnnotationMetadata.java:124"$0$"	 * @since 5.2"
"AnnotationMetadata.java:125"$0$"	 */"
"AnnotationMetadata.java:126"$1$"	static AnnotationMetadata introspect(Class<?> type) {"
"AnnotationMetadata.java:127"$1$"		return StandardAnnotationMetadata.from(type);"
"AnnotationMetadata.java:128"$1$"	}"
"AnnotationMetadata.java:129"$0$""
"AnnotationMetadata.java:130"$0$"}"
"StaxResult.java:1"$0$"/*"
"StaxResult.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"StaxResult.java:3"$0$" *"
"StaxResult.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxResult.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxResult.java:6"$0$" * You may obtain a copy of the License at"
"StaxResult.java:7"$0$" *"
"StaxResult.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxResult.java:9"$0$" *"
"StaxResult.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxResult.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxResult.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxResult.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxResult.java:14"$0$" * limitations under the License."
"StaxResult.java:15"$0$" */"
"StaxResult.java:16"$0$""
"StaxResult.java:17"$0$"package org.springframework.util.xml;"
"StaxResult.java:18"$0$""
"StaxResult.java:19"$0$"import javax.xml.stream.XMLEventWriter;"
"StaxResult.java:20"$0$"import javax.xml.stream.XMLStreamWriter;"
"StaxResult.java:21"$0$"import javax.xml.transform.sax.SAXResult;"
"StaxResult.java:22"$0$""
"StaxResult.java:23"$0$"import org.xml.sax.ContentHandler;"
"StaxResult.java:24"$0$"import org.xml.sax.ext.LexicalHandler;"
"StaxResult.java:25"$0$""
"StaxResult.java:26"$0$"import org.springframework.lang.Nullable;"
"StaxResult.java:27"$0$""
"StaxResult.java:28"$0$"/**"
"StaxResult.java:29"$1$" * Implementation of the {@code Result} tagging interface for StAX writers. Can be constructed with"
"StaxResult.java:30"$1$" * an {@code XMLEventConsumer} or an {@code XMLStreamWriter}."
"StaxResult.java:31"$0$" *"
"StaxResult.java:32"$1$" * <p>This class is necessary because there is no implementation of {@code Source} for StaxReaders"
"StaxResult.java:33"$1$" * in JAXP 1.3. There is a {@code StAXResult} in JAXP 1.4 (JDK 1.6), but this class is kept around"
"StaxResult.java:34"$0$" * for backwards compatibility reasons."
"StaxResult.java:35"$0$" *"
"StaxResult.java:36"$1$" * <p>Even though {@code StaxResult} extends from {@code SAXResult}, calling the methods of"
"StaxResult.java:37"$1$" * {@code SAXResult} is <strong>not supported</strong>. In general, the only supported operation"
"StaxResult.java:38"$1$" * on this class is to use the {@code ContentHandler} obtained via {@link #getHandler()} to parse an"
"StaxResult.java:39"$1$" * input source using an {@code XMLReader}. Calling {@link #setHandler(org.xml.sax.ContentHandler)}"
"StaxResult.java:40"$1$" * or {@link #setLexicalHandler(org.xml.sax.ext.LexicalHandler)} will result in"
"StaxResult.java:41"$1$" * {@code UnsupportedOperationException}s."
"StaxResult.java:42"$0$" *"
"StaxResult.java:43"$0$" * @author Arjen Poutsma"
"StaxResult.java:44"$0$" * @since 3.0"
"StaxResult.java:45"$0$" * @see XMLEventWriter"
"StaxResult.java:46"$0$" * @see XMLStreamWriter"
"StaxResult.java:47"$0$" * @see javax.xml.transform.Transformer"
"StaxResult.java:48"$0$" */"
"StaxResult.java:49"$1$"class StaxResult extends SAXResult {"
"StaxResult.java:50"$1$""
"StaxResult.java:51"$1$"	@Nullable"
"StaxResult.java:52"$1$"	private XMLEventWriter eventWriter;"
"StaxResult.java:53"$1$""
"StaxResult.java:54"$1$"	@Nullable"
"StaxResult.java:55"$1$"	private XMLStreamWriter streamWriter;"
"StaxResult.java:56"$1$""
"StaxResult.java:57"$1$""
"StaxResult.java:58"$1$"	/**"
"StaxResult.java:59"$1$"	 * Construct a new instance of the {@code StaxResult} with the specified {@code XMLEventWriter}."
"StaxResult.java:60"$1$"	 * @param eventWriter the {@code XMLEventWriter} to write to"
"StaxResult.java:61"$1$"	 */"
"StaxResult.java:62"$1$"	public StaxResult(XMLEventWriter eventWriter) {"
"StaxResult.java:63"$1$"		StaxEventHandler handler = new StaxEventHandler(eventWriter);"
"StaxResult.java:64"$1$"		super.setHandler(handler);"
"StaxResult.java:65"$1$"		super.setLexicalHandler(handler);"
"StaxResult.java:66"$1$"		this.eventWriter = eventWriter;"
"StaxResult.java:67"$1$"	}"
"StaxResult.java:68"$0$""
"StaxResult.java:69"$0$"	/**"
"StaxResult.java:70"$1$"	 * Construct a new instance of the {@code StaxResult} with the specified {@code XMLStreamWriter}."
"StaxResult.java:71"$1$"	 * @param streamWriter the {@code XMLStreamWriter} to write to"
"StaxResult.java:72"$0$"	 */"
"StaxResult.java:73"$1$"	public StaxResult(XMLStreamWriter streamWriter) {"
"StaxResult.java:74"$1$"		StaxStreamHandler handler = new StaxStreamHandler(streamWriter);"
"StaxResult.java:75"$1$"		super.setHandler(handler);"
"StaxResult.java:76"$1$"		super.setLexicalHandler(handler);"
"StaxResult.java:77"$1$"		this.streamWriter = streamWriter;"
"StaxResult.java:78"$1$"	}"
"StaxResult.java:79"$0$""
"StaxResult.java:80"$0$""
"StaxResult.java:81"$0$"	/**"
"StaxResult.java:82"$1$"	 * Return the {@code XMLEventWriter} used by this {@code StaxResult}."
"StaxResult.java:83"$1$"	 * <p>If this {@code StaxResult} was created with an {@code XMLStreamWriter},"
"StaxResult.java:84"$1$"	 * the result will be {@code null}."
"StaxResult.java:85"$0$"	 * @return the StAX event writer used by this result"
"StaxResult.java:86"$0$"	 * @see #StaxResult(javax.xml.stream.XMLEventWriter)"
"StaxResult.java:87"$0$"	 */"
"StaxResult.java:88"$0$"	@Nullable"
"StaxResult.java:89"$1$"	public XMLEventWriter getXMLEventWriter() {"
"StaxResult.java:90"$1$"		return this.eventWriter;"
"StaxResult.java:91"$1$"	}"
"StaxResult.java:92"$0$""
"StaxResult.java:93"$0$"	/**"
"StaxResult.java:94"$1$"	 * Return the {@code XMLStreamWriter} used by this {@code StaxResult}."
"StaxResult.java:95"$1$"	 * <p>If this {@code StaxResult} was created with an {@code XMLEventConsumer},"
"StaxResult.java:96"$1$"	 * the result will be {@code null}."
"StaxResult.java:97"$0$"	 * @return the StAX stream writer used by this result"
"StaxResult.java:98"$0$"	 * @see #StaxResult(javax.xml.stream.XMLStreamWriter)"
"StaxResult.java:99"$0$"	 */"
"StaxResult.java:100"$0$"	@Nullable"
"StaxResult.java:101"$1$"	public XMLStreamWriter getXMLStreamWriter() {"
"StaxResult.java:102"$1$"		return this.streamWriter;"
"StaxResult.java:103"$1$"	}"
"StaxResult.java:104"$0$""
"StaxResult.java:105"$0$""
"StaxResult.java:106"$0$"	/**"
"StaxResult.java:107"$1$"	 * Throws an {@code UnsupportedOperationException}."
"StaxResult.java:108"$0$"	 * @throws UnsupportedOperationException always"
"StaxResult.java:109"$0$"	 */"
"StaxResult.java:110"$0$"	@Override"
"StaxResult.java:111"$1$"	public void setHandler(ContentHandler handler) {"
"StaxResult.java:112"$1$"		throw new UnsupportedOperationException(""setHandler is not supported"");"
"StaxResult.java:113"$1$"	}"
"StaxResult.java:114"$0$""
"StaxResult.java:115"$0$"	/**"
"StaxResult.java:116"$1$"	 * Throws an {@code UnsupportedOperationException}."
"StaxResult.java:117"$0$"	 * @throws UnsupportedOperationException always"
"StaxResult.java:118"$0$"	 */"
"StaxResult.java:119"$0$"	@Override"
"StaxResult.java:120"$1$"	public void setLexicalHandler(LexicalHandler handler) {"
"StaxResult.java:121"$1$"		throw new UnsupportedOperationException(""setLexicalHandler is not supported"");"
"StaxResult.java:122"$1$"	}"
"StaxResult.java:123"$0$""
"StaxResult.java:124"$0$"}"
"PropertySourcesPropertyResolver.java:1"$0$"/*"
"PropertySourcesPropertyResolver.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"PropertySourcesPropertyResolver.java:3"$0$" *"
"PropertySourcesPropertyResolver.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PropertySourcesPropertyResolver.java:5"$0$" * you may not use this file except in compliance with the License."
"PropertySourcesPropertyResolver.java:6"$0$" * You may obtain a copy of the License at"
"PropertySourcesPropertyResolver.java:7"$0$" *"
"PropertySourcesPropertyResolver.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PropertySourcesPropertyResolver.java:9"$0$" *"
"PropertySourcesPropertyResolver.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PropertySourcesPropertyResolver.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PropertySourcesPropertyResolver.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PropertySourcesPropertyResolver.java:13"$0$" * See the License for the specific language governing permissions and"
"PropertySourcesPropertyResolver.java:14"$0$" * limitations under the License."
"PropertySourcesPropertyResolver.java:15"$0$" */"
"PropertySourcesPropertyResolver.java:16"$0$""
"PropertySourcesPropertyResolver.java:17"$0$"package org.springframework.core.env;"
"PropertySourcesPropertyResolver.java:18"$0$""
"PropertySourcesPropertyResolver.java:19"$0$"import org.springframework.lang.Nullable;"
"PropertySourcesPropertyResolver.java:20"$0$""
"PropertySourcesPropertyResolver.java:21"$0$"/**"
"PropertySourcesPropertyResolver.java:22"$1$" * {@link PropertyResolver} implementation that resolves property values against"
"PropertySourcesPropertyResolver.java:23"$1$" * an underlying set of {@link PropertySources}."
"PropertySourcesPropertyResolver.java:24"$0$" *"
"PropertySourcesPropertyResolver.java:25"$0$" * @author Chris Beams"
"PropertySourcesPropertyResolver.java:26"$0$" * @author Juergen Hoeller"
"PropertySourcesPropertyResolver.java:27"$0$" * @since 3.1"
"PropertySourcesPropertyResolver.java:28"$0$" * @see PropertySource"
"PropertySourcesPropertyResolver.java:29"$0$" * @see PropertySources"
"PropertySourcesPropertyResolver.java:30"$0$" * @see AbstractEnvironment"
"PropertySourcesPropertyResolver.java:31"$0$" */"
"PropertySourcesPropertyResolver.java:32"$1$"public class PropertySourcesPropertyResolver extends AbstractPropertyResolver {"
"PropertySourcesPropertyResolver.java:33"$1$""
"PropertySourcesPropertyResolver.java:34"$1$"	@Nullable"
"PropertySourcesPropertyResolver.java:35"$1$"	private final PropertySources propertySources;"
"PropertySourcesPropertyResolver.java:36"$1$""
"PropertySourcesPropertyResolver.java:37"$1$""
"PropertySourcesPropertyResolver.java:38"$1$"	/**"
"PropertySourcesPropertyResolver.java:39"$1$"	 * Create a new resolver against the given property sources."
"PropertySourcesPropertyResolver.java:40"$1$"	 * @param propertySources the set of {@link PropertySource} objects to use"
"PropertySourcesPropertyResolver.java:41"$1$"	 */"
"PropertySourcesPropertyResolver.java:42"$1$"	public PropertySourcesPropertyResolver(@Nullable PropertySources propertySources) {"
"PropertySourcesPropertyResolver.java:43"$1$"		this.propertySources = propertySources;"
"PropertySourcesPropertyResolver.java:44"$1$"	}"
"PropertySourcesPropertyResolver.java:45"$0$""
"PropertySourcesPropertyResolver.java:46"$0$""
"PropertySourcesPropertyResolver.java:47"$0$"	@Override"
"PropertySourcesPropertyResolver.java:48"$1$"	public boolean containsProperty(String key) {"
"PropertySourcesPropertyResolver.java:49"$1$"		if (this.propertySources != null) {"
"PropertySourcesPropertyResolver.java:50"$1$"			for (PropertySource<?> propertySource : this.propertySources) {"
"PropertySourcesPropertyResolver.java:51"$1$"				if (propertySource.containsProperty(key)) {"
"PropertySourcesPropertyResolver.java:52"$1$"					return true;"
"PropertySourcesPropertyResolver.java:53"$1$"				}"
"PropertySourcesPropertyResolver.java:54"$0$"			}"
"PropertySourcesPropertyResolver.java:55"$0$"		}"
"PropertySourcesPropertyResolver.java:56"$0$"		return false;"
"PropertySourcesPropertyResolver.java:57"$0$"	}"
"PropertySourcesPropertyResolver.java:58"$0$""
"PropertySourcesPropertyResolver.java:59"$0$"	@Override"
"PropertySourcesPropertyResolver.java:60"$0$"	@Nullable"
"PropertySourcesPropertyResolver.java:61"$1$"	public String getProperty(String key) {"
"PropertySourcesPropertyResolver.java:62"$1$"		return getProperty(key, String.class, true);"
"PropertySourcesPropertyResolver.java:63"$1$"	}"
"PropertySourcesPropertyResolver.java:64"$0$""
"PropertySourcesPropertyResolver.java:65"$0$"	@Override"
"PropertySourcesPropertyResolver.java:66"$0$"	@Nullable"
"PropertySourcesPropertyResolver.java:67"$1$"	public <T> T getProperty(String key, Class<T> targetValueType) {"
"PropertySourcesPropertyResolver.java:68"$1$"		return getProperty(key, targetValueType, true);"
"PropertySourcesPropertyResolver.java:69"$1$"	}"
"PropertySourcesPropertyResolver.java:70"$0$""
"PropertySourcesPropertyResolver.java:71"$0$"	@Override"
"PropertySourcesPropertyResolver.java:72"$0$"	@Nullable"
"PropertySourcesPropertyResolver.java:73"$1$"	protected String getPropertyAsRawString(String key) {"
"PropertySourcesPropertyResolver.java:74"$1$"		return getProperty(key, String.class, false);"
"PropertySourcesPropertyResolver.java:75"$1$"	}"
"PropertySourcesPropertyResolver.java:76"$0$""
"PropertySourcesPropertyResolver.java:77"$0$"	@Nullable"
"PropertySourcesPropertyResolver.java:78"$1$"	protected <T> T getProperty(String key, Class<T> targetValueType, boolean resolveNestedPlaceholders) {"
"PropertySourcesPropertyResolver.java:79"$1$"		if (this.propertySources != null) {"
"PropertySourcesPropertyResolver.java:80"$1$"			for (PropertySource<?> propertySource : this.propertySources) {"
"PropertySourcesPropertyResolver.java:81"$1$"				if (logger.isTraceEnabled()) {"
"PropertySourcesPropertyResolver.java:82"$1$"					logger.trace(""Searching for key '"" + key + ""' in PropertySource '"" +"
"PropertySourcesPropertyResolver.java:83"$1$"							propertySource.getName() + ""'"");"
"PropertySourcesPropertyResolver.java:84"$1$"				}"
"PropertySourcesPropertyResolver.java:85"$0$"				Object value = propertySource.getProperty(key);"
"PropertySourcesPropertyResolver.java:86"$1$"				if (value != null) {"
"PropertySourcesPropertyResolver.java:87"$1$"					if (resolveNestedPlaceholders && value instanceof String) {"
"PropertySourcesPropertyResolver.java:88"$1$"						value = resolveNestedPlaceholders((String) value);"
"PropertySourcesPropertyResolver.java:89"$1$"					}"
"PropertySourcesPropertyResolver.java:90"$0$"					logKeyFound(key, propertySource, value);"
"PropertySourcesPropertyResolver.java:91"$0$"					return convertValueIfNecessary(value, targetValueType);"
"PropertySourcesPropertyResolver.java:92"$0$"				}"
"PropertySourcesPropertyResolver.java:93"$0$"			}"
"PropertySourcesPropertyResolver.java:94"$0$"		}"
"PropertySourcesPropertyResolver.java:95"$1$"		if (logger.isTraceEnabled()) {"
"PropertySourcesPropertyResolver.java:96"$1$"			logger.trace(""Could not find key '"" + key + ""' in any property source"");"
"PropertySourcesPropertyResolver.java:97"$1$"		}"
"PropertySourcesPropertyResolver.java:98"$0$"		return null;"
"PropertySourcesPropertyResolver.java:99"$0$"	}"
"PropertySourcesPropertyResolver.java:100"$0$""
"PropertySourcesPropertyResolver.java:101"$0$"	/**"
"PropertySourcesPropertyResolver.java:102"$1$"	 * Log the given key as found in the given {@link PropertySource}, resulting in"
"PropertySourcesPropertyResolver.java:103"$0$"	 * the given value."
"PropertySourcesPropertyResolver.java:104"$0$"	 * <p>The default implementation writes a debug log message with key and source."
"PropertySourcesPropertyResolver.java:105"$0$"	 * As of 4.3.3, this does not log the value anymore in order to avoid accidental"
"PropertySourcesPropertyResolver.java:106"$0$"	 * logging of sensitive settings. Subclasses may override this method to change"
"PropertySourcesPropertyResolver.java:107"$0$"	 * the log level and/or log message, including the property's value if desired."
"PropertySourcesPropertyResolver.java:108"$0$"	 * @param key the key found"
"PropertySourcesPropertyResolver.java:109"$1$"	 * @param propertySource the {@code PropertySource} that the key has been found in"
"PropertySourcesPropertyResolver.java:110"$0$"	 * @param value the corresponding value"
"PropertySourcesPropertyResolver.java:111"$0$"	 * @since 4.3.1"
"PropertySourcesPropertyResolver.java:112"$0$"	 */"
"PropertySourcesPropertyResolver.java:113"$1$"	protected void logKeyFound(String key, PropertySource<?> propertySource, Object value) {"
"PropertySourcesPropertyResolver.java:114"$1$"		if (logger.isDebugEnabled()) {"
"PropertySourcesPropertyResolver.java:115"$1$"			logger.debug(""Found key '"" + key + ""' in PropertySource '"" + propertySource.getName() +"
"PropertySourcesPropertyResolver.java:116"$1$"					""' with value of type "" + value.getClass().getSimpleName());"
"PropertySourcesPropertyResolver.java:117"$1$"		}"
"PropertySourcesPropertyResolver.java:118"$0$"	}"
"PropertySourcesPropertyResolver.java:119"$0$""
"PropertySourcesPropertyResolver.java:120"$0$"}"
"ByteArrayEncoder.java:1"$0$"/*"
"ByteArrayEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ByteArrayEncoder.java:3"$0$" *"
"ByteArrayEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ByteArrayEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ByteArrayEncoder.java:6"$0$" * You may obtain a copy of the License at"
"ByteArrayEncoder.java:7"$0$" *"
"ByteArrayEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ByteArrayEncoder.java:9"$0$" *"
"ByteArrayEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ByteArrayEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ByteArrayEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ByteArrayEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ByteArrayEncoder.java:14"$0$" * limitations under the License."
"ByteArrayEncoder.java:15"$0$" */"
"ByteArrayEncoder.java:16"$0$""
"ByteArrayEncoder.java:17"$0$"package org.springframework.core.codec;"
"ByteArrayEncoder.java:18"$0$""
"ByteArrayEncoder.java:19"$0$"import java.util.Map;"
"ByteArrayEncoder.java:20"$0$""
"ByteArrayEncoder.java:21"$0$"import org.reactivestreams.Publisher;"
"ByteArrayEncoder.java:22"$0$"import reactor.core.publisher.Flux;"
"ByteArrayEncoder.java:23"$0$""
"ByteArrayEncoder.java:24"$0$"import org.springframework.core.ResolvableType;"
"ByteArrayEncoder.java:25"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ByteArrayEncoder.java:26"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"ByteArrayEncoder.java:27"$0$"import org.springframework.lang.Nullable;"
"ByteArrayEncoder.java:28"$0$"import org.springframework.util.MimeType;"
"ByteArrayEncoder.java:29"$0$"import org.springframework.util.MimeTypeUtils;"
"ByteArrayEncoder.java:30"$0$""
"ByteArrayEncoder.java:31"$0$"/**"
"ByteArrayEncoder.java:32"$1$" * Encoder for {@code byte} arrays."
"ByteArrayEncoder.java:33"$0$" *"
"ByteArrayEncoder.java:34"$0$" * @author Arjen Poutsma"
"ByteArrayEncoder.java:35"$0$" * @since 5.0"
"ByteArrayEncoder.java:36"$0$" */"
"ByteArrayEncoder.java:37"$1$"public class ByteArrayEncoder extends AbstractEncoder<byte[]> {"
"ByteArrayEncoder.java:38"$1$""
"ByteArrayEncoder.java:39"$1$"	public ByteArrayEncoder() {"
"ByteArrayEncoder.java:40"$1$"		super(MimeTypeUtils.ALL);"
"ByteArrayEncoder.java:41"$1$"	}"
"ByteArrayEncoder.java:42"$0$""
"ByteArrayEncoder.java:43"$0$""
"ByteArrayEncoder.java:44"$0$"	@Override"
"ByteArrayEncoder.java:45"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ByteArrayEncoder.java:46"$1$"		Class<?> clazz = elementType.toClass();"
"ByteArrayEncoder.java:47"$1$"		return super.canEncode(elementType, mimeType) && byte[].class.isAssignableFrom(clazz);"
"ByteArrayEncoder.java:48"$1$"	}"
"ByteArrayEncoder.java:49"$0$""
"ByteArrayEncoder.java:50"$0$"	@Override"
"ByteArrayEncoder.java:51"$0$"	public Flux<DataBuffer> encode(Publisher<? extends byte[]> inputStream,"
"ByteArrayEncoder.java:52"$0$"			DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,"
"ByteArrayEncoder.java:53"$1$"			@Nullable Map<String, Object> hints) {"
"ByteArrayEncoder.java:54"$1$""
"ByteArrayEncoder.java:55"$0$"		// Use (byte[] bytes) for Eclipse"
"ByteArrayEncoder.java:56"$1$"		return Flux.from(inputStream).map((byte[] bytes) ->"
"ByteArrayEncoder.java:57"$1$"				encodeValue(bytes, bufferFactory, elementType, mimeType, hints));"
"ByteArrayEncoder.java:58"$1$"	}"
"ByteArrayEncoder.java:59"$0$""
"ByteArrayEncoder.java:60"$0$"	@Override"
"ByteArrayEncoder.java:61"$0$"	public DataBuffer encodeValue(byte[] bytes, DataBufferFactory bufferFactory,"
"ByteArrayEncoder.java:62"$1$"			ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ByteArrayEncoder.java:63"$1$""
"ByteArrayEncoder.java:64"$1$"		DataBuffer dataBuffer = bufferFactory.wrap(bytes);"
"ByteArrayEncoder.java:65"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"ByteArrayEncoder.java:66"$1$"			String logPrefix = Hints.getLogPrefix(hints);"
"ByteArrayEncoder.java:67"$1$"			logger.debug(logPrefix + ""Writing "" + dataBuffer.readableByteCount() + "" bytes"");"
"ByteArrayEncoder.java:68"$1$"		}"
"ByteArrayEncoder.java:69"$0$"		return dataBuffer;"
"ByteArrayEncoder.java:70"$0$"	}"
"ByteArrayEncoder.java:71"$0$""
"ByteArrayEncoder.java:72"$0$"}"
"AbstractStaxHandler.java:1"$0$"/*"
"AbstractStaxHandler.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"AbstractStaxHandler.java:3"$0$" *"
"AbstractStaxHandler.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AbstractStaxHandler.java:5"$0$" * you may not use this file except in compliance with the License."
"AbstractStaxHandler.java:6"$0$" * You may obtain a copy of the License at"
"AbstractStaxHandler.java:7"$0$" *"
"AbstractStaxHandler.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AbstractStaxHandler.java:9"$0$" *"
"AbstractStaxHandler.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AbstractStaxHandler.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AbstractStaxHandler.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AbstractStaxHandler.java:13"$0$" * See the License for the specific language governing permissions and"
"AbstractStaxHandler.java:14"$0$" * limitations under the License."
"AbstractStaxHandler.java:15"$0$" */"
"AbstractStaxHandler.java:16"$0$""
"AbstractStaxHandler.java:17"$0$"package org.springframework.util.xml;"
"AbstractStaxHandler.java:18"$0$""
"AbstractStaxHandler.java:19"$0$"import java.util.ArrayList;"
"AbstractStaxHandler.java:20"$0$"import java.util.HashMap;"
"AbstractStaxHandler.java:21"$0$"import java.util.List;"
"AbstractStaxHandler.java:22"$0$"import java.util.Map;"
"AbstractStaxHandler.java:23"$0$""
"AbstractStaxHandler.java:24"$0$"import javax.xml.XMLConstants;"
"AbstractStaxHandler.java:25"$0$"import javax.xml.namespace.QName;"
"AbstractStaxHandler.java:26"$0$"import javax.xml.stream.XMLStreamException;"
"AbstractStaxHandler.java:27"$0$""
"AbstractStaxHandler.java:28"$0$"import org.xml.sax.Attributes;"
"AbstractStaxHandler.java:29"$0$"import org.xml.sax.ContentHandler;"
"AbstractStaxHandler.java:30"$0$"import org.xml.sax.SAXException;"
"AbstractStaxHandler.java:31"$0$"import org.xml.sax.ext.LexicalHandler;"
"AbstractStaxHandler.java:32"$0$""
"AbstractStaxHandler.java:33"$0$"import org.springframework.lang.Nullable;"
"AbstractStaxHandler.java:34"$0$""
"AbstractStaxHandler.java:35"$0$"/**"
"AbstractStaxHandler.java:36"$1$" * Abstract base class for SAX {@code ContentHandler} and {@code LexicalHandler}"
"AbstractStaxHandler.java:37"$0$" * implementations that use StAX as a basis. All methods delegate to internal template"
"AbstractStaxHandler.java:38"$1$" * methods, capable of throwing a {@code XMLStreamException}. Additionally, an namespace"
"AbstractStaxHandler.java:39"$0$" * context stack is used to keep track of declared namespaces."
"AbstractStaxHandler.java:40"$0$" *"
"AbstractStaxHandler.java:41"$0$" * @author Arjen Poutsma"
"AbstractStaxHandler.java:42"$0$" * @since 4.0.3"
"AbstractStaxHandler.java:43"$0$" */"
"AbstractStaxHandler.java:44"$1$"abstract class AbstractStaxHandler implements ContentHandler, LexicalHandler {"
"AbstractStaxHandler.java:45"$1$""
"AbstractStaxHandler.java:46"$1$"	private final List<Map<String, String>> namespaceMappings = new ArrayList<>();"
"AbstractStaxHandler.java:47"$1$""
"AbstractStaxHandler.java:48"$1$"	private boolean inCData;"
"AbstractStaxHandler.java:49"$1$""
"AbstractStaxHandler.java:50"$1$""
"AbstractStaxHandler.java:51"$1$"	@Override"
"AbstractStaxHandler.java:52"$1$"	public final void startDocument() throws SAXException {"
"AbstractStaxHandler.java:53"$1$"		removeAllNamespaceMappings();"
"AbstractStaxHandler.java:54"$1$"		newNamespaceMapping();"
"AbstractStaxHandler.java:55"$1$"		try {"
"AbstractStaxHandler.java:56"$1$"			startDocumentInternal();"
"AbstractStaxHandler.java:57"$1$"		}"
"AbstractStaxHandler.java:58"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:59"$1$"			throw new SAXException(""Could not handle startDocument: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:60"$1$"		}"
"AbstractStaxHandler.java:61"$0$"	}"
"AbstractStaxHandler.java:62"$0$""
"AbstractStaxHandler.java:63"$0$"	@Override"
"AbstractStaxHandler.java:64"$1$"	public final void endDocument() throws SAXException {"
"AbstractStaxHandler.java:65"$1$"		removeAllNamespaceMappings();"
"AbstractStaxHandler.java:66"$1$"		try {"
"AbstractStaxHandler.java:67"$1$"			endDocumentInternal();"
"AbstractStaxHandler.java:68"$1$"		}"
"AbstractStaxHandler.java:69"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:70"$1$"			throw new SAXException(""Could not handle endDocument: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:71"$1$"		}"
"AbstractStaxHandler.java:72"$0$"	}"
"AbstractStaxHandler.java:73"$0$""
"AbstractStaxHandler.java:74"$0$"	@Override"
"AbstractStaxHandler.java:75"$1$"	public final void startPrefixMapping(String prefix, String uri) {"
"AbstractStaxHandler.java:76"$1$"		currentNamespaceMapping().put(prefix, uri);"
"AbstractStaxHandler.java:77"$1$"	}"
"AbstractStaxHandler.java:78"$0$""
"AbstractStaxHandler.java:79"$0$"	@Override"
"AbstractStaxHandler.java:80"$1$"	public final void endPrefixMapping(String prefix) {"
"AbstractStaxHandler.java:81"$1$"	}"
"AbstractStaxHandler.java:82"$0$""
"AbstractStaxHandler.java:83"$0$"	@Override"
"AbstractStaxHandler.java:84"$1$"	public final void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {"
"AbstractStaxHandler.java:85"$1$"		try {"
"AbstractStaxHandler.java:86"$1$"			startElementInternal(toQName(uri, qName), atts, currentNamespaceMapping());"
"AbstractStaxHandler.java:87"$1$"			newNamespaceMapping();"
"AbstractStaxHandler.java:88"$1$"		}"
"AbstractStaxHandler.java:89"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:90"$1$"			throw new SAXException(""Could not handle startElement: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:91"$1$"		}"
"AbstractStaxHandler.java:92"$0$"	}"
"AbstractStaxHandler.java:93"$0$""
"AbstractStaxHandler.java:94"$0$"	@Override"
"AbstractStaxHandler.java:95"$1$"	public final void endElement(String uri, String localName, String qName) throws SAXException {"
"AbstractStaxHandler.java:96"$1$"		try {"
"AbstractStaxHandler.java:97"$1$"			endElementInternal(toQName(uri, qName), currentNamespaceMapping());"
"AbstractStaxHandler.java:98"$1$"			removeNamespaceMapping();"
"AbstractStaxHandler.java:99"$1$"		}"
"AbstractStaxHandler.java:100"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:101"$1$"			throw new SAXException(""Could not handle endElement: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:102"$1$"		}"
"AbstractStaxHandler.java:103"$0$"	}"
"AbstractStaxHandler.java:104"$0$""
"AbstractStaxHandler.java:105"$0$"	@Override"
"AbstractStaxHandler.java:106"$1$"	public final void characters(char[] ch, int start, int length) throws SAXException {"
"AbstractStaxHandler.java:107"$1$"		try {"
"AbstractStaxHandler.java:108"$1$"			String data = new String(ch, start, length);"
"AbstractStaxHandler.java:109"$1$"			if (!this.inCData) {"
"AbstractStaxHandler.java:110"$1$"				charactersInternal(data);"
"AbstractStaxHandler.java:111"$1$"			}"
"AbstractStaxHandler.java:112"$1$"			else {"
"AbstractStaxHandler.java:113"$1$"				cDataInternal(data);"
"AbstractStaxHandler.java:114"$1$"			}"
"AbstractStaxHandler.java:115"$0$"		}"
"AbstractStaxHandler.java:116"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:117"$1$"			throw new SAXException(""Could not handle characters: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:118"$1$"		}"
"AbstractStaxHandler.java:119"$0$"	}"
"AbstractStaxHandler.java:120"$0$""
"AbstractStaxHandler.java:121"$0$"	@Override"
"AbstractStaxHandler.java:122"$1$"	public final void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {"
"AbstractStaxHandler.java:123"$1$"		try {"
"AbstractStaxHandler.java:124"$1$"			ignorableWhitespaceInternal(new String(ch, start, length));"
"AbstractStaxHandler.java:125"$1$"		}"
"AbstractStaxHandler.java:126"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:127"$1$"			throw new SAXException("
"AbstractStaxHandler.java:128"$1$"					""Could not handle ignorableWhitespace:"" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:129"$1$"		}"
"AbstractStaxHandler.java:130"$0$"	}"
"AbstractStaxHandler.java:131"$0$""
"AbstractStaxHandler.java:132"$0$"	@Override"
"AbstractStaxHandler.java:133"$1$"	public final void processingInstruction(String target, String data) throws SAXException {"
"AbstractStaxHandler.java:134"$1$"		try {"
"AbstractStaxHandler.java:135"$1$"			processingInstructionInternal(target, data);"
"AbstractStaxHandler.java:136"$1$"		}"
"AbstractStaxHandler.java:137"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:138"$1$"			throw new SAXException(""Could not handle processingInstruction: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:139"$1$"		}"
"AbstractStaxHandler.java:140"$0$"	}"
"AbstractStaxHandler.java:141"$0$""
"AbstractStaxHandler.java:142"$0$"	@Override"
"AbstractStaxHandler.java:143"$1$"	public final void skippedEntity(String name) throws SAXException {"
"AbstractStaxHandler.java:144"$1$"		try {"
"AbstractStaxHandler.java:145"$1$"			skippedEntityInternal(name);"
"AbstractStaxHandler.java:146"$1$"		}"
"AbstractStaxHandler.java:147"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:148"$1$"			throw new SAXException(""Could not handle skippedEntity: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:149"$1$"		}"
"AbstractStaxHandler.java:150"$0$"	}"
"AbstractStaxHandler.java:151"$0$""
"AbstractStaxHandler.java:152"$0$"	@Override"
"AbstractStaxHandler.java:153"$1$"	public final void startDTD(String name, @Nullable String publicId, String systemId) throws SAXException {"
"AbstractStaxHandler.java:154"$1$"		try {"
"AbstractStaxHandler.java:155"$1$"			StringBuilder builder = new StringBuilder(""<!DOCTYPE "");"
"AbstractStaxHandler.java:156"$1$"			builder.append(name);"
"AbstractStaxHandler.java:157"$1$"			if (publicId != null) {"
"AbstractStaxHandler.java:158"$1$"				builder.append("" PUBLIC \"""");"
"AbstractStaxHandler.java:159"$1$"				builder.append(publicId);"
"AbstractStaxHandler.java:160"$1$"				builder.append(""\"" \"""");"
"AbstractStaxHandler.java:161"$1$"			}"
"AbstractStaxHandler.java:162"$1$"			else {"
"AbstractStaxHandler.java:163"$1$"				builder.append("" SYSTEM \"""");"
"AbstractStaxHandler.java:164"$1$"			}"
"AbstractStaxHandler.java:165"$0$"			builder.append(systemId);"
"AbstractStaxHandler.java:166"$0$"			builder.append(""\"">"");"
"AbstractStaxHandler.java:167"$0$""
"AbstractStaxHandler.java:168"$0$"			dtdInternal(builder.toString());"
"AbstractStaxHandler.java:169"$0$"		}"
"AbstractStaxHandler.java:170"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:171"$1$"			throw new SAXException(""Could not handle startDTD: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:172"$1$"		}"
"AbstractStaxHandler.java:173"$0$"	}"
"AbstractStaxHandler.java:174"$0$""
"AbstractStaxHandler.java:175"$0$"	@Override"
"AbstractStaxHandler.java:176"$1$"	public final void endDTD() throws SAXException {"
"AbstractStaxHandler.java:177"$1$"	}"
"AbstractStaxHandler.java:178"$0$""
"AbstractStaxHandler.java:179"$0$"	@Override"
"AbstractStaxHandler.java:180"$1$"	public final void startCDATA() throws SAXException {"
"AbstractStaxHandler.java:181"$1$"		this.inCData = true;"
"AbstractStaxHandler.java:182"$1$"	}"
"AbstractStaxHandler.java:183"$0$""
"AbstractStaxHandler.java:184"$0$"	@Override"
"AbstractStaxHandler.java:185"$1$"	public final void endCDATA() throws SAXException {"
"AbstractStaxHandler.java:186"$1$"		this.inCData = false;"
"AbstractStaxHandler.java:187"$1$"	}"
"AbstractStaxHandler.java:188"$0$""
"AbstractStaxHandler.java:189"$0$"	@Override"
"AbstractStaxHandler.java:190"$1$"	public final void comment(char[] ch, int start, int length) throws SAXException {"
"AbstractStaxHandler.java:191"$1$"		try {"
"AbstractStaxHandler.java:192"$1$"			commentInternal(new String(ch, start, length));"
"AbstractStaxHandler.java:193"$1$"		}"
"AbstractStaxHandler.java:194"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxHandler.java:195"$1$"			throw new SAXException(""Could not handle comment: "" + ex.getMessage(), ex);"
"AbstractStaxHandler.java:196"$1$"		}"
"AbstractStaxHandler.java:197"$0$"	}"
"AbstractStaxHandler.java:198"$0$""
"AbstractStaxHandler.java:199"$0$"	@Override"
"AbstractStaxHandler.java:200"$1$"	public void startEntity(String name) throws SAXException {"
"AbstractStaxHandler.java:201"$1$"	}"
"AbstractStaxHandler.java:202"$0$""
"AbstractStaxHandler.java:203"$0$"	@Override"
"AbstractStaxHandler.java:204"$1$"	public void endEntity(String name) throws SAXException {"
"AbstractStaxHandler.java:205"$1$"	}"
"AbstractStaxHandler.java:206"$0$""
"AbstractStaxHandler.java:207"$0$"	/**"
"AbstractStaxHandler.java:208"$1$"	 * Convert a namespace URI and DOM or SAX qualified name to a {@code QName}. The"
"AbstractStaxHandler.java:209"$1$"	 * qualified name can have the form {@code prefix:localname} or {@code localName}."
"AbstractStaxHandler.java:210"$0$"	 * @param namespaceUri the namespace URI"
"AbstractStaxHandler.java:211"$0$"	 * @param qualifiedName the qualified name"
"AbstractStaxHandler.java:212"$0$"	 * @return a QName"
"AbstractStaxHandler.java:213"$0$"	 */"
"AbstractStaxHandler.java:214"$1$"	protected QName toQName(String namespaceUri, String qualifiedName) {"
"AbstractStaxHandler.java:215"$1$"		int idx = qualifiedName.indexOf(':');"
"AbstractStaxHandler.java:216"$1$"		if (idx == -1) {"
"AbstractStaxHandler.java:217"$1$"			return new QName(namespaceUri, qualifiedName);"
"AbstractStaxHandler.java:218"$1$"		}"
"AbstractStaxHandler.java:219"$1$"		else {"
"AbstractStaxHandler.java:220"$1$"			String prefix = qualifiedName.substring(0, idx);"
"AbstractStaxHandler.java:221"$1$"			String localPart = qualifiedName.substring(idx + 1);"
"AbstractStaxHandler.java:222"$1$"			return new QName(namespaceUri, localPart, prefix);"
"AbstractStaxHandler.java:223"$1$"		}"
"AbstractStaxHandler.java:224"$0$"	}"
"AbstractStaxHandler.java:225"$0$""
"AbstractStaxHandler.java:226"$1$"	protected boolean isNamespaceDeclaration(QName qName) {"
"AbstractStaxHandler.java:227"$1$"		String prefix = qName.getPrefix();"
"AbstractStaxHandler.java:228"$1$"		String localPart = qName.getLocalPart();"
"AbstractStaxHandler.java:229"$1$"		return (XMLConstants.XMLNS_ATTRIBUTE.equals(localPart) && prefix.isEmpty()) ||"
"AbstractStaxHandler.java:230"$1$"				(XMLConstants.XMLNS_ATTRIBUTE.equals(prefix) && !localPart.isEmpty());"
"AbstractStaxHandler.java:231"$1$"	}"
"AbstractStaxHandler.java:232"$0$""
"AbstractStaxHandler.java:233"$0$""
"AbstractStaxHandler.java:234"$1$"	private Map<String, String> currentNamespaceMapping() {"
"AbstractStaxHandler.java:235"$1$"		return this.namespaceMappings.get(this.namespaceMappings.size() - 1);"
"AbstractStaxHandler.java:236"$1$"	}"
"AbstractStaxHandler.java:237"$0$""
"AbstractStaxHandler.java:238"$1$"	private void newNamespaceMapping() {"
"AbstractStaxHandler.java:239"$1$"		this.namespaceMappings.add(new HashMap<>());"
"AbstractStaxHandler.java:240"$1$"	}"
"AbstractStaxHandler.java:241"$0$""
"AbstractStaxHandler.java:242"$1$"	private void removeNamespaceMapping() {"
"AbstractStaxHandler.java:243"$1$"		this.namespaceMappings.remove(this.namespaceMappings.size() - 1);"
"AbstractStaxHandler.java:244"$1$"	}"
"AbstractStaxHandler.java:245"$0$""
"AbstractStaxHandler.java:246"$1$"	private void removeAllNamespaceMappings() {"
"AbstractStaxHandler.java:247"$1$"		this.namespaceMappings.clear();"
"AbstractStaxHandler.java:248"$1$"	}"
"AbstractStaxHandler.java:249"$0$""
"AbstractStaxHandler.java:250"$0$""
"AbstractStaxHandler.java:251"$0$"	protected abstract void startDocumentInternal() throws XMLStreamException;"
"AbstractStaxHandler.java:252"$0$""
"AbstractStaxHandler.java:253"$0$"	protected abstract void endDocumentInternal() throws XMLStreamException;"
"AbstractStaxHandler.java:254"$0$""
"AbstractStaxHandler.java:255"$0$"	protected abstract void startElementInternal(QName name, Attributes attributes,"
"AbstractStaxHandler.java:256"$0$"			Map<String, String> namespaceMapping) throws XMLStreamException;"
"AbstractStaxHandler.java:257"$0$""
"AbstractStaxHandler.java:258"$0$"	protected abstract void endElementInternal(QName name, Map<String, String> namespaceMapping)"
"AbstractStaxHandler.java:259"$0$"			throws XMLStreamException;"
"AbstractStaxHandler.java:260"$0$""
"AbstractStaxHandler.java:261"$0$"	protected abstract void charactersInternal(String data) throws XMLStreamException;"
"AbstractStaxHandler.java:262"$0$""
"AbstractStaxHandler.java:263"$0$"	protected abstract void cDataInternal(String data) throws XMLStreamException;"
"AbstractStaxHandler.java:264"$0$""
"AbstractStaxHandler.java:265"$0$"	protected abstract void ignorableWhitespaceInternal(String data) throws XMLStreamException;"
"AbstractStaxHandler.java:266"$0$""
"AbstractStaxHandler.java:267"$0$"	protected abstract void processingInstructionInternal(String target, String data)"
"AbstractStaxHandler.java:268"$0$"			throws XMLStreamException;"
"AbstractStaxHandler.java:269"$0$""
"AbstractStaxHandler.java:270"$0$"	protected abstract void skippedEntityInternal(String name) throws XMLStreamException;"
"AbstractStaxHandler.java:271"$0$""
"AbstractStaxHandler.java:272"$0$"	protected abstract void dtdInternal(String dtd) throws XMLStreamException;"
"AbstractStaxHandler.java:273"$0$""
"AbstractStaxHandler.java:274"$0$"	protected abstract void commentInternal(String comment) throws XMLStreamException;"
"AbstractStaxHandler.java:275"$0$""
"AbstractStaxHandler.java:276"$0$"}"
"ResourceEditor.java:1"$0$"/*"
"ResourceEditor.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"ResourceEditor.java:3"$0$" *"
"ResourceEditor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceEditor.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceEditor.java:6"$0$" * You may obtain a copy of the License at"
"ResourceEditor.java:7"$0$" *"
"ResourceEditor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceEditor.java:9"$0$" *"
"ResourceEditor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceEditor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceEditor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceEditor.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceEditor.java:14"$0$" * limitations under the License."
"ResourceEditor.java:15"$0$" */"
"ResourceEditor.java:16"$0$""
"ResourceEditor.java:17"$0$"package org.springframework.core.io;"
"ResourceEditor.java:18"$0$""
"ResourceEditor.java:19"$0$"import java.beans.PropertyEditorSupport;"
"ResourceEditor.java:20"$0$"import java.io.IOException;"
"ResourceEditor.java:21"$0$""
"ResourceEditor.java:22"$0$"import org.springframework.core.env.PropertyResolver;"
"ResourceEditor.java:23"$0$"import org.springframework.core.env.StandardEnvironment;"
"ResourceEditor.java:24"$0$"import org.springframework.lang.Nullable;"
"ResourceEditor.java:25"$0$"import org.springframework.util.Assert;"
"ResourceEditor.java:26"$0$"import org.springframework.util.StringUtils;"
"ResourceEditor.java:27"$0$""
"ResourceEditor.java:28"$0$"/**"
"ResourceEditor.java:29"$1$" * {@link java.beans.PropertyEditor Editor} for {@link Resource}"
"ResourceEditor.java:30"$1$" * descriptors, to automatically convert {@code String} locations"
"ResourceEditor.java:31"$1$" * e.g. {@code file:C:/myfile.txt} or {@code classpath:myfile.txt} to"
"ResourceEditor.java:32"$1$" * {@code Resource} properties instead of using a {@code String} location property."
"ResourceEditor.java:33"$0$" *"
"ResourceEditor.java:34"$1$" * <p>The path may contain {@code ${...}} placeholders, to be"
"ResourceEditor.java:35"$1$" * resolved as {@link org.springframework.core.env.Environment} properties:"
"ResourceEditor.java:36"$1$" * e.g. {@code ${user.dir}}. Unresolvable placeholders are ignored by default."
"ResourceEditor.java:37"$0$" *"
"ResourceEditor.java:38"$1$" * <p>Delegates to a {@link ResourceLoader} to do the heavy lifting,"
"ResourceEditor.java:39"$1$" * by default using a {@link DefaultResourceLoader}."
"ResourceEditor.java:40"$0$" *"
"ResourceEditor.java:41"$0$" * @author Juergen Hoeller"
"ResourceEditor.java:42"$0$" * @author Dave Syer"
"ResourceEditor.java:43"$0$" * @author Chris Beams"
"ResourceEditor.java:44"$0$" * @since 28.12.2003"
"ResourceEditor.java:45"$0$" * @see Resource"
"ResourceEditor.java:46"$0$" * @see ResourceLoader"
"ResourceEditor.java:47"$0$" * @see DefaultResourceLoader"
"ResourceEditor.java:48"$0$" * @see PropertyResolver#resolvePlaceholders"
"ResourceEditor.java:49"$0$" */"
"ResourceEditor.java:50"$1$"public class ResourceEditor extends PropertyEditorSupport {"
"ResourceEditor.java:51"$1$""
"ResourceEditor.java:52"$1$"	private final ResourceLoader resourceLoader;"
"ResourceEditor.java:53"$1$""
"ResourceEditor.java:54"$1$"	@Nullable"
"ResourceEditor.java:55"$1$"	private PropertyResolver propertyResolver;"
"ResourceEditor.java:56"$1$""
"ResourceEditor.java:57"$1$"	private final boolean ignoreUnresolvablePlaceholders;"
"ResourceEditor.java:58"$1$""
"ResourceEditor.java:59"$1$""
"ResourceEditor.java:60"$1$"	/**"
"ResourceEditor.java:61"$1$"	 * Create a new instance of the {@link ResourceEditor} class"
"ResourceEditor.java:62"$1$"	 * using a {@link DefaultResourceLoader} and {@link StandardEnvironment}."
"ResourceEditor.java:63"$1$"	 */"
"ResourceEditor.java:64"$1$"	public ResourceEditor() {"
"ResourceEditor.java:65"$1$"		this(new DefaultResourceLoader(), null);"
"ResourceEditor.java:66"$1$"	}"
"ResourceEditor.java:67"$0$""
"ResourceEditor.java:68"$0$"	/**"
"ResourceEditor.java:69"$1$"	 * Create a new instance of the {@link ResourceEditor} class"
"ResourceEditor.java:70"$1$"	 * using the given {@link ResourceLoader} and {@link PropertyResolver}."
"ResourceEditor.java:71"$1$"	 * @param resourceLoader the {@code ResourceLoader} to use"
"ResourceEditor.java:72"$1$"	 * @param propertyResolver the {@code PropertyResolver} to use"
"ResourceEditor.java:73"$0$"	 */"
"ResourceEditor.java:74"$1$"	public ResourceEditor(ResourceLoader resourceLoader, @Nullable PropertyResolver propertyResolver) {"
"ResourceEditor.java:75"$1$"		this(resourceLoader, propertyResolver, true);"
"ResourceEditor.java:76"$1$"	}"
"ResourceEditor.java:77"$0$""
"ResourceEditor.java:78"$0$"	/**"
"ResourceEditor.java:79"$1$"	 * Create a new instance of the {@link ResourceEditor} class"
"ResourceEditor.java:80"$1$"	 * using the given {@link ResourceLoader}."
"ResourceEditor.java:81"$1$"	 * @param resourceLoader the {@code ResourceLoader} to use"
"ResourceEditor.java:82"$1$"	 * @param propertyResolver the {@code PropertyResolver} to use"
"ResourceEditor.java:83"$0$"	 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholders"
"ResourceEditor.java:84"$1$"	 * if no corresponding property could be found in the given {@code propertyResolver}"
"ResourceEditor.java:85"$0$"	 */"
"ResourceEditor.java:86"$0$"	public ResourceEditor(ResourceLoader resourceLoader, @Nullable PropertyResolver propertyResolver,"
"ResourceEditor.java:87"$1$"			boolean ignoreUnresolvablePlaceholders) {"
"ResourceEditor.java:88"$1$""
"ResourceEditor.java:89"$1$"		Assert.notNull(resourceLoader, ""ResourceLoader must not be null"");"
"ResourceEditor.java:90"$1$"		this.resourceLoader = resourceLoader;"
"ResourceEditor.java:91"$1$"		this.propertyResolver = propertyResolver;"
"ResourceEditor.java:92"$1$"		this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;"
"ResourceEditor.java:93"$1$"	}"
"ResourceEditor.java:94"$0$""
"ResourceEditor.java:95"$0$""
"ResourceEditor.java:96"$0$"	@Override"
"ResourceEditor.java:97"$1$"	public void setAsText(String text) {"
"ResourceEditor.java:98"$1$"		if (StringUtils.hasText(text)) {"
"ResourceEditor.java:99"$1$"			String locationToUse = resolvePath(text).trim();"
"ResourceEditor.java:100"$1$"			setValue(this.resourceLoader.getResource(locationToUse));"
"ResourceEditor.java:101"$1$"		}"
"ResourceEditor.java:102"$1$"		else {"
"ResourceEditor.java:103"$1$"			setValue(null);"
"ResourceEditor.java:104"$1$"		}"
"ResourceEditor.java:105"$0$"	}"
"ResourceEditor.java:106"$0$""
"ResourceEditor.java:107"$0$"	/**"
"ResourceEditor.java:108"$0$"	 * Resolve the given path, replacing placeholders with corresponding"
"ResourceEditor.java:109"$1$"	 * property values from the {@code environment} if necessary."
"ResourceEditor.java:110"$0$"	 * @param path the original file path"
"ResourceEditor.java:111"$0$"	 * @return the resolved file path"
"ResourceEditor.java:112"$0$"	 * @see PropertyResolver#resolvePlaceholders"
"ResourceEditor.java:113"$0$"	 * @see PropertyResolver#resolveRequiredPlaceholders"
"ResourceEditor.java:114"$0$"	 */"
"ResourceEditor.java:115"$1$"	protected String resolvePath(String path) {"
"ResourceEditor.java:116"$1$"		if (this.propertyResolver == null) {"
"ResourceEditor.java:117"$1$"			this.propertyResolver = new StandardEnvironment();"
"ResourceEditor.java:118"$1$"		}"
"ResourceEditor.java:119"$0$"		return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) :"
"ResourceEditor.java:120"$0$"				this.propertyResolver.resolveRequiredPlaceholders(path));"
"ResourceEditor.java:121"$0$"	}"
"ResourceEditor.java:122"$0$""
"ResourceEditor.java:123"$0$""
"ResourceEditor.java:124"$0$"	@Override"
"ResourceEditor.java:125"$0$"	@Nullable"
"ResourceEditor.java:126"$1$"	public String getAsText() {"
"ResourceEditor.java:127"$1$"		Resource value = (Resource) getValue();"
"ResourceEditor.java:128"$1$"		try {"
"ResourceEditor.java:129"$0$"			// Try to determine URL for resource."
"ResourceEditor.java:130"$1$"			return (value != null ? value.getURL().toExternalForm() : """");"
"ResourceEditor.java:131"$1$"		}"
"ResourceEditor.java:132"$1$"		catch (IOException ex) {"
"ResourceEditor.java:133"$0$"			// Couldn't determine resource URL - return null to indicate"
"ResourceEditor.java:134"$0$"			// that there is no appropriate text representation."
"ResourceEditor.java:135"$1$"			return null;"
"ResourceEditor.java:136"$1$"		}"
"ResourceEditor.java:137"$0$"	}"
"ResourceEditor.java:138"$0$""
"ResourceEditor.java:139"$0$"}"
"ResourceEncoder.java:1"$0$"/*"
"ResourceEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ResourceEncoder.java:3"$0$" *"
"ResourceEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceEncoder.java:6"$0$" * You may obtain a copy of the License at"
"ResourceEncoder.java:7"$0$" *"
"ResourceEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceEncoder.java:9"$0$" *"
"ResourceEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceEncoder.java:14"$0$" * limitations under the License."
"ResourceEncoder.java:15"$0$" */"
"ResourceEncoder.java:16"$0$""
"ResourceEncoder.java:17"$0$"package org.springframework.core.codec;"
"ResourceEncoder.java:18"$0$""
"ResourceEncoder.java:19"$0$"import java.util.Map;"
"ResourceEncoder.java:20"$0$""
"ResourceEncoder.java:21"$0$"import reactor.core.publisher.Flux;"
"ResourceEncoder.java:22"$0$""
"ResourceEncoder.java:23"$0$"import org.springframework.core.ResolvableType;"
"ResourceEncoder.java:24"$0$"import org.springframework.core.io.Resource;"
"ResourceEncoder.java:25"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ResourceEncoder.java:26"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"ResourceEncoder.java:27"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"ResourceEncoder.java:28"$0$"import org.springframework.lang.Nullable;"
"ResourceEncoder.java:29"$0$"import org.springframework.util.Assert;"
"ResourceEncoder.java:30"$0$"import org.springframework.util.MimeType;"
"ResourceEncoder.java:31"$0$"import org.springframework.util.MimeTypeUtils;"
"ResourceEncoder.java:32"$0$"import org.springframework.util.StreamUtils;"
"ResourceEncoder.java:33"$0$""
"ResourceEncoder.java:34"$0$"/**"
"ResourceEncoder.java:35"$1$" * Encoder for {@link Resource Resources}."
"ResourceEncoder.java:36"$0$" *"
"ResourceEncoder.java:37"$0$" * @author Arjen Poutsma"
"ResourceEncoder.java:38"$0$" * @since 5.0"
"ResourceEncoder.java:39"$0$" */"
"ResourceEncoder.java:40"$1$"public class ResourceEncoder extends AbstractSingleValueEncoder<Resource> {"
"ResourceEncoder.java:41"$1$""
"ResourceEncoder.java:42"$1$"	/**"
"ResourceEncoder.java:43"$1$"	 * The default buffer size used by the encoder."
"ResourceEncoder.java:44"$1$"	 */"
"ResourceEncoder.java:45"$1$"	public static final int DEFAULT_BUFFER_SIZE = StreamUtils.BUFFER_SIZE;"
"ResourceEncoder.java:46"$1$""
"ResourceEncoder.java:47"$1$"	private final int bufferSize;"
"ResourceEncoder.java:48"$1$""
"ResourceEncoder.java:49"$1$""
"ResourceEncoder.java:50"$1$"	public ResourceEncoder() {"
"ResourceEncoder.java:51"$1$"		this(DEFAULT_BUFFER_SIZE);"
"ResourceEncoder.java:52"$1$"	}"
"ResourceEncoder.java:53"$0$""
"ResourceEncoder.java:54"$1$"	public ResourceEncoder(int bufferSize) {"
"ResourceEncoder.java:55"$1$"		super(MimeTypeUtils.APPLICATION_OCTET_STREAM, MimeTypeUtils.ALL);"
"ResourceEncoder.java:56"$1$"		Assert.isTrue(bufferSize > 0, ""'bufferSize' must be larger than 0"");"
"ResourceEncoder.java:57"$1$"		this.bufferSize = bufferSize;"
"ResourceEncoder.java:58"$1$"	}"
"ResourceEncoder.java:59"$0$""
"ResourceEncoder.java:60"$0$""
"ResourceEncoder.java:61"$0$"	@Override"
"ResourceEncoder.java:62"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ResourceEncoder.java:63"$1$"		Class<?> clazz = elementType.toClass();"
"ResourceEncoder.java:64"$1$"		return (super.canEncode(elementType, mimeType) && Resource.class.isAssignableFrom(clazz));"
"ResourceEncoder.java:65"$1$"	}"
"ResourceEncoder.java:66"$0$""
"ResourceEncoder.java:67"$0$"	@Override"
"ResourceEncoder.java:68"$0$"	protected Flux<DataBuffer> encode(Resource resource, DataBufferFactory bufferFactory,"
"ResourceEncoder.java:69"$1$"			ResolvableType type, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ResourceEncoder.java:70"$1$""
"ResourceEncoder.java:71"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"ResourceEncoder.java:72"$1$"			String logPrefix = Hints.getLogPrefix(hints);"
"ResourceEncoder.java:73"$1$"			logger.debug(logPrefix + ""Writing ["" + resource + ""]"");"
"ResourceEncoder.java:74"$1$"		}"
"ResourceEncoder.java:75"$0$"		return DataBufferUtils.read(resource, bufferFactory, this.bufferSize);"
"ResourceEncoder.java:76"$0$"	}"
"ResourceEncoder.java:77"$0$""
"ResourceEncoder.java:78"$0$"}"
"ConvertingComparator.java:1"$0$"/*"
"ConvertingComparator.java:2"$0$" * Copyright 2002-2017 the original author or authors."
"ConvertingComparator.java:3"$0$" *"
"ConvertingComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ConvertingComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"ConvertingComparator.java:6"$0$" * You may obtain a copy of the License at"
"ConvertingComparator.java:7"$0$" *"
"ConvertingComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ConvertingComparator.java:9"$0$" *"
"ConvertingComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ConvertingComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ConvertingComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ConvertingComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"ConvertingComparator.java:14"$0$" * limitations under the License."
"ConvertingComparator.java:15"$0$" */"
"ConvertingComparator.java:16"$0$""
"ConvertingComparator.java:17"$0$"package org.springframework.core.convert.converter;"
"ConvertingComparator.java:18"$0$""
"ConvertingComparator.java:19"$0$"import java.util.Comparator;"
"ConvertingComparator.java:20"$0$"import java.util.Map;"
"ConvertingComparator.java:21"$0$""
"ConvertingComparator.java:22"$0$"import org.springframework.core.convert.ConversionService;"
"ConvertingComparator.java:23"$0$"import org.springframework.lang.Nullable;"
"ConvertingComparator.java:24"$0$"import org.springframework.util.Assert;"
"ConvertingComparator.java:25"$0$"import org.springframework.util.comparator.Comparators;"
"ConvertingComparator.java:26"$0$""
"ConvertingComparator.java:27"$0$"/**"
"ConvertingComparator.java:28"$1$" * A {@link Comparator} that converts values before they are compared."
"ConvertingComparator.java:29"$1$" * The specified {@link Converter} will be used to convert each value"
"ConvertingComparator.java:30"$1$" * before it passed to the underlying {@code Comparator}."
"ConvertingComparator.java:31"$0$" *"
"ConvertingComparator.java:32"$0$" * @author Phillip Webb"
"ConvertingComparator.java:33"$0$" * @since 3.2"
"ConvertingComparator.java:34"$0$" * @param <S> the source type"
"ConvertingComparator.java:35"$0$" * @param <T> the target type"
"ConvertingComparator.java:36"$0$" */"
"ConvertingComparator.java:37"$1$"public class ConvertingComparator<S, T> implements Comparator<S> {"
"ConvertingComparator.java:38"$1$""
"ConvertingComparator.java:39"$1$"	private final Comparator<T> comparator;"
"ConvertingComparator.java:40"$1$""
"ConvertingComparator.java:41"$1$"	private final Converter<S, T> converter;"
"ConvertingComparator.java:42"$1$""
"ConvertingComparator.java:43"$1$""
"ConvertingComparator.java:44"$1$"	/**"
"ConvertingComparator.java:45"$1$"	 * Create a new {@link ConvertingComparator} instance."
"ConvertingComparator.java:46"$1$"	 * @param converter the converter"
"ConvertingComparator.java:47"$1$"	 */"
"ConvertingComparator.java:48"$1$"	public ConvertingComparator(Converter<S, T> converter) {"
"ConvertingComparator.java:49"$1$"		this(Comparators.comparable(), converter);"
"ConvertingComparator.java:50"$1$"	}"
"ConvertingComparator.java:51"$0$""
"ConvertingComparator.java:52"$0$"	/**"
"ConvertingComparator.java:53"$1$"	 * Create a new {@link ConvertingComparator} instance."
"ConvertingComparator.java:54"$0$"	 * @param comparator the underlying comparator used to compare the converted values"
"ConvertingComparator.java:55"$0$"	 * @param converter the converter"
"ConvertingComparator.java:56"$0$"	 */"
"ConvertingComparator.java:57"$1$"	public ConvertingComparator(Comparator<T> comparator, Converter<S, T> converter) {"
"ConvertingComparator.java:58"$1$"		Assert.notNull(comparator, ""Comparator must not be null"");"
"ConvertingComparator.java:59"$1$"		Assert.notNull(converter, ""Converter must not be null"");"
"ConvertingComparator.java:60"$1$"		this.comparator = comparator;"
"ConvertingComparator.java:61"$1$"		this.converter = converter;"
"ConvertingComparator.java:62"$1$"	}"
"ConvertingComparator.java:63"$0$""
"ConvertingComparator.java:64"$0$"	/**"
"ConvertingComparator.java:65"$1$"	 * Create a new {@code ConvertingComparator} instance."
"ConvertingComparator.java:66"$0$"	 * @param comparator the underlying comparator"
"ConvertingComparator.java:67"$0$"	 * @param conversionService the conversion service"
"ConvertingComparator.java:68"$0$"	 * @param targetType the target type"
"ConvertingComparator.java:69"$0$"	 */"
"ConvertingComparator.java:70"$0$"	public ConvertingComparator("
"ConvertingComparator.java:71"$1$"			Comparator<T> comparator, ConversionService conversionService, Class<? extends T> targetType) {"
"ConvertingComparator.java:72"$1$""
"ConvertingComparator.java:73"$1$"		this(comparator, new ConversionServiceConverter<>(conversionService, targetType));"
"ConvertingComparator.java:74"$1$"	}"
"ConvertingComparator.java:75"$0$""
"ConvertingComparator.java:76"$0$""
"ConvertingComparator.java:77"$0$"	@Override"
"ConvertingComparator.java:78"$1$"	public int compare(S o1, S o2) {"
"ConvertingComparator.java:79"$1$"		T c1 = this.converter.convert(o1);"
"ConvertingComparator.java:80"$1$"		T c2 = this.converter.convert(o2);"
"ConvertingComparator.java:81"$1$"		return this.comparator.compare(c1, c2);"
"ConvertingComparator.java:82"$1$"	}"
"ConvertingComparator.java:83"$0$""
"ConvertingComparator.java:84"$0$"	/**"
"ConvertingComparator.java:85"$1$"	 * Create a new {@link ConvertingComparator} that compares {@link java.util.Map.Entry"
"ConvertingComparator.java:86"$1$"	 * map * entries} based on their {@link java.util.Map.Entry#getKey() keys}."
"ConvertingComparator.java:87"$0$"	 * @param comparator the underlying comparator used to compare keys"
"ConvertingComparator.java:88"$1$"	 * @return a new {@link ConvertingComparator} instance"
"ConvertingComparator.java:89"$0$"	 */"
"ConvertingComparator.java:90"$1$"	public static <K, V> ConvertingComparator<Map.Entry<K, V>, K> mapEntryKeys(Comparator<K> comparator) {"
"ConvertingComparator.java:91"$1$"		return new ConvertingComparator<>(comparator, Map.Entry::getKey);"
"ConvertingComparator.java:92"$1$"	}"
"ConvertingComparator.java:93"$0$""
"ConvertingComparator.java:94"$0$"	/**"
"ConvertingComparator.java:95"$1$"	 * Create a new {@link ConvertingComparator} that compares {@link java.util.Map.Entry"
"ConvertingComparator.java:96"$1$"	 * map entries} based on their {@link java.util.Map.Entry#getValue() values}."
"ConvertingComparator.java:97"$0$"	 * @param comparator the underlying comparator used to compare values"
"ConvertingComparator.java:98"$1$"	 * @return a new {@link ConvertingComparator} instance"
"ConvertingComparator.java:99"$0$"	 */"
"ConvertingComparator.java:100"$1$"	public static <K, V> ConvertingComparator<Map.Entry<K, V>, V> mapEntryValues(Comparator<V> comparator) {"
"ConvertingComparator.java:101"$1$"		return new ConvertingComparator<>(comparator, Map.Entry::getValue);"
"ConvertingComparator.java:102"$1$"	}"
"ConvertingComparator.java:103"$0$""
"ConvertingComparator.java:104"$0$""
"ConvertingComparator.java:105"$0$"	/**"
"ConvertingComparator.java:106"$1$"	 * Adapts a {@link ConversionService} and <tt>targetType</tt> to a {@link Converter}."
"ConvertingComparator.java:107"$0$"	 */"
"ConvertingComparator.java:108"$1$"	private static class ConversionServiceConverter<S, T> implements Converter<S, T> {"
"ConvertingComparator.java:109"$1$""
"ConvertingComparator.java:110"$1$"		private final ConversionService conversionService;"
"ConvertingComparator.java:111"$1$""
"ConvertingComparator.java:112"$1$"		private final Class<? extends T> targetType;"
"ConvertingComparator.java:113"$1$""
"ConvertingComparator.java:114"$1$"		public ConversionServiceConverter(ConversionService conversionService,"
"ConvertingComparator.java:115"$1$"			Class<? extends T> targetType) {"
"ConvertingComparator.java:116"$1$"			Assert.notNull(conversionService, ""ConversionService must not be null"");"
"ConvertingComparator.java:117"$1$"			Assert.notNull(targetType, ""TargetType must not be null"");"
"ConvertingComparator.java:118"$1$"			this.conversionService = conversionService;"
"ConvertingComparator.java:119"$1$"			this.targetType = targetType;"
"ConvertingComparator.java:120"$1$"		}"
"ConvertingComparator.java:121"$0$""
"ConvertingComparator.java:122"$0$"		@Override"
"ConvertingComparator.java:123"$0$"		@Nullable"
"ConvertingComparator.java:124"$1$"		public T convert(S source) {"
"ConvertingComparator.java:125"$1$"			return this.conversionService.convert(source, this.targetType);"
"ConvertingComparator.java:126"$1$"		}"
"ConvertingComparator.java:127"$0$"	}"
"ConvertingComparator.java:128"$0$""
"ConvertingComparator.java:129"$0$"}"
"StaxUtils.java:1"$0$"/*"
"StaxUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"StaxUtils.java:3"$0$" *"
"StaxUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxUtils.java:6"$0$" * You may obtain a copy of the License at"
"StaxUtils.java:7"$0$" *"
"StaxUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxUtils.java:9"$0$" *"
"StaxUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxUtils.java:14"$0$" * limitations under the License."
"StaxUtils.java:15"$0$" */"
"StaxUtils.java:16"$0$""
"StaxUtils.java:17"$0$"package org.springframework.util.xml;"
"StaxUtils.java:18"$0$""
"StaxUtils.java:19"$0$"import java.util.List;"
"StaxUtils.java:20"$0$"import java.util.function.Supplier;"
"StaxUtils.java:21"$0$""
"StaxUtils.java:22"$0$"import javax.xml.stream.XMLEventFactory;"
"StaxUtils.java:23"$0$"import javax.xml.stream.XMLEventReader;"
"StaxUtils.java:24"$0$"import javax.xml.stream.XMLEventWriter;"
"StaxUtils.java:25"$0$"import javax.xml.stream.XMLInputFactory;"
"StaxUtils.java:26"$0$"import javax.xml.stream.XMLResolver;"
"StaxUtils.java:27"$0$"import javax.xml.stream.XMLStreamException;"
"StaxUtils.java:28"$0$"import javax.xml.stream.XMLStreamReader;"
"StaxUtils.java:29"$0$"import javax.xml.stream.XMLStreamWriter;"
"StaxUtils.java:30"$0$"import javax.xml.stream.events.XMLEvent;"
"StaxUtils.java:31"$0$"import javax.xml.transform.Result;"
"StaxUtils.java:32"$0$"import javax.xml.transform.Source;"
"StaxUtils.java:33"$0$"import javax.xml.transform.stax.StAXResult;"
"StaxUtils.java:34"$0$"import javax.xml.transform.stax.StAXSource;"
"StaxUtils.java:35"$0$""
"StaxUtils.java:36"$0$"import org.xml.sax.ContentHandler;"
"StaxUtils.java:37"$0$"import org.xml.sax.XMLReader;"
"StaxUtils.java:38"$0$""
"StaxUtils.java:39"$0$"import org.springframework.lang.Nullable;"
"StaxUtils.java:40"$0$"import org.springframework.util.StreamUtils;"
"StaxUtils.java:41"$0$""
"StaxUtils.java:42"$0$"/**"
"StaxUtils.java:43"$0$" * Convenience methods for working with the StAX API. Partly historic due to JAXP 1.3"
"StaxUtils.java:44"$0$" * compatibility; as of Spring 4.0, relying on JAXP 1.4 as included in JDK 1.6 and higher."
"StaxUtils.java:45"$0$" *"
"StaxUtils.java:46"$1$" * <p>In particular, methods for using StAX ({@code javax.xml.stream}) in combination with"
"StaxUtils.java:47"$1$" * the TrAX API ({@code javax.xml.transform}), and converting StAX readers/writers into SAX"
"StaxUtils.java:48"$0$" * readers/handlers and vice-versa."
"StaxUtils.java:49"$0$" *"
"StaxUtils.java:50"$0$" * @author Arjen Poutsma"
"StaxUtils.java:51"$0$" * @author Juergen Hoeller"
"StaxUtils.java:52"$0$" * @since 3.0"
"StaxUtils.java:53"$0$" */"
"StaxUtils.java:54"$1$"public abstract class StaxUtils {"
"StaxUtils.java:55"$1$""
"StaxUtils.java:56"$1$"	private static final XMLResolver NO_OP_XML_RESOLVER ="
"StaxUtils.java:57"$1$"			(publicID, systemID, base, ns) -> StreamUtils.emptyInput();"
"StaxUtils.java:58"$1$""
"StaxUtils.java:59"$1$""
"StaxUtils.java:60"$1$"	/**"
"StaxUtils.java:61"$1$"	 * Create an {@link XMLInputFactory} with Spring's defensive setup,"
"StaxUtils.java:62"$1$"	 * i.e. no support for the resolution of DTDs and external entities."
"StaxUtils.java:63"$1$"	 * @return a new defensively initialized input factory instance to use"
"StaxUtils.java:64"$1$"	 * @since 5.0"
"StaxUtils.java:65"$1$"	 */"
"StaxUtils.java:66"$1$"	public static XMLInputFactory createDefensiveInputFactory() {"
"StaxUtils.java:67"$1$"		return createDefensiveInputFactory(XMLInputFactory::newInstance);"
"StaxUtils.java:68"$1$"	}"
"StaxUtils.java:69"$0$""
"StaxUtils.java:70"$0$"	/**"
"StaxUtils.java:71"$1$"	 * Variant of {@link #createDefensiveInputFactory()} with a custom instance."
"StaxUtils.java:72"$0$"	 * @param instanceSupplier supplier for the input factory instance"
"StaxUtils.java:73"$0$"	 * @return a new defensively initialized input factory instance to use"
"StaxUtils.java:74"$0$"	 * @since 5.0.12"
"StaxUtils.java:75"$0$"	 */"
"StaxUtils.java:76"$1$"	public static <T extends XMLInputFactory> T createDefensiveInputFactory(Supplier<T> instanceSupplier) {"
"StaxUtils.java:77"$1$"		T inputFactory = instanceSupplier.get();"
"StaxUtils.java:78"$1$"		inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);"
"StaxUtils.java:79"$1$"		inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);"
"StaxUtils.java:80"$1$"		inputFactory.setXMLResolver(NO_OP_XML_RESOLVER);"
"StaxUtils.java:81"$1$"		return inputFactory;"
"StaxUtils.java:82"$1$"	}"
"StaxUtils.java:83"$0$""
"StaxUtils.java:84"$0$"	/**"
"StaxUtils.java:85"$1$"	 * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLStreamReader}."
"StaxUtils.java:86"$0$"	 * @param streamReader the StAX stream reader"
"StaxUtils.java:87"$1$"	 * @return a source wrapping the {@code streamReader}"
"StaxUtils.java:88"$0$"	 */"
"StaxUtils.java:89"$1$"	public static Source createStaxSource(XMLStreamReader streamReader) {"
"StaxUtils.java:90"$1$"		return new StAXSource(streamReader);"
"StaxUtils.java:91"$1$"	}"
"StaxUtils.java:92"$0$""
"StaxUtils.java:93"$0$"	/**"
"StaxUtils.java:94"$1$"	 * Create a JAXP 1.4 {@link StAXSource} for the given {@link XMLEventReader}."
"StaxUtils.java:95"$0$"	 * @param eventReader the StAX event reader"
"StaxUtils.java:96"$1$"	 * @return a source wrapping the {@code eventReader}"
"StaxUtils.java:97"$0$"	 */"
"StaxUtils.java:98"$1$"	public static Source createStaxSource(XMLEventReader eventReader) throws XMLStreamException {"
"StaxUtils.java:99"$1$"		return new StAXSource(eventReader);"
"StaxUtils.java:100"$1$"	}"
"StaxUtils.java:101"$0$""
"StaxUtils.java:102"$0$"	/**"
"StaxUtils.java:103"$1$"	 * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLStreamReader}."
"StaxUtils.java:104"$0$"	 * @param streamReader the StAX stream reader"
"StaxUtils.java:105"$1$"	 * @return a source wrapping the {@code streamReader}"
"StaxUtils.java:106"$0$"	 */"
"StaxUtils.java:107"$1$"	public static Source createCustomStaxSource(XMLStreamReader streamReader) {"
"StaxUtils.java:108"$1$"		return new StaxSource(streamReader);"
"StaxUtils.java:109"$1$"	}"
"StaxUtils.java:110"$0$""
"StaxUtils.java:111"$0$"	/**"
"StaxUtils.java:112"$1$"	 * Create a custom, non-JAXP 1.4 StAX {@link Source} for the given {@link XMLEventReader}."
"StaxUtils.java:113"$0$"	 * @param eventReader the StAX event reader"
"StaxUtils.java:114"$1$"	 * @return a source wrapping the {@code eventReader}"
"StaxUtils.java:115"$0$"	 */"
"StaxUtils.java:116"$1$"	public static Source createCustomStaxSource(XMLEventReader eventReader) {"
"StaxUtils.java:117"$1$"		return new StaxSource(eventReader);"
"StaxUtils.java:118"$1$"	}"
"StaxUtils.java:119"$0$""
"StaxUtils.java:120"$0$"	/**"
"StaxUtils.java:121"$1$"	 * Indicate whether the given {@link Source} is a JAXP 1.4 StAX Source or"
"StaxUtils.java:122"$0$"	 * custom StAX Source."
"StaxUtils.java:123"$1$"	 * @return {@code true} if {@code source} is a JAXP 1.4 {@link StAXSource} or"
"StaxUtils.java:124"$1$"	 * custom StAX Source; {@code false} otherwise"
"StaxUtils.java:125"$0$"	 */"
"StaxUtils.java:126"$1$"	public static boolean isStaxSource(Source source) {"
"StaxUtils.java:127"$1$"		return (source instanceof StAXSource || source instanceof StaxSource);"
"StaxUtils.java:128"$1$"	}"
"StaxUtils.java:129"$0$""
"StaxUtils.java:130"$0$"	/**"
"StaxUtils.java:131"$1$"	 * Return the {@link XMLStreamReader} for the given StAX Source."
"StaxUtils.java:132"$1$"	 * @param source a JAXP 1.4 {@link StAXSource}"
"StaxUtils.java:133"$1$"	 * @return the {@link XMLStreamReader}"
"StaxUtils.java:134"$1$"	 * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}"
"StaxUtils.java:135"$0$"	 * or custom StAX Source"
"StaxUtils.java:136"$0$"	 */"
"StaxUtils.java:137"$0$"	@Nullable"
"StaxUtils.java:138"$1$"	public static XMLStreamReader getXMLStreamReader(Source source) {"
"StaxUtils.java:139"$1$"		if (source instanceof StAXSource) {"
"StaxUtils.java:140"$1$"			return ((StAXSource) source).getXMLStreamReader();"
"StaxUtils.java:141"$1$"		}"
"StaxUtils.java:142"$1$"		else if (source instanceof StaxSource) {"
"StaxUtils.java:143"$1$"			return ((StaxSource) source).getXMLStreamReader();"
"StaxUtils.java:144"$1$"		}"
"StaxUtils.java:145"$1$"		else {"
"StaxUtils.java:146"$1$"			throw new IllegalArgumentException(""Source '"" + source + ""' is neither StaxSource nor StAXSource"");"
"StaxUtils.java:147"$1$"		}"
"StaxUtils.java:148"$0$"	}"
"StaxUtils.java:149"$0$""
"StaxUtils.java:150"$0$"	/**"
"StaxUtils.java:151"$1$"	 * Return the {@link XMLEventReader} for the given StAX Source."
"StaxUtils.java:152"$1$"	 * @param source a JAXP 1.4 {@link StAXSource}"
"StaxUtils.java:153"$1$"	 * @return the {@link XMLEventReader}"
"StaxUtils.java:154"$1$"	 * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXSource}"
"StaxUtils.java:155"$0$"	 * or custom StAX Source"
"StaxUtils.java:156"$0$"	 */"
"StaxUtils.java:157"$0$"	@Nullable"
"StaxUtils.java:158"$1$"	public static XMLEventReader getXMLEventReader(Source source) {"
"StaxUtils.java:159"$1$"		if (source instanceof StAXSource) {"
"StaxUtils.java:160"$1$"			return ((StAXSource) source).getXMLEventReader();"
"StaxUtils.java:161"$1$"		}"
"StaxUtils.java:162"$1$"		else if (source instanceof StaxSource) {"
"StaxUtils.java:163"$1$"			return ((StaxSource) source).getXMLEventReader();"
"StaxUtils.java:164"$1$"		}"
"StaxUtils.java:165"$1$"		else {"
"StaxUtils.java:166"$1$"			throw new IllegalArgumentException(""Source '"" + source + ""' is neither StaxSource nor StAXSource"");"
"StaxUtils.java:167"$1$"		}"
"StaxUtils.java:168"$0$"	}"
"StaxUtils.java:169"$0$""
"StaxUtils.java:170"$0$"	/**"
"StaxUtils.java:171"$1$"	 * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLStreamWriter}."
"StaxUtils.java:172"$0$"	 * @param streamWriter the StAX stream writer"
"StaxUtils.java:173"$1$"	 * @return a result wrapping the {@code streamWriter}"
"StaxUtils.java:174"$0$"	 */"
"StaxUtils.java:175"$1$"	public static Result createStaxResult(XMLStreamWriter streamWriter) {"
"StaxUtils.java:176"$1$"		return new StAXResult(streamWriter);"
"StaxUtils.java:177"$1$"	}"
"StaxUtils.java:178"$0$""
"StaxUtils.java:179"$0$"	/**"
"StaxUtils.java:180"$1$"	 * Create a JAXP 1.4 {@link StAXResult} for the given {@link XMLEventWriter}."
"StaxUtils.java:181"$0$"	 * @param eventWriter the StAX event writer"
"StaxUtils.java:182"$1$"	 * @return a result wrapping {@code streamReader}"
"StaxUtils.java:183"$0$"	 */"
"StaxUtils.java:184"$1$"	public static Result createStaxResult(XMLEventWriter eventWriter) {"
"StaxUtils.java:185"$1$"		return new StAXResult(eventWriter);"
"StaxUtils.java:186"$1$"	}"
"StaxUtils.java:187"$0$""
"StaxUtils.java:188"$0$"	/**"
"StaxUtils.java:189"$1$"	 * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLStreamWriter}."
"StaxUtils.java:190"$0$"	 * @param streamWriter the StAX stream writer"
"StaxUtils.java:191"$1$"	 * @return a source wrapping the {@code streamWriter}"
"StaxUtils.java:192"$0$"	 */"
"StaxUtils.java:193"$1$"	public static Result createCustomStaxResult(XMLStreamWriter streamWriter) {"
"StaxUtils.java:194"$1$"		return new StaxResult(streamWriter);"
"StaxUtils.java:195"$1$"	}"
"StaxUtils.java:196"$0$""
"StaxUtils.java:197"$0$"	/**"
"StaxUtils.java:198"$1$"	 * Create a custom, non-JAXP 1.4 StAX {@link Result} for the given {@link XMLEventWriter}."
"StaxUtils.java:199"$0$"	 * @param eventWriter the StAX event writer"
"StaxUtils.java:200"$1$"	 * @return a source wrapping the {@code eventWriter}"
"StaxUtils.java:201"$0$"	 */"
"StaxUtils.java:202"$1$"	public static Result createCustomStaxResult(XMLEventWriter eventWriter) {"
"StaxUtils.java:203"$1$"		return new StaxResult(eventWriter);"
"StaxUtils.java:204"$1$"	}"
"StaxUtils.java:205"$0$""
"StaxUtils.java:206"$0$"	/**"
"StaxUtils.java:207"$1$"	 * Indicate whether the given {@link Result} is a JAXP 1.4 StAX Result or"
"StaxUtils.java:208"$0$"	 * custom StAX Result."
"StaxUtils.java:209"$1$"	 * @return {@code true} if {@code result} is a JAXP 1.4 {@link StAXResult} or"
"StaxUtils.java:210"$1$"	 * custom StAX Result; {@code false} otherwise"
"StaxUtils.java:211"$0$"	 */"
"StaxUtils.java:212"$1$"	public static boolean isStaxResult(Result result) {"
"StaxUtils.java:213"$1$"		return (result instanceof StAXResult || result instanceof StaxResult);"
"StaxUtils.java:214"$1$"	}"
"StaxUtils.java:215"$0$""
"StaxUtils.java:216"$0$"	/**"
"StaxUtils.java:217"$1$"	 * Return the {@link XMLStreamWriter} for the given StAX Result."
"StaxUtils.java:218"$1$"	 * @param result a JAXP 1.4 {@link StAXResult}"
"StaxUtils.java:219"$1$"	 * @return the {@link XMLStreamReader}"
"StaxUtils.java:220"$1$"	 * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}"
"StaxUtils.java:221"$0$"	 * or custom StAX Result"
"StaxUtils.java:222"$0$"	 */"
"StaxUtils.java:223"$0$"	@Nullable"
"StaxUtils.java:224"$1$"	public static XMLStreamWriter getXMLStreamWriter(Result result) {"
"StaxUtils.java:225"$1$"		if (result instanceof StAXResult) {"
"StaxUtils.java:226"$1$"			return ((StAXResult) result).getXMLStreamWriter();"
"StaxUtils.java:227"$1$"		}"
"StaxUtils.java:228"$1$"		else if (result instanceof StaxResult) {"
"StaxUtils.java:229"$1$"			return ((StaxResult) result).getXMLStreamWriter();"
"StaxUtils.java:230"$1$"		}"
"StaxUtils.java:231"$1$"		else {"
"StaxUtils.java:232"$1$"			throw new IllegalArgumentException(""Result '"" + result + ""' is neither StaxResult nor StAXResult"");"
"StaxUtils.java:233"$1$"		}"
"StaxUtils.java:234"$0$"	}"
"StaxUtils.java:235"$0$""
"StaxUtils.java:236"$0$"	/**"
"StaxUtils.java:237"$1$"	 * Return the {@link XMLEventWriter} for the given StAX Result."
"StaxUtils.java:238"$1$"	 * @param result a JAXP 1.4 {@link StAXResult}"
"StaxUtils.java:239"$1$"	 * @return the {@link XMLStreamReader}"
"StaxUtils.java:240"$1$"	 * @throws IllegalArgumentException if {@code source} isn't a JAXP 1.4 {@link StAXResult}"
"StaxUtils.java:241"$0$"	 * or custom StAX Result"
"StaxUtils.java:242"$0$"	 */"
"StaxUtils.java:243"$0$"	@Nullable"
"StaxUtils.java:244"$1$"	public static XMLEventWriter getXMLEventWriter(Result result) {"
"StaxUtils.java:245"$1$"		if (result instanceof StAXResult) {"
"StaxUtils.java:246"$1$"			return ((StAXResult) result).getXMLEventWriter();"
"StaxUtils.java:247"$1$"		}"
"StaxUtils.java:248"$1$"		else if (result instanceof StaxResult) {"
"StaxUtils.java:249"$1$"			return ((StaxResult) result).getXMLEventWriter();"
"StaxUtils.java:250"$1$"		}"
"StaxUtils.java:251"$1$"		else {"
"StaxUtils.java:252"$1$"			throw new IllegalArgumentException(""Result '"" + result + ""' is neither StaxResult nor StAXResult"");"
"StaxUtils.java:253"$1$"		}"
"StaxUtils.java:254"$0$"	}"
"StaxUtils.java:255"$0$""
"StaxUtils.java:256"$0$"	/**"
"StaxUtils.java:257"$1$"	 * Create a {@link XMLEventReader} from the given list of {@link XMLEvent}."
"StaxUtils.java:258"$1$"	 * @param events the list of {@link XMLEvent XMLEvents}."
"StaxUtils.java:259"$1$"	 * @return an {@code XMLEventReader} that reads from the given events"
"StaxUtils.java:260"$0$"	 * @since 5.0"
"StaxUtils.java:261"$0$"	 */"
"StaxUtils.java:262"$1$"	public static XMLEventReader createXMLEventReader(List<XMLEvent> events) {"
"StaxUtils.java:263"$1$"		return new ListBasedXMLEventReader(events);"
"StaxUtils.java:264"$1$"	}"
"StaxUtils.java:265"$0$""
"StaxUtils.java:266"$0$"	/**"
"StaxUtils.java:267"$1$"	 * Create a SAX {@link ContentHandler} that writes to the given StAX {@link XMLStreamWriter}."
"StaxUtils.java:268"$0$"	 * @param streamWriter the StAX stream writer"
"StaxUtils.java:269"$1$"	 * @return a content handler writing to the {@code streamWriter}"
"StaxUtils.java:270"$0$"	 */"
"StaxUtils.java:271"$1$"	public static ContentHandler createContentHandler(XMLStreamWriter streamWriter) {"
"StaxUtils.java:272"$1$"		return new StaxStreamHandler(streamWriter);"
"StaxUtils.java:273"$1$"	}"
"StaxUtils.java:274"$0$""
"StaxUtils.java:275"$0$"	/**"
"StaxUtils.java:276"$1$"	 * Create a SAX {@link ContentHandler} that writes events to the given StAX {@link XMLEventWriter}."
"StaxUtils.java:277"$0$"	 * @param eventWriter the StAX event writer"
"StaxUtils.java:278"$1$"	 * @return a content handler writing to the {@code eventWriter}"
"StaxUtils.java:279"$0$"	 */"
"StaxUtils.java:280"$1$"	public static ContentHandler createContentHandler(XMLEventWriter eventWriter) {"
"StaxUtils.java:281"$1$"		return new StaxEventHandler(eventWriter);"
"StaxUtils.java:282"$1$"	}"
"StaxUtils.java:283"$0$""
"StaxUtils.java:284"$0$"	/**"
"StaxUtils.java:285"$1$"	 * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLStreamReader}."
"StaxUtils.java:286"$0$"	 * @param streamReader the StAX stream reader"
"StaxUtils.java:287"$1$"	 * @return a XMLReader reading from the {@code streamWriter}"
"StaxUtils.java:288"$0$"	 */"
"StaxUtils.java:289"$1$"	public static XMLReader createXMLReader(XMLStreamReader streamReader) {"
"StaxUtils.java:290"$1$"		return new StaxStreamXMLReader(streamReader);"
"StaxUtils.java:291"$1$"	}"
"StaxUtils.java:292"$0$""
"StaxUtils.java:293"$0$"	/**"
"StaxUtils.java:294"$1$"	 * Create a SAX {@link XMLReader} that reads from the given StAX {@link XMLEventReader}."
"StaxUtils.java:295"$0$"	 * @param eventReader the StAX event reader"
"StaxUtils.java:296"$1$"	 * @return a XMLReader reading from the {@code eventWriter}"
"StaxUtils.java:297"$0$"	 */"
"StaxUtils.java:298"$1$"	public static XMLReader createXMLReader(XMLEventReader eventReader) {"
"StaxUtils.java:299"$1$"		return new StaxEventXMLReader(eventReader);"
"StaxUtils.java:300"$1$"	}"
"StaxUtils.java:301"$0$""
"StaxUtils.java:302"$0$"	/**"
"StaxUtils.java:303"$1$"	 * Return a {@link XMLStreamReader} that reads from a {@link XMLEventReader}."
"StaxUtils.java:304"$1$"	 * Useful because the StAX {@code XMLInputFactory} allows one to create an"
"StaxUtils.java:305"$0$"	 * event reader from a stream reader, but not vice-versa."
"StaxUtils.java:306"$0$"	 * @return a stream reader that reads from an event reader"
"StaxUtils.java:307"$0$"	 */"
"StaxUtils.java:308"$1$"	public static XMLStreamReader createEventStreamReader(XMLEventReader eventReader) throws XMLStreamException {"
"StaxUtils.java:309"$1$"		return new XMLEventStreamReader(eventReader);"
"StaxUtils.java:310"$1$"	}"
"StaxUtils.java:311"$0$""
"StaxUtils.java:312"$0$"	/**"
"StaxUtils.java:313"$1$"	 * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}."
"StaxUtils.java:314"$0$"	 * @return a stream writer that writes to an event writer"
"StaxUtils.java:315"$0$"	 * @since 3.2"
"StaxUtils.java:316"$0$"	 */"
"StaxUtils.java:317"$1$"	public static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter) {"
"StaxUtils.java:318"$1$"		return new XMLEventStreamWriter(eventWriter, XMLEventFactory.newFactory());"
"StaxUtils.java:319"$1$"	}"
"StaxUtils.java:320"$0$""
"StaxUtils.java:321"$0$"	/**"
"StaxUtils.java:322"$1$"	 * Return a {@link XMLStreamWriter} that writes to a {@link XMLEventWriter}."
"StaxUtils.java:323"$0$"	 * @return a stream writer that writes to an event writer"
"StaxUtils.java:324"$0$"	 * @since 3.0.5"
"StaxUtils.java:325"$0$"	 */"
"StaxUtils.java:326"$1$"	public static XMLStreamWriter createEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {"
"StaxUtils.java:327"$1$"		return new XMLEventStreamWriter(eventWriter, eventFactory);"
"StaxUtils.java:328"$1$"	}"
"StaxUtils.java:329"$0$""
"StaxUtils.java:330"$0$"}"
"CharSequenceEncoder.java:1"$0$"/*"
"CharSequenceEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"CharSequenceEncoder.java:3"$0$" *"
"CharSequenceEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CharSequenceEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"CharSequenceEncoder.java:6"$0$" * You may obtain a copy of the License at"
"CharSequenceEncoder.java:7"$0$" *"
"CharSequenceEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CharSequenceEncoder.java:9"$0$" *"
"CharSequenceEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CharSequenceEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CharSequenceEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CharSequenceEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"CharSequenceEncoder.java:14"$0$" * limitations under the License."
"CharSequenceEncoder.java:15"$0$" */"
"CharSequenceEncoder.java:16"$0$""
"CharSequenceEncoder.java:17"$0$"package org.springframework.core.codec;"
"CharSequenceEncoder.java:18"$0$""
"CharSequenceEncoder.java:19"$0$"import java.nio.charset.Charset;"
"CharSequenceEncoder.java:20"$0$"import java.nio.charset.CoderMalfunctionError;"
"CharSequenceEncoder.java:21"$0$"import java.nio.charset.StandardCharsets;"
"CharSequenceEncoder.java:22"$0$"import java.util.Map;"
"CharSequenceEncoder.java:23"$0$"import java.util.concurrent.ConcurrentHashMap;"
"CharSequenceEncoder.java:24"$0$"import java.util.concurrent.ConcurrentMap;"
"CharSequenceEncoder.java:25"$0$""
"CharSequenceEncoder.java:26"$0$"import org.reactivestreams.Publisher;"
"CharSequenceEncoder.java:27"$0$"import reactor.core.publisher.Flux;"
"CharSequenceEncoder.java:28"$0$""
"CharSequenceEncoder.java:29"$0$"import org.springframework.core.ResolvableType;"
"CharSequenceEncoder.java:30"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"CharSequenceEncoder.java:31"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"CharSequenceEncoder.java:32"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"CharSequenceEncoder.java:33"$0$"import org.springframework.core.log.LogFormatUtils;"
"CharSequenceEncoder.java:34"$0$"import org.springframework.lang.Nullable;"
"CharSequenceEncoder.java:35"$0$"import org.springframework.util.MimeType;"
"CharSequenceEncoder.java:36"$0$"import org.springframework.util.MimeTypeUtils;"
"CharSequenceEncoder.java:37"$0$""
"CharSequenceEncoder.java:38"$0$"/**"
"CharSequenceEncoder.java:39"$1$" * Encode from a {@code CharSequence} stream to a bytes stream."
"CharSequenceEncoder.java:40"$0$" *"
"CharSequenceEncoder.java:41"$0$" * @author Sebastien Deleuze"
"CharSequenceEncoder.java:42"$0$" * @author Arjen Poutsma"
"CharSequenceEncoder.java:43"$0$" * @author Rossen Stoyanchev"
"CharSequenceEncoder.java:44"$0$" * @since 5.0"
"CharSequenceEncoder.java:45"$0$" * @see StringDecoder"
"CharSequenceEncoder.java:46"$0$" */"
"CharSequenceEncoder.java:47"$1$"public final class CharSequenceEncoder extends AbstractEncoder<CharSequence> {"
"CharSequenceEncoder.java:48"$1$""
"CharSequenceEncoder.java:49"$1$"	/**"
"CharSequenceEncoder.java:50"$1$"	 * The default charset used by the encoder."
"CharSequenceEncoder.java:51"$1$"	 */"
"CharSequenceEncoder.java:52"$1$"	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;"
"CharSequenceEncoder.java:53"$1$""
"CharSequenceEncoder.java:54"$1$"	private final ConcurrentMap<Charset, Float> charsetToMaxBytesPerChar ="
"CharSequenceEncoder.java:55"$1$"			new ConcurrentHashMap<>(3);"
"CharSequenceEncoder.java:56"$1$""
"CharSequenceEncoder.java:57"$1$""
"CharSequenceEncoder.java:58"$1$"	private CharSequenceEncoder(MimeType... mimeTypes) {"
"CharSequenceEncoder.java:59"$1$"		super(mimeTypes);"
"CharSequenceEncoder.java:60"$1$"	}"
"CharSequenceEncoder.java:61"$0$""
"CharSequenceEncoder.java:62"$0$""
"CharSequenceEncoder.java:63"$0$"	@Override"
"CharSequenceEncoder.java:64"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"CharSequenceEncoder.java:65"$1$"		Class<?> clazz = elementType.toClass();"
"CharSequenceEncoder.java:66"$1$"		return super.canEncode(elementType, mimeType) && CharSequence.class.isAssignableFrom(clazz);"
"CharSequenceEncoder.java:67"$1$"	}"
"CharSequenceEncoder.java:68"$0$""
"CharSequenceEncoder.java:69"$0$"	@Override"
"CharSequenceEncoder.java:70"$0$"	public Flux<DataBuffer> encode(Publisher<? extends CharSequence> inputStream,"
"CharSequenceEncoder.java:71"$0$"			DataBufferFactory bufferFactory, ResolvableType elementType,"
"CharSequenceEncoder.java:72"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"CharSequenceEncoder.java:73"$1$""
"CharSequenceEncoder.java:74"$1$"		return Flux.from(inputStream).map(charSequence ->"
"CharSequenceEncoder.java:75"$1$"				encodeValue(charSequence, bufferFactory, elementType, mimeType, hints));"
"CharSequenceEncoder.java:76"$1$"	}"
"CharSequenceEncoder.java:77"$0$""
"CharSequenceEncoder.java:78"$0$"	@Override"
"CharSequenceEncoder.java:79"$0$"	public DataBuffer encodeValue(CharSequence charSequence, DataBufferFactory bufferFactory,"
"CharSequenceEncoder.java:80"$1$"			ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"CharSequenceEncoder.java:81"$1$""
"CharSequenceEncoder.java:82"$1$"		if (!Hints.isLoggingSuppressed(hints)) {"
"CharSequenceEncoder.java:83"$1$"			LogFormatUtils.traceDebug(logger, traceOn -> {"
"CharSequenceEncoder.java:84"$1$"				String formatted = LogFormatUtils.formatValue(charSequence, !traceOn);"
"CharSequenceEncoder.java:85"$1$"				return Hints.getLogPrefix(hints) + ""Writing "" + formatted;"
"CharSequenceEncoder.java:86"$1$"			});"
"CharSequenceEncoder.java:87"$0$"		}"
"CharSequenceEncoder.java:88"$0$"		boolean release = true;"
"CharSequenceEncoder.java:89"$0$"		Charset charset = getCharset(mimeType);"
"CharSequenceEncoder.java:90"$0$"		int capacity = calculateCapacity(charSequence, charset);"
"CharSequenceEncoder.java:91"$0$"		DataBuffer dataBuffer = bufferFactory.allocateBuffer(capacity);"
"CharSequenceEncoder.java:92"$1$"		try {"
"CharSequenceEncoder.java:93"$1$"			dataBuffer.write(charSequence, charset);"
"CharSequenceEncoder.java:94"$1$"			release = false;"
"CharSequenceEncoder.java:95"$1$"		}"
"CharSequenceEncoder.java:96"$1$"		catch (CoderMalfunctionError ex) {"
"CharSequenceEncoder.java:97"$1$"			throw new EncodingException(""String encoding error: "" + ex.getMessage(), ex);"
"CharSequenceEncoder.java:98"$1$"		}"
"CharSequenceEncoder.java:99"$1$"		finally {"
"CharSequenceEncoder.java:100"$1$"			if (release) {"
"CharSequenceEncoder.java:101"$1$"				DataBufferUtils.release(dataBuffer);"
"CharSequenceEncoder.java:102"$1$"			}"
"CharSequenceEncoder.java:103"$0$"		}"
"CharSequenceEncoder.java:104"$0$"		return dataBuffer;"
"CharSequenceEncoder.java:105"$0$"	}"
"CharSequenceEncoder.java:106"$0$""
"CharSequenceEncoder.java:107"$1$"	int calculateCapacity(CharSequence sequence, Charset charset) {"
"CharSequenceEncoder.java:108"$1$"		float maxBytesPerChar = this.charsetToMaxBytesPerChar"
"CharSequenceEncoder.java:109"$1$"				.computeIfAbsent(charset, cs -> cs.newEncoder().maxBytesPerChar());"
"CharSequenceEncoder.java:110"$1$"		float maxBytesForSequence = sequence.length() * maxBytesPerChar;"
"CharSequenceEncoder.java:111"$1$"		return (int) Math.ceil(maxBytesForSequence);"
"CharSequenceEncoder.java:112"$1$"	}"
"CharSequenceEncoder.java:113"$0$""
"CharSequenceEncoder.java:114"$1$"	private Charset getCharset(@Nullable MimeType mimeType) {"
"CharSequenceEncoder.java:115"$1$"		if (mimeType != null && mimeType.getCharset() != null) {"
"CharSequenceEncoder.java:116"$1$"			return mimeType.getCharset();"
"CharSequenceEncoder.java:117"$1$"		}"
"CharSequenceEncoder.java:118"$1$"		else {"
"CharSequenceEncoder.java:119"$1$"			return DEFAULT_CHARSET;"
"CharSequenceEncoder.java:120"$1$"		}"
"CharSequenceEncoder.java:121"$0$"	}"
"CharSequenceEncoder.java:122"$0$""
"CharSequenceEncoder.java:123"$0$""
"CharSequenceEncoder.java:124"$0$"	/**"
"CharSequenceEncoder.java:125"$1$"	 * Create a {@code CharSequenceEncoder} that supports only ""text/plain""."
"CharSequenceEncoder.java:126"$0$"	 */"
"CharSequenceEncoder.java:127"$1$"	public static CharSequenceEncoder textPlainOnly() {"
"CharSequenceEncoder.java:128"$1$"		return new CharSequenceEncoder(new MimeType(""text"", ""plain"", DEFAULT_CHARSET));"
"CharSequenceEncoder.java:129"$1$"	}"
"CharSequenceEncoder.java:130"$0$""
"CharSequenceEncoder.java:131"$0$"	/**"
"CharSequenceEncoder.java:132"$1$"	 * Create a {@code CharSequenceEncoder} that supports all MIME types."
"CharSequenceEncoder.java:133"$0$"	 */"
"CharSequenceEncoder.java:134"$1$"	public static CharSequenceEncoder allMimeTypes() {"
"CharSequenceEncoder.java:135"$1$"		return new CharSequenceEncoder(new MimeType(""text"", ""plain"", DEFAULT_CHARSET), MimeTypeUtils.ALL);"
"CharSequenceEncoder.java:136"$1$"	}"
"CharSequenceEncoder.java:137"$0$""
"CharSequenceEncoder.java:138"$0$"}"
"PatternMatchUtils.java:1"$0$"/*"
"PatternMatchUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"PatternMatchUtils.java:3"$0$" *"
"PatternMatchUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PatternMatchUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"PatternMatchUtils.java:6"$0$" * You may obtain a copy of the License at"
"PatternMatchUtils.java:7"$0$" *"
"PatternMatchUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PatternMatchUtils.java:9"$0$" *"
"PatternMatchUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PatternMatchUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PatternMatchUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PatternMatchUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"PatternMatchUtils.java:14"$0$" * limitations under the License."
"PatternMatchUtils.java:15"$0$" */"
"PatternMatchUtils.java:16"$0$""
"PatternMatchUtils.java:17"$0$"package org.springframework.util;"
"PatternMatchUtils.java:18"$0$""
"PatternMatchUtils.java:19"$0$"import org.springframework.lang.Nullable;"
"PatternMatchUtils.java:20"$0$""
"PatternMatchUtils.java:21"$0$"/**"
"PatternMatchUtils.java:22"$0$" * Utility methods for simple pattern matching, in particular for"
"PatternMatchUtils.java:23"$0$" * Spring's typical ""xxx*"", ""*xxx"" and ""*xxx*"" pattern styles."
"PatternMatchUtils.java:24"$0$" *"
"PatternMatchUtils.java:25"$0$" * @author Juergen Hoeller"
"PatternMatchUtils.java:26"$0$" * @since 2.0"
"PatternMatchUtils.java:27"$0$" */"
"PatternMatchUtils.java:28"$1$"public abstract class PatternMatchUtils {"
"PatternMatchUtils.java:29"$1$""
"PatternMatchUtils.java:30"$1$"	/**"
"PatternMatchUtils.java:31"$1$"	 * Match a String against the given pattern, supporting the following simple"
"PatternMatchUtils.java:32"$1$"	 * pattern styles: ""xxx*"", ""*xxx"", ""*xxx*"" and ""xxx*yyy"" matches (with an"
"PatternMatchUtils.java:33"$1$"	 * arbitrary number of pattern parts), as well as direct equality."
"PatternMatchUtils.java:34"$1$"	 * @param pattern the pattern to match against"
"PatternMatchUtils.java:35"$1$"	 * @param str the String to match"
"PatternMatchUtils.java:36"$1$"	 * @return whether the String matches the given pattern"
"PatternMatchUtils.java:37"$1$"	 */"
"PatternMatchUtils.java:38"$1$"	public static boolean simpleMatch(@Nullable String pattern, @Nullable String str) {"
"PatternMatchUtils.java:39"$1$"		if (pattern == null || str == null) {"
"PatternMatchUtils.java:40"$1$"			return false;"
"PatternMatchUtils.java:41"$1$"		}"
"PatternMatchUtils.java:42"$0$""
"PatternMatchUtils.java:43"$0$"		int firstIndex = pattern.indexOf('*');"
"PatternMatchUtils.java:44"$1$"		if (firstIndex == -1) {"
"PatternMatchUtils.java:45"$1$"			return pattern.equals(str);"
"PatternMatchUtils.java:46"$1$"		}"
"PatternMatchUtils.java:47"$0$""
"PatternMatchUtils.java:48"$1$"		if (firstIndex == 0) {"
"PatternMatchUtils.java:49"$1$"			if (pattern.length() == 1) {"
"PatternMatchUtils.java:50"$1$"				return true;"
"PatternMatchUtils.java:51"$1$"			}"
"PatternMatchUtils.java:52"$0$"			int nextIndex = pattern.indexOf('*', 1);"
"PatternMatchUtils.java:53"$1$"			if (nextIndex == -1) {"
"PatternMatchUtils.java:54"$1$"				return str.endsWith(pattern.substring(1));"
"PatternMatchUtils.java:55"$1$"			}"
"PatternMatchUtils.java:56"$0$"			String part = pattern.substring(1, nextIndex);"
"PatternMatchUtils.java:57"$1$"			if (part.isEmpty()) {"
"PatternMatchUtils.java:58"$1$"				return simpleMatch(pattern.substring(nextIndex), str);"
"PatternMatchUtils.java:59"$1$"			}"
"PatternMatchUtils.java:60"$0$"			int partIndex = str.indexOf(part);"
"PatternMatchUtils.java:61"$1$"			while (partIndex != -1) {"
"PatternMatchUtils.java:62"$1$"				if (simpleMatch(pattern.substring(nextIndex), str.substring(partIndex + part.length()))) {"
"PatternMatchUtils.java:63"$1$"					return true;"
"PatternMatchUtils.java:64"$1$"				}"
"PatternMatchUtils.java:65"$0$"				partIndex = str.indexOf(part, partIndex + 1);"
"PatternMatchUtils.java:66"$0$"			}"
"PatternMatchUtils.java:67"$0$"			return false;"
"PatternMatchUtils.java:68"$0$"		}"
"PatternMatchUtils.java:69"$0$""
"PatternMatchUtils.java:70"$0$"		return (str.length() >= firstIndex &&"
"PatternMatchUtils.java:71"$0$"				pattern.substring(0, firstIndex).equals(str.substring(0, firstIndex)) &&"
"PatternMatchUtils.java:72"$0$"				simpleMatch(pattern.substring(firstIndex), str.substring(firstIndex)));"
"PatternMatchUtils.java:73"$0$"	}"
"PatternMatchUtils.java:74"$0$""
"PatternMatchUtils.java:75"$0$"	/**"
"PatternMatchUtils.java:76"$0$"	 * Match a String against the given patterns, supporting the following simple"
"PatternMatchUtils.java:77"$0$"	 * pattern styles: ""xxx*"", ""*xxx"", ""*xxx*"" and ""xxx*yyy"" matches (with an"
"PatternMatchUtils.java:78"$0$"	 * arbitrary number of pattern parts), as well as direct equality."
"PatternMatchUtils.java:79"$0$"	 * @param patterns the patterns to match against"
"PatternMatchUtils.java:80"$0$"	 * @param str the String to match"
"PatternMatchUtils.java:81"$0$"	 * @return whether the String matches any of the given patterns"
"PatternMatchUtils.java:82"$0$"	 */"
"PatternMatchUtils.java:83"$1$"	public static boolean simpleMatch(@Nullable String[] patterns, String str) {"
"PatternMatchUtils.java:84"$1$"		if (patterns != null) {"
"PatternMatchUtils.java:85"$1$"			for (String pattern : patterns) {"
"PatternMatchUtils.java:86"$1$"				if (simpleMatch(pattern, str)) {"
"PatternMatchUtils.java:87"$1$"					return true;"
"PatternMatchUtils.java:88"$1$"				}"
"PatternMatchUtils.java:89"$0$"			}"
"PatternMatchUtils.java:90"$0$"		}"
"PatternMatchUtils.java:91"$0$"		return false;"
"PatternMatchUtils.java:92"$0$"	}"
"PatternMatchUtils.java:93"$0$""
"PatternMatchUtils.java:94"$0$"}"
"SimpleCommandLinePropertySource.java:1"$0$"/*"
"SimpleCommandLinePropertySource.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"SimpleCommandLinePropertySource.java:3"$0$" *"
"SimpleCommandLinePropertySource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleCommandLinePropertySource.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleCommandLinePropertySource.java:6"$0$" * You may obtain a copy of the License at"
"SimpleCommandLinePropertySource.java:7"$0$" *"
"SimpleCommandLinePropertySource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleCommandLinePropertySource.java:9"$0$" *"
"SimpleCommandLinePropertySource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleCommandLinePropertySource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleCommandLinePropertySource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleCommandLinePropertySource.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleCommandLinePropertySource.java:14"$0$" * limitations under the License."
"SimpleCommandLinePropertySource.java:15"$0$" */"
"SimpleCommandLinePropertySource.java:16"$0$""
"SimpleCommandLinePropertySource.java:17"$0$"package org.springframework.core.env;"
"SimpleCommandLinePropertySource.java:18"$0$""
"SimpleCommandLinePropertySource.java:19"$0$"import java.util.List;"
"SimpleCommandLinePropertySource.java:20"$0$""
"SimpleCommandLinePropertySource.java:21"$0$"import org.springframework.lang.Nullable;"
"SimpleCommandLinePropertySource.java:22"$0$"import org.springframework.util.StringUtils;"
"SimpleCommandLinePropertySource.java:23"$0$""
"SimpleCommandLinePropertySource.java:24"$0$"/**"
"SimpleCommandLinePropertySource.java:25"$1$" * {@link CommandLinePropertySource} implementation backed by a simple String array."
"SimpleCommandLinePropertySource.java:26"$0$" *"
"SimpleCommandLinePropertySource.java:27"$0$" * <h3>Purpose</h3>"
"SimpleCommandLinePropertySource.java:28"$1$" * <p>This {@code CommandLinePropertySource} implementation aims to provide the simplest"
"SimpleCommandLinePropertySource.java:29"$1$" * possible approach to parsing command line arguments. As with all {@code"
"SimpleCommandLinePropertySource.java:30"$1$" * CommandLinePropertySource} implementations, command line arguments are broken into two"
"SimpleCommandLinePropertySource.java:31"$0$" * distinct groups: <em>option arguments</em> and <em>non-option arguments</em>, as"
"SimpleCommandLinePropertySource.java:32"$0$" * described below <em>(some sections copied from Javadoc for"
"SimpleCommandLinePropertySource.java:33"$1$" * {@link SimpleCommandLineArgsParser})</em>:"
"SimpleCommandLinePropertySource.java:34"$0$" *"
"SimpleCommandLinePropertySource.java:35"$0$" * <h3>Working with option arguments</h3>"
"SimpleCommandLinePropertySource.java:36"$0$" * <p>Option arguments must adhere to the exact syntax:"
"SimpleCommandLinePropertySource.java:37"$0$" *"
"SimpleCommandLinePropertySource.java:38"$0$" * <pre class=""code"">--optName[=optValue]</pre>"
"SimpleCommandLinePropertySource.java:39"$0$" *"
"SimpleCommandLinePropertySource.java:40"$1$" * <p>That is, options must be prefixed with ""{@code --}"" and may or may not"
"SimpleCommandLinePropertySource.java:41"$0$" * specify a value. If a value is specified, the name and value must be separated"
"SimpleCommandLinePropertySource.java:42"$0$" * <em>without spaces</em> by an equals sign (""=""). The value may optionally be"
"SimpleCommandLinePropertySource.java:43"$0$" * an empty string."
"SimpleCommandLinePropertySource.java:44"$0$" *"
"SimpleCommandLinePropertySource.java:45"$0$" * <h4>Valid examples of option arguments</h4>"
"SimpleCommandLinePropertySource.java:46"$0$" * <pre class=""code"">"
"SimpleCommandLinePropertySource.java:47"$0$" * --foo"
"SimpleCommandLinePropertySource.java:48"$0$" * --foo="
"SimpleCommandLinePropertySource.java:49"$0$" * --foo="""""
"SimpleCommandLinePropertySource.java:50"$0$" * --foo=bar"
"SimpleCommandLinePropertySource.java:51"$0$" * --foo=""bar then baz"""
"SimpleCommandLinePropertySource.java:52"$0$" * --foo=bar,baz,biz</pre>"
"SimpleCommandLinePropertySource.java:53"$0$" *"
"SimpleCommandLinePropertySource.java:54"$0$" * <h4>Invalid examples of option arguments</h4>"
"SimpleCommandLinePropertySource.java:55"$0$" * <pre class=""code"">"
"SimpleCommandLinePropertySource.java:56"$0$" * -foo"
"SimpleCommandLinePropertySource.java:57"$0$" * --foo bar"
"SimpleCommandLinePropertySource.java:58"$0$" * --foo = bar"
"SimpleCommandLinePropertySource.java:59"$0$" * --foo=bar --foo=baz --foo=biz</pre>"
"SimpleCommandLinePropertySource.java:60"$0$" *"
"SimpleCommandLinePropertySource.java:61"$0$" * <h3>Working with non-option arguments</h3>"
"SimpleCommandLinePropertySource.java:62"$1$" * <p>Any and all arguments specified at the command line without the ""{@code --}"""
"SimpleCommandLinePropertySource.java:63"$0$" * option prefix will be considered as ""non-option arguments"" and made available"
"SimpleCommandLinePropertySource.java:64"$1$" * through the {@link CommandLineArgs#getNonOptionArgs()} method."
"SimpleCommandLinePropertySource.java:65"$0$" *"
"SimpleCommandLinePropertySource.java:66"$0$" * <h3>Typical usage</h3>"
"SimpleCommandLinePropertySource.java:67"$0$" * <pre class=""code"">"
"SimpleCommandLinePropertySource.java:68"$1$" * public static void main(String[] args) {"
"SimpleCommandLinePropertySource.java:69"$1$" *     PropertySource<?> ps = new SimpleCommandLinePropertySource(args);"
"SimpleCommandLinePropertySource.java:70"$1$" *     // ..."
"SimpleCommandLinePropertySource.java:71"$1$" * }</pre>"
"SimpleCommandLinePropertySource.java:72"$0$" *"
"SimpleCommandLinePropertySource.java:73"$1$" * See {@link CommandLinePropertySource} for complete general usage examples."
"SimpleCommandLinePropertySource.java:74"$0$" *"
"SimpleCommandLinePropertySource.java:75"$0$" * <h3>Beyond the basics</h3>"
"SimpleCommandLinePropertySource.java:76"$0$" *"
"SimpleCommandLinePropertySource.java:77"$0$" * <p>When more fully-featured command line parsing is necessary, consider using"
"SimpleCommandLinePropertySource.java:78"$1$" * the provided {@link JOptCommandLinePropertySource}, or implement your own"
"SimpleCommandLinePropertySource.java:79"$1$" * {@code CommandLinePropertySource} against the command line parsing library of your"
"SimpleCommandLinePropertySource.java:80"$0$" * choice."
"SimpleCommandLinePropertySource.java:81"$0$" *"
"SimpleCommandLinePropertySource.java:82"$0$" * @author Chris Beams"
"SimpleCommandLinePropertySource.java:83"$0$" * @since 3.1"
"SimpleCommandLinePropertySource.java:84"$0$" * @see CommandLinePropertySource"
"SimpleCommandLinePropertySource.java:85"$0$" * @see JOptCommandLinePropertySource"
"SimpleCommandLinePropertySource.java:86"$0$" */"
"SimpleCommandLinePropertySource.java:87"$1$"public class SimpleCommandLinePropertySource extends CommandLinePropertySource<CommandLineArgs> {"
"SimpleCommandLinePropertySource.java:88"$1$""
"SimpleCommandLinePropertySource.java:89"$1$"	/**"
"SimpleCommandLinePropertySource.java:90"$1$"	 * Create a new {@code SimpleCommandLinePropertySource} having the default name"
"SimpleCommandLinePropertySource.java:91"$1$"	 * and backed by the given {@code String[]} of command line arguments."
"SimpleCommandLinePropertySource.java:92"$1$"	 * @see CommandLinePropertySource#COMMAND_LINE_PROPERTY_SOURCE_NAME"
"SimpleCommandLinePropertySource.java:93"$1$"	 * @see CommandLinePropertySource#CommandLinePropertySource(Object)"
"SimpleCommandLinePropertySource.java:94"$1$"	 */"
"SimpleCommandLinePropertySource.java:95"$1$"	public SimpleCommandLinePropertySource(String... args) {"
"SimpleCommandLinePropertySource.java:96"$1$"		super(new SimpleCommandLineArgsParser().parse(args));"
"SimpleCommandLinePropertySource.java:97"$1$"	}"
"SimpleCommandLinePropertySource.java:98"$0$""
"SimpleCommandLinePropertySource.java:99"$0$"	/**"
"SimpleCommandLinePropertySource.java:100"$1$"	 * Create a new {@code SimpleCommandLinePropertySource} having the given name"
"SimpleCommandLinePropertySource.java:101"$1$"	 * and backed by the given {@code String[]} of command line arguments."
"SimpleCommandLinePropertySource.java:102"$0$"	 */"
"SimpleCommandLinePropertySource.java:103"$1$"	public SimpleCommandLinePropertySource(String name, String[] args) {"
"SimpleCommandLinePropertySource.java:104"$1$"		super(name, new SimpleCommandLineArgsParser().parse(args));"
"SimpleCommandLinePropertySource.java:105"$1$"	}"
"SimpleCommandLinePropertySource.java:106"$0$""
"SimpleCommandLinePropertySource.java:107"$0$"	/**"
"SimpleCommandLinePropertySource.java:108"$0$"	 * Get the property names for the option arguments."
"SimpleCommandLinePropertySource.java:109"$0$"	 */"
"SimpleCommandLinePropertySource.java:110"$0$"	@Override"
"SimpleCommandLinePropertySource.java:111"$1$"	public String[] getPropertyNames() {"
"SimpleCommandLinePropertySource.java:112"$1$"		return StringUtils.toStringArray(this.source.getOptionNames());"
"SimpleCommandLinePropertySource.java:113"$1$"	}"
"SimpleCommandLinePropertySource.java:114"$0$""
"SimpleCommandLinePropertySource.java:115"$0$"	@Override"
"SimpleCommandLinePropertySource.java:116"$1$"	protected boolean containsOption(String name) {"
"SimpleCommandLinePropertySource.java:117"$1$"		return this.source.containsOption(name);"
"SimpleCommandLinePropertySource.java:118"$1$"	}"
"SimpleCommandLinePropertySource.java:119"$0$""
"SimpleCommandLinePropertySource.java:120"$0$"	@Override"
"SimpleCommandLinePropertySource.java:121"$0$"	@Nullable"
"SimpleCommandLinePropertySource.java:122"$1$"	protected List<String> getOptionValues(String name) {"
"SimpleCommandLinePropertySource.java:123"$1$"		return this.source.getOptionValues(name);"
"SimpleCommandLinePropertySource.java:124"$1$"	}"
"SimpleCommandLinePropertySource.java:125"$0$""
"SimpleCommandLinePropertySource.java:126"$0$"	@Override"
"SimpleCommandLinePropertySource.java:127"$1$"	protected List<String> getNonOptionArgs() {"
"SimpleCommandLinePropertySource.java:128"$1$"		return this.source.getNonOptionArgs();"
"SimpleCommandLinePropertySource.java:129"$1$"	}"
"SimpleCommandLinePropertySource.java:130"$0$""
"SimpleCommandLinePropertySource.java:131"$0$"}"
"ObjectUtils.java:1"$0$"/*"
"ObjectUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ObjectUtils.java:3"$0$" *"
"ObjectUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ObjectUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"ObjectUtils.java:6"$0$" * You may obtain a copy of the License at"
"ObjectUtils.java:7"$0$" *"
"ObjectUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ObjectUtils.java:9"$0$" *"
"ObjectUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ObjectUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ObjectUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ObjectUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"ObjectUtils.java:14"$0$" * limitations under the License."
"ObjectUtils.java:15"$0$" */"
"ObjectUtils.java:16"$0$""
"ObjectUtils.java:17"$0$"package org.springframework.util;"
"ObjectUtils.java:18"$0$""
"ObjectUtils.java:19"$0$"import java.lang.reflect.Array;"
"ObjectUtils.java:20"$0$"import java.util.Arrays;"
"ObjectUtils.java:21"$0$"import java.util.Collection;"
"ObjectUtils.java:22"$0$"import java.util.Map;"
"ObjectUtils.java:23"$0$"import java.util.Optional;"
"ObjectUtils.java:24"$0$"import java.util.StringJoiner;"
"ObjectUtils.java:25"$0$""
"ObjectUtils.java:26"$0$"import org.springframework.lang.Nullable;"
"ObjectUtils.java:27"$0$""
"ObjectUtils.java:28"$0$"/**"
"ObjectUtils.java:29"$0$" * Miscellaneous object utility methods."
"ObjectUtils.java:30"$0$" *"
"ObjectUtils.java:31"$0$" * <p>Mainly for internal use within the framework."
"ObjectUtils.java:32"$0$" *"
"ObjectUtils.java:33"$0$" * <p>Thanks to Alex Ruiz for contributing several enhancements to this class!"
"ObjectUtils.java:34"$0$" *"
"ObjectUtils.java:35"$0$" * @author Juergen Hoeller"
"ObjectUtils.java:36"$0$" * @author Keith Donald"
"ObjectUtils.java:37"$0$" * @author Rod Johnson"
"ObjectUtils.java:38"$0$" * @author Rob Harrop"
"ObjectUtils.java:39"$0$" * @author Chris Beams"
"ObjectUtils.java:40"$0$" * @author Sam Brannen"
"ObjectUtils.java:41"$0$" * @since 19.03.2004"
"ObjectUtils.java:42"$0$" * @see ClassUtils"
"ObjectUtils.java:43"$0$" * @see CollectionUtils"
"ObjectUtils.java:44"$0$" * @see StringUtils"
"ObjectUtils.java:45"$0$" */"
"ObjectUtils.java:46"$1$"public abstract class ObjectUtils {"
"ObjectUtils.java:47"$1$""
"ObjectUtils.java:48"$1$"	private static final int INITIAL_HASH = 7;"
"ObjectUtils.java:49"$1$"	private static final int MULTIPLIER = 31;"
"ObjectUtils.java:50"$1$""
"ObjectUtils.java:51"$1$"	private static final String EMPTY_STRING = """";"
"ObjectUtils.java:52"$1$"	private static final String NULL_STRING = ""null"";"
"ObjectUtils.java:53"$1$"	private static final String ARRAY_START = ""{"";"
"ObjectUtils.java:54"$1$"	private static final String ARRAY_END = ""}"";"
"ObjectUtils.java:55"$0$"	private static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;"
"ObjectUtils.java:56"$0$"	private static final String ARRAY_ELEMENT_SEPARATOR = "", "";"
"ObjectUtils.java:57"$0$"	private static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];"
"ObjectUtils.java:58"$0$""
"ObjectUtils.java:59"$0$""
"ObjectUtils.java:60"$0$"	/**"
"ObjectUtils.java:61"$0$"	 * Return whether the given throwable is a checked exception:"
"ObjectUtils.java:62"$0$"	 * that is, neither a RuntimeException nor an Error."
"ObjectUtils.java:63"$0$"	 * @param ex the throwable to check"
"ObjectUtils.java:64"$0$"	 * @return whether the throwable is a checked exception"
"ObjectUtils.java:65"$0$"	 * @see java.lang.Exception"
"ObjectUtils.java:66"$0$"	 * @see java.lang.RuntimeException"
"ObjectUtils.java:67"$0$"	 * @see java.lang.Error"
"ObjectUtils.java:68"$0$"	 */"
"ObjectUtils.java:69"$1$"	public static boolean isCheckedException(Throwable ex) {"
"ObjectUtils.java:70"$1$"		return !(ex instanceof RuntimeException || ex instanceof Error);"
"ObjectUtils.java:71"$1$"	}"
"ObjectUtils.java:72"$0$""
"ObjectUtils.java:73"$0$"	/**"
"ObjectUtils.java:74"$0$"	 * Check whether the given exception is compatible with the specified"
"ObjectUtils.java:75"$0$"	 * exception types, as declared in a throws clause."
"ObjectUtils.java:76"$0$"	 * @param ex the exception to check"
"ObjectUtils.java:77"$0$"	 * @param declaredExceptions the exception types declared in the throws clause"
"ObjectUtils.java:78"$0$"	 * @return whether the given exception is compatible"
"ObjectUtils.java:79"$0$"	 */"
"ObjectUtils.java:80"$1$"	public static boolean isCompatibleWithThrowsClause(Throwable ex, @Nullable Class<?>... declaredExceptions) {"
"ObjectUtils.java:81"$1$"		if (!isCheckedException(ex)) {"
"ObjectUtils.java:82"$1$"			return true;"
"ObjectUtils.java:83"$1$"		}"
"ObjectUtils.java:84"$1$"		if (declaredExceptions != null) {"
"ObjectUtils.java:85"$1$"			for (Class<?> declaredException : declaredExceptions) {"
"ObjectUtils.java:86"$1$"				if (declaredException.isInstance(ex)) {"
"ObjectUtils.java:87"$1$"					return true;"
"ObjectUtils.java:88"$1$"				}"
"ObjectUtils.java:89"$0$"			}"
"ObjectUtils.java:90"$0$"		}"
"ObjectUtils.java:91"$0$"		return false;"
"ObjectUtils.java:92"$0$"	}"
"ObjectUtils.java:93"$0$""
"ObjectUtils.java:94"$0$"	/**"
"ObjectUtils.java:95"$0$"	 * Determine whether the given object is an array:"
"ObjectUtils.java:96"$0$"	 * either an Object array or a primitive array."
"ObjectUtils.java:97"$0$"	 * @param obj the object to check"
"ObjectUtils.java:98"$0$"	 */"
"ObjectUtils.java:99"$1$"	public static boolean isArray(@Nullable Object obj) {"
"ObjectUtils.java:100"$1$"		return (obj != null && obj.getClass().isArray());"
"ObjectUtils.java:101"$1$"	}"
"ObjectUtils.java:102"$0$""
"ObjectUtils.java:103"$0$"	/**"
"ObjectUtils.java:104"$0$"	 * Determine whether the given array is empty:"
"ObjectUtils.java:105"$1$"	 * i.e. {@code null} or of zero length."
"ObjectUtils.java:106"$0$"	 * @param array the array to check"
"ObjectUtils.java:107"$0$"	 * @see #isEmpty(Object)"
"ObjectUtils.java:108"$0$"	 */"
"ObjectUtils.java:109"$1$"	public static boolean isEmpty(@Nullable Object[] array) {"
"ObjectUtils.java:110"$1$"		return (array == null || array.length == 0);"
"ObjectUtils.java:111"$1$"	}"
"ObjectUtils.java:112"$0$""
"ObjectUtils.java:113"$0$"	/**"
"ObjectUtils.java:114"$0$"	 * Determine whether the given object is empty."
"ObjectUtils.java:115"$0$"	 * <p>This method supports the following object types."
"ObjectUtils.java:116"$0$"	 * <ul>"
"ObjectUtils.java:117"$1$"	 * <li>{@code Optional}: considered empty if {@link Optional#empty()}</li>"
"ObjectUtils.java:118"$1$"	 * <li>{@code Array}: considered empty if its length is zero</li>"
"ObjectUtils.java:119"$1$"	 * <li>{@link CharSequence}: considered empty if its length is zero</li>"
"ObjectUtils.java:120"$1$"	 * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>"
"ObjectUtils.java:121"$1$"	 * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>"
"ObjectUtils.java:122"$0$"	 * </ul>"
"ObjectUtils.java:123"$0$"	 * <p>If the given object is non-null and not one of the aforementioned"
"ObjectUtils.java:124"$1$"	 * supported types, this method returns {@code false}."
"ObjectUtils.java:125"$0$"	 * @param obj the object to check"
"ObjectUtils.java:126"$1$"	 * @return {@code true} if the object is {@code null} or <em>empty</em>"
"ObjectUtils.java:127"$0$"	 * @since 4.2"
"ObjectUtils.java:128"$0$"	 * @see Optional#isPresent()"
"ObjectUtils.java:129"$0$"	 * @see ObjectUtils#isEmpty(Object[])"
"ObjectUtils.java:130"$0$"	 * @see StringUtils#hasLength(CharSequence)"
"ObjectUtils.java:131"$0$"	 * @see StringUtils#isEmpty(Object)"
"ObjectUtils.java:132"$0$"	 * @see CollectionUtils#isEmpty(java.util.Collection)"
"ObjectUtils.java:133"$0$"	 * @see CollectionUtils#isEmpty(java.util.Map)"
"ObjectUtils.java:134"$0$"	 */"
"ObjectUtils.java:135"$0$"	@SuppressWarnings(""rawtypes"")"
"ObjectUtils.java:136"$1$"	public static boolean isEmpty(@Nullable Object obj) {"
"ObjectUtils.java:137"$1$"		if (obj == null) {"
"ObjectUtils.java:138"$1$"			return true;"
"ObjectUtils.java:139"$1$"		}"
"ObjectUtils.java:140"$0$""
"ObjectUtils.java:141"$1$"		if (obj instanceof Optional) {"
"ObjectUtils.java:142"$1$"			return !((Optional) obj).isPresent();"
"ObjectUtils.java:143"$1$"		}"
"ObjectUtils.java:144"$1$"		if (obj instanceof CharSequence) {"
"ObjectUtils.java:145"$1$"			return ((CharSequence) obj).length() == 0;"
"ObjectUtils.java:146"$1$"		}"
"ObjectUtils.java:147"$1$"		if (obj.getClass().isArray()) {"
"ObjectUtils.java:148"$1$"			return Array.getLength(obj) == 0;"
"ObjectUtils.java:149"$1$"		}"
"ObjectUtils.java:150"$1$"		if (obj instanceof Collection) {"
"ObjectUtils.java:151"$1$"			return ((Collection) obj).isEmpty();"
"ObjectUtils.java:152"$1$"		}"
"ObjectUtils.java:153"$1$"		if (obj instanceof Map) {"
"ObjectUtils.java:154"$1$"			return ((Map) obj).isEmpty();"
"ObjectUtils.java:155"$1$"		}"
"ObjectUtils.java:156"$0$""
"ObjectUtils.java:157"$0$"		// else"
"ObjectUtils.java:158"$0$"		return false;"
"ObjectUtils.java:159"$0$"	}"
"ObjectUtils.java:160"$0$""
"ObjectUtils.java:161"$0$"	/**"
"ObjectUtils.java:162"$1$"	 * Unwrap the given object which is potentially a {@link java.util.Optional}."
"ObjectUtils.java:163"$0$"	 * @param obj the candidate object"
"ObjectUtils.java:164"$1$"	 * @return either the value held within the {@code Optional}, {@code null}"
"ObjectUtils.java:165"$1$"	 * if the {@code Optional} is empty, or simply the given object as-is"
"ObjectUtils.java:166"$0$"	 * @since 5.0"
"ObjectUtils.java:167"$0$"	 */"
"ObjectUtils.java:168"$0$"	@Nullable"
"ObjectUtils.java:169"$1$"	public static Object unwrapOptional(@Nullable Object obj) {"
"ObjectUtils.java:170"$1$"		if (obj instanceof Optional) {"
"ObjectUtils.java:171"$1$"			Optional<?> optional = (Optional<?>) obj;"
"ObjectUtils.java:172"$1$"			if (!optional.isPresent()) {"
"ObjectUtils.java:173"$1$"				return null;"
"ObjectUtils.java:174"$1$"			}"
"ObjectUtils.java:175"$0$"			Object result = optional.get();"
"ObjectUtils.java:176"$0$"			Assert.isTrue(!(result instanceof Optional), ""Multi-level Optional usage not supported"");"
"ObjectUtils.java:177"$0$"			return result;"
"ObjectUtils.java:178"$0$"		}"
"ObjectUtils.java:179"$0$"		return obj;"
"ObjectUtils.java:180"$0$"	}"
"ObjectUtils.java:181"$0$""
"ObjectUtils.java:182"$0$"	/**"
"ObjectUtils.java:183"$0$"	 * Check whether the given array contains the given element."
"ObjectUtils.java:184"$1$"	 * @param array the array to check (may be {@code null},"
"ObjectUtils.java:185"$1$"	 * in which case the return value will always be {@code false})"
"ObjectUtils.java:186"$0$"	 * @param element the element to check for"
"ObjectUtils.java:187"$0$"	 * @return whether the element has been found in the given array"
"ObjectUtils.java:188"$0$"	 */"
"ObjectUtils.java:189"$1$"	public static boolean containsElement(@Nullable Object[] array, Object element) {"
"ObjectUtils.java:190"$1$"		if (array == null) {"
"ObjectUtils.java:191"$1$"			return false;"
"ObjectUtils.java:192"$1$"		}"
"ObjectUtils.java:193"$1$"		for (Object arrayEle : array) {"
"ObjectUtils.java:194"$1$"			if (nullSafeEquals(arrayEle, element)) {"
"ObjectUtils.java:195"$1$"				return true;"
"ObjectUtils.java:196"$1$"			}"
"ObjectUtils.java:197"$0$"		}"
"ObjectUtils.java:198"$0$"		return false;"
"ObjectUtils.java:199"$0$"	}"
"ObjectUtils.java:200"$0$""
"ObjectUtils.java:201"$0$"	/**"
"ObjectUtils.java:202"$0$"	 * Check whether the given array of enum constants contains a constant with the given name,"
"ObjectUtils.java:203"$0$"	 * ignoring case when determining a match."
"ObjectUtils.java:204"$1$"	 * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}"
"ObjectUtils.java:205"$0$"	 * @param constant the constant name to find (must not be null or empty string)"
"ObjectUtils.java:206"$0$"	 * @return whether the constant has been found in the given array"
"ObjectUtils.java:207"$0$"	 */"
"ObjectUtils.java:208"$1$"	public static boolean containsConstant(Enum<?>[] enumValues, String constant) {"
"ObjectUtils.java:209"$1$"		return containsConstant(enumValues, constant, false);"
"ObjectUtils.java:210"$1$"	}"
"ObjectUtils.java:211"$0$""
"ObjectUtils.java:212"$0$"	/**"
"ObjectUtils.java:213"$0$"	 * Check whether the given array of enum constants contains a constant with the given name."
"ObjectUtils.java:214"$1$"	 * @param enumValues the enum values to check, typically obtained via {@code MyEnum.values()}"
"ObjectUtils.java:215"$0$"	 * @param constant the constant name to find (must not be null or empty string)"
"ObjectUtils.java:216"$0$"	 * @param caseSensitive whether case is significant in determining a match"
"ObjectUtils.java:217"$0$"	 * @return whether the constant has been found in the given array"
"ObjectUtils.java:218"$0$"	 */"
"ObjectUtils.java:219"$1$"	public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {"
"ObjectUtils.java:220"$1$"		for (Enum<?> candidate : enumValues) {"
"ObjectUtils.java:221"$1$"			if (caseSensitive ? candidate.toString().equals(constant) :"
"ObjectUtils.java:222"$1$"					candidate.toString().equalsIgnoreCase(constant)) {"
"ObjectUtils.java:223"$1$"				return true;"
"ObjectUtils.java:224"$1$"			}"
"ObjectUtils.java:225"$0$"		}"
"ObjectUtils.java:226"$0$"		return false;"
"ObjectUtils.java:227"$0$"	}"
"ObjectUtils.java:228"$0$""
"ObjectUtils.java:229"$0$"	/**"
"ObjectUtils.java:230"$1$"	 * Case insensitive alternative to {@link Enum#valueOf(Class, String)}."
"ObjectUtils.java:231"$0$"	 * @param <E> the concrete Enum type"
"ObjectUtils.java:232"$1$"	 * @param enumValues the array of all Enum constants in question, usually per {@code Enum.values()}"
"ObjectUtils.java:233"$0$"	 * @param constant the constant to get the enum value of"
"ObjectUtils.java:234"$0$"	 * @throws IllegalArgumentException if the given constant is not found in the given array"
"ObjectUtils.java:235"$1$"	 * of enum values. Use {@link #containsConstant(Enum[], String)} as a guard to avoid this exception."
"ObjectUtils.java:236"$0$"	 */"
"ObjectUtils.java:237"$1$"	public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {"
"ObjectUtils.java:238"$1$"		for (E candidate : enumValues) {"
"ObjectUtils.java:239"$1$"			if (candidate.toString().equalsIgnoreCase(constant)) {"
"ObjectUtils.java:240"$1$"				return candidate;"
"ObjectUtils.java:241"$1$"			}"
"ObjectUtils.java:242"$0$"		}"
"ObjectUtils.java:243"$0$"		throw new IllegalArgumentException(""Constant ["" + constant + ""] does not exist in enum type "" +"
"ObjectUtils.java:244"$0$"				enumValues.getClass().getComponentType().getName());"
"ObjectUtils.java:245"$0$"	}"
"ObjectUtils.java:246"$0$""
"ObjectUtils.java:247"$0$"	/**"
"ObjectUtils.java:248"$0$"	 * Append the given object to the given array, returning a new array"
"ObjectUtils.java:249"$0$"	 * consisting of the input array contents plus the given object."
"ObjectUtils.java:250"$1$"	 * @param array the array to append to (can be {@code null})"
"ObjectUtils.java:251"$0$"	 * @param obj the object to append"
"ObjectUtils.java:252"$1$"	 * @return the new array (of the same component type; never {@code null})"
"ObjectUtils.java:253"$0$"	 */"
"ObjectUtils.java:254"$1$"	public static <A, O extends A> A[] addObjectToArray(@Nullable A[] array, @Nullable O obj) {"
"ObjectUtils.java:255"$1$"		Class<?> compType = Object.class;"
"ObjectUtils.java:256"$1$"		if (array != null) {"
"ObjectUtils.java:257"$1$"			compType = array.getClass().getComponentType();"
"ObjectUtils.java:258"$1$"		}"
"ObjectUtils.java:259"$1$"		else if (obj != null) {"
"ObjectUtils.java:260"$1$"			compType = obj.getClass();"
"ObjectUtils.java:261"$1$"		}"
"ObjectUtils.java:262"$0$"		int newArrLength = (array != null ? array.length + 1 : 1);"
"ObjectUtils.java:263"$0$"		@SuppressWarnings(""unchecked"")"
"ObjectUtils.java:264"$0$"		A[] newArr = (A[]) Array.newInstance(compType, newArrLength);"
"ObjectUtils.java:265"$1$"		if (array != null) {"
"ObjectUtils.java:266"$1$"			System.arraycopy(array, 0, newArr, 0, array.length);"
"ObjectUtils.java:267"$1$"		}"
"ObjectUtils.java:268"$0$"		newArr[newArr.length - 1] = obj;"
"ObjectUtils.java:269"$0$"		return newArr;"
"ObjectUtils.java:270"$0$"	}"
"ObjectUtils.java:271"$0$""
"ObjectUtils.java:272"$0$"	/**"
"ObjectUtils.java:273"$0$"	 * Convert the given array (which may be a primitive array) to an"
"ObjectUtils.java:274"$0$"	 * object array (if necessary of primitive wrapper objects)."
"ObjectUtils.java:275"$1$"	 * <p>A {@code null} source value will be converted to an"
"ObjectUtils.java:276"$0$"	 * empty Object array."
"ObjectUtils.java:277"$0$"	 * @param source the (potentially primitive) array"
"ObjectUtils.java:278"$1$"	 * @return the corresponding object array (never {@code null})"
"ObjectUtils.java:279"$0$"	 * @throws IllegalArgumentException if the parameter is not an array"
"ObjectUtils.java:280"$0$"	 */"
"ObjectUtils.java:281"$1$"	public static Object[] toObjectArray(@Nullable Object source) {"
"ObjectUtils.java:282"$1$"		if (source instanceof Object[]) {"
"ObjectUtils.java:283"$1$"			return (Object[]) source;"
"ObjectUtils.java:284"$1$"		}"
"ObjectUtils.java:285"$1$"		if (source == null) {"
"ObjectUtils.java:286"$1$"			return EMPTY_OBJECT_ARRAY;"
"ObjectUtils.java:287"$1$"		}"
"ObjectUtils.java:288"$1$"		if (!source.getClass().isArray()) {"
"ObjectUtils.java:289"$1$"			throw new IllegalArgumentException(""Source is not an array: "" + source);"
"ObjectUtils.java:290"$1$"		}"
"ObjectUtils.java:291"$0$"		int length = Array.getLength(source);"
"ObjectUtils.java:292"$1$"		if (length == 0) {"
"ObjectUtils.java:293"$1$"			return EMPTY_OBJECT_ARRAY;"
"ObjectUtils.java:294"$1$"		}"
"ObjectUtils.java:295"$0$"		Class<?> wrapperType = Array.get(source, 0).getClass();"
"ObjectUtils.java:296"$0$"		Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);"
"ObjectUtils.java:297"$1$"		for (int i = 0; i < length; i++) {"
"ObjectUtils.java:298"$1$"			newArray[i] = Array.get(source, i);"
"ObjectUtils.java:299"$1$"		}"
"ObjectUtils.java:300"$0$"		return newArray;"
"ObjectUtils.java:301"$0$"	}"
"ObjectUtils.java:302"$0$""
"ObjectUtils.java:303"$0$""
"ObjectUtils.java:304"$0$"	//---------------------------------------------------------------------"
"ObjectUtils.java:305"$0$"	// Convenience methods for content-based equality/hash-code handling"
"ObjectUtils.java:306"$0$"	//---------------------------------------------------------------------"
"ObjectUtils.java:307"$0$""
"ObjectUtils.java:308"$0$"	/**"
"ObjectUtils.java:309"$1$"	 * Determine if the given objects are equal, returning {@code true} if"
"ObjectUtils.java:310"$1$"	 * both are {@code null} or {@code false} if only one is {@code null}."
"ObjectUtils.java:311"$1$"	 * <p>Compares arrays with {@code Arrays.equals}, performing an equality"
"ObjectUtils.java:312"$0$"	 * check based on the array elements rather than the array reference."
"ObjectUtils.java:313"$0$"	 * @param o1 first Object to compare"
"ObjectUtils.java:314"$0$"	 * @param o2 second Object to compare"
"ObjectUtils.java:315"$0$"	 * @return whether the given objects are equal"
"ObjectUtils.java:316"$0$"	 * @see Object#equals(Object)"
"ObjectUtils.java:317"$0$"	 * @see java.util.Arrays#equals"
"ObjectUtils.java:318"$0$"	 */"
"ObjectUtils.java:319"$1$"	public static boolean nullSafeEquals(@Nullable Object o1, @Nullable Object o2) {"
"ObjectUtils.java:320"$1$"		if (o1 == o2) {"
"ObjectUtils.java:321"$1$"			return true;"
"ObjectUtils.java:322"$1$"		}"
"ObjectUtils.java:323"$1$"		if (o1 == null || o2 == null) {"
"ObjectUtils.java:324"$1$"			return false;"
"ObjectUtils.java:325"$1$"		}"
"ObjectUtils.java:326"$1$"		if (o1.equals(o2)) {"
"ObjectUtils.java:327"$1$"			return true;"
"ObjectUtils.java:328"$1$"		}"
"ObjectUtils.java:329"$1$"		if (o1.getClass().isArray() && o2.getClass().isArray()) {"
"ObjectUtils.java:330"$1$"			return arrayEquals(o1, o2);"
"ObjectUtils.java:331"$1$"		}"
"ObjectUtils.java:332"$0$"		return false;"
"ObjectUtils.java:333"$0$"	}"
"ObjectUtils.java:334"$0$""
"ObjectUtils.java:335"$0$"	/**"
"ObjectUtils.java:336"$1$"	 * Compare the given arrays with {@code Arrays.equals}, performing an equality"
"ObjectUtils.java:337"$0$"	 * check based on the array elements rather than the array reference."
"ObjectUtils.java:338"$0$"	 * @param o1 first array to compare"
"ObjectUtils.java:339"$0$"	 * @param o2 second array to compare"
"ObjectUtils.java:340"$0$"	 * @return whether the given objects are equal"
"ObjectUtils.java:341"$0$"	 * @see #nullSafeEquals(Object, Object)"
"ObjectUtils.java:342"$0$"	 * @see java.util.Arrays#equals"
"ObjectUtils.java:343"$0$"	 */"
"ObjectUtils.java:344"$1$"	private static boolean arrayEquals(Object o1, Object o2) {"
"ObjectUtils.java:345"$1$"		if (o1 instanceof Object[] && o2 instanceof Object[]) {"
"ObjectUtils.java:346"$1$"			return Arrays.equals((Object[]) o1, (Object[]) o2);"
"ObjectUtils.java:347"$1$"		}"
"ObjectUtils.java:348"$1$"		if (o1 instanceof boolean[] && o2 instanceof boolean[]) {"
"ObjectUtils.java:349"$1$"			return Arrays.equals((boolean[]) o1, (boolean[]) o2);"
"ObjectUtils.java:350"$1$"		}"
"ObjectUtils.java:351"$1$"		if (o1 instanceof byte[] && o2 instanceof byte[]) {"
"ObjectUtils.java:352"$1$"			return Arrays.equals((byte[]) o1, (byte[]) o2);"
"ObjectUtils.java:353"$1$"		}"
"ObjectUtils.java:354"$1$"		if (o1 instanceof char[] && o2 instanceof char[]) {"
"ObjectUtils.java:355"$1$"			return Arrays.equals((char[]) o1, (char[]) o2);"
"ObjectUtils.java:356"$1$"		}"
"ObjectUtils.java:357"$1$"		if (o1 instanceof double[] && o2 instanceof double[]) {"
"ObjectUtils.java:358"$1$"			return Arrays.equals((double[]) o1, (double[]) o2);"
"ObjectUtils.java:359"$1$"		}"
"ObjectUtils.java:360"$1$"		if (o1 instanceof float[] && o2 instanceof float[]) {"
"ObjectUtils.java:361"$1$"			return Arrays.equals((float[]) o1, (float[]) o2);"
"ObjectUtils.java:362"$1$"		}"
"ObjectUtils.java:363"$1$"		if (o1 instanceof int[] && o2 instanceof int[]) {"
"ObjectUtils.java:364"$1$"			return Arrays.equals((int[]) o1, (int[]) o2);"
"ObjectUtils.java:365"$1$"		}"
"ObjectUtils.java:366"$1$"		if (o1 instanceof long[] && o2 instanceof long[]) {"
"ObjectUtils.java:367"$1$"			return Arrays.equals((long[]) o1, (long[]) o2);"
"ObjectUtils.java:368"$1$"		}"
"ObjectUtils.java:369"$1$"		if (o1 instanceof short[] && o2 instanceof short[]) {"
"ObjectUtils.java:370"$1$"			return Arrays.equals((short[]) o1, (short[]) o2);"
"ObjectUtils.java:371"$1$"		}"
"ObjectUtils.java:372"$0$"		return false;"
"ObjectUtils.java:373"$0$"	}"
"ObjectUtils.java:374"$0$""
"ObjectUtils.java:375"$0$"	/**"
"ObjectUtils.java:376"$0$"	 * Return as hash code for the given object; typically the value of"
"ObjectUtils.java:377"$1$"	 * {@code Object#hashCode()}}. If the object is an array,"
"ObjectUtils.java:378"$1$"	 * this method will delegate to any of the {@code nullSafeHashCode}"
"ObjectUtils.java:379"$1$"	 * methods for arrays in this class. If the object is {@code null},"
"ObjectUtils.java:380"$0$"	 * this method returns 0."
"ObjectUtils.java:381"$0$"	 * @see Object#hashCode()"
"ObjectUtils.java:382"$0$"	 * @see #nullSafeHashCode(Object[])"
"ObjectUtils.java:383"$0$"	 * @see #nullSafeHashCode(boolean[])"
"ObjectUtils.java:384"$0$"	 * @see #nullSafeHashCode(byte[])"
"ObjectUtils.java:385"$0$"	 * @see #nullSafeHashCode(char[])"
"ObjectUtils.java:386"$0$"	 * @see #nullSafeHashCode(double[])"
"ObjectUtils.java:387"$0$"	 * @see #nullSafeHashCode(float[])"
"ObjectUtils.java:388"$0$"	 * @see #nullSafeHashCode(int[])"
"ObjectUtils.java:389"$0$"	 * @see #nullSafeHashCode(long[])"
"ObjectUtils.java:390"$0$"	 * @see #nullSafeHashCode(short[])"
"ObjectUtils.java:391"$0$"	 */"
"ObjectUtils.java:392"$1$"	public static int nullSafeHashCode(@Nullable Object obj) {"
"ObjectUtils.java:393"$1$"		if (obj == null) {"
"ObjectUtils.java:394"$1$"			return 0;"
"ObjectUtils.java:395"$1$"		}"
"ObjectUtils.java:396"$1$"		if (obj.getClass().isArray()) {"
"ObjectUtils.java:397"$1$"			if (obj instanceof Object[]) {"
"ObjectUtils.java:398"$1$"				return nullSafeHashCode((Object[]) obj);"
"ObjectUtils.java:399"$1$"			}"
"ObjectUtils.java:400"$1$"			if (obj instanceof boolean[]) {"
"ObjectUtils.java:401"$1$"				return nullSafeHashCode((boolean[]) obj);"
"ObjectUtils.java:402"$1$"			}"
"ObjectUtils.java:403"$1$"			if (obj instanceof byte[]) {"
"ObjectUtils.java:404"$1$"				return nullSafeHashCode((byte[]) obj);"
"ObjectUtils.java:405"$1$"			}"
"ObjectUtils.java:406"$1$"			if (obj instanceof char[]) {"
"ObjectUtils.java:407"$1$"				return nullSafeHashCode((char[]) obj);"
"ObjectUtils.java:408"$1$"			}"
"ObjectUtils.java:409"$1$"			if (obj instanceof double[]) {"
"ObjectUtils.java:410"$1$"				return nullSafeHashCode((double[]) obj);"
"ObjectUtils.java:411"$1$"			}"
"ObjectUtils.java:412"$1$"			if (obj instanceof float[]) {"
"ObjectUtils.java:413"$1$"				return nullSafeHashCode((float[]) obj);"
"ObjectUtils.java:414"$1$"			}"
"ObjectUtils.java:415"$1$"			if (obj instanceof int[]) {"
"ObjectUtils.java:416"$1$"				return nullSafeHashCode((int[]) obj);"
"ObjectUtils.java:417"$1$"			}"
"ObjectUtils.java:418"$1$"			if (obj instanceof long[]) {"
"ObjectUtils.java:419"$1$"				return nullSafeHashCode((long[]) obj);"
"ObjectUtils.java:420"$1$"			}"
"ObjectUtils.java:421"$1$"			if (obj instanceof short[]) {"
"ObjectUtils.java:422"$1$"				return nullSafeHashCode((short[]) obj);"
"ObjectUtils.java:423"$1$"			}"
"ObjectUtils.java:424"$0$"		}"
"ObjectUtils.java:425"$0$"		return obj.hashCode();"
"ObjectUtils.java:426"$0$"	}"
"ObjectUtils.java:427"$0$""
"ObjectUtils.java:428"$0$"	/**"
"ObjectUtils.java:429"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:430"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:431"$0$"	 */"
"ObjectUtils.java:432"$1$"	public static int nullSafeHashCode(@Nullable Object[] array) {"
"ObjectUtils.java:433"$1$"		if (array == null) {"
"ObjectUtils.java:434"$1$"			return 0;"
"ObjectUtils.java:435"$1$"		}"
"ObjectUtils.java:436"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:437"$1$"		for (Object element : array) {"
"ObjectUtils.java:438"$1$"			hash = MULTIPLIER * hash + nullSafeHashCode(element);"
"ObjectUtils.java:439"$1$"		}"
"ObjectUtils.java:440"$0$"		return hash;"
"ObjectUtils.java:441"$0$"	}"
"ObjectUtils.java:442"$0$""
"ObjectUtils.java:443"$0$"	/**"
"ObjectUtils.java:444"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:445"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:446"$0$"	 */"
"ObjectUtils.java:447"$1$"	public static int nullSafeHashCode(@Nullable boolean[] array) {"
"ObjectUtils.java:448"$1$"		if (array == null) {"
"ObjectUtils.java:449"$1$"			return 0;"
"ObjectUtils.java:450"$1$"		}"
"ObjectUtils.java:451"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:452"$1$"		for (boolean element : array) {"
"ObjectUtils.java:453"$1$"			hash = MULTIPLIER * hash + Boolean.hashCode(element);"
"ObjectUtils.java:454"$1$"		}"
"ObjectUtils.java:455"$0$"		return hash;"
"ObjectUtils.java:456"$0$"	}"
"ObjectUtils.java:457"$0$""
"ObjectUtils.java:458"$0$"	/**"
"ObjectUtils.java:459"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:460"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:461"$0$"	 */"
"ObjectUtils.java:462"$1$"	public static int nullSafeHashCode(@Nullable byte[] array) {"
"ObjectUtils.java:463"$1$"		if (array == null) {"
"ObjectUtils.java:464"$1$"			return 0;"
"ObjectUtils.java:465"$1$"		}"
"ObjectUtils.java:466"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:467"$1$"		for (byte element : array) {"
"ObjectUtils.java:468"$1$"			hash = MULTIPLIER * hash + element;"
"ObjectUtils.java:469"$1$"		}"
"ObjectUtils.java:470"$0$"		return hash;"
"ObjectUtils.java:471"$0$"	}"
"ObjectUtils.java:472"$0$""
"ObjectUtils.java:473"$0$"	/**"
"ObjectUtils.java:474"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:475"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:476"$0$"	 */"
"ObjectUtils.java:477"$1$"	public static int nullSafeHashCode(@Nullable char[] array) {"
"ObjectUtils.java:478"$1$"		if (array == null) {"
"ObjectUtils.java:479"$1$"			return 0;"
"ObjectUtils.java:480"$1$"		}"
"ObjectUtils.java:481"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:482"$1$"		for (char element : array) {"
"ObjectUtils.java:483"$1$"			hash = MULTIPLIER * hash + element;"
"ObjectUtils.java:484"$1$"		}"
"ObjectUtils.java:485"$0$"		return hash;"
"ObjectUtils.java:486"$0$"	}"
"ObjectUtils.java:487"$0$""
"ObjectUtils.java:488"$0$"	/**"
"ObjectUtils.java:489"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:490"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:491"$0$"	 */"
"ObjectUtils.java:492"$1$"	public static int nullSafeHashCode(@Nullable double[] array) {"
"ObjectUtils.java:493"$1$"		if (array == null) {"
"ObjectUtils.java:494"$1$"			return 0;"
"ObjectUtils.java:495"$1$"		}"
"ObjectUtils.java:496"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:497"$1$"		for (double element : array) {"
"ObjectUtils.java:498"$1$"			hash = MULTIPLIER * hash + Double.hashCode(element);"
"ObjectUtils.java:499"$1$"		}"
"ObjectUtils.java:500"$0$"		return hash;"
"ObjectUtils.java:501"$0$"	}"
"ObjectUtils.java:502"$0$""
"ObjectUtils.java:503"$0$"	/**"
"ObjectUtils.java:504"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:505"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:506"$0$"	 */"
"ObjectUtils.java:507"$1$"	public static int nullSafeHashCode(@Nullable float[] array) {"
"ObjectUtils.java:508"$1$"		if (array == null) {"
"ObjectUtils.java:509"$1$"			return 0;"
"ObjectUtils.java:510"$1$"		}"
"ObjectUtils.java:511"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:512"$1$"		for (float element : array) {"
"ObjectUtils.java:513"$1$"			hash = MULTIPLIER * hash + Float.hashCode(element);"
"ObjectUtils.java:514"$1$"		}"
"ObjectUtils.java:515"$0$"		return hash;"
"ObjectUtils.java:516"$0$"	}"
"ObjectUtils.java:517"$0$""
"ObjectUtils.java:518"$0$"	/**"
"ObjectUtils.java:519"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:520"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:521"$0$"	 */"
"ObjectUtils.java:522"$1$"	public static int nullSafeHashCode(@Nullable int[] array) {"
"ObjectUtils.java:523"$1$"		if (array == null) {"
"ObjectUtils.java:524"$1$"			return 0;"
"ObjectUtils.java:525"$1$"		}"
"ObjectUtils.java:526"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:527"$1$"		for (int element : array) {"
"ObjectUtils.java:528"$1$"			hash = MULTIPLIER * hash + element;"
"ObjectUtils.java:529"$1$"		}"
"ObjectUtils.java:530"$0$"		return hash;"
"ObjectUtils.java:531"$0$"	}"
"ObjectUtils.java:532"$0$""
"ObjectUtils.java:533"$0$"	/**"
"ObjectUtils.java:534"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:535"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:536"$0$"	 */"
"ObjectUtils.java:537"$1$"	public static int nullSafeHashCode(@Nullable long[] array) {"
"ObjectUtils.java:538"$1$"		if (array == null) {"
"ObjectUtils.java:539"$1$"			return 0;"
"ObjectUtils.java:540"$1$"		}"
"ObjectUtils.java:541"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:542"$1$"		for (long element : array) {"
"ObjectUtils.java:543"$1$"			hash = MULTIPLIER * hash + Long.hashCode(element);"
"ObjectUtils.java:544"$1$"		}"
"ObjectUtils.java:545"$0$"		return hash;"
"ObjectUtils.java:546"$0$"	}"
"ObjectUtils.java:547"$0$""
"ObjectUtils.java:548"$0$"	/**"
"ObjectUtils.java:549"$0$"	 * Return a hash code based on the contents of the specified array."
"ObjectUtils.java:550"$1$"	 * If {@code array} is {@code null}, this method returns 0."
"ObjectUtils.java:551"$0$"	 */"
"ObjectUtils.java:552"$1$"	public static int nullSafeHashCode(@Nullable short[] array) {"
"ObjectUtils.java:553"$1$"		if (array == null) {"
"ObjectUtils.java:554"$1$"			return 0;"
"ObjectUtils.java:555"$1$"		}"
"ObjectUtils.java:556"$0$"		int hash = INITIAL_HASH;"
"ObjectUtils.java:557"$1$"		for (short element : array) {"
"ObjectUtils.java:558"$1$"			hash = MULTIPLIER * hash + element;"
"ObjectUtils.java:559"$1$"		}"
"ObjectUtils.java:560"$0$"		return hash;"
"ObjectUtils.java:561"$0$"	}"
"ObjectUtils.java:562"$0$""
"ObjectUtils.java:563"$0$"	/**"
"ObjectUtils.java:564"$1$"	 * Return the same value as {@link Boolean#hashCode(boolean)}}."
"ObjectUtils.java:565"$0$"	 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant"
"ObjectUtils.java:566"$0$"	 */"
"ObjectUtils.java:567"$0$"	@Deprecated"
"ObjectUtils.java:568"$1$"	public static int hashCode(boolean bool) {"
"ObjectUtils.java:569"$1$"		return Boolean.hashCode(bool);"
"ObjectUtils.java:570"$1$"	}"
"ObjectUtils.java:571"$0$""
"ObjectUtils.java:572"$0$"	/**"
"ObjectUtils.java:573"$1$"	 * Return the same value as {@link Double#hashCode(double)}}."
"ObjectUtils.java:574"$0$"	 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant"
"ObjectUtils.java:575"$0$"	 */"
"ObjectUtils.java:576"$0$"	@Deprecated"
"ObjectUtils.java:577"$1$"	public static int hashCode(double dbl) {"
"ObjectUtils.java:578"$1$"		return Double.hashCode(dbl);"
"ObjectUtils.java:579"$1$"	}"
"ObjectUtils.java:580"$0$""
"ObjectUtils.java:581"$0$"	/**"
"ObjectUtils.java:582"$1$"	 * Return the same value as {@link Float#hashCode(float)}}."
"ObjectUtils.java:583"$0$"	 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant"
"ObjectUtils.java:584"$0$"	 */"
"ObjectUtils.java:585"$0$"	@Deprecated"
"ObjectUtils.java:586"$1$"	public static int hashCode(float flt) {"
"ObjectUtils.java:587"$1$"		return Float.hashCode(flt);"
"ObjectUtils.java:588"$1$"	}"
"ObjectUtils.java:589"$0$""
"ObjectUtils.java:590"$0$"	/**"
"ObjectUtils.java:591"$1$"	 * Return the same value as {@link Long#hashCode(long)}}."
"ObjectUtils.java:592"$0$"	 * @deprecated as of Spring Framework 5.0, in favor of the native JDK 8 variant"
"ObjectUtils.java:593"$0$"	 */"
"ObjectUtils.java:594"$0$"	@Deprecated"
"ObjectUtils.java:595"$1$"	public static int hashCode(long lng) {"
"ObjectUtils.java:596"$1$"		return Long.hashCode(lng);"
"ObjectUtils.java:597"$1$"	}"
"ObjectUtils.java:598"$0$""
"ObjectUtils.java:599"$0$""
"ObjectUtils.java:600"$0$"	//---------------------------------------------------------------------"
"ObjectUtils.java:601"$0$"	// Convenience methods for toString output"
"ObjectUtils.java:602"$0$"	//---------------------------------------------------------------------"
"ObjectUtils.java:603"$0$""
"ObjectUtils.java:604"$0$"	/**"
"ObjectUtils.java:605"$0$"	 * Return a String representation of an object's overall identity."
"ObjectUtils.java:606"$1$"	 * @param obj the object (may be {@code null})"
"ObjectUtils.java:607"$0$"	 * @return the object's identity as String representation,"
"ObjectUtils.java:608"$1$"	 * or an empty String if the object was {@code null}"
"ObjectUtils.java:609"$0$"	 */"
"ObjectUtils.java:610"$1$"	public static String identityToString(@Nullable Object obj) {"
"ObjectUtils.java:611"$1$"		if (obj == null) {"
"ObjectUtils.java:612"$1$"			return EMPTY_STRING;"
"ObjectUtils.java:613"$1$"		}"
"ObjectUtils.java:614"$0$"		String className = obj.getClass().getName();"
"ObjectUtils.java:615"$0$"		String identityHexString = getIdentityHexString(obj);"
"ObjectUtils.java:616"$0$"		return className + '@' + identityHexString;"
"ObjectUtils.java:617"$0$"	}"
"ObjectUtils.java:618"$0$""
"ObjectUtils.java:619"$0$"	/**"
"ObjectUtils.java:620"$0$"	 * Return a hex String form of an object's identity hash code."
"ObjectUtils.java:621"$0$"	 * @param obj the object"
"ObjectUtils.java:622"$0$"	 * @return the object's identity code in hex notation"
"ObjectUtils.java:623"$0$"	 */"
"ObjectUtils.java:624"$1$"	public static String getIdentityHexString(Object obj) {"
"ObjectUtils.java:625"$1$"		return Integer.toHexString(System.identityHashCode(obj));"
"ObjectUtils.java:626"$1$"	}"
"ObjectUtils.java:627"$0$""
"ObjectUtils.java:628"$0$"	/**"
"ObjectUtils.java:629"$1$"	 * Return a content-based String representation if {@code obj} is"
"ObjectUtils.java:630"$1$"	 * not {@code null}; otherwise returns an empty String."
"ObjectUtils.java:631"$1$"	 * <p>Differs from {@link #nullSafeToString(Object)} in that it returns"
"ObjectUtils.java:632"$1$"	 * an empty String rather than ""null"" for a {@code null} value."
"ObjectUtils.java:633"$0$"	 * @param obj the object to build a display String for"
"ObjectUtils.java:634"$1$"	 * @return a display String representation of {@code obj}"
"ObjectUtils.java:635"$0$"	 * @see #nullSafeToString(Object)"
"ObjectUtils.java:636"$0$"	 */"
"ObjectUtils.java:637"$1$"	public static String getDisplayString(@Nullable Object obj) {"
"ObjectUtils.java:638"$1$"		if (obj == null) {"
"ObjectUtils.java:639"$1$"			return EMPTY_STRING;"
"ObjectUtils.java:640"$1$"		}"
"ObjectUtils.java:641"$0$"		return nullSafeToString(obj);"
"ObjectUtils.java:642"$0$"	}"
"ObjectUtils.java:643"$0$""
"ObjectUtils.java:644"$0$"	/**"
"ObjectUtils.java:645"$0$"	 * Determine the class name for the given object."
"ObjectUtils.java:646"$1$"	 * <p>Returns a {@code ""null""} String if {@code obj} is {@code null}."
"ObjectUtils.java:647"$1$"	 * @param obj the object to introspect (may be {@code null})"
"ObjectUtils.java:648"$0$"	 * @return the corresponding class name"
"ObjectUtils.java:649"$0$"	 */"
"ObjectUtils.java:650"$1$"	public static String nullSafeClassName(@Nullable Object obj) {"
"ObjectUtils.java:651"$1$"		return (obj != null ? obj.getClass().getName() : NULL_STRING);"
"ObjectUtils.java:652"$1$"	}"
"ObjectUtils.java:653"$0$""
"ObjectUtils.java:654"$0$"	/**"
"ObjectUtils.java:655"$0$"	 * Return a String representation of the specified Object."
"ObjectUtils.java:656"$0$"	 * <p>Builds a String representation of the contents in case of an array."
"ObjectUtils.java:657"$1$"	 * Returns a {@code ""null""} String if {@code obj} is {@code null}."
"ObjectUtils.java:658"$0$"	 * @param obj the object to build a String representation for"
"ObjectUtils.java:659"$1$"	 * @return a String representation of {@code obj}"
"ObjectUtils.java:660"$0$"	 */"
"ObjectUtils.java:661"$1$"	public static String nullSafeToString(@Nullable Object obj) {"
"ObjectUtils.java:662"$1$"		if (obj == null) {"
"ObjectUtils.java:663"$1$"			return NULL_STRING;"
"ObjectUtils.java:664"$1$"		}"
"ObjectUtils.java:665"$1$"		if (obj instanceof String) {"
"ObjectUtils.java:666"$1$"			return (String) obj;"
"ObjectUtils.java:667"$1$"		}"
"ObjectUtils.java:668"$1$"		if (obj instanceof Object[]) {"
"ObjectUtils.java:669"$1$"			return nullSafeToString((Object[]) obj);"
"ObjectUtils.java:670"$1$"		}"
"ObjectUtils.java:671"$1$"		if (obj instanceof boolean[]) {"
"ObjectUtils.java:672"$1$"			return nullSafeToString((boolean[]) obj);"
"ObjectUtils.java:673"$1$"		}"
"ObjectUtils.java:674"$1$"		if (obj instanceof byte[]) {"
"ObjectUtils.java:675"$1$"			return nullSafeToString((byte[]) obj);"
"ObjectUtils.java:676"$1$"		}"
"ObjectUtils.java:677"$1$"		if (obj instanceof char[]) {"
"ObjectUtils.java:678"$1$"			return nullSafeToString((char[]) obj);"
"ObjectUtils.java:679"$1$"		}"
"ObjectUtils.java:680"$1$"		if (obj instanceof double[]) {"
"ObjectUtils.java:681"$1$"			return nullSafeToString((double[]) obj);"
"ObjectUtils.java:682"$1$"		}"
"ObjectUtils.java:683"$1$"		if (obj instanceof float[]) {"
"ObjectUtils.java:684"$1$"			return nullSafeToString((float[]) obj);"
"ObjectUtils.java:685"$1$"		}"
"ObjectUtils.java:686"$1$"		if (obj instanceof int[]) {"
"ObjectUtils.java:687"$1$"			return nullSafeToString((int[]) obj);"
"ObjectUtils.java:688"$1$"		}"
"ObjectUtils.java:689"$1$"		if (obj instanceof long[]) {"
"ObjectUtils.java:690"$1$"			return nullSafeToString((long[]) obj);"
"ObjectUtils.java:691"$1$"		}"
"ObjectUtils.java:692"$1$"		if (obj instanceof short[]) {"
"ObjectUtils.java:693"$1$"			return nullSafeToString((short[]) obj);"
"ObjectUtils.java:694"$1$"		}"
"ObjectUtils.java:695"$0$"		String str = obj.toString();"
"ObjectUtils.java:696"$0$"		return (str != null ? str : EMPTY_STRING);"
"ObjectUtils.java:697"$0$"	}"
"ObjectUtils.java:698"$0$""
"ObjectUtils.java:699"$0$"	/**"
"ObjectUtils.java:700"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:701"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:702"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:703"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:704"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:705"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:706"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:707"$0$"	 */"
"ObjectUtils.java:708"$1$"	public static String nullSafeToString(@Nullable Object[] array) {"
"ObjectUtils.java:709"$1$"		if (array == null) {"
"ObjectUtils.java:710"$1$"			return NULL_STRING;"
"ObjectUtils.java:711"$1$"		}"
"ObjectUtils.java:712"$0$"		int length = array.length;"
"ObjectUtils.java:713"$1$"		if (length == 0) {"
"ObjectUtils.java:714"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:715"$1$"		}"
"ObjectUtils.java:716"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:717"$1$"		for (Object o : array) {"
"ObjectUtils.java:718"$1$"			stringJoiner.add(String.valueOf(o));"
"ObjectUtils.java:719"$1$"		}"
"ObjectUtils.java:720"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:721"$0$"	}"
"ObjectUtils.java:722"$0$""
"ObjectUtils.java:723"$0$"	/**"
"ObjectUtils.java:724"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:725"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:726"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:727"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:728"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:729"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:730"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:731"$0$"	 */"
"ObjectUtils.java:732"$1$"	public static String nullSafeToString(@Nullable boolean[] array) {"
"ObjectUtils.java:733"$1$"		if (array == null) {"
"ObjectUtils.java:734"$1$"			return NULL_STRING;"
"ObjectUtils.java:735"$1$"		}"
"ObjectUtils.java:736"$0$"		int length = array.length;"
"ObjectUtils.java:737"$1$"		if (length == 0) {"
"ObjectUtils.java:738"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:739"$1$"		}"
"ObjectUtils.java:740"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:741"$1$"		for (boolean b : array) {"
"ObjectUtils.java:742"$1$"			stringJoiner.add(String.valueOf(b));"
"ObjectUtils.java:743"$1$"		}"
"ObjectUtils.java:744"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:745"$0$"	}"
"ObjectUtils.java:746"$0$""
"ObjectUtils.java:747"$0$"	/**"
"ObjectUtils.java:748"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:749"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:750"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:751"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:752"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:753"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:754"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:755"$0$"	 */"
"ObjectUtils.java:756"$1$"	public static String nullSafeToString(@Nullable byte[] array) {"
"ObjectUtils.java:757"$1$"		if (array == null) {"
"ObjectUtils.java:758"$1$"			return NULL_STRING;"
"ObjectUtils.java:759"$1$"		}"
"ObjectUtils.java:760"$0$"		int length = array.length;"
"ObjectUtils.java:761"$1$"		if (length == 0) {"
"ObjectUtils.java:762"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:763"$1$"		}"
"ObjectUtils.java:764"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:765"$1$"		for (byte b : array) {"
"ObjectUtils.java:766"$1$"			stringJoiner.add(String.valueOf(b));"
"ObjectUtils.java:767"$1$"		}"
"ObjectUtils.java:768"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:769"$0$"	}"
"ObjectUtils.java:770"$0$""
"ObjectUtils.java:771"$0$"	/**"
"ObjectUtils.java:772"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:773"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:774"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:775"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:776"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:777"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:778"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:779"$0$"	 */"
"ObjectUtils.java:780"$1$"	public static String nullSafeToString(@Nullable char[] array) {"
"ObjectUtils.java:781"$1$"		if (array == null) {"
"ObjectUtils.java:782"$1$"			return NULL_STRING;"
"ObjectUtils.java:783"$1$"		}"
"ObjectUtils.java:784"$0$"		int length = array.length;"
"ObjectUtils.java:785"$1$"		if (length == 0) {"
"ObjectUtils.java:786"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:787"$1$"		}"
"ObjectUtils.java:788"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:789"$1$"		for (char c : array) {"
"ObjectUtils.java:790"$1$"			stringJoiner.add('\'' + String.valueOf(c) + '\'');"
"ObjectUtils.java:791"$1$"		}"
"ObjectUtils.java:792"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:793"$0$"	}"
"ObjectUtils.java:794"$0$""
"ObjectUtils.java:795"$0$"	/**"
"ObjectUtils.java:796"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:797"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:798"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:799"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:800"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:801"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:802"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:803"$0$"	 */"
"ObjectUtils.java:804"$1$"	public static String nullSafeToString(@Nullable double[] array) {"
"ObjectUtils.java:805"$1$"		if (array == null) {"
"ObjectUtils.java:806"$1$"			return NULL_STRING;"
"ObjectUtils.java:807"$1$"		}"
"ObjectUtils.java:808"$0$"		int length = array.length;"
"ObjectUtils.java:809"$1$"		if (length == 0) {"
"ObjectUtils.java:810"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:811"$1$"		}"
"ObjectUtils.java:812"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:813"$1$"		for (double d : array) {"
"ObjectUtils.java:814"$1$"			stringJoiner.add(String.valueOf(d));"
"ObjectUtils.java:815"$1$"		}"
"ObjectUtils.java:816"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:817"$0$"	}"
"ObjectUtils.java:818"$0$""
"ObjectUtils.java:819"$0$"	/**"
"ObjectUtils.java:820"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:821"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:822"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:823"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:824"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:825"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:826"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:827"$0$"	 */"
"ObjectUtils.java:828"$1$"	public static String nullSafeToString(@Nullable float[] array) {"
"ObjectUtils.java:829"$1$"		if (array == null) {"
"ObjectUtils.java:830"$1$"			return NULL_STRING;"
"ObjectUtils.java:831"$1$"		}"
"ObjectUtils.java:832"$0$"		int length = array.length;"
"ObjectUtils.java:833"$1$"		if (length == 0) {"
"ObjectUtils.java:834"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:835"$1$"		}"
"ObjectUtils.java:836"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:837"$1$"		for (float f : array) {"
"ObjectUtils.java:838"$1$"			stringJoiner.add(String.valueOf(f));"
"ObjectUtils.java:839"$1$"		}"
"ObjectUtils.java:840"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:841"$0$"	}"
"ObjectUtils.java:842"$0$""
"ObjectUtils.java:843"$0$"	/**"
"ObjectUtils.java:844"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:845"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:846"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:847"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:848"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:849"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:850"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:851"$0$"	 */"
"ObjectUtils.java:852"$1$"	public static String nullSafeToString(@Nullable int[] array) {"
"ObjectUtils.java:853"$1$"		if (array == null) {"
"ObjectUtils.java:854"$1$"			return NULL_STRING;"
"ObjectUtils.java:855"$1$"		}"
"ObjectUtils.java:856"$0$"		int length = array.length;"
"ObjectUtils.java:857"$1$"		if (length == 0) {"
"ObjectUtils.java:858"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:859"$1$"		}"
"ObjectUtils.java:860"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:861"$1$"		for (int i : array) {"
"ObjectUtils.java:862"$1$"			stringJoiner.add(String.valueOf(i));"
"ObjectUtils.java:863"$1$"		}"
"ObjectUtils.java:864"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:865"$0$"	}"
"ObjectUtils.java:866"$0$""
"ObjectUtils.java:867"$0$"	/**"
"ObjectUtils.java:868"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:869"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:870"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:871"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:872"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:873"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:874"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:875"$0$"	 */"
"ObjectUtils.java:876"$1$"	public static String nullSafeToString(@Nullable long[] array) {"
"ObjectUtils.java:877"$1$"		if (array == null) {"
"ObjectUtils.java:878"$1$"			return NULL_STRING;"
"ObjectUtils.java:879"$1$"		}"
"ObjectUtils.java:880"$0$"		int length = array.length;"
"ObjectUtils.java:881"$1$"		if (length == 0) {"
"ObjectUtils.java:882"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:883"$1$"		}"
"ObjectUtils.java:884"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:885"$1$"		for (long l : array) {"
"ObjectUtils.java:886"$1$"			stringJoiner.add(String.valueOf(l));"
"ObjectUtils.java:887"$1$"		}"
"ObjectUtils.java:888"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:889"$0$"	}"
"ObjectUtils.java:890"$0$""
"ObjectUtils.java:891"$0$"	/**"
"ObjectUtils.java:892"$0$"	 * Return a String representation of the contents of the specified array."
"ObjectUtils.java:893"$0$"	 * <p>The String representation consists of a list of the array's elements,"
"ObjectUtils.java:894"$1$"	 * enclosed in curly braces ({@code ""{}""}). Adjacent elements are separated"
"ObjectUtils.java:895"$1$"	 * by the characters {@code "", ""} (a comma followed by a space)."
"ObjectUtils.java:896"$1$"	 * Returns a {@code ""null""} String if {@code array} is {@code null}."
"ObjectUtils.java:897"$0$"	 * @param array the array to build a String representation for"
"ObjectUtils.java:898"$1$"	 * @return a String representation of {@code array}"
"ObjectUtils.java:899"$0$"	 */"
"ObjectUtils.java:900"$1$"	public static String nullSafeToString(@Nullable short[] array) {"
"ObjectUtils.java:901"$1$"		if (array == null) {"
"ObjectUtils.java:902"$1$"			return NULL_STRING;"
"ObjectUtils.java:903"$1$"		}"
"ObjectUtils.java:904"$0$"		int length = array.length;"
"ObjectUtils.java:905"$1$"		if (length == 0) {"
"ObjectUtils.java:906"$1$"			return EMPTY_ARRAY;"
"ObjectUtils.java:907"$1$"		}"
"ObjectUtils.java:908"$0$"		StringJoiner stringJoiner = new StringJoiner(ARRAY_ELEMENT_SEPARATOR, ARRAY_START, ARRAY_END);"
"ObjectUtils.java:909"$1$"		for (short s : array) {"
"ObjectUtils.java:910"$1$"			stringJoiner.add(String.valueOf(s));"
"ObjectUtils.java:911"$1$"		}"
"ObjectUtils.java:912"$0$"		return stringJoiner.toString();"
"ObjectUtils.java:913"$0$"	}"
"ObjectUtils.java:914"$0$""
"ObjectUtils.java:915"$0$"}"
"SimpleNamespaceContext.java:1"$0$"/*"
"SimpleNamespaceContext.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"SimpleNamespaceContext.java:3"$0$" *"
"SimpleNamespaceContext.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleNamespaceContext.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleNamespaceContext.java:6"$0$" * You may obtain a copy of the License at"
"SimpleNamespaceContext.java:7"$0$" *"
"SimpleNamespaceContext.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleNamespaceContext.java:9"$0$" *"
"SimpleNamespaceContext.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleNamespaceContext.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleNamespaceContext.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleNamespaceContext.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleNamespaceContext.java:14"$0$" * limitations under the License."
"SimpleNamespaceContext.java:15"$0$" */"
"SimpleNamespaceContext.java:16"$0$""
"SimpleNamespaceContext.java:17"$0$"package org.springframework.util.xml;"
"SimpleNamespaceContext.java:18"$0$""
"SimpleNamespaceContext.java:19"$0$"import java.util.Collections;"
"SimpleNamespaceContext.java:20"$0$"import java.util.HashMap;"
"SimpleNamespaceContext.java:21"$0$"import java.util.Iterator;"
"SimpleNamespaceContext.java:22"$0$"import java.util.LinkedHashSet;"
"SimpleNamespaceContext.java:23"$0$"import java.util.Map;"
"SimpleNamespaceContext.java:24"$0$"import java.util.Set;"
"SimpleNamespaceContext.java:25"$0$""
"SimpleNamespaceContext.java:26"$0$"import javax.xml.XMLConstants;"
"SimpleNamespaceContext.java:27"$0$"import javax.xml.namespace.NamespaceContext;"
"SimpleNamespaceContext.java:28"$0$""
"SimpleNamespaceContext.java:29"$0$"import org.springframework.lang.Nullable;"
"SimpleNamespaceContext.java:30"$0$"import org.springframework.util.Assert;"
"SimpleNamespaceContext.java:31"$0$""
"SimpleNamespaceContext.java:32"$0$"/**"
"SimpleNamespaceContext.java:33"$1$" * Simple {@code javax.xml.namespace.NamespaceContext} implementation."
"SimpleNamespaceContext.java:34"$1$" * Follows the standard {@code NamespaceContext} contract, and is loadable"
"SimpleNamespaceContext.java:35"$1$" * via a {@code java.util.Map} or {@code java.util.Properties} object"
"SimpleNamespaceContext.java:36"$0$" *"
"SimpleNamespaceContext.java:37"$0$" * @author Arjen Poutsma"
"SimpleNamespaceContext.java:38"$0$" * @author Juergen Hoeller"
"SimpleNamespaceContext.java:39"$0$" * @since 3.0"
"SimpleNamespaceContext.java:40"$0$" */"
"SimpleNamespaceContext.java:41"$1$"public class SimpleNamespaceContext implements NamespaceContext {"
"SimpleNamespaceContext.java:42"$1$""
"SimpleNamespaceContext.java:43"$1$"	private final Map<String, String> prefixToNamespaceUri = new HashMap<>();"
"SimpleNamespaceContext.java:44"$1$""
"SimpleNamespaceContext.java:45"$1$"	private final Map<String, Set<String>> namespaceUriToPrefixes = new HashMap<>();"
"SimpleNamespaceContext.java:46"$1$""
"SimpleNamespaceContext.java:47"$1$"	private String defaultNamespaceUri = """";"
"SimpleNamespaceContext.java:48"$1$""
"SimpleNamespaceContext.java:49"$1$""
"SimpleNamespaceContext.java:50"$1$"	@Override"
"SimpleNamespaceContext.java:51"$1$"	public String getNamespaceURI(String prefix) {"
"SimpleNamespaceContext.java:52"$1$"		Assert.notNull(prefix, ""No prefix given"");"
"SimpleNamespaceContext.java:53"$1$"		if (XMLConstants.XML_NS_PREFIX.equals(prefix)) {"
"SimpleNamespaceContext.java:54"$1$"			return XMLConstants.XML_NS_URI;"
"SimpleNamespaceContext.java:55"$1$"		}"
"SimpleNamespaceContext.java:56"$1$"		else if (XMLConstants.XMLNS_ATTRIBUTE.equals(prefix)) {"
"SimpleNamespaceContext.java:57"$1$"			return XMLConstants.XMLNS_ATTRIBUTE_NS_URI;"
"SimpleNamespaceContext.java:58"$1$"		}"
"SimpleNamespaceContext.java:59"$1$"		else if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {"
"SimpleNamespaceContext.java:60"$1$"			return this.defaultNamespaceUri;"
"SimpleNamespaceContext.java:61"$1$"		}"
"SimpleNamespaceContext.java:62"$1$"		else if (this.prefixToNamespaceUri.containsKey(prefix)) {"
"SimpleNamespaceContext.java:63"$1$"			return this.prefixToNamespaceUri.get(prefix);"
"SimpleNamespaceContext.java:64"$1$"		}"
"SimpleNamespaceContext.java:65"$0$"		return """";"
"SimpleNamespaceContext.java:66"$0$"	}"
"SimpleNamespaceContext.java:67"$0$""
"SimpleNamespaceContext.java:68"$0$"	@Override"
"SimpleNamespaceContext.java:69"$0$"	@Nullable"
"SimpleNamespaceContext.java:70"$1$"	public String getPrefix(String namespaceUri) {"
"SimpleNamespaceContext.java:71"$1$"		Set<String> prefixes = getPrefixesSet(namespaceUri);"
"SimpleNamespaceContext.java:72"$1$"		return (!prefixes.isEmpty() ? prefixes.iterator().next() : null);"
"SimpleNamespaceContext.java:73"$1$"	}"
"SimpleNamespaceContext.java:74"$0$""
"SimpleNamespaceContext.java:75"$0$"	@Override"
"SimpleNamespaceContext.java:76"$1$"	public Iterator<String> getPrefixes(String namespaceUri) {"
"SimpleNamespaceContext.java:77"$1$"		return getPrefixesSet(namespaceUri).iterator();"
"SimpleNamespaceContext.java:78"$1$"	}"
"SimpleNamespaceContext.java:79"$0$""
"SimpleNamespaceContext.java:80"$1$"	private Set<String> getPrefixesSet(String namespaceUri) {"
"SimpleNamespaceContext.java:81"$1$"		Assert.notNull(namespaceUri, ""No namespaceUri given"");"
"SimpleNamespaceContext.java:82"$1$"		if (this.defaultNamespaceUri.equals(namespaceUri)) {"
"SimpleNamespaceContext.java:83"$1$"			return Collections.singleton(XMLConstants.DEFAULT_NS_PREFIX);"
"SimpleNamespaceContext.java:84"$1$"		}"
"SimpleNamespaceContext.java:85"$1$"		else if (XMLConstants.XML_NS_URI.equals(namespaceUri)) {"
"SimpleNamespaceContext.java:86"$1$"			return Collections.singleton(XMLConstants.XML_NS_PREFIX);"
"SimpleNamespaceContext.java:87"$1$"		}"
"SimpleNamespaceContext.java:88"$1$"		else if (XMLConstants.XMLNS_ATTRIBUTE_NS_URI.equals(namespaceUri)) {"
"SimpleNamespaceContext.java:89"$1$"			return Collections.singleton(XMLConstants.XMLNS_ATTRIBUTE);"
"SimpleNamespaceContext.java:90"$1$"		}"
"SimpleNamespaceContext.java:91"$1$"		else {"
"SimpleNamespaceContext.java:92"$1$"			Set<String> prefixes = this.namespaceUriToPrefixes.get(namespaceUri);"
"SimpleNamespaceContext.java:93"$1$"			return (prefixes != null ?  Collections.unmodifiableSet(prefixes) : Collections.emptySet());"
"SimpleNamespaceContext.java:94"$1$"		}"
"SimpleNamespaceContext.java:95"$0$"	}"
"SimpleNamespaceContext.java:96"$0$""
"SimpleNamespaceContext.java:97"$0$""
"SimpleNamespaceContext.java:98"$0$"	/**"
"SimpleNamespaceContext.java:99"$0$"	 * Set the bindings for this namespace context."
"SimpleNamespaceContext.java:100"$0$"	 * The supplied map must consist of string key value pairs."
"SimpleNamespaceContext.java:101"$0$"	 */"
"SimpleNamespaceContext.java:102"$1$"	public void setBindings(Map<String, String> bindings) {"
"SimpleNamespaceContext.java:103"$1$"		bindings.forEach(this::bindNamespaceUri);"
"SimpleNamespaceContext.java:104"$1$"	}"
"SimpleNamespaceContext.java:105"$0$""
"SimpleNamespaceContext.java:106"$0$"	/**"
"SimpleNamespaceContext.java:107"$0$"	 * Bind the given namespace as default namespace."
"SimpleNamespaceContext.java:108"$0$"	 * @param namespaceUri the namespace uri"
"SimpleNamespaceContext.java:109"$0$"	 */"
"SimpleNamespaceContext.java:110"$1$"	public void bindDefaultNamespaceUri(String namespaceUri) {"
"SimpleNamespaceContext.java:111"$1$"		bindNamespaceUri(XMLConstants.DEFAULT_NS_PREFIX, namespaceUri);"
"SimpleNamespaceContext.java:112"$1$"	}"
"SimpleNamespaceContext.java:113"$0$""
"SimpleNamespaceContext.java:114"$0$"	/**"
"SimpleNamespaceContext.java:115"$0$"	 * Bind the given prefix to the given namespace."
"SimpleNamespaceContext.java:116"$0$"	 * @param prefix the namespace prefix"
"SimpleNamespaceContext.java:117"$0$"	 * @param namespaceUri the namespace uri"
"SimpleNamespaceContext.java:118"$0$"	 */"
"SimpleNamespaceContext.java:119"$1$"	public void bindNamespaceUri(String prefix, String namespaceUri) {"
"SimpleNamespaceContext.java:120"$1$"		Assert.notNull(prefix, ""No prefix given"");"
"SimpleNamespaceContext.java:121"$1$"		Assert.notNull(namespaceUri, ""No namespaceUri given"");"
"SimpleNamespaceContext.java:122"$1$"		if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {"
"SimpleNamespaceContext.java:123"$1$"			this.defaultNamespaceUri = namespaceUri;"
"SimpleNamespaceContext.java:124"$1$"		}"
"SimpleNamespaceContext.java:125"$1$"		else {"
"SimpleNamespaceContext.java:126"$1$"			this.prefixToNamespaceUri.put(prefix, namespaceUri);"
"SimpleNamespaceContext.java:127"$1$"			Set<String> prefixes ="
"SimpleNamespaceContext.java:128"$1$"					this.namespaceUriToPrefixes.computeIfAbsent(namespaceUri, k -> new LinkedHashSet<>());"
"SimpleNamespaceContext.java:129"$1$"			prefixes.add(prefix);"
"SimpleNamespaceContext.java:130"$1$"		}"
"SimpleNamespaceContext.java:131"$0$"	}"
"SimpleNamespaceContext.java:132"$0$""
"SimpleNamespaceContext.java:133"$0$"	/**"
"SimpleNamespaceContext.java:134"$0$"	 * Remove the given prefix from this context."
"SimpleNamespaceContext.java:135"$0$"	 * @param prefix the prefix to be removed"
"SimpleNamespaceContext.java:136"$0$"	 */"
"SimpleNamespaceContext.java:137"$1$"	public void removeBinding(@Nullable String prefix) {"
"SimpleNamespaceContext.java:138"$1$"		if (XMLConstants.DEFAULT_NS_PREFIX.equals(prefix)) {"
"SimpleNamespaceContext.java:139"$1$"			this.defaultNamespaceUri = """";"
"SimpleNamespaceContext.java:140"$1$"		}"
"SimpleNamespaceContext.java:141"$1$"		else if (prefix != null) {"
"SimpleNamespaceContext.java:142"$1$"			String namespaceUri = this.prefixToNamespaceUri.remove(prefix);"
"SimpleNamespaceContext.java:143"$1$"			if (namespaceUri != null) {"
"SimpleNamespaceContext.java:144"$1$"				Set<String> prefixes = this.namespaceUriToPrefixes.get(namespaceUri);"
"SimpleNamespaceContext.java:145"$1$"				if (prefixes != null) {"
"SimpleNamespaceContext.java:146"$1$"					prefixes.remove(prefix);"
"SimpleNamespaceContext.java:147"$1$"					if (prefixes.isEmpty()) {"
"SimpleNamespaceContext.java:148"$1$"						this.namespaceUriToPrefixes.remove(namespaceUri);"
"SimpleNamespaceContext.java:149"$1$"					}"
"SimpleNamespaceContext.java:150"$0$"				}"
"SimpleNamespaceContext.java:151"$0$"			}"
"SimpleNamespaceContext.java:152"$0$"		}"
"SimpleNamespaceContext.java:153"$0$"	}"
"SimpleNamespaceContext.java:154"$0$""
"SimpleNamespaceContext.java:155"$0$"	/**"
"SimpleNamespaceContext.java:156"$0$"	 * Remove all declared prefixes."
"SimpleNamespaceContext.java:157"$0$"	 */"
"SimpleNamespaceContext.java:158"$1$"	public void clear() {"
"SimpleNamespaceContext.java:159"$1$"		this.prefixToNamespaceUri.clear();"
"SimpleNamespaceContext.java:160"$1$"		this.namespaceUriToPrefixes.clear();"
"SimpleNamespaceContext.java:161"$1$"	}"
"SimpleNamespaceContext.java:162"$0$""
"SimpleNamespaceContext.java:163"$0$"	/**"
"SimpleNamespaceContext.java:164"$0$"	 * Return all declared prefixes."
"SimpleNamespaceContext.java:165"$0$"	 */"
"SimpleNamespaceContext.java:166"$1$"	public Iterator<String> getBoundPrefixes() {"
"SimpleNamespaceContext.java:167"$1$"		return this.prefixToNamespaceUri.keySet().iterator();"
"SimpleNamespaceContext.java:168"$1$"	}"
"SimpleNamespaceContext.java:169"$0$""
"SimpleNamespaceContext.java:170"$0$"}"
"InvertibleComparator.java:1"$0$"/*"
"InvertibleComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"InvertibleComparator.java:3"$0$" *"
"InvertibleComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"InvertibleComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"InvertibleComparator.java:6"$0$" * You may obtain a copy of the License at"
"InvertibleComparator.java:7"$0$" *"
"InvertibleComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"InvertibleComparator.java:9"$0$" *"
"InvertibleComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"InvertibleComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"InvertibleComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"InvertibleComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"InvertibleComparator.java:14"$0$" * limitations under the License."
"InvertibleComparator.java:15"$0$" */"
"InvertibleComparator.java:16"$0$""
"InvertibleComparator.java:17"$0$"package org.springframework.util.comparator;"
"InvertibleComparator.java:18"$0$""
"InvertibleComparator.java:19"$0$"import java.io.Serializable;"
"InvertibleComparator.java:20"$0$"import java.util.Comparator;"
"InvertibleComparator.java:21"$0$""
"InvertibleComparator.java:22"$0$"import org.springframework.lang.Nullable;"
"InvertibleComparator.java:23"$0$"import org.springframework.util.Assert;"
"InvertibleComparator.java:24"$0$""
"InvertibleComparator.java:25"$0$"/**"
"InvertibleComparator.java:26"$0$" * A decorator for a comparator, with an ""ascending"" flag denoting"
"InvertibleComparator.java:27"$0$" * whether comparison results should be treated in forward (standard"
"InvertibleComparator.java:28"$0$" * ascending) order or flipped for reverse (descending) order."
"InvertibleComparator.java:29"$0$" *"
"InvertibleComparator.java:30"$0$" * @author Keith Donald"
"InvertibleComparator.java:31"$0$" * @author Juergen Hoeller"
"InvertibleComparator.java:32"$0$" * @since 1.2.2"
"InvertibleComparator.java:33"$0$" * @param <T> the type of objects that may be compared by this comparator"
"InvertibleComparator.java:34"$0$" * @deprecated as of Spring Framework 5.0, in favor of the standard JDK 8"
"InvertibleComparator.java:35"$1$" * {@link Comparator#reversed()}"
"InvertibleComparator.java:36"$0$" */"
"InvertibleComparator.java:37"$0$"Deprecated"
"InvertibleComparator.java:38"$0$"SuppressWarnings(""serial"")"
"InvertibleComparator.java:39"$1$"public class InvertibleComparator<T> implements Comparator<T>, Serializable {"
"InvertibleComparator.java:40"$1$""
"InvertibleComparator.java:41"$1$"	private final Comparator<T> comparator;"
"InvertibleComparator.java:42"$1$""
"InvertibleComparator.java:43"$1$"	private boolean ascending = true;"
"InvertibleComparator.java:44"$1$""
"InvertibleComparator.java:45"$1$""
"InvertibleComparator.java:46"$1$"	/**"
"InvertibleComparator.java:47"$1$"	 * Create an InvertibleComparator that sorts ascending by default."
"InvertibleComparator.java:48"$1$"	 * For the actual comparison, the specified Comparator will be used."
"InvertibleComparator.java:49"$1$"	 * @param comparator the comparator to decorate"
"InvertibleComparator.java:50"$1$"	 */"
"InvertibleComparator.java:51"$1$"	public InvertibleComparator(Comparator<T> comparator) {"
"InvertibleComparator.java:52"$1$"		Assert.notNull(comparator, ""Comparator must not be null"");"
"InvertibleComparator.java:53"$1$"		this.comparator = comparator;"
"InvertibleComparator.java:54"$1$"	}"
"InvertibleComparator.java:55"$0$""
"InvertibleComparator.java:56"$0$"	/**"
"InvertibleComparator.java:57"$0$"	 * Create an InvertibleComparator that sorts based on the provided order."
"InvertibleComparator.java:58"$0$"	 * For the actual comparison, the specified Comparator will be used."
"InvertibleComparator.java:59"$0$"	 * @param comparator the comparator to decorate"
"InvertibleComparator.java:60"$0$"	 * @param ascending the sort order: ascending (true) or descending (false)"
"InvertibleComparator.java:61"$0$"	 */"
"InvertibleComparator.java:62"$1$"	public InvertibleComparator(Comparator<T> comparator, boolean ascending) {"
"InvertibleComparator.java:63"$1$"		Assert.notNull(comparator, ""Comparator must not be null"");"
"InvertibleComparator.java:64"$1$"		this.comparator = comparator;"
"InvertibleComparator.java:65"$1$"		setAscending(ascending);"
"InvertibleComparator.java:66"$1$"	}"
"InvertibleComparator.java:67"$0$""
"InvertibleComparator.java:68"$0$""
"InvertibleComparator.java:69"$0$"	/**"
"InvertibleComparator.java:70"$0$"	 * Specify the sort order: ascending (true) or descending (false)."
"InvertibleComparator.java:71"$0$"	 */"
"InvertibleComparator.java:72"$1$"	public void setAscending(boolean ascending) {"
"InvertibleComparator.java:73"$1$"		this.ascending = ascending;"
"InvertibleComparator.java:74"$1$"	}"
"InvertibleComparator.java:75"$0$""
"InvertibleComparator.java:76"$0$"	/**"
"InvertibleComparator.java:77"$0$"	 * Return the sort order: ascending (true) or descending (false)."
"InvertibleComparator.java:78"$0$"	 */"
"InvertibleComparator.java:79"$1$"	public boolean isAscending() {"
"InvertibleComparator.java:80"$1$"		return this.ascending;"
"InvertibleComparator.java:81"$1$"	}"
"InvertibleComparator.java:82"$0$""
"InvertibleComparator.java:83"$0$"	/**"
"InvertibleComparator.java:84"$0$"	 * Invert the sort order: ascending -> descending or"
"InvertibleComparator.java:85"$0$"	 * descending -> ascending."
"InvertibleComparator.java:86"$0$"	 */"
"InvertibleComparator.java:87"$1$"	public void invertOrder() {"
"InvertibleComparator.java:88"$1$"		this.ascending = !this.ascending;"
"InvertibleComparator.java:89"$1$"	}"
"InvertibleComparator.java:90"$0$""
"InvertibleComparator.java:91"$0$""
"InvertibleComparator.java:92"$0$"	@Override"
"InvertibleComparator.java:93"$1$"	public int compare(T o1, T o2) {"
"InvertibleComparator.java:94"$1$"		int result = this.comparator.compare(o1, o2);"
"InvertibleComparator.java:95"$1$"		if (result != 0) {"
"InvertibleComparator.java:96"$0$"			// Invert the order if it is a reverse sort."
"InvertibleComparator.java:97"$1$"			if (!this.ascending) {"
"InvertibleComparator.java:98"$1$"				if (Integer.MIN_VALUE == result) {"
"InvertibleComparator.java:99"$1$"					result = Integer.MAX_VALUE;"
"InvertibleComparator.java:100"$1$"				}"
"InvertibleComparator.java:101"$1$"				else {"
"InvertibleComparator.java:102"$1$"					result *= -1;"
"InvertibleComparator.java:103"$1$"				}"
"InvertibleComparator.java:104"$0$"			}"
"InvertibleComparator.java:105"$0$"			return result;"
"InvertibleComparator.java:106"$0$"		}"
"InvertibleComparator.java:107"$0$"		return 0;"
"InvertibleComparator.java:108"$0$"	}"
"InvertibleComparator.java:109"$0$""
"InvertibleComparator.java:110"$0$"	@Override"
"InvertibleComparator.java:111"$0$"	@SuppressWarnings(""unchecked"")"
"InvertibleComparator.java:112"$1$"	public boolean equals(@Nullable Object other) {"
"InvertibleComparator.java:113"$1$"		if (this == other) {"
"InvertibleComparator.java:114"$1$"			return true;"
"InvertibleComparator.java:115"$1$"		}"
"InvertibleComparator.java:116"$1$"		if (!(other instanceof InvertibleComparator)) {"
"InvertibleComparator.java:117"$1$"			return false;"
"InvertibleComparator.java:118"$1$"		}"
"InvertibleComparator.java:119"$0$"		InvertibleComparator<T> otherComp = (InvertibleComparator<T>) other;"
"InvertibleComparator.java:120"$0$"		return (this.comparator.equals(otherComp.comparator) && this.ascending == otherComp.ascending);"
"InvertibleComparator.java:121"$0$"	}"
"InvertibleComparator.java:122"$0$""
"InvertibleComparator.java:123"$0$"	@Override"
"InvertibleComparator.java:124"$1$"	public int hashCode() {"
"InvertibleComparator.java:125"$1$"		return this.comparator.hashCode();"
"InvertibleComparator.java:126"$1$"	}"
"InvertibleComparator.java:127"$0$""
"InvertibleComparator.java:128"$0$"	@Override"
"InvertibleComparator.java:129"$1$"	public String toString() {"
"InvertibleComparator.java:130"$1$"		return ""InvertibleComparator: ["" + this.comparator + ""]; ascending="" + this.ascending;"
"InvertibleComparator.java:131"$1$"	}"
"InvertibleComparator.java:132"$0$""
"InvertibleComparator.java:133"$0$"}"
"ByteArrayDecoder.java:1"$0$"/*"
"ByteArrayDecoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ByteArrayDecoder.java:3"$0$" *"
"ByteArrayDecoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ByteArrayDecoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ByteArrayDecoder.java:6"$0$" * You may obtain a copy of the License at"
"ByteArrayDecoder.java:7"$0$" *"
"ByteArrayDecoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ByteArrayDecoder.java:9"$0$" *"
"ByteArrayDecoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ByteArrayDecoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ByteArrayDecoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ByteArrayDecoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ByteArrayDecoder.java:14"$0$" * limitations under the License."
"ByteArrayDecoder.java:15"$0$" */"
"ByteArrayDecoder.java:16"$0$""
"ByteArrayDecoder.java:17"$0$"package org.springframework.core.codec;"
"ByteArrayDecoder.java:18"$0$""
"ByteArrayDecoder.java:19"$0$"import java.util.Map;"
"ByteArrayDecoder.java:20"$0$""
"ByteArrayDecoder.java:21"$0$"import org.springframework.core.ResolvableType;"
"ByteArrayDecoder.java:22"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ByteArrayDecoder.java:23"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"ByteArrayDecoder.java:24"$0$"import org.springframework.lang.Nullable;"
"ByteArrayDecoder.java:25"$0$"import org.springframework.util.MimeType;"
"ByteArrayDecoder.java:26"$0$"import org.springframework.util.MimeTypeUtils;"
"ByteArrayDecoder.java:27"$0$""
"ByteArrayDecoder.java:28"$0$"/**"
"ByteArrayDecoder.java:29"$1$" * Decoder for {@code byte} arrays."
"ByteArrayDecoder.java:30"$0$" *"
"ByteArrayDecoder.java:31"$0$" * @author Arjen Poutsma"
"ByteArrayDecoder.java:32"$0$" * @author Rossen Stoyanchev"
"ByteArrayDecoder.java:33"$0$" * @since 5.0"
"ByteArrayDecoder.java:34"$0$" */"
"ByteArrayDecoder.java:35"$1$"public class ByteArrayDecoder extends AbstractDataBufferDecoder<byte[]> {"
"ByteArrayDecoder.java:36"$1$""
"ByteArrayDecoder.java:37"$1$"	public ByteArrayDecoder() {"
"ByteArrayDecoder.java:38"$1$"		super(MimeTypeUtils.ALL);"
"ByteArrayDecoder.java:39"$1$"	}"
"ByteArrayDecoder.java:40"$0$""
"ByteArrayDecoder.java:41"$0$""
"ByteArrayDecoder.java:42"$0$"	@Override"
"ByteArrayDecoder.java:43"$1$"	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ByteArrayDecoder.java:44"$1$"		return (elementType.resolve() == byte[].class && super.canDecode(elementType, mimeType));"
"ByteArrayDecoder.java:45"$1$"	}"
"ByteArrayDecoder.java:46"$0$""
"ByteArrayDecoder.java:47"$0$"	@Override"
"ByteArrayDecoder.java:48"$0$"	public byte[] decode(DataBuffer dataBuffer, ResolvableType elementType,"
"ByteArrayDecoder.java:49"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ByteArrayDecoder.java:50"$1$""
"ByteArrayDecoder.java:51"$1$"		byte[] result = new byte[dataBuffer.readableByteCount()];"
"ByteArrayDecoder.java:52"$1$"		dataBuffer.read(result);"
"ByteArrayDecoder.java:53"$1$"		DataBufferUtils.release(dataBuffer);"
"ByteArrayDecoder.java:54"$1$"		if (logger.isDebugEnabled()) {"
"ByteArrayDecoder.java:55"$1$"			logger.debug(Hints.getLogPrefix(hints) + ""Read "" + result.length + "" bytes"");"
"ByteArrayDecoder.java:56"$1$"		}"
"ByteArrayDecoder.java:57"$0$"		return result;"
"ByteArrayDecoder.java:58"$0$"	}"
"ByteArrayDecoder.java:59"$0$""
"ByteArrayDecoder.java:60"$0$"}"
"StaxEventXMLReader.java:1"$0$"/*"
"StaxEventXMLReader.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"StaxEventXMLReader.java:3"$0$" *"
"StaxEventXMLReader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxEventXMLReader.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxEventXMLReader.java:6"$0$" * You may obtain a copy of the License at"
"StaxEventXMLReader.java:7"$0$" *"
"StaxEventXMLReader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxEventXMLReader.java:9"$0$" *"
"StaxEventXMLReader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxEventXMLReader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxEventXMLReader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxEventXMLReader.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxEventXMLReader.java:14"$0$" * limitations under the License."
"StaxEventXMLReader.java:15"$0$" */"
"StaxEventXMLReader.java:16"$0$""
"StaxEventXMLReader.java:17"$0$"package org.springframework.util.xml;"
"StaxEventXMLReader.java:18"$0$""
"StaxEventXMLReader.java:19"$0$"import java.util.Iterator;"
"StaxEventXMLReader.java:20"$0$""
"StaxEventXMLReader.java:21"$0$"import javax.xml.namespace.QName;"
"StaxEventXMLReader.java:22"$0$"import javax.xml.stream.Location;"
"StaxEventXMLReader.java:23"$0$"import javax.xml.stream.XMLEventReader;"
"StaxEventXMLReader.java:24"$0$"import javax.xml.stream.XMLStreamConstants;"
"StaxEventXMLReader.java:25"$0$"import javax.xml.stream.XMLStreamException;"
"StaxEventXMLReader.java:26"$0$"import javax.xml.stream.events.Attribute;"
"StaxEventXMLReader.java:27"$0$"import javax.xml.stream.events.Characters;"
"StaxEventXMLReader.java:28"$0$"import javax.xml.stream.events.Comment;"
"StaxEventXMLReader.java:29"$0$"import javax.xml.stream.events.DTD;"
"StaxEventXMLReader.java:30"$0$"import javax.xml.stream.events.EndElement;"
"StaxEventXMLReader.java:31"$0$"import javax.xml.stream.events.EntityDeclaration;"
"StaxEventXMLReader.java:32"$0$"import javax.xml.stream.events.EntityReference;"
"StaxEventXMLReader.java:33"$0$"import javax.xml.stream.events.Namespace;"
"StaxEventXMLReader.java:34"$0$"import javax.xml.stream.events.NotationDeclaration;"
"StaxEventXMLReader.java:35"$0$"import javax.xml.stream.events.ProcessingInstruction;"
"StaxEventXMLReader.java:36"$0$"import javax.xml.stream.events.StartDocument;"
"StaxEventXMLReader.java:37"$0$"import javax.xml.stream.events.StartElement;"
"StaxEventXMLReader.java:38"$0$"import javax.xml.stream.events.XMLEvent;"
"StaxEventXMLReader.java:39"$0$""
"StaxEventXMLReader.java:40"$0$"import org.xml.sax.Attributes;"
"StaxEventXMLReader.java:41"$0$"import org.xml.sax.SAXException;"
"StaxEventXMLReader.java:42"$0$"import org.xml.sax.ext.Locator2;"
"StaxEventXMLReader.java:43"$0$"import org.xml.sax.helpers.AttributesImpl;"
"StaxEventXMLReader.java:44"$0$""
"StaxEventXMLReader.java:45"$0$"import org.springframework.lang.Nullable;"
"StaxEventXMLReader.java:46"$0$"import org.springframework.util.StringUtils;"
"StaxEventXMLReader.java:47"$0$""
"StaxEventXMLReader.java:48"$0$"/**"
"StaxEventXMLReader.java:49"$1$" * SAX {@code XMLReader} that reads from a StAX {@code XMLEventReader}. Consumes {@code XMLEvents} from"
"StaxEventXMLReader.java:50"$1$" * an {@code XMLEventReader}, and calls the corresponding methods on the SAX callback interfaces."
"StaxEventXMLReader.java:51"$0$" *"
"StaxEventXMLReader.java:52"$0$" * @author Arjen Poutsma"
"StaxEventXMLReader.java:53"$0$" * @since 3.0"
"StaxEventXMLReader.java:54"$0$" * @see XMLEventReader"
"StaxEventXMLReader.java:55"$0$" * @see #setContentHandler(org.xml.sax.ContentHandler)"
"StaxEventXMLReader.java:56"$0$" * @see #setDTDHandler(org.xml.sax.DTDHandler)"
"StaxEventXMLReader.java:57"$0$" * @see #setEntityResolver(org.xml.sax.EntityResolver)"
"StaxEventXMLReader.java:58"$0$" * @see #setErrorHandler(org.xml.sax.ErrorHandler)"
"StaxEventXMLReader.java:59"$0$" */"
"StaxEventXMLReader.java:60"$0$"SuppressWarnings(""rawtypes"")"
"StaxEventXMLReader.java:61"$1$"class StaxEventXMLReader extends AbstractStaxXMLReader {"
"StaxEventXMLReader.java:62"$1$""
"StaxEventXMLReader.java:63"$1$"	private static final String DEFAULT_XML_VERSION = ""1.0"";"
"StaxEventXMLReader.java:64"$1$""
"StaxEventXMLReader.java:65"$1$"	private final XMLEventReader reader;"
"StaxEventXMLReader.java:66"$1$""
"StaxEventXMLReader.java:67"$1$"	private String xmlVersion = DEFAULT_XML_VERSION;"
"StaxEventXMLReader.java:68"$1$""
"StaxEventXMLReader.java:69"$1$"	@Nullable"
"StaxEventXMLReader.java:70"$1$"	private String encoding;"
"StaxEventXMLReader.java:71"$1$""
"StaxEventXMLReader.java:72"$1$""
"StaxEventXMLReader.java:73"$1$"	/**"
"StaxEventXMLReader.java:74"$1$"	 * Constructs a new instance of the {@code StaxEventXmlReader} that reads from"
"StaxEventXMLReader.java:75"$1$"	 * the given {@code XMLEventReader}. The supplied event reader must be in"
"StaxEventXMLReader.java:76"$1$"	 * {@code XMLStreamConstants.START_DOCUMENT} or {@code XMLStreamConstants.START_ELEMENT} state."
"StaxEventXMLReader.java:77"$1$"	 * @param reader the {@code XMLEventReader} to read from"
"StaxEventXMLReader.java:78"$1$"	 * @throws IllegalStateException if the reader is not at the start of a document or element"
"StaxEventXMLReader.java:79"$1$"	 */"
"StaxEventXMLReader.java:80"$1$"	StaxEventXMLReader(XMLEventReader reader) {"
"StaxEventXMLReader.java:81"$1$"		try {"
"StaxEventXMLReader.java:82"$1$"			XMLEvent event = reader.peek();"
"StaxEventXMLReader.java:83"$1$"			if (event != null && !(event.isStartDocument() || event.isStartElement())) {"
"StaxEventXMLReader.java:84"$1$"				throw new IllegalStateException(""XMLEventReader not at start of document or element"");"
"StaxEventXMLReader.java:85"$1$"			}"
"StaxEventXMLReader.java:86"$0$"		}"
"StaxEventXMLReader.java:87"$1$"		catch (XMLStreamException ex) {"
"StaxEventXMLReader.java:88"$1$"			throw new IllegalStateException(""Could not read first element: "" + ex.getMessage());"
"StaxEventXMLReader.java:89"$1$"		}"
"StaxEventXMLReader.java:90"$0$"		this.reader = reader;"
"StaxEventXMLReader.java:91"$0$"	}"
"StaxEventXMLReader.java:92"$0$""
"StaxEventXMLReader.java:93"$0$""
"StaxEventXMLReader.java:94"$0$"	@Override"
"StaxEventXMLReader.java:95"$1$"	protected void parseInternal() throws SAXException, XMLStreamException {"
"StaxEventXMLReader.java:96"$1$"		boolean documentStarted = false;"
"StaxEventXMLReader.java:97"$1$"		boolean documentEnded = false;"
"StaxEventXMLReader.java:98"$1$"		int elementDepth = 0;"
"StaxEventXMLReader.java:99"$1$"		while (this.reader.hasNext() && elementDepth >= 0) {"
"StaxEventXMLReader.java:100"$1$"			XMLEvent event = this.reader.nextEvent();"
"StaxEventXMLReader.java:101"$1$"			if (!event.isStartDocument() && !event.isEndDocument() && !documentStarted) {"
"StaxEventXMLReader.java:102"$1$"				handleStartDocument(event);"
"StaxEventXMLReader.java:103"$1$"				documentStarted = true;"
"StaxEventXMLReader.java:104"$1$"			}"
"StaxEventXMLReader.java:105"$1$"			switch (event.getEventType()) {"
"StaxEventXMLReader.java:106"$1$"				case XMLStreamConstants.START_DOCUMENT:"
"StaxEventXMLReader.java:107"$1$"					handleStartDocument(event);"
"StaxEventXMLReader.java:108"$1$"					documentStarted = true;"
"StaxEventXMLReader.java:109"$1$"					break;"
"StaxEventXMLReader.java:110"$1$"				case XMLStreamConstants.START_ELEMENT:"
"StaxEventXMLReader.java:111"$1$"					elementDepth++;"
"StaxEventXMLReader.java:112"$1$"					handleStartElement(event.asStartElement());"
"StaxEventXMLReader.java:113"$1$"					break;"
"StaxEventXMLReader.java:114"$1$"				case XMLStreamConstants.END_ELEMENT:"
"StaxEventXMLReader.java:115"$1$"					elementDepth--;"
"StaxEventXMLReader.java:116"$1$"					if (elementDepth >= 0) {"
"StaxEventXMLReader.java:117"$1$"						handleEndElement(event.asEndElement());"
"StaxEventXMLReader.java:118"$1$"					}"
"StaxEventXMLReader.java:119"$0$"					break;"
"StaxEventXMLReader.java:120"$0$"				case XMLStreamConstants.PROCESSING_INSTRUCTION:"
"StaxEventXMLReader.java:121"$0$"					handleProcessingInstruction((ProcessingInstruction) event);"
"StaxEventXMLReader.java:122"$0$"					break;"
"StaxEventXMLReader.java:123"$0$"				case XMLStreamConstants.CHARACTERS:"
"StaxEventXMLReader.java:124"$0$"				case XMLStreamConstants.SPACE:"
"StaxEventXMLReader.java:125"$0$"				case XMLStreamConstants.CDATA:"
"StaxEventXMLReader.java:126"$0$"					handleCharacters(event.asCharacters());"
"StaxEventXMLReader.java:127"$0$"					break;"
"StaxEventXMLReader.java:128"$0$"				case XMLStreamConstants.END_DOCUMENT:"
"StaxEventXMLReader.java:129"$0$"					handleEndDocument();"
"StaxEventXMLReader.java:130"$0$"					documentEnded = true;"
"StaxEventXMLReader.java:131"$0$"					break;"
"StaxEventXMLReader.java:132"$0$"				case XMLStreamConstants.NOTATION_DECLARATION:"
"StaxEventXMLReader.java:133"$0$"					handleNotationDeclaration((NotationDeclaration) event);"
"StaxEventXMLReader.java:134"$0$"					break;"
"StaxEventXMLReader.java:135"$0$"				case XMLStreamConstants.ENTITY_DECLARATION:"
"StaxEventXMLReader.java:136"$0$"					handleEntityDeclaration((EntityDeclaration) event);"
"StaxEventXMLReader.java:137"$0$"					break;"
"StaxEventXMLReader.java:138"$0$"				case XMLStreamConstants.COMMENT:"
"StaxEventXMLReader.java:139"$0$"					handleComment((Comment) event);"
"StaxEventXMLReader.java:140"$0$"					break;"
"StaxEventXMLReader.java:141"$0$"				case XMLStreamConstants.DTD:"
"StaxEventXMLReader.java:142"$0$"					handleDtd((DTD) event);"
"StaxEventXMLReader.java:143"$0$"					break;"
"StaxEventXMLReader.java:144"$0$"				case XMLStreamConstants.ENTITY_REFERENCE:"
"StaxEventXMLReader.java:145"$0$"					handleEntityReference((EntityReference) event);"
"StaxEventXMLReader.java:146"$0$"					break;"
"StaxEventXMLReader.java:147"$0$"			}"
"StaxEventXMLReader.java:148"$0$"		}"
"StaxEventXMLReader.java:149"$1$"		if (documentStarted && !documentEnded) {"
"StaxEventXMLReader.java:150"$1$"			handleEndDocument();"
"StaxEventXMLReader.java:151"$1$"		}"
"StaxEventXMLReader.java:152"$0$""
"StaxEventXMLReader.java:153"$0$"	}"
"StaxEventXMLReader.java:154"$0$""
"StaxEventXMLReader.java:155"$1$"	private void handleStartDocument(final XMLEvent event) throws SAXException {"
"StaxEventXMLReader.java:156"$1$"		if (event.isStartDocument()) {"
"StaxEventXMLReader.java:157"$1$"			StartDocument startDocument = (StartDocument) event;"
"StaxEventXMLReader.java:158"$1$"			String xmlVersion = startDocument.getVersion();"
"StaxEventXMLReader.java:159"$1$"			if (StringUtils.hasLength(xmlVersion)) {"
"StaxEventXMLReader.java:160"$1$"				this.xmlVersion = xmlVersion;"
"StaxEventXMLReader.java:161"$1$"			}"
"StaxEventXMLReader.java:162"$1$"			if (startDocument.encodingSet()) {"
"StaxEventXMLReader.java:163"$1$"				this.encoding = startDocument.getCharacterEncodingScheme();"
"StaxEventXMLReader.java:164"$1$"			}"
"StaxEventXMLReader.java:165"$0$"		}"
"StaxEventXMLReader.java:166"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:167"$1$"			final Location location = event.getLocation();"
"StaxEventXMLReader.java:168"$1$"			getContentHandler().setDocumentLocator(new Locator2() {"
"StaxEventXMLReader.java:169"$1$"				@Override"
"StaxEventXMLReader.java:170"$1$"				public int getColumnNumber() {"
"StaxEventXMLReader.java:171"$1$"					return (location != null ? location.getColumnNumber() : -1);"
"StaxEventXMLReader.java:172"$1$"				}"
"StaxEventXMLReader.java:173"$0$"				@Override"
"StaxEventXMLReader.java:174"$1$"				public int getLineNumber() {"
"StaxEventXMLReader.java:175"$1$"					return (location != null ? location.getLineNumber() : -1);"
"StaxEventXMLReader.java:176"$1$"				}"
"StaxEventXMLReader.java:177"$0$"				@Override"
"StaxEventXMLReader.java:178"$0$"				@Nullable"
"StaxEventXMLReader.java:179"$1$"				public String getPublicId() {"
"StaxEventXMLReader.java:180"$1$"					return (location != null ? location.getPublicId() : null);"
"StaxEventXMLReader.java:181"$1$"				}"
"StaxEventXMLReader.java:182"$0$"				@Override"
"StaxEventXMLReader.java:183"$0$"				@Nullable"
"StaxEventXMLReader.java:184"$1$"				public String getSystemId() {"
"StaxEventXMLReader.java:185"$1$"					return (location != null ? location.getSystemId() : null);"
"StaxEventXMLReader.java:186"$1$"				}"
"StaxEventXMLReader.java:187"$0$"				@Override"
"StaxEventXMLReader.java:188"$1$"				public String getXMLVersion() {"
"StaxEventXMLReader.java:189"$1$"					return xmlVersion;"
"StaxEventXMLReader.java:190"$1$"				}"
"StaxEventXMLReader.java:191"$0$"				@Override"
"StaxEventXMLReader.java:192"$0$"				@Nullable"
"StaxEventXMLReader.java:193"$1$"				public String getEncoding() {"
"StaxEventXMLReader.java:194"$1$"					return encoding;"
"StaxEventXMLReader.java:195"$1$"				}"
"StaxEventXMLReader.java:196"$0$"			});"
"StaxEventXMLReader.java:197"$0$"			getContentHandler().startDocument();"
"StaxEventXMLReader.java:198"$0$"		}"
"StaxEventXMLReader.java:199"$0$"	}"
"StaxEventXMLReader.java:200"$0$""
"StaxEventXMLReader.java:201"$1$"	private void handleStartElement(StartElement startElement) throws SAXException {"
"StaxEventXMLReader.java:202"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:203"$1$"			QName qName = startElement.getName();"
"StaxEventXMLReader.java:204"$1$"			if (hasNamespacesFeature()) {"
"StaxEventXMLReader.java:205"$1$"				for (Iterator i = startElement.getNamespaces(); i.hasNext();) {"
"StaxEventXMLReader.java:206"$1$"					Namespace namespace = (Namespace) i.next();"
"StaxEventXMLReader.java:207"$1$"					startPrefixMapping(namespace.getPrefix(), namespace.getNamespaceURI());"
"StaxEventXMLReader.java:208"$1$"				}"
"StaxEventXMLReader.java:209"$1$"				for (Iterator i = startElement.getAttributes(); i.hasNext();){"
"StaxEventXMLReader.java:210"$1$"					Attribute attribute = (Attribute) i.next();"
"StaxEventXMLReader.java:211"$1$"					QName attributeName = attribute.getName();"
"StaxEventXMLReader.java:212"$1$"					startPrefixMapping(attributeName.getPrefix(), attributeName.getNamespaceURI());"
"StaxEventXMLReader.java:213"$1$"				}"
"StaxEventXMLReader.java:214"$0$""
"StaxEventXMLReader.java:215"$0$"				getContentHandler().startElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName),"
"StaxEventXMLReader.java:216"$0$"						getAttributes(startElement));"
"StaxEventXMLReader.java:217"$0$"			}"
"StaxEventXMLReader.java:218"$1$"			else {"
"StaxEventXMLReader.java:219"$1$"				getContentHandler().startElement("""", """", toQualifiedName(qName), getAttributes(startElement));"
"StaxEventXMLReader.java:220"$1$"			}"
"StaxEventXMLReader.java:221"$0$"		}"
"StaxEventXMLReader.java:222"$0$"	}"
"StaxEventXMLReader.java:223"$0$""
"StaxEventXMLReader.java:224"$1$"	private void handleCharacters(Characters characters) throws SAXException {"
"StaxEventXMLReader.java:225"$1$"		char[] data = characters.getData().toCharArray();"
"StaxEventXMLReader.java:226"$1$"		if (getContentHandler() != null && characters.isIgnorableWhiteSpace()) {"
"StaxEventXMLReader.java:227"$1$"			getContentHandler().ignorableWhitespace(data, 0, data.length);"
"StaxEventXMLReader.java:228"$1$"			return;"
"StaxEventXMLReader.java:229"$1$"		}"
"StaxEventXMLReader.java:230"$1$"		if (characters.isCData() && getLexicalHandler() != null) {"
"StaxEventXMLReader.java:231"$1$"			getLexicalHandler().startCDATA();"
"StaxEventXMLReader.java:232"$1$"		}"
"StaxEventXMLReader.java:233"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:234"$1$"			getContentHandler().characters(data, 0, data.length);"
"StaxEventXMLReader.java:235"$1$"		}"
"StaxEventXMLReader.java:236"$1$"		if (characters.isCData() && getLexicalHandler() != null) {"
"StaxEventXMLReader.java:237"$1$"			getLexicalHandler().endCDATA();"
"StaxEventXMLReader.java:238"$1$"		}"
"StaxEventXMLReader.java:239"$0$"	}"
"StaxEventXMLReader.java:240"$0$""
"StaxEventXMLReader.java:241"$1$"	private void handleEndElement(EndElement endElement) throws SAXException {"
"StaxEventXMLReader.java:242"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:243"$1$"			QName qName = endElement.getName();"
"StaxEventXMLReader.java:244"$1$"			if (hasNamespacesFeature()) {"
"StaxEventXMLReader.java:245"$1$"				getContentHandler().endElement(qName.getNamespaceURI(), qName.getLocalPart(), toQualifiedName(qName));"
"StaxEventXMLReader.java:246"$1$"				for (Iterator i = endElement.getNamespaces(); i.hasNext();) {"
"StaxEventXMLReader.java:247"$1$"					Namespace namespace = (Namespace) i.next();"
"StaxEventXMLReader.java:248"$1$"					endPrefixMapping(namespace.getPrefix());"
"StaxEventXMLReader.java:249"$1$"				}"
"StaxEventXMLReader.java:250"$0$"			}"
"StaxEventXMLReader.java:251"$1$"			else {"
"StaxEventXMLReader.java:252"$1$"				getContentHandler().endElement("""", """", toQualifiedName(qName));"
"StaxEventXMLReader.java:253"$1$"			}"
"StaxEventXMLReader.java:254"$0$""
"StaxEventXMLReader.java:255"$0$"		}"
"StaxEventXMLReader.java:256"$0$"	}"
"StaxEventXMLReader.java:257"$0$""
"StaxEventXMLReader.java:258"$1$"	private void handleEndDocument() throws SAXException {"
"StaxEventXMLReader.java:259"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:260"$1$"			getContentHandler().endDocument();"
"StaxEventXMLReader.java:261"$1$"		}"
"StaxEventXMLReader.java:262"$0$"	}"
"StaxEventXMLReader.java:263"$0$""
"StaxEventXMLReader.java:264"$1$"	private void handleNotationDeclaration(NotationDeclaration declaration) throws SAXException {"
"StaxEventXMLReader.java:265"$1$"		if (getDTDHandler() != null) {"
"StaxEventXMLReader.java:266"$1$"			getDTDHandler().notationDecl(declaration.getName(), declaration.getPublicId(), declaration.getSystemId());"
"StaxEventXMLReader.java:267"$1$"		}"
"StaxEventXMLReader.java:268"$0$"	}"
"StaxEventXMLReader.java:269"$0$""
"StaxEventXMLReader.java:270"$1$"	private void handleEntityDeclaration(EntityDeclaration entityDeclaration) throws SAXException {"
"StaxEventXMLReader.java:271"$1$"		if (getDTDHandler() != null) {"
"StaxEventXMLReader.java:272"$1$"			getDTDHandler().unparsedEntityDecl(entityDeclaration.getName(), entityDeclaration.getPublicId(),"
"StaxEventXMLReader.java:273"$1$"					entityDeclaration.getSystemId(), entityDeclaration.getNotationName());"
"StaxEventXMLReader.java:274"$1$"		}"
"StaxEventXMLReader.java:275"$0$"	}"
"StaxEventXMLReader.java:276"$0$""
"StaxEventXMLReader.java:277"$1$"	private void handleProcessingInstruction(ProcessingInstruction pi) throws SAXException {"
"StaxEventXMLReader.java:278"$1$"		if (getContentHandler() != null) {"
"StaxEventXMLReader.java:279"$1$"			getContentHandler().processingInstruction(pi.getTarget(), pi.getData());"
"StaxEventXMLReader.java:280"$1$"		}"
"StaxEventXMLReader.java:281"$0$"	}"
"StaxEventXMLReader.java:282"$0$""
"StaxEventXMLReader.java:283"$1$"	private void handleComment(Comment comment) throws SAXException {"
"StaxEventXMLReader.java:284"$1$"		if (getLexicalHandler() != null) {"
"StaxEventXMLReader.java:285"$1$"			char[] ch = comment.getText().toCharArray();"
"StaxEventXMLReader.java:286"$1$"			getLexicalHandler().comment(ch, 0, ch.length);"
"StaxEventXMLReader.java:287"$1$"		}"
"StaxEventXMLReader.java:288"$0$"	}"
"StaxEventXMLReader.java:289"$0$""
"StaxEventXMLReader.java:290"$1$"	private void handleDtd(DTD dtd) throws SAXException {"
"StaxEventXMLReader.java:291"$1$"		if (getLexicalHandler() != null) {"
"StaxEventXMLReader.java:292"$1$"			javax.xml.stream.Location location = dtd.getLocation();"
"StaxEventXMLReader.java:293"$1$"			getLexicalHandler().startDTD(null, location.getPublicId(), location.getSystemId());"
"StaxEventXMLReader.java:294"$1$"		}"
"StaxEventXMLReader.java:295"$1$"		if (getLexicalHandler() != null) {"
"StaxEventXMLReader.java:296"$1$"			getLexicalHandler().endDTD();"
"StaxEventXMLReader.java:297"$1$"		}"
"StaxEventXMLReader.java:298"$0$""
"StaxEventXMLReader.java:299"$0$"	}"
"StaxEventXMLReader.java:300"$0$""
"StaxEventXMLReader.java:301"$1$"	private void handleEntityReference(EntityReference reference) throws SAXException {"
"StaxEventXMLReader.java:302"$1$"		if (getLexicalHandler() != null) {"
"StaxEventXMLReader.java:303"$1$"			getLexicalHandler().startEntity(reference.getName());"
"StaxEventXMLReader.java:304"$1$"		}"
"StaxEventXMLReader.java:305"$1$"		if (getLexicalHandler() != null) {"
"StaxEventXMLReader.java:306"$1$"			getLexicalHandler().endEntity(reference.getName());"
"StaxEventXMLReader.java:307"$1$"		}"
"StaxEventXMLReader.java:308"$0$""
"StaxEventXMLReader.java:309"$0$"	}"
"StaxEventXMLReader.java:310"$0$""
"StaxEventXMLReader.java:311"$1$"	private Attributes getAttributes(StartElement event) {"
"StaxEventXMLReader.java:312"$1$"		AttributesImpl attributes = new AttributesImpl();"
"StaxEventXMLReader.java:313"$1$"		for (Iterator i = event.getAttributes(); i.hasNext();) {"
"StaxEventXMLReader.java:314"$1$"			Attribute attribute = (Attribute) i.next();"
"StaxEventXMLReader.java:315"$1$"			QName qName = attribute.getName();"
"StaxEventXMLReader.java:316"$1$"			String namespace = qName.getNamespaceURI();"
"StaxEventXMLReader.java:317"$1$"			if (namespace == null || !hasNamespacesFeature()) {"
"StaxEventXMLReader.java:318"$1$"				namespace = """";"
"StaxEventXMLReader.java:319"$1$"			}"
"StaxEventXMLReader.java:320"$0$"			String type = attribute.getDTDType();"
"StaxEventXMLReader.java:321"$1$"			if (type == null) {"
"StaxEventXMLReader.java:322"$1$"				type = ""CDATA"";"
"StaxEventXMLReader.java:323"$1$"			}"
"StaxEventXMLReader.java:324"$0$"			attributes.addAttribute(namespace, qName.getLocalPart(), toQualifiedName(qName), type, attribute.getValue());"
"StaxEventXMLReader.java:325"$0$"		}"
"StaxEventXMLReader.java:326"$1$"		if (hasNamespacePrefixesFeature()) {"
"StaxEventXMLReader.java:327"$1$"			for (Iterator i = event.getNamespaces(); i.hasNext();) {"
"StaxEventXMLReader.java:328"$1$"				Namespace namespace = (Namespace) i.next();"
"StaxEventXMLReader.java:329"$1$"				String prefix = namespace.getPrefix();"
"StaxEventXMLReader.java:330"$1$"				String namespaceUri = namespace.getNamespaceURI();"
"StaxEventXMLReader.java:331"$1$"				String qName;"
"StaxEventXMLReader.java:332"$1$"				if (StringUtils.hasLength(prefix)) {"
"StaxEventXMLReader.java:333"$1$"					qName = ""xmlns:"" + prefix;"
"StaxEventXMLReader.java:334"$1$"				}"
"StaxEventXMLReader.java:335"$1$"				else {"
"StaxEventXMLReader.java:336"$1$"					qName = ""xmlns"";"
"StaxEventXMLReader.java:337"$1$"				}"
"StaxEventXMLReader.java:338"$0$"				attributes.addAttribute("""", """", qName, ""CDATA"", namespaceUri);"
"StaxEventXMLReader.java:339"$0$"			}"
"StaxEventXMLReader.java:340"$0$"		}"
"StaxEventXMLReader.java:341"$0$""
"StaxEventXMLReader.java:342"$0$"		return attributes;"
"StaxEventXMLReader.java:343"$0$"	}"
"StaxEventXMLReader.java:344"$0$""
"StaxEventXMLReader.java:345"$0$"}"
"AnnotatedElementUtils.java:1"$0$"/*"
"AnnotatedElementUtils.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AnnotatedElementUtils.java:3"$0$" *"
"AnnotatedElementUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotatedElementUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotatedElementUtils.java:6"$0$" * You may obtain a copy of the License at"
"AnnotatedElementUtils.java:7"$0$" *"
"AnnotatedElementUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotatedElementUtils.java:9"$0$" *"
"AnnotatedElementUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotatedElementUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotatedElementUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotatedElementUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotatedElementUtils.java:14"$0$" * limitations under the License."
"AnnotatedElementUtils.java:15"$0$" */"
"AnnotatedElementUtils.java:16"$0$""
"AnnotatedElementUtils.java:17"$0$"package org.springframework.core.annotation;"
"AnnotatedElementUtils.java:18"$0$""
"AnnotatedElementUtils.java:19"$0$"import java.lang.annotation.Annotation;"
"AnnotatedElementUtils.java:20"$0$"import java.lang.reflect.AnnotatedElement;"
"AnnotatedElementUtils.java:21"$0$"import java.util.Collections;"
"AnnotatedElementUtils.java:22"$0$"import java.util.Comparator;"
"AnnotatedElementUtils.java:23"$0$"import java.util.LinkedHashSet;"
"AnnotatedElementUtils.java:24"$0$"import java.util.Set;"
"AnnotatedElementUtils.java:25"$0$"import java.util.stream.Collectors;"
"AnnotatedElementUtils.java:26"$0$""
"AnnotatedElementUtils.java:27"$0$"import org.springframework.core.BridgeMethodResolver;"
"AnnotatedElementUtils.java:28"$0$"import org.springframework.core.annotation.MergedAnnotation.Adapt;"
"AnnotatedElementUtils.java:29"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"AnnotatedElementUtils.java:30"$0$"import org.springframework.lang.Nullable;"
"AnnotatedElementUtils.java:31"$0$"import org.springframework.util.MultiValueMap;"
"AnnotatedElementUtils.java:32"$0$""
"AnnotatedElementUtils.java:33"$0$"/**"
"AnnotatedElementUtils.java:34"$0$" * General utility methods for finding annotations, meta-annotations, and"
"AnnotatedElementUtils.java:35"$1$" * repeatable annotations on {@link AnnotatedElement AnnotatedElements}."
"AnnotatedElementUtils.java:36"$0$" *"
"AnnotatedElementUtils.java:37"$1$" * <p>{@code AnnotatedElementUtils} defines the public API for Spring's"
"AnnotatedElementUtils.java:38"$0$" * meta-annotation programming model with support for <em>annotation attribute"
"AnnotatedElementUtils.java:39"$0$" * overrides</em>. If you do not need support for annotation attribute"
"AnnotatedElementUtils.java:40"$1$" * overrides, consider using {@link AnnotationUtils} instead."
"AnnotatedElementUtils.java:41"$0$" *"
"AnnotatedElementUtils.java:42"$0$" * <p>Note that the features of this class are not provided by the JDK's"
"AnnotatedElementUtils.java:43"$0$" * introspection facilities themselves."
"AnnotatedElementUtils.java:44"$0$" *"
"AnnotatedElementUtils.java:45"$0$" * <h3>Annotation Attribute Overrides</h3>"
"AnnotatedElementUtils.java:46"$0$" * <p>Support for meta-annotations with <em>attribute overrides</em> in"
"AnnotatedElementUtils.java:47"$0$" * <em>composed annotations</em> is provided by all variants of the"
"AnnotatedElementUtils.java:48"$1$" * {@code getMergedAnnotationAttributes()}, {@code getMergedAnnotation()},"
"AnnotatedElementUtils.java:49"$1$" * {@code getAllMergedAnnotations()}, {@code getMergedRepeatableAnnotations()},"
"AnnotatedElementUtils.java:50"$1$" * {@code findMergedAnnotationAttributes()}, {@code findMergedAnnotation()},"
"AnnotatedElementUtils.java:51"$1$" * {@code findAllMergedAnnotations()}, and {@code findMergedRepeatableAnnotations()}"
"AnnotatedElementUtils.java:52"$0$" * methods."
"AnnotatedElementUtils.java:53"$0$" *"
"AnnotatedElementUtils.java:54"$0$" * <h3>Find vs. Get Semantics</h3>"
"AnnotatedElementUtils.java:55"$0$" * <p>The search algorithms used by methods in this class follow either"
"AnnotatedElementUtils.java:56"$0$" * <em>find</em> or <em>get</em> semantics. Consult the javadocs for each"
"AnnotatedElementUtils.java:57"$0$" * individual method for details on which search algorithm is used."
"AnnotatedElementUtils.java:58"$0$" *"
"AnnotatedElementUtils.java:59"$0$" * <p><strong>Get semantics</strong> are limited to searching for annotations"
"AnnotatedElementUtils.java:60"$1$" * that are either <em>present</em> on an {@code AnnotatedElement} (i.e. declared"
"AnnotatedElementUtils.java:61"$1$" * locally or {@linkplain java.lang.annotation.Inherited inherited}) or declared"
"AnnotatedElementUtils.java:62"$1$" * within the annotation hierarchy <em>above</em> the {@code AnnotatedElement}."
"AnnotatedElementUtils.java:63"$0$" *"
"AnnotatedElementUtils.java:64"$0$" * <p><strong>Find semantics</strong> are much more exhaustive, providing"
"AnnotatedElementUtils.java:65"$0$" * <em>get semantics</em> plus support for the following:"
"AnnotatedElementUtils.java:66"$0$" *"
"AnnotatedElementUtils.java:67"$0$" * <ul>"
"AnnotatedElementUtils.java:68"$0$" * <li>Searching on interfaces, if the annotated element is a class"
"AnnotatedElementUtils.java:69"$0$" * <li>Searching on superclasses, if the annotated element is a class"
"AnnotatedElementUtils.java:70"$0$" * <li>Resolving bridged methods, if the annotated element is a method"
"AnnotatedElementUtils.java:71"$0$" * <li>Searching on methods in interfaces, if the annotated element is a method"
"AnnotatedElementUtils.java:72"$0$" * <li>Searching on methods in superclasses, if the annotated element is a method"
"AnnotatedElementUtils.java:73"$0$" * </ul>"
"AnnotatedElementUtils.java:74"$0$" *"
"AnnotatedElementUtils.java:75"$1$" * <h3>Support for {@code @Inherited}</h3>"
"AnnotatedElementUtils.java:76"$0$" * <p>Methods following <em>get semantics</em> will honor the contract of Java's"
"AnnotatedElementUtils.java:77"$1$" * {@link java.lang.annotation.Inherited @Inherited} annotation except that locally"
"AnnotatedElementUtils.java:78"$0$" * declared annotations (including custom composed annotations) will be favored over"
"AnnotatedElementUtils.java:79"$0$" * inherited annotations. In contrast, methods following <em>find semantics</em>"
"AnnotatedElementUtils.java:80"$1$" * will completely ignore the presence of {@code @Inherited} since the <em>find</em>"
"AnnotatedElementUtils.java:81"$0$" * search algorithm manually traverses type and method hierarchies and thereby"
"AnnotatedElementUtils.java:82"$1$" * implicitly supports annotation inheritance without a need for {@code @Inherited}."
"AnnotatedElementUtils.java:83"$0$" *"
"AnnotatedElementUtils.java:84"$0$" * @author Phillip Webb"
"AnnotatedElementUtils.java:85"$0$" * @author Juergen Hoeller"
"AnnotatedElementUtils.java:86"$0$" * @author Sam Brannen"
"AnnotatedElementUtils.java:87"$0$" * @since 4.0"
"AnnotatedElementUtils.java:88"$0$" * @see AliasFor"
"AnnotatedElementUtils.java:89"$0$" * @see AnnotationAttributes"
"AnnotatedElementUtils.java:90"$0$" * @see AnnotationUtils"
"AnnotatedElementUtils.java:91"$0$" * @see BridgeMethodResolver"
"AnnotatedElementUtils.java:92"$0$" */"
"AnnotatedElementUtils.java:93"$1$"public abstract class AnnotatedElementUtils {"
"AnnotatedElementUtils.java:94"$1$""
"AnnotatedElementUtils.java:95"$1$"	/**"
"AnnotatedElementUtils.java:96"$1$"	 * Build an adapted {@link AnnotatedElement} for the given annotations,"
"AnnotatedElementUtils.java:97"$1$"	 * typically for use with other methods on {@link AnnotatedElementUtils}."
"AnnotatedElementUtils.java:98"$1$"	 * @param annotations the annotations to expose through the {@code AnnotatedElement}"
"AnnotatedElementUtils.java:99"$1$"	 * @since 4.3"
"AnnotatedElementUtils.java:100"$1$"	 */"
"AnnotatedElementUtils.java:101"$1$"	public static AnnotatedElement forAnnotations(Annotation... annotations) {"
"AnnotatedElementUtils.java:102"$1$"		return new AnnotatedElementForAnnotations(annotations);"
"AnnotatedElementUtils.java:103"$1$"	}"
"AnnotatedElementUtils.java:104"$0$""
"AnnotatedElementUtils.java:105"$0$"	/**"
"AnnotatedElementUtils.java:106"$0$"	 * Get the fully qualified class names of all meta-annotation types"
"AnnotatedElementUtils.java:107"$1$"	 * <em>present</em> on the annotation (of the specified {@code annotationType})"
"AnnotatedElementUtils.java:108"$1$"	 * on the supplied {@link AnnotatedElement}."
"AnnotatedElementUtils.java:109"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:110"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:111"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:112"$0$"	 * @param annotationType the annotation type on which to find meta-annotations"
"AnnotatedElementUtils.java:113"$0$"	 * @return the names of all meta-annotations present on the annotation,"
"AnnotatedElementUtils.java:114"$0$"	 * or an empty set if not found"
"AnnotatedElementUtils.java:115"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:116"$0$"	 * @see #getMetaAnnotationTypes(AnnotatedElement, String)"
"AnnotatedElementUtils.java:117"$0$"	 * @see #hasMetaAnnotationTypes"
"AnnotatedElementUtils.java:118"$0$"	 */"
"AnnotatedElementUtils.java:119"$0$"	public static Set<String> getMetaAnnotationTypes(AnnotatedElement element,"
"AnnotatedElementUtils.java:120"$1$"			Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:121"$1$""
"AnnotatedElementUtils.java:122"$1$"		return getMetaAnnotationTypes(element, element.getAnnotation(annotationType));"
"AnnotatedElementUtils.java:123"$1$"	}"
"AnnotatedElementUtils.java:124"$0$""
"AnnotatedElementUtils.java:125"$0$"	/**"
"AnnotatedElementUtils.java:126"$0$"	 * Get the fully qualified class names of all meta-annotation"
"AnnotatedElementUtils.java:127"$0$"	 * types <em>present</em> on the annotation (of the specified"
"AnnotatedElementUtils.java:128"$1$"	 * {@code annotationName}) on the supplied {@link AnnotatedElement}."
"AnnotatedElementUtils.java:129"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:130"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:131"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:132"$0$"	 * @param annotationName the fully qualified class name of the annotation"
"AnnotatedElementUtils.java:133"$0$"	 * type on which to find meta-annotations"
"AnnotatedElementUtils.java:134"$0$"	 * @return the names of all meta-annotations present on the annotation,"
"AnnotatedElementUtils.java:135"$0$"	 * or an empty set if none found"
"AnnotatedElementUtils.java:136"$0$"	 * @see #getMetaAnnotationTypes(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:137"$0$"	 * @see #hasMetaAnnotationTypes"
"AnnotatedElementUtils.java:138"$0$"	 */"
"AnnotatedElementUtils.java:139"$1$"	public static Set<String> getMetaAnnotationTypes(AnnotatedElement element, String annotationName) {"
"AnnotatedElementUtils.java:140"$1$"		for (Annotation annotation : element.getAnnotations()) {"
"AnnotatedElementUtils.java:141"$1$"			if (annotation.annotationType().getName().equals(annotationName)) {"
"AnnotatedElementUtils.java:142"$1$"				return getMetaAnnotationTypes(element, annotation);"
"AnnotatedElementUtils.java:143"$1$"			}"
"AnnotatedElementUtils.java:144"$0$"		}"
"AnnotatedElementUtils.java:145"$0$"		return Collections.emptySet();"
"AnnotatedElementUtils.java:146"$0$"	}"
"AnnotatedElementUtils.java:147"$0$""
"AnnotatedElementUtils.java:148"$1$"	private static Set<String> getMetaAnnotationTypes(AnnotatedElement element, @Nullable Annotation annotation) {"
"AnnotatedElementUtils.java:149"$1$"		if (annotation == null) {"
"AnnotatedElementUtils.java:150"$1$"			return Collections.emptySet();"
"AnnotatedElementUtils.java:151"$1$"		}"
"AnnotatedElementUtils.java:152"$0$"		return getAnnotations(annotation.annotationType()).stream()"
"AnnotatedElementUtils.java:153"$0$"				.map(mergedAnnotation -> mergedAnnotation.getType().getName())"
"AnnotatedElementUtils.java:154"$0$"				.collect(Collectors.toCollection(LinkedHashSet::new));"
"AnnotatedElementUtils.java:155"$0$"	}"
"AnnotatedElementUtils.java:156"$0$""
"AnnotatedElementUtils.java:157"$0$"	/**"
"AnnotatedElementUtils.java:158"$1$"	 * Determine if the supplied {@link AnnotatedElement} is annotated with"
"AnnotatedElementUtils.java:159"$0$"	 * a <em>composed annotation</em> that is meta-annotated with an"
"AnnotatedElementUtils.java:160"$1$"	 * annotation of the specified {@code annotationType}."
"AnnotatedElementUtils.java:161"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:162"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:163"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:164"$0$"	 * @param annotationType the meta-annotation type to find"
"AnnotatedElementUtils.java:165"$1$"	 * @return {@code true} if a matching meta-annotation is present"
"AnnotatedElementUtils.java:166"$0$"	 * @since 4.2.3"
"AnnotatedElementUtils.java:167"$0$"	 * @see #getMetaAnnotationTypes"
"AnnotatedElementUtils.java:168"$0$"	 */"
"AnnotatedElementUtils.java:169"$1$"	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:170"$1$"		return getAnnotations(element).stream(annotationType).anyMatch(MergedAnnotation::isMetaPresent);"
"AnnotatedElementUtils.java:171"$1$"	}"
"AnnotatedElementUtils.java:172"$0$""
"AnnotatedElementUtils.java:173"$0$"	/**"
"AnnotatedElementUtils.java:174"$1$"	 * Determine if the supplied {@link AnnotatedElement} is annotated with a"
"AnnotatedElementUtils.java:175"$0$"	 * <em>composed annotation</em> that is meta-annotated with an annotation"
"AnnotatedElementUtils.java:176"$1$"	 * of the specified {@code annotationName}."
"AnnotatedElementUtils.java:177"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:178"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:179"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:180"$0$"	 * @param annotationName the fully qualified class name of the"
"AnnotatedElementUtils.java:181"$0$"	 * meta-annotation type to find"
"AnnotatedElementUtils.java:182"$1$"	 * @return {@code true} if a matching meta-annotation is present"
"AnnotatedElementUtils.java:183"$0$"	 * @see #getMetaAnnotationTypes"
"AnnotatedElementUtils.java:184"$0$"	 */"
"AnnotatedElementUtils.java:185"$1$"	public static boolean hasMetaAnnotationTypes(AnnotatedElement element, String annotationName) {"
"AnnotatedElementUtils.java:186"$1$"		return getAnnotations(element).stream(annotationName).anyMatch(MergedAnnotation::isMetaPresent);"
"AnnotatedElementUtils.java:187"$1$"	}"
"AnnotatedElementUtils.java:188"$0$""
"AnnotatedElementUtils.java:189"$0$"	/**"
"AnnotatedElementUtils.java:190"$1$"	 * Determine if an annotation of the specified {@code annotationType}"
"AnnotatedElementUtils.java:191"$1$"	 * is <em>present</em> on the supplied {@link AnnotatedElement} or"
"AnnotatedElementUtils.java:192"$0$"	 * within the annotation hierarchy <em>above</em> the specified element."
"AnnotatedElementUtils.java:193"$1$"	 * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}"
"AnnotatedElementUtils.java:194"$0$"	 * will return a non-null value."
"AnnotatedElementUtils.java:195"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:196"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:197"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:198"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:199"$1$"	 * @return {@code true} if a matching annotation is present"
"AnnotatedElementUtils.java:200"$0$"	 * @since 4.2.3"
"AnnotatedElementUtils.java:201"$0$"	 * @see #hasAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:202"$0$"	 */"
"AnnotatedElementUtils.java:203"$1$"	public static boolean isAnnotated(AnnotatedElement element, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:204"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotatedElementUtils.java:205"$1$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotatedElementUtils.java:206"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {"
"AnnotatedElementUtils.java:207"$1$"			return element.isAnnotationPresent(annotationType);"
"AnnotatedElementUtils.java:208"$1$"		}"
"AnnotatedElementUtils.java:209"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotatedElementUtils.java:210"$0$"		return getAnnotations(element).isPresent(annotationType);"
"AnnotatedElementUtils.java:211"$0$"	}"
"AnnotatedElementUtils.java:212"$0$""
"AnnotatedElementUtils.java:213"$0$"	/**"
"AnnotatedElementUtils.java:214"$1$"	 * Determine if an annotation of the specified {@code annotationName} is"
"AnnotatedElementUtils.java:215"$1$"	 * <em>present</em> on the supplied {@link AnnotatedElement} or within the"
"AnnotatedElementUtils.java:216"$0$"	 * annotation hierarchy <em>above</em> the specified element."
"AnnotatedElementUtils.java:217"$1$"	 * <p>If this method returns {@code true}, then {@link #getMergedAnnotationAttributes}"
"AnnotatedElementUtils.java:218"$0$"	 * will return a non-null value."
"AnnotatedElementUtils.java:219"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:220"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:221"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:222"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:223"$1$"	 * @return {@code true} if a matching annotation is present"
"AnnotatedElementUtils.java:224"$0$"	 */"
"AnnotatedElementUtils.java:225"$1$"	public static boolean isAnnotated(AnnotatedElement element, String annotationName) {"
"AnnotatedElementUtils.java:226"$1$"		return getAnnotations(element).isPresent(annotationName);"
"AnnotatedElementUtils.java:227"$1$"	}"
"AnnotatedElementUtils.java:228"$0$""
"AnnotatedElementUtils.java:229"$0$"	/**"
"AnnotatedElementUtils.java:230"$1$"	 * Get the first annotation of the specified {@code annotationType} within"
"AnnotatedElementUtils.java:231"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element} and"
"AnnotatedElementUtils.java:232"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:233"$0$"	 * annotations in lower levels of the annotation hierarchy."
"AnnotatedElementUtils.java:234"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:235"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:236"$1$"	 * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)}."
"AnnotatedElementUtils.java:237"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:238"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:239"$1$"	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found"
"AnnotatedElementUtils.java:240"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:241"$0$"	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:242"$0$"	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:243"$0$"	 * @see #getMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:244"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:245"$0$"	 */"
"AnnotatedElementUtils.java:246"$0$"	@Nullable"
"AnnotatedElementUtils.java:247"$0$"	public static AnnotationAttributes getMergedAnnotationAttributes("
"AnnotatedElementUtils.java:248"$1$"			AnnotatedElement element, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:249"$1$""
"AnnotatedElementUtils.java:250"$1$"		MergedAnnotation<?> mergedAnnotation = getAnnotations(element)"
"AnnotatedElementUtils.java:251"$1$"				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());"
"AnnotatedElementUtils.java:252"$1$"		return getAnnotationAttributes(mergedAnnotation, false, false);"
"AnnotatedElementUtils.java:253"$1$"	}"
"AnnotatedElementUtils.java:254"$0$""
"AnnotatedElementUtils.java:255"$0$"	/**"
"AnnotatedElementUtils.java:256"$1$"	 * Get the first annotation of the specified {@code annotationName} within"
"AnnotatedElementUtils.java:257"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element} and"
"AnnotatedElementUtils.java:258"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:259"$0$"	 * annotations in lower levels of the annotation hierarchy."
"AnnotatedElementUtils.java:260"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:261"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:262"$1$"	 * <p>This method delegates to {@link #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)},"
"AnnotatedElementUtils.java:263"$1$"	 * supplying {@code false} for {@code classValuesAsString} and {@code nestedAnnotationsAsMap}."
"AnnotatedElementUtils.java:264"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:265"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:266"$1$"	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found"
"AnnotatedElementUtils.java:267"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:268"$0$"	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:269"$0$"	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:270"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:271"$0$"	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)"
"AnnotatedElementUtils.java:272"$0$"	 */"
"AnnotatedElementUtils.java:273"$0$"	@Nullable"
"AnnotatedElementUtils.java:274"$0$"	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,"
"AnnotatedElementUtils.java:275"$1$"			String annotationName) {"
"AnnotatedElementUtils.java:276"$1$""
"AnnotatedElementUtils.java:277"$1$"		return getMergedAnnotationAttributes(element, annotationName, false, false);"
"AnnotatedElementUtils.java:278"$1$"	}"
"AnnotatedElementUtils.java:279"$0$""
"AnnotatedElementUtils.java:280"$0$"	/**"
"AnnotatedElementUtils.java:281"$1$"	 * Get the first annotation of the specified {@code annotationName} within"
"AnnotatedElementUtils.java:282"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element} and"
"AnnotatedElementUtils.java:283"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:284"$0$"	 * annotations in lower levels of the annotation hierarchy."
"AnnotatedElementUtils.java:285"$0$"	 * <p>Attributes from lower levels in the annotation hierarchy override attributes"
"AnnotatedElementUtils.java:286"$1$"	 * of the same name from higher levels, and {@link AliasFor @AliasFor} semantics are"
"AnnotatedElementUtils.java:287"$0$"	 * fully supported, both within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:288"$1$"	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm used by"
"AnnotatedElementUtils.java:289"$0$"	 * this method will stop searching the annotation hierarchy once the first annotation"
"AnnotatedElementUtils.java:290"$1$"	 * of the specified {@code annotationName} has been found. As a consequence,"
"AnnotatedElementUtils.java:291"$1$"	 * additional annotations of the specified {@code annotationName} will be ignored."
"AnnotatedElementUtils.java:292"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:293"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:294"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:295"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:296"$0$"	 * @param classValuesAsString whether to convert Class references into Strings or to"
"AnnotatedElementUtils.java:297"$0$"	 * preserve them as Class references"
"AnnotatedElementUtils.java:298"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances"
"AnnotatedElementUtils.java:299"$1$"	 * into {@code AnnotationAttributes} maps or to preserve them as Annotation instances"
"AnnotatedElementUtils.java:300"$1$"	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found"
"AnnotatedElementUtils.java:301"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:302"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:303"$0$"	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:304"$0$"	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:305"$0$"	 */"
"AnnotatedElementUtils.java:306"$0$"	@Nullable"
"AnnotatedElementUtils.java:307"$0$"	public static AnnotationAttributes getMergedAnnotationAttributes(AnnotatedElement element,"
"AnnotatedElementUtils.java:308"$1$"			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotatedElementUtils.java:309"$1$""
"AnnotatedElementUtils.java:310"$1$"		MergedAnnotation<?> mergedAnnotation = getAnnotations(element)"
"AnnotatedElementUtils.java:311"$1$"				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());"
"AnnotatedElementUtils.java:312"$1$"		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);"
"AnnotatedElementUtils.java:313"$1$"	}"
"AnnotatedElementUtils.java:314"$0$""
"AnnotatedElementUtils.java:315"$0$"	/**"
"AnnotatedElementUtils.java:316"$1$"	 * Get the first annotation of the specified {@code annotationType} within"
"AnnotatedElementUtils.java:317"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element},"
"AnnotatedElementUtils.java:318"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:319"$0$"	 * annotations in lower levels of the annotation hierarchy, and synthesize"
"AnnotatedElementUtils.java:320"$1$"	 * the result back into an annotation of the specified {@code annotationType}."
"AnnotatedElementUtils.java:321"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:322"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:323"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:324"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:325"$1$"	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found"
"AnnotatedElementUtils.java:326"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:327"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:328"$0$"	 */"
"AnnotatedElementUtils.java:329"$0$"	@Nullable"
"AnnotatedElementUtils.java:330"$1$"	public static <A extends Annotation> A getMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {"
"AnnotatedElementUtils.java:331"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotatedElementUtils.java:332"$1$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotatedElementUtils.java:333"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {"
"AnnotatedElementUtils.java:334"$1$"			return element.getDeclaredAnnotation(annotationType);"
"AnnotatedElementUtils.java:335"$1$"		}"
"AnnotatedElementUtils.java:336"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotatedElementUtils.java:337"$0$"		return getAnnotations(element)"
"AnnotatedElementUtils.java:338"$0$"				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())"
"AnnotatedElementUtils.java:339"$0$"				.synthesize(MergedAnnotation::isPresent).orElse(null);"
"AnnotatedElementUtils.java:340"$0$"	}"
"AnnotatedElementUtils.java:341"$0$""
"AnnotatedElementUtils.java:342"$0$"	/**"
"AnnotatedElementUtils.java:343"$1$"	 * Get <strong>all</strong> annotations of the specified {@code annotationType}"
"AnnotatedElementUtils.java:344"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:345"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:346"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:347"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:348"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:349"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:350"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:351"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:352"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:353"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:354"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:355"$1$"	 * @return the set of all merged, synthesized {@code Annotations} found,"
"AnnotatedElementUtils.java:356"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:357"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:358"$0$"	 * @see #getMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:359"$0$"	 * @see #getAllAnnotationAttributes(AnnotatedElement, String)"
"AnnotatedElementUtils.java:360"$0$"	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:361"$0$"	 */"
"AnnotatedElementUtils.java:362"$0$"	public static <A extends Annotation> Set<A> getAllMergedAnnotations("
"AnnotatedElementUtils.java:363"$1$"			AnnotatedElement element, Class<A> annotationType) {"
"AnnotatedElementUtils.java:364"$1$""
"AnnotatedElementUtils.java:365"$1$"		return getAnnotations(element).stream(annotationType)"
"AnnotatedElementUtils.java:366"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:367"$1$"	}"
"AnnotatedElementUtils.java:368"$0$""
"AnnotatedElementUtils.java:369"$0$"	/**"
"AnnotatedElementUtils.java:370"$1$"	 * Get <strong>all</strong> annotations of the specified {@code annotationTypes}"
"AnnotatedElementUtils.java:371"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:372"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:373"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the"
"AnnotatedElementUtils.java:374"$0$"	 * annotation hierarchy and synthesize the results back into an annotation"
"AnnotatedElementUtils.java:375"$1$"	 * of the corresponding {@code annotationType}."
"AnnotatedElementUtils.java:376"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:377"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:378"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:379"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:380"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:381"$0$"	 * @param annotationTypes the annotation types to find"
"AnnotatedElementUtils.java:382"$1$"	 * @return the set of all merged, synthesized {@code Annotations} found,"
"AnnotatedElementUtils.java:383"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:384"$0$"	 * @since 5.1"
"AnnotatedElementUtils.java:385"$0$"	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:386"$0$"	 */"
"AnnotatedElementUtils.java:387"$0$"	public static Set<Annotation> getAllMergedAnnotations(AnnotatedElement element,"
"AnnotatedElementUtils.java:388"$1$"			Set<Class<? extends Annotation>> annotationTypes) {"
"AnnotatedElementUtils.java:389"$1$""
"AnnotatedElementUtils.java:390"$1$"		return getAnnotations(element).stream()"
"AnnotatedElementUtils.java:391"$1$"				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))"
"AnnotatedElementUtils.java:392"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:393"$1$"	}"
"AnnotatedElementUtils.java:394"$0$""
"AnnotatedElementUtils.java:395"$0$"	/**"
"AnnotatedElementUtils.java:396"$1$"	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}"
"AnnotatedElementUtils.java:397"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:398"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:399"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:400"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:401"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:402"$0$"	 * <p>The container type that holds the repeatable annotations will be looked up"
"AnnotatedElementUtils.java:403"$1$"	 * via {@link java.lang.annotation.Repeatable}."
"AnnotatedElementUtils.java:404"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:405"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:406"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:407"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:408"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:409"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:410"$1$"	 * @return the set of all merged repeatable {@code Annotations} found,"
"AnnotatedElementUtils.java:411"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:412"$1$"	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}"
"AnnotatedElementUtils.java:413"$1$"	 * is {@code null}, or if the container type cannot be resolved"
"AnnotatedElementUtils.java:414"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:415"$0$"	 * @see #getMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:416"$0$"	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:417"$0$"	 * @see #getMergedRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotatedElementUtils.java:418"$0$"	 */"
"AnnotatedElementUtils.java:419"$0$"	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations("
"AnnotatedElementUtils.java:420"$1$"			AnnotatedElement element, Class<A> annotationType) {"
"AnnotatedElementUtils.java:421"$1$""
"AnnotatedElementUtils.java:422"$1$"		return getMergedRepeatableAnnotations(element, annotationType, null);"
"AnnotatedElementUtils.java:423"$1$"	}"
"AnnotatedElementUtils.java:424"$0$""
"AnnotatedElementUtils.java:425"$0$"	/**"
"AnnotatedElementUtils.java:426"$1$"	 * Get all <em>repeatable annotations</em> of the specified {@code annotationType}"
"AnnotatedElementUtils.java:427"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:428"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:429"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:430"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:431"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:432"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:433"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:434"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:435"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:436"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:437"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:438"$0$"	 * @param containerType the type of the container that holds the annotations;"
"AnnotatedElementUtils.java:439"$1$"	 * may be {@code null} if the container type should be looked up via"
"AnnotatedElementUtils.java:440"$1$"	 * {@link java.lang.annotation.Repeatable}"
"AnnotatedElementUtils.java:441"$1$"	 * @return the set of all merged repeatable {@code Annotations} found,"
"AnnotatedElementUtils.java:442"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:443"$1$"	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}"
"AnnotatedElementUtils.java:444"$1$"	 * is {@code null}, or if the container type cannot be resolved"
"AnnotatedElementUtils.java:445"$1$"	 * @throws AnnotationConfigurationException if the supplied {@code containerType}"
"AnnotatedElementUtils.java:446"$1$"	 * is not a valid container annotation for the supplied {@code annotationType}"
"AnnotatedElementUtils.java:447"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:448"$0$"	 * @see #getMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:449"$0$"	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:450"$0$"	 */"
"AnnotatedElementUtils.java:451"$0$"	public static <A extends Annotation> Set<A> getMergedRepeatableAnnotations("
"AnnotatedElementUtils.java:452"$0$"			AnnotatedElement element, Class<A> annotationType,"
"AnnotatedElementUtils.java:453"$1$"			@Nullable Class<? extends Annotation> containerType) {"
"AnnotatedElementUtils.java:454"$1$""
"AnnotatedElementUtils.java:455"$1$"		return getRepeatableAnnotations(element, containerType, annotationType)"
"AnnotatedElementUtils.java:456"$1$"				.stream(annotationType)"
"AnnotatedElementUtils.java:457"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:458"$1$"	}"
"AnnotatedElementUtils.java:459"$0$""
"AnnotatedElementUtils.java:460"$0$"	/**"
"AnnotatedElementUtils.java:461"$0$"	 * Get the annotation attributes of <strong>all</strong> annotations of the specified"
"AnnotatedElementUtils.java:462"$1$"	 * {@code annotationName} in the annotation hierarchy above the supplied"
"AnnotatedElementUtils.java:463"$1$"	 * {@link AnnotatedElement} and store the results in a {@link MultiValueMap}."
"AnnotatedElementUtils.java:464"$1$"	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},"
"AnnotatedElementUtils.java:465"$0$"	 * this method does <em>not</em> support attribute overrides."
"AnnotatedElementUtils.java:466"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:467"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:468"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:469"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:470"$1$"	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation"
"AnnotatedElementUtils.java:471"$1$"	 * attributes from all annotations found, or {@code null} if not found"
"AnnotatedElementUtils.java:472"$0$"	 * @see #getAllAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:473"$0$"	 */"
"AnnotatedElementUtils.java:474"$0$"	@Nullable"
"AnnotatedElementUtils.java:475"$0$"	public static MultiValueMap<String, Object> getAllAnnotationAttributes("
"AnnotatedElementUtils.java:476"$1$"			AnnotatedElement element, String annotationName) {"
"AnnotatedElementUtils.java:477"$1$""
"AnnotatedElementUtils.java:478"$1$"		return getAllAnnotationAttributes(element, annotationName, false, false);"
"AnnotatedElementUtils.java:479"$1$"	}"
"AnnotatedElementUtils.java:480"$0$""
"AnnotatedElementUtils.java:481"$0$"	/**"
"AnnotatedElementUtils.java:482"$0$"	 * Get the annotation attributes of <strong>all</strong> annotations of"
"AnnotatedElementUtils.java:483"$1$"	 * the specified {@code annotationName} in the annotation hierarchy above"
"AnnotatedElementUtils.java:484"$1$"	 * the supplied {@link AnnotatedElement} and store the results in a"
"AnnotatedElementUtils.java:485"$1$"	 * {@link MultiValueMap}."
"AnnotatedElementUtils.java:486"$1$"	 * <p>Note: in contrast to {@link #getMergedAnnotationAttributes(AnnotatedElement, String)},"
"AnnotatedElementUtils.java:487"$0$"	 * this method does <em>not</em> support attribute overrides."
"AnnotatedElementUtils.java:488"$0$"	 * <p>This method follows <em>get semantics</em> as described in the"
"AnnotatedElementUtils.java:489"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:490"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:491"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:492"$0$"	 * @param classValuesAsString whether to convert Class references into Strings or to"
"AnnotatedElementUtils.java:493"$0$"	 * preserve them as Class references"
"AnnotatedElementUtils.java:494"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into"
"AnnotatedElementUtils.java:495"$1$"	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances"
"AnnotatedElementUtils.java:496"$1$"	 * @return a {@link MultiValueMap} keyed by attribute name, containing the annotation"
"AnnotatedElementUtils.java:497"$1$"	 * attributes from all annotations found, or {@code null} if not found"
"AnnotatedElementUtils.java:498"$0$"	 */"
"AnnotatedElementUtils.java:499"$0$"	@Nullable"
"AnnotatedElementUtils.java:500"$0$"	public static MultiValueMap<String, Object> getAllAnnotationAttributes(AnnotatedElement element,"
"AnnotatedElementUtils.java:501"$1$"			String annotationName, final boolean classValuesAsString, final boolean nestedAnnotationsAsMap) {"
"AnnotatedElementUtils.java:502"$1$""
"AnnotatedElementUtils.java:503"$1$"		Adapt[] adaptations = Adapt.values(classValuesAsString, nestedAnnotationsAsMap);"
"AnnotatedElementUtils.java:504"$1$"		return getAnnotations(element).stream(annotationName)"
"AnnotatedElementUtils.java:505"$1$"				.filter(MergedAnnotationPredicates.unique(MergedAnnotation::getMetaTypes))"
"AnnotatedElementUtils.java:506"$1$"				.map(MergedAnnotation::withNonMergedAttributes)"
"AnnotatedElementUtils.java:507"$1$"				.collect(MergedAnnotationCollectors.toMultiValueMap(AnnotatedElementUtils::nullIfEmpty, adaptations));"
"AnnotatedElementUtils.java:508"$1$"	}"
"AnnotatedElementUtils.java:509"$0$""
"AnnotatedElementUtils.java:510"$0$"	/**"
"AnnotatedElementUtils.java:511"$1$"	 * Determine if an annotation of the specified {@code annotationType}"
"AnnotatedElementUtils.java:512"$1$"	 * is <em>available</em> on the supplied {@link AnnotatedElement} or"
"AnnotatedElementUtils.java:513"$0$"	 * within the annotation hierarchy <em>above</em> the specified element."
"AnnotatedElementUtils.java:514"$1$"	 * <p>If this method returns {@code true}, then {@link #findMergedAnnotationAttributes}"
"AnnotatedElementUtils.java:515"$0$"	 * will return a non-null value."
"AnnotatedElementUtils.java:516"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:517"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:518"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:519"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:520"$1$"	 * @return {@code true} if a matching annotation is present"
"AnnotatedElementUtils.java:521"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:522"$0$"	 * @see #isAnnotated(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:523"$0$"	 */"
"AnnotatedElementUtils.java:524"$1$"	public static boolean hasAnnotation(AnnotatedElement element, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:525"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotatedElementUtils.java:526"$1$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotatedElementUtils.java:527"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {"
"AnnotatedElementUtils.java:528"$1$"			return element.isAnnotationPresent(annotationType);"
"AnnotatedElementUtils.java:529"$1$"		}"
"AnnotatedElementUtils.java:530"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotatedElementUtils.java:531"$0$"		return findAnnotations(element).isPresent(annotationType);"
"AnnotatedElementUtils.java:532"$0$"	}"
"AnnotatedElementUtils.java:533"$0$""
"AnnotatedElementUtils.java:534"$0$"	/**"
"AnnotatedElementUtils.java:535"$1$"	 * Find the first annotation of the specified {@code annotationType} within"
"AnnotatedElementUtils.java:536"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element} and"
"AnnotatedElementUtils.java:537"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:538"$0$"	 * annotations in lower levels of the annotation hierarchy."
"AnnotatedElementUtils.java:539"$0$"	 * <p>Attributes from lower levels in the annotation hierarchy override"
"AnnotatedElementUtils.java:540"$0$"	 * attributes of the same name from higher levels, and"
"AnnotatedElementUtils.java:541"$1$"	 * {@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:542"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:543"$1$"	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search algorithm"
"AnnotatedElementUtils.java:544"$0$"	 * used by this method will stop searching the annotation hierarchy once the"
"AnnotatedElementUtils.java:545"$1$"	 * first annotation of the specified {@code annotationType} has been found."
"AnnotatedElementUtils.java:546"$0$"	 * As a consequence, additional annotations of the specified"
"AnnotatedElementUtils.java:547"$1$"	 * {@code annotationType} will be ignored."
"AnnotatedElementUtils.java:548"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:549"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:550"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:551"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:552"$0$"	 * @param classValuesAsString whether to convert Class references into"
"AnnotatedElementUtils.java:553"$0$"	 * Strings or to preserve them as Class references"
"AnnotatedElementUtils.java:554"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into"
"AnnotatedElementUtils.java:555"$1$"	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances"
"AnnotatedElementUtils.java:556"$1$"	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found"
"AnnotatedElementUtils.java:557"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:558"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:559"$0$"	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:560"$0$"	 */"
"AnnotatedElementUtils.java:561"$0$"	@Nullable"
"AnnotatedElementUtils.java:562"$0$"	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,"
"AnnotatedElementUtils.java:563"$1$"			Class<? extends Annotation> annotationType, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotatedElementUtils.java:564"$1$""
"AnnotatedElementUtils.java:565"$1$"		MergedAnnotation<?> mergedAnnotation = findAnnotations(element)"
"AnnotatedElementUtils.java:566"$1$"				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared());"
"AnnotatedElementUtils.java:567"$1$"		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);"
"AnnotatedElementUtils.java:568"$1$"	}"
"AnnotatedElementUtils.java:569"$0$""
"AnnotatedElementUtils.java:570"$0$"	/**"
"AnnotatedElementUtils.java:571"$1$"	 * Find the first annotation of the specified {@code annotationName} within"
"AnnotatedElementUtils.java:572"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element} and"
"AnnotatedElementUtils.java:573"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:574"$0$"	 * annotations in lower levels of the annotation hierarchy."
"AnnotatedElementUtils.java:575"$0$"	 * <p>Attributes from lower levels in the annotation hierarchy override"
"AnnotatedElementUtils.java:576"$0$"	 * attributes of the same name from higher levels, and"
"AnnotatedElementUtils.java:577"$1$"	 * {@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:578"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:579"$1$"	 * <p>In contrast to {@link #getAllAnnotationAttributes}, the search"
"AnnotatedElementUtils.java:580"$0$"	 * algorithm used by this method will stop searching the annotation"
"AnnotatedElementUtils.java:581"$0$"	 * hierarchy once the first annotation of the specified"
"AnnotatedElementUtils.java:582"$1$"	 * {@code annotationName} has been found. As a consequence, additional"
"AnnotatedElementUtils.java:583"$1$"	 * annotations of the specified {@code annotationName} will be ignored."
"AnnotatedElementUtils.java:584"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:585"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:586"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:587"$0$"	 * @param annotationName the fully qualified class name of the annotation type to find"
"AnnotatedElementUtils.java:588"$0$"	 * @param classValuesAsString whether to convert Class references into Strings or to"
"AnnotatedElementUtils.java:589"$0$"	 * preserve them as Class references"
"AnnotatedElementUtils.java:590"$0$"	 * @param nestedAnnotationsAsMap whether to convert nested Annotation instances into"
"AnnotatedElementUtils.java:591"$1$"	 * {@code AnnotationAttributes} maps or to preserve them as Annotation instances"
"AnnotatedElementUtils.java:592"$1$"	 * @return the merged {@code AnnotationAttributes}, or {@code null} if not found"
"AnnotatedElementUtils.java:593"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:594"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:595"$0$"	 * @see #getMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:596"$0$"	 */"
"AnnotatedElementUtils.java:597"$0$"	@Nullable"
"AnnotatedElementUtils.java:598"$0$"	public static AnnotationAttributes findMergedAnnotationAttributes(AnnotatedElement element,"
"AnnotatedElementUtils.java:599"$1$"			String annotationName, boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotatedElementUtils.java:600"$1$""
"AnnotatedElementUtils.java:601"$1$"		MergedAnnotation<?> mergedAnnotation = findAnnotations(element)"
"AnnotatedElementUtils.java:602"$1$"				.get(annotationName, null, MergedAnnotationSelectors.firstDirectlyDeclared());"
"AnnotatedElementUtils.java:603"$1$"		return getAnnotationAttributes(mergedAnnotation, classValuesAsString, nestedAnnotationsAsMap);"
"AnnotatedElementUtils.java:604"$1$"	}"
"AnnotatedElementUtils.java:605"$0$""
"AnnotatedElementUtils.java:606"$0$"	/**"
"AnnotatedElementUtils.java:607"$1$"	 * Find the first annotation of the specified {@code annotationType} within"
"AnnotatedElementUtils.java:608"$1$"	 * the annotation hierarchy <em>above</em> the supplied {@code element},"
"AnnotatedElementUtils.java:609"$0$"	 * merge that annotation's attributes with <em>matching</em> attributes from"
"AnnotatedElementUtils.java:610"$0$"	 * annotations in lower levels of the annotation hierarchy, and synthesize"
"AnnotatedElementUtils.java:611"$1$"	 * the result back into an annotation of the specified {@code annotationType}."
"AnnotatedElementUtils.java:612"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both"
"AnnotatedElementUtils.java:613"$0$"	 * within a single annotation and within the annotation hierarchy."
"AnnotatedElementUtils.java:614"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:615"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:616"$0$"	 * @param element the annotated element"
"AnnotatedElementUtils.java:617"$0$"	 * @param annotationType the annotation type to find"
"AnnotatedElementUtils.java:618"$1$"	 * @return the merged, synthesized {@code Annotation}, or {@code null} if not found"
"AnnotatedElementUtils.java:619"$0$"	 * @since 4.2"
"AnnotatedElementUtils.java:620"$0$"	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:621"$0$"	 * @see #findMergedAnnotationAttributes(AnnotatedElement, String, boolean, boolean)"
"AnnotatedElementUtils.java:622"$0$"	 * @see #getMergedAnnotationAttributes(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:623"$0$"	 */"
"AnnotatedElementUtils.java:624"$0$"	@Nullable"
"AnnotatedElementUtils.java:625"$1$"	public static <A extends Annotation> A findMergedAnnotation(AnnotatedElement element, Class<A> annotationType) {"
"AnnotatedElementUtils.java:626"$0$"		// Shortcut: directly present on the element, with no merging needed?"
"AnnotatedElementUtils.java:627"$1$"		if (AnnotationFilter.PLAIN.matches(annotationType) ||"
"AnnotatedElementUtils.java:628"$1$"				AnnotationsScanner.hasPlainJavaAnnotationsOnly(element)) {"
"AnnotatedElementUtils.java:629"$1$"			return element.getDeclaredAnnotation(annotationType);"
"AnnotatedElementUtils.java:630"$1$"		}"
"AnnotatedElementUtils.java:631"$0$"		// Exhaustive retrieval of merged annotations..."
"AnnotatedElementUtils.java:632"$0$"		return findAnnotations(element)"
"AnnotatedElementUtils.java:633"$0$"				.get(annotationType, null, MergedAnnotationSelectors.firstDirectlyDeclared())"
"AnnotatedElementUtils.java:634"$0$"				.synthesize(MergedAnnotation::isPresent).orElse(null);"
"AnnotatedElementUtils.java:635"$0$"	}"
"AnnotatedElementUtils.java:636"$0$""
"AnnotatedElementUtils.java:637"$0$"	/**"
"AnnotatedElementUtils.java:638"$1$"	 * Find <strong>all</strong> annotations of the specified {@code annotationType}"
"AnnotatedElementUtils.java:639"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:640"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:641"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:642"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:643"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:644"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:645"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:646"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:647"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:648"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:649"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:650"$1$"	 * @return the set of all merged, synthesized {@code Annotations} found,"
"AnnotatedElementUtils.java:651"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:652"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:653"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:654"$0$"	 * @see #getAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:655"$0$"	 */"
"AnnotatedElementUtils.java:656"$1$"	public static <A extends Annotation> Set<A> findAllMergedAnnotations(AnnotatedElement element, Class<A> annotationType) {"
"AnnotatedElementUtils.java:657"$1$"		return findAnnotations(element).stream(annotationType)"
"AnnotatedElementUtils.java:658"$1$"				.sorted(highAggregateIndexesFirst())"
"AnnotatedElementUtils.java:659"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:660"$1$"	}"
"AnnotatedElementUtils.java:661"$0$""
"AnnotatedElementUtils.java:662"$0$"	/**"
"AnnotatedElementUtils.java:663"$1$"	 * Find <strong>all</strong> annotations of the specified {@code annotationTypes}"
"AnnotatedElementUtils.java:664"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:665"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:666"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the"
"AnnotatedElementUtils.java:667"$0$"	 * annotation hierarchy and synthesize the results back into an annotation"
"AnnotatedElementUtils.java:668"$1$"	 * of the corresponding {@code annotationType}."
"AnnotatedElementUtils.java:669"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:670"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:671"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:672"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:673"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:674"$0$"	 * @param annotationTypes the annotation types to find"
"AnnotatedElementUtils.java:675"$1$"	 * @return the set of all merged, synthesized {@code Annotations} found,"
"AnnotatedElementUtils.java:676"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:677"$0$"	 * @since 5.1"
"AnnotatedElementUtils.java:678"$0$"	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:679"$0$"	 */"
"AnnotatedElementUtils.java:680"$1$"	public static Set<Annotation> findAllMergedAnnotations(AnnotatedElement element, Set<Class<? extends Annotation>> annotationTypes) {"
"AnnotatedElementUtils.java:681"$1$"		return findAnnotations(element).stream()"
"AnnotatedElementUtils.java:682"$1$"				.filter(MergedAnnotationPredicates.typeIn(annotationTypes))"
"AnnotatedElementUtils.java:683"$1$"				.sorted(highAggregateIndexesFirst())"
"AnnotatedElementUtils.java:684"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:685"$1$"	}"
"AnnotatedElementUtils.java:686"$0$""
"AnnotatedElementUtils.java:687"$0$"	/**"
"AnnotatedElementUtils.java:688"$1$"	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}"
"AnnotatedElementUtils.java:689"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:690"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:691"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:692"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:693"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:694"$0$"	 * <p>The container type that holds the repeatable annotations will be looked up"
"AnnotatedElementUtils.java:695"$1$"	 * via {@link java.lang.annotation.Repeatable}."
"AnnotatedElementUtils.java:696"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:697"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:698"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:699"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:700"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:701"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:702"$1$"	 * @return the set of all merged repeatable {@code Annotations} found,"
"AnnotatedElementUtils.java:703"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:704"$1$"	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}"
"AnnotatedElementUtils.java:705"$1$"	 * is {@code null}, or if the container type cannot be resolved"
"AnnotatedElementUtils.java:706"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:707"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:708"$0$"	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:709"$0$"	 * @see #findMergedRepeatableAnnotations(AnnotatedElement, Class, Class)"
"AnnotatedElementUtils.java:710"$0$"	 */"
"AnnotatedElementUtils.java:711"$0$"	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,"
"AnnotatedElementUtils.java:712"$1$"			Class<A> annotationType) {"
"AnnotatedElementUtils.java:713"$1$""
"AnnotatedElementUtils.java:714"$1$"		return findMergedRepeatableAnnotations(element, annotationType, null);"
"AnnotatedElementUtils.java:715"$1$"	}"
"AnnotatedElementUtils.java:716"$0$""
"AnnotatedElementUtils.java:717"$0$"	/**"
"AnnotatedElementUtils.java:718"$1$"	 * Find all <em>repeatable annotations</em> of the specified {@code annotationType}"
"AnnotatedElementUtils.java:719"$1$"	 * within the annotation hierarchy <em>above</em> the supplied {@code element};"
"AnnotatedElementUtils.java:720"$0$"	 * and for each annotation found, merge that annotation's attributes with"
"AnnotatedElementUtils.java:721"$0$"	 * <em>matching</em> attributes from annotations in lower levels of the annotation"
"AnnotatedElementUtils.java:722"$0$"	 * hierarchy and synthesize the results back into an annotation of the specified"
"AnnotatedElementUtils.java:723"$1$"	 * {@code annotationType}."
"AnnotatedElementUtils.java:724"$1$"	 * <p>{@link AliasFor @AliasFor} semantics are fully supported, both within a"
"AnnotatedElementUtils.java:725"$0$"	 * single annotation and within annotation hierarchies."
"AnnotatedElementUtils.java:726"$0$"	 * <p>This method follows <em>find semantics</em> as described in the"
"AnnotatedElementUtils.java:727"$1$"	 * {@linkplain AnnotatedElementUtils class-level javadoc}."
"AnnotatedElementUtils.java:728"$1$"	 * @param element the annotated element (never {@code null})"
"AnnotatedElementUtils.java:729"$1$"	 * @param annotationType the annotation type to find (never {@code null})"
"AnnotatedElementUtils.java:730"$0$"	 * @param containerType the type of the container that holds the annotations;"
"AnnotatedElementUtils.java:731"$1$"	 * may be {@code null} if the container type should be looked up via"
"AnnotatedElementUtils.java:732"$1$"	 * {@link java.lang.annotation.Repeatable}"
"AnnotatedElementUtils.java:733"$1$"	 * @return the set of all merged repeatable {@code Annotations} found,"
"AnnotatedElementUtils.java:734"$0$"	 * or an empty set if none were found"
"AnnotatedElementUtils.java:735"$1$"	 * @throws IllegalArgumentException if the {@code element} or {@code annotationType}"
"AnnotatedElementUtils.java:736"$1$"	 * is {@code null}, or if the container type cannot be resolved"
"AnnotatedElementUtils.java:737"$1$"	 * @throws AnnotationConfigurationException if the supplied {@code containerType}"
"AnnotatedElementUtils.java:738"$1$"	 * is not a valid container annotation for the supplied {@code annotationType}"
"AnnotatedElementUtils.java:739"$0$"	 * @since 4.3"
"AnnotatedElementUtils.java:740"$0$"	 * @see #findMergedAnnotation(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:741"$0$"	 * @see #findAllMergedAnnotations(AnnotatedElement, Class)"
"AnnotatedElementUtils.java:742"$0$"	 */"
"AnnotatedElementUtils.java:743"$0$"	public static <A extends Annotation> Set<A> findMergedRepeatableAnnotations(AnnotatedElement element,"
"AnnotatedElementUtils.java:744"$1$"			Class<A> annotationType, @Nullable Class<? extends Annotation> containerType) {"
"AnnotatedElementUtils.java:745"$1$""
"AnnotatedElementUtils.java:746"$1$"		return findRepeatableAnnotations(element, containerType, annotationType)"
"AnnotatedElementUtils.java:747"$1$"				.stream(annotationType)"
"AnnotatedElementUtils.java:748"$1$"				.sorted(highAggregateIndexesFirst())"
"AnnotatedElementUtils.java:749"$1$"				.collect(MergedAnnotationCollectors.toAnnotationSet());"
"AnnotatedElementUtils.java:750"$1$"	}"
"AnnotatedElementUtils.java:751"$0$""
"AnnotatedElementUtils.java:752"$1$"	private static MergedAnnotations getAnnotations(AnnotatedElement element) {"
"AnnotatedElementUtils.java:753"$1$"		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, RepeatableContainers.none());"
"AnnotatedElementUtils.java:754"$1$"	}"
"AnnotatedElementUtils.java:755"$0$""
"AnnotatedElementUtils.java:756"$0$"	private static MergedAnnotations getRepeatableAnnotations(AnnotatedElement element,"
"AnnotatedElementUtils.java:757"$1$"			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:758"$1$""
"AnnotatedElementUtils.java:759"$1$"		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);"
"AnnotatedElementUtils.java:760"$1$"		return MergedAnnotations.from(element, SearchStrategy.INHERITED_ANNOTATIONS, repeatableContainers);"
"AnnotatedElementUtils.java:761"$1$"	}"
"AnnotatedElementUtils.java:762"$0$""
"AnnotatedElementUtils.java:763"$1$"	private static MergedAnnotations findAnnotations(AnnotatedElement element) {"
"AnnotatedElementUtils.java:764"$1$"		return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, RepeatableContainers.none());"
"AnnotatedElementUtils.java:765"$1$"	}"
"AnnotatedElementUtils.java:766"$0$""
"AnnotatedElementUtils.java:767"$0$"	private static MergedAnnotations findRepeatableAnnotations(AnnotatedElement element,"
"AnnotatedElementUtils.java:768"$1$"			@Nullable Class<? extends Annotation> containerType, Class<? extends Annotation> annotationType) {"
"AnnotatedElementUtils.java:769"$1$""
"AnnotatedElementUtils.java:770"$1$"		RepeatableContainers repeatableContainers = RepeatableContainers.of(annotationType, containerType);"
"AnnotatedElementUtils.java:771"$1$"		return MergedAnnotations.from(element, SearchStrategy.TYPE_HIERARCHY, repeatableContainers);"
"AnnotatedElementUtils.java:772"$1$"	}"
"AnnotatedElementUtils.java:773"$0$""
"AnnotatedElementUtils.java:774"$0$"	@Nullable"
"AnnotatedElementUtils.java:775"$1$"	private static MultiValueMap<String, Object> nullIfEmpty(MultiValueMap<String, Object> map) {"
"AnnotatedElementUtils.java:776"$1$"		return (map.isEmpty() ? null : map);"
"AnnotatedElementUtils.java:777"$1$"	}"
"AnnotatedElementUtils.java:778"$0$""
"AnnotatedElementUtils.java:779"$1$"	private static <A extends Annotation> Comparator<MergedAnnotation<A>> highAggregateIndexesFirst() {"
"AnnotatedElementUtils.java:780"$1$"		return Comparator.<MergedAnnotation<A>> comparingInt("
"AnnotatedElementUtils.java:781"$1$"				MergedAnnotation::getAggregateIndex).reversed();"
"AnnotatedElementUtils.java:782"$1$"	}"
"AnnotatedElementUtils.java:783"$0$""
"AnnotatedElementUtils.java:784"$0$"	@Nullable"
"AnnotatedElementUtils.java:785"$0$"	private static AnnotationAttributes getAnnotationAttributes(MergedAnnotation<?> annotation,"
"AnnotatedElementUtils.java:786"$1$"			boolean classValuesAsString, boolean nestedAnnotationsAsMap) {"
"AnnotatedElementUtils.java:787"$1$""
"AnnotatedElementUtils.java:788"$1$"		if (!annotation.isPresent()) {"
"AnnotatedElementUtils.java:789"$1$"			return null;"
"AnnotatedElementUtils.java:790"$1$"		}"
"AnnotatedElementUtils.java:791"$0$"		return annotation.asAnnotationAttributes("
"AnnotatedElementUtils.java:792"$0$"				Adapt.values(classValuesAsString, nestedAnnotationsAsMap));"
"AnnotatedElementUtils.java:793"$0$"	}"
"AnnotatedElementUtils.java:794"$0$""
"AnnotatedElementUtils.java:795"$0$""
"AnnotatedElementUtils.java:796"$0$"	/**"
"AnnotatedElementUtils.java:797"$1$"	 * Adapted {@link AnnotatedElement} that hold specific annotations."
"AnnotatedElementUtils.java:798"$0$"	 */"
"AnnotatedElementUtils.java:799"$1$"	private static class AnnotatedElementForAnnotations implements AnnotatedElement {"
"AnnotatedElementUtils.java:800"$1$""
"AnnotatedElementUtils.java:801"$1$"		private final Annotation[] annotations;"
"AnnotatedElementUtils.java:802"$1$""
"AnnotatedElementUtils.java:803"$1$"		AnnotatedElementForAnnotations(Annotation... annotations) {"
"AnnotatedElementUtils.java:804"$1$"			this.annotations = annotations;"
"AnnotatedElementUtils.java:805"$1$"		}"
"AnnotatedElementUtils.java:806"$0$""
"AnnotatedElementUtils.java:807"$0$"		@Override"
"AnnotatedElementUtils.java:808"$0$"		@SuppressWarnings(""unchecked"")"
"AnnotatedElementUtils.java:809"$0$"		@Nullable"
"AnnotatedElementUtils.java:810"$1$"		public <T extends Annotation> T getAnnotation(Class<T> annotationClass) {"
"AnnotatedElementUtils.java:811"$1$"			for (Annotation annotation : this.annotations) {"
"AnnotatedElementUtils.java:812"$1$"				if (annotation.annotationType() == annotationClass) {"
"AnnotatedElementUtils.java:813"$1$"					return (T) annotation;"
"AnnotatedElementUtils.java:814"$1$"				}"
"AnnotatedElementUtils.java:815"$0$"			}"
"AnnotatedElementUtils.java:816"$0$"			return null;"
"AnnotatedElementUtils.java:817"$0$"		}"
"AnnotatedElementUtils.java:818"$0$""
"AnnotatedElementUtils.java:819"$0$"		@Override"
"AnnotatedElementUtils.java:820"$1$"		public Annotation[] getAnnotations() {"
"AnnotatedElementUtils.java:821"$1$"			return this.annotations.clone();"
"AnnotatedElementUtils.java:822"$1$"		}"
"AnnotatedElementUtils.java:823"$0$""
"AnnotatedElementUtils.java:824"$0$"		@Override"
"AnnotatedElementUtils.java:825"$1$"		public Annotation[] getDeclaredAnnotations() {"
"AnnotatedElementUtils.java:826"$1$"			return this.annotations.clone();"
"AnnotatedElementUtils.java:827"$1$"		}"
"AnnotatedElementUtils.java:828"$0$""
"AnnotatedElementUtils.java:829"$0$"	}"
"AnnotatedElementUtils.java:830"$0$""
"AnnotatedElementUtils.java:831"$0$"}"
"AbstractStaxXMLReader.java:1"$0$"/*"
"AbstractStaxXMLReader.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"AbstractStaxXMLReader.java:3"$0$" *"
"AbstractStaxXMLReader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AbstractStaxXMLReader.java:5"$0$" * you may not use this file except in compliance with the License."
"AbstractStaxXMLReader.java:6"$0$" * You may obtain a copy of the License at"
"AbstractStaxXMLReader.java:7"$0$" *"
"AbstractStaxXMLReader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AbstractStaxXMLReader.java:9"$0$" *"
"AbstractStaxXMLReader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AbstractStaxXMLReader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AbstractStaxXMLReader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AbstractStaxXMLReader.java:13"$0$" * See the License for the specific language governing permissions and"
"AbstractStaxXMLReader.java:14"$0$" * limitations under the License."
"AbstractStaxXMLReader.java:15"$0$" */"
"AbstractStaxXMLReader.java:16"$0$""
"AbstractStaxXMLReader.java:17"$0$"package org.springframework.util.xml;"
"AbstractStaxXMLReader.java:18"$0$""
"AbstractStaxXMLReader.java:19"$0$"import java.util.LinkedHashMap;"
"AbstractStaxXMLReader.java:20"$0$"import java.util.Map;"
"AbstractStaxXMLReader.java:21"$0$""
"AbstractStaxXMLReader.java:22"$0$"import javax.xml.namespace.QName;"
"AbstractStaxXMLReader.java:23"$0$"import javax.xml.stream.Location;"
"AbstractStaxXMLReader.java:24"$0$"import javax.xml.stream.XMLStreamException;"
"AbstractStaxXMLReader.java:25"$0$""
"AbstractStaxXMLReader.java:26"$0$"import org.xml.sax.InputSource;"
"AbstractStaxXMLReader.java:27"$0$"import org.xml.sax.Locator;"
"AbstractStaxXMLReader.java:28"$0$"import org.xml.sax.SAXException;"
"AbstractStaxXMLReader.java:29"$0$"import org.xml.sax.SAXNotRecognizedException;"
"AbstractStaxXMLReader.java:30"$0$"import org.xml.sax.SAXNotSupportedException;"
"AbstractStaxXMLReader.java:31"$0$"import org.xml.sax.SAXParseException;"
"AbstractStaxXMLReader.java:32"$0$""
"AbstractStaxXMLReader.java:33"$0$"import org.springframework.lang.Nullable;"
"AbstractStaxXMLReader.java:34"$0$"import org.springframework.util.StringUtils;"
"AbstractStaxXMLReader.java:35"$0$""
"AbstractStaxXMLReader.java:36"$0$"/**"
"AbstractStaxXMLReader.java:37"$1$" * Abstract base class for SAX {@code XMLReader} implementations that use StAX as a basis."
"AbstractStaxXMLReader.java:38"$0$" *"
"AbstractStaxXMLReader.java:39"$0$" * @author Arjen Poutsma"
"AbstractStaxXMLReader.java:40"$0$" * @author Juergen Hoeller"
"AbstractStaxXMLReader.java:41"$0$" * @since 3.0"
"AbstractStaxXMLReader.java:42"$0$" * @see #setContentHandler(org.xml.sax.ContentHandler)"
"AbstractStaxXMLReader.java:43"$0$" * @see #setDTDHandler(org.xml.sax.DTDHandler)"
"AbstractStaxXMLReader.java:44"$0$" * @see #setEntityResolver(org.xml.sax.EntityResolver)"
"AbstractStaxXMLReader.java:45"$0$" * @see #setErrorHandler(org.xml.sax.ErrorHandler)"
"AbstractStaxXMLReader.java:46"$0$" */"
"AbstractStaxXMLReader.java:47"$1$"abstract class AbstractStaxXMLReader extends AbstractXMLReader {"
"AbstractStaxXMLReader.java:48"$1$""
"AbstractStaxXMLReader.java:49"$1$"	private static final String NAMESPACES_FEATURE_NAME = ""http://xml.org/sax/features/namespaces"";"
"AbstractStaxXMLReader.java:50"$1$""
"AbstractStaxXMLReader.java:51"$1$"	private static final String NAMESPACE_PREFIXES_FEATURE_NAME = ""http://xml.org/sax/features/namespace-prefixes"";"
"AbstractStaxXMLReader.java:52"$1$""
"AbstractStaxXMLReader.java:53"$1$"	private static final String IS_STANDALONE_FEATURE_NAME = ""http://xml.org/sax/features/is-standalone"";"
"AbstractStaxXMLReader.java:54"$1$""
"AbstractStaxXMLReader.java:55"$1$""
"AbstractStaxXMLReader.java:56"$1$"	private boolean namespacesFeature = true;"
"AbstractStaxXMLReader.java:57"$1$""
"AbstractStaxXMLReader.java:58"$1$"	private boolean namespacePrefixesFeature = false;"
"AbstractStaxXMLReader.java:59"$1$""
"AbstractStaxXMLReader.java:60"$1$"	@Nullable"
"AbstractStaxXMLReader.java:61"$1$"	private Boolean isStandalone;"
"AbstractStaxXMLReader.java:62"$1$""
"AbstractStaxXMLReader.java:63"$1$"	private final Map<String, String> namespaces = new LinkedHashMap<>();"
"AbstractStaxXMLReader.java:64"$1$""
"AbstractStaxXMLReader.java:65"$1$""
"AbstractStaxXMLReader.java:66"$1$"	@Override"
"AbstractStaxXMLReader.java:67"$1$"	public boolean getFeature(String name) throws SAXNotRecognizedException, SAXNotSupportedException {"
"AbstractStaxXMLReader.java:68"$1$"		switch (name) {"
"AbstractStaxXMLReader.java:69"$1$"			case NAMESPACES_FEATURE_NAME:"
"AbstractStaxXMLReader.java:70"$1$"				return this.namespacesFeature;"
"AbstractStaxXMLReader.java:71"$1$"			case NAMESPACE_PREFIXES_FEATURE_NAME:"
"AbstractStaxXMLReader.java:72"$1$"				return this.namespacePrefixesFeature;"
"AbstractStaxXMLReader.java:73"$1$"			case IS_STANDALONE_FEATURE_NAME:"
"AbstractStaxXMLReader.java:74"$1$"				if (this.isStandalone != null) {"
"AbstractStaxXMLReader.java:75"$1$"					return this.isStandalone;"
"AbstractStaxXMLReader.java:76"$1$"				}"
"AbstractStaxXMLReader.java:77"$1$"				else {"
"AbstractStaxXMLReader.java:78"$1$"					throw new SAXNotSupportedException(""startDocument() callback not completed yet"");"
"AbstractStaxXMLReader.java:79"$1$"				}"
"AbstractStaxXMLReader.java:80"$0$"			default:"
"AbstractStaxXMLReader.java:81"$0$"				return super.getFeature(name);"
"AbstractStaxXMLReader.java:82"$0$"		}"
"AbstractStaxXMLReader.java:83"$0$"	}"
"AbstractStaxXMLReader.java:84"$0$""
"AbstractStaxXMLReader.java:85"$0$"	@Override"
"AbstractStaxXMLReader.java:86"$1$"	public void setFeature(String name, boolean value) throws SAXNotRecognizedException, SAXNotSupportedException {"
"AbstractStaxXMLReader.java:87"$1$"		if (NAMESPACES_FEATURE_NAME.equals(name)) {"
"AbstractStaxXMLReader.java:88"$1$"			this.namespacesFeature = value;"
"AbstractStaxXMLReader.java:89"$1$"		}"
"AbstractStaxXMLReader.java:90"$1$"		else if (NAMESPACE_PREFIXES_FEATURE_NAME.equals(name)) {"
"AbstractStaxXMLReader.java:91"$1$"			this.namespacePrefixesFeature = value;"
"AbstractStaxXMLReader.java:92"$1$"		}"
"AbstractStaxXMLReader.java:93"$1$"		else {"
"AbstractStaxXMLReader.java:94"$1$"			super.setFeature(name, value);"
"AbstractStaxXMLReader.java:95"$1$"		}"
"AbstractStaxXMLReader.java:96"$0$"	}"
"AbstractStaxXMLReader.java:97"$0$""
"AbstractStaxXMLReader.java:98"$1$"	protected void setStandalone(boolean standalone) {"
"AbstractStaxXMLReader.java:99"$1$"		this.isStandalone = standalone;"
"AbstractStaxXMLReader.java:100"$1$"	}"
"AbstractStaxXMLReader.java:101"$0$""
"AbstractStaxXMLReader.java:102"$0$"	/**"
"AbstractStaxXMLReader.java:103"$1$"	 * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces} is turned on."
"AbstractStaxXMLReader.java:104"$0$"	 */"
"AbstractStaxXMLReader.java:105"$1$"	protected boolean hasNamespacesFeature() {"
"AbstractStaxXMLReader.java:106"$1$"		return this.namespacesFeature;"
"AbstractStaxXMLReader.java:107"$1$"	}"
"AbstractStaxXMLReader.java:108"$0$""
"AbstractStaxXMLReader.java:109"$0$"	/**"
"AbstractStaxXMLReader.java:110"$1$"	 * Indicates whether the SAX feature {@code http://xml.org/sax/features/namespaces-prefixes} is turned on."
"AbstractStaxXMLReader.java:111"$0$"	 */"
"AbstractStaxXMLReader.java:112"$1$"	protected boolean hasNamespacePrefixesFeature() {"
"AbstractStaxXMLReader.java:113"$1$"		return this.namespacePrefixesFeature;"
"AbstractStaxXMLReader.java:114"$1$"	}"
"AbstractStaxXMLReader.java:115"$0$""
"AbstractStaxXMLReader.java:116"$0$"	/**"
"AbstractStaxXMLReader.java:117"$1$"	 * Convert a {@code QName} to a qualified name, as used by DOM and SAX."
"AbstractStaxXMLReader.java:118"$1$"	 * The returned string has a format of {@code prefix:localName} if the"
"AbstractStaxXMLReader.java:119"$1$"	 * prefix is set, or just {@code localName} if not."
"AbstractStaxXMLReader.java:120"$1$"	 * @param qName the {@code QName}"
"AbstractStaxXMLReader.java:121"$0$"	 * @return the qualified name"
"AbstractStaxXMLReader.java:122"$0$"	 */"
"AbstractStaxXMLReader.java:123"$1$"	protected String toQualifiedName(QName qName) {"
"AbstractStaxXMLReader.java:124"$1$"		String prefix = qName.getPrefix();"
"AbstractStaxXMLReader.java:125"$1$"		if (!StringUtils.hasLength(prefix)) {"
"AbstractStaxXMLReader.java:126"$1$"			return qName.getLocalPart();"
"AbstractStaxXMLReader.java:127"$1$"		}"
"AbstractStaxXMLReader.java:128"$1$"		else {"
"AbstractStaxXMLReader.java:129"$1$"			return prefix + "":"" + qName.getLocalPart();"
"AbstractStaxXMLReader.java:130"$1$"		}"
"AbstractStaxXMLReader.java:131"$0$"	}"
"AbstractStaxXMLReader.java:132"$0$""
"AbstractStaxXMLReader.java:133"$0$""
"AbstractStaxXMLReader.java:134"$0$"	/**"
"AbstractStaxXMLReader.java:135"$0$"	 * Parse the StAX XML reader passed at construction-time."
"AbstractStaxXMLReader.java:136"$1$"	 * <p><b>NOTE:</b>: The given {@code InputSource} is not read, but ignored."
"AbstractStaxXMLReader.java:137"$0$"	 * @param ignored is ignored"
"AbstractStaxXMLReader.java:138"$1$"	 * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}"
"AbstractStaxXMLReader.java:139"$0$"	 */"
"AbstractStaxXMLReader.java:140"$0$"	@Override"
"AbstractStaxXMLReader.java:141"$1$"	public final void parse(InputSource ignored) throws SAXException {"
"AbstractStaxXMLReader.java:142"$1$"		parse();"
"AbstractStaxXMLReader.java:143"$1$"	}"
"AbstractStaxXMLReader.java:144"$0$""
"AbstractStaxXMLReader.java:145"$0$"	/**"
"AbstractStaxXMLReader.java:146"$0$"	 * Parse the StAX XML reader passed at construction-time."
"AbstractStaxXMLReader.java:147"$0$"	 * <p><b>NOTE:</b>: The given system identifier is not read, but ignored."
"AbstractStaxXMLReader.java:148"$0$"	 * @param ignored is ignored"
"AbstractStaxXMLReader.java:149"$1$"	 * @throws SAXException a SAX exception, possibly wrapping a {@code XMLStreamException}"
"AbstractStaxXMLReader.java:150"$0$"	 */"
"AbstractStaxXMLReader.java:151"$0$"	@Override"
"AbstractStaxXMLReader.java:152"$1$"	public final void parse(String ignored) throws SAXException {"
"AbstractStaxXMLReader.java:153"$1$"		parse();"
"AbstractStaxXMLReader.java:154"$1$"	}"
"AbstractStaxXMLReader.java:155"$0$""
"AbstractStaxXMLReader.java:156"$1$"	private void parse() throws SAXException {"
"AbstractStaxXMLReader.java:157"$1$"		try {"
"AbstractStaxXMLReader.java:158"$1$"			parseInternal();"
"AbstractStaxXMLReader.java:159"$1$"		}"
"AbstractStaxXMLReader.java:160"$1$"		catch (XMLStreamException ex) {"
"AbstractStaxXMLReader.java:161"$1$"			Locator locator = null;"
"AbstractStaxXMLReader.java:162"$1$"			if (ex.getLocation() != null) {"
"AbstractStaxXMLReader.java:163"$1$"				locator = new StaxLocator(ex.getLocation());"
"AbstractStaxXMLReader.java:164"$1$"			}"
"AbstractStaxXMLReader.java:165"$0$"			SAXParseException saxException = new SAXParseException(ex.getMessage(), locator, ex);"
"AbstractStaxXMLReader.java:166"$1$"			if (getErrorHandler() != null) {"
"AbstractStaxXMLReader.java:167"$1$"				getErrorHandler().fatalError(saxException);"
"AbstractStaxXMLReader.java:168"$1$"			}"
"AbstractStaxXMLReader.java:169"$1$"			else {"
"AbstractStaxXMLReader.java:170"$1$"				throw saxException;"
"AbstractStaxXMLReader.java:171"$1$"			}"
"AbstractStaxXMLReader.java:172"$0$"		}"
"AbstractStaxXMLReader.java:173"$0$"	}"
"AbstractStaxXMLReader.java:174"$0$""
"AbstractStaxXMLReader.java:175"$0$"	/**"
"AbstractStaxXMLReader.java:176"$0$"	 * Template method that parses the StAX reader passed at construction-time."
"AbstractStaxXMLReader.java:177"$0$"	 */"
"AbstractStaxXMLReader.java:178"$0$"	protected abstract void parseInternal() throws SAXException, XMLStreamException;"
"AbstractStaxXMLReader.java:179"$0$""
"AbstractStaxXMLReader.java:180"$0$""
"AbstractStaxXMLReader.java:181"$0$"	/**"
"AbstractStaxXMLReader.java:182"$0$"	 * Start the prefix mapping for the given prefix."
"AbstractStaxXMLReader.java:183"$0$"	 * @see org.xml.sax.ContentHandler#startPrefixMapping(String, String)"
"AbstractStaxXMLReader.java:184"$0$"	 */"
"AbstractStaxXMLReader.java:185"$1$"	protected void startPrefixMapping(@Nullable String prefix, String namespace) throws SAXException {"
"AbstractStaxXMLReader.java:186"$1$"		if (getContentHandler() != null && StringUtils.hasLength(namespace)) {"
"AbstractStaxXMLReader.java:187"$1$"			if (prefix == null) {"
"AbstractStaxXMLReader.java:188"$1$"				prefix = """";"
"AbstractStaxXMLReader.java:189"$1$"			}"
"AbstractStaxXMLReader.java:190"$1$"			if (!namespace.equals(this.namespaces.get(prefix))) {"
"AbstractStaxXMLReader.java:191"$1$"				getContentHandler().startPrefixMapping(prefix, namespace);"
"AbstractStaxXMLReader.java:192"$1$"				this.namespaces.put(prefix, namespace);"
"AbstractStaxXMLReader.java:193"$1$"			}"
"AbstractStaxXMLReader.java:194"$0$"		}"
"AbstractStaxXMLReader.java:195"$0$"	}"
"AbstractStaxXMLReader.java:196"$0$""
"AbstractStaxXMLReader.java:197"$0$"	/**"
"AbstractStaxXMLReader.java:198"$0$"	 * End the prefix mapping for the given prefix."
"AbstractStaxXMLReader.java:199"$0$"	 * @see org.xml.sax.ContentHandler#endPrefixMapping(String)"
"AbstractStaxXMLReader.java:200"$0$"	 */"
"AbstractStaxXMLReader.java:201"$1$"	protected void endPrefixMapping(String prefix) throws SAXException {"
"AbstractStaxXMLReader.java:202"$1$"		if (getContentHandler() != null && this.namespaces.containsKey(prefix)) {"
"AbstractStaxXMLReader.java:203"$1$"			getContentHandler().endPrefixMapping(prefix);"
"AbstractStaxXMLReader.java:204"$1$"			this.namespaces.remove(prefix);"
"AbstractStaxXMLReader.java:205"$1$"		}"
"AbstractStaxXMLReader.java:206"$0$"	}"
"AbstractStaxXMLReader.java:207"$0$""
"AbstractStaxXMLReader.java:208"$0$""
"AbstractStaxXMLReader.java:209"$0$"	/**"
"AbstractStaxXMLReader.java:210"$1$"	 * Implementation of the {@code Locator} interface based on a given StAX {@code Location}."
"AbstractStaxXMLReader.java:211"$0$"	 * @see Locator"
"AbstractStaxXMLReader.java:212"$0$"	 * @see Location"
"AbstractStaxXMLReader.java:213"$0$"	 */"
"AbstractStaxXMLReader.java:214"$1$"	private static class StaxLocator implements Locator {"
"AbstractStaxXMLReader.java:215"$1$""
"AbstractStaxXMLReader.java:216"$1$"		private final Location location;"
"AbstractStaxXMLReader.java:217"$1$""
"AbstractStaxXMLReader.java:218"$1$"		public StaxLocator(Location location) {"
"AbstractStaxXMLReader.java:219"$1$"			this.location = location;"
"AbstractStaxXMLReader.java:220"$1$"		}"
"AbstractStaxXMLReader.java:221"$0$""
"AbstractStaxXMLReader.java:222"$0$"		@Override"
"AbstractStaxXMLReader.java:223"$1$"		public String getPublicId() {"
"AbstractStaxXMLReader.java:224"$1$"			return this.location.getPublicId();"
"AbstractStaxXMLReader.java:225"$1$"		}"
"AbstractStaxXMLReader.java:226"$0$""
"AbstractStaxXMLReader.java:227"$0$"		@Override"
"AbstractStaxXMLReader.java:228"$1$"		public String getSystemId() {"
"AbstractStaxXMLReader.java:229"$1$"			return this.location.getSystemId();"
"AbstractStaxXMLReader.java:230"$1$"		}"
"AbstractStaxXMLReader.java:231"$0$""
"AbstractStaxXMLReader.java:232"$0$"		@Override"
"AbstractStaxXMLReader.java:233"$1$"		public int getLineNumber() {"
"AbstractStaxXMLReader.java:234"$1$"			return this.location.getLineNumber();"
"AbstractStaxXMLReader.java:235"$1$"		}"
"AbstractStaxXMLReader.java:236"$0$""
"AbstractStaxXMLReader.java:237"$0$"		@Override"
"AbstractStaxXMLReader.java:238"$1$"		public int getColumnNumber() {"
"AbstractStaxXMLReader.java:239"$1$"			return this.location.getColumnNumber();"
"AbstractStaxXMLReader.java:240"$1$"		}"
"AbstractStaxXMLReader.java:241"$0$"	}"
"AbstractStaxXMLReader.java:242"$0$""
"AbstractStaxXMLReader.java:243"$0$"}"
"PackagesAnnotationFilter.java:1"$0$"/*"
"PackagesAnnotationFilter.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"PackagesAnnotationFilter.java:3"$0$" *"
"PackagesAnnotationFilter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PackagesAnnotationFilter.java:5"$0$" * you may not use this file except in compliance with the License."
"PackagesAnnotationFilter.java:6"$0$" * You may obtain a copy of the License at"
"PackagesAnnotationFilter.java:7"$0$" *"
"PackagesAnnotationFilter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PackagesAnnotationFilter.java:9"$0$" *"
"PackagesAnnotationFilter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PackagesAnnotationFilter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PackagesAnnotationFilter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PackagesAnnotationFilter.java:13"$0$" * See the License for the specific language governing permissions and"
"PackagesAnnotationFilter.java:14"$0$" * limitations under the License."
"PackagesAnnotationFilter.java:15"$0$" */"
"PackagesAnnotationFilter.java:16"$0$""
"PackagesAnnotationFilter.java:17"$0$"package org.springframework.core.annotation;"
"PackagesAnnotationFilter.java:18"$0$""
"PackagesAnnotationFilter.java:19"$0$"import java.util.Arrays;"
"PackagesAnnotationFilter.java:20"$0$""
"PackagesAnnotationFilter.java:21"$0$"import org.springframework.lang.Nullable;"
"PackagesAnnotationFilter.java:22"$0$"import org.springframework.util.Assert;"
"PackagesAnnotationFilter.java:23"$0$"import org.springframework.util.StringUtils;"
"PackagesAnnotationFilter.java:24"$0$""
"PackagesAnnotationFilter.java:25"$0$"/**"
"PackagesAnnotationFilter.java:26"$1$" * {@link AnnotationFilter} implementation used for"
"PackagesAnnotationFilter.java:27"$1$" * {@link AnnotationFilter#packages(String...)}."
"PackagesAnnotationFilter.java:28"$0$" *"
"PackagesAnnotationFilter.java:29"$0$" * @author Phillip Webb"
"PackagesAnnotationFilter.java:30"$0$" * @since 5.2"
"PackagesAnnotationFilter.java:31"$0$" */"
"PackagesAnnotationFilter.java:32"$1$"final class PackagesAnnotationFilter implements AnnotationFilter {"
"PackagesAnnotationFilter.java:33"$1$""
"PackagesAnnotationFilter.java:34"$1$"	private final String[] prefixes;"
"PackagesAnnotationFilter.java:35"$1$""
"PackagesAnnotationFilter.java:36"$1$"	private final int hashCode;"
"PackagesAnnotationFilter.java:37"$1$""
"PackagesAnnotationFilter.java:38"$1$""
"PackagesAnnotationFilter.java:39"$1$"	PackagesAnnotationFilter(String... packages) {"
"PackagesAnnotationFilter.java:40"$1$"		Assert.notNull(packages, ""Packages array must not be null"");"
"PackagesAnnotationFilter.java:41"$1$"		this.prefixes = new String[packages.length];"
"PackagesAnnotationFilter.java:42"$1$"		for (int i = 0; i < packages.length; i++) {"
"PackagesAnnotationFilter.java:43"$1$"			String pkg = packages[i];"
"PackagesAnnotationFilter.java:44"$1$"			Assert.hasText(pkg, ""Packages array must not have empty elements"");"
"PackagesAnnotationFilter.java:45"$1$"			this.prefixes[i] = pkg + ""."";"
"PackagesAnnotationFilter.java:46"$1$"		}"
"PackagesAnnotationFilter.java:47"$0$"		Arrays.sort(this.prefixes);"
"PackagesAnnotationFilter.java:48"$0$"		this.hashCode = Arrays.hashCode(this.prefixes);"
"PackagesAnnotationFilter.java:49"$0$"	}"
"PackagesAnnotationFilter.java:50"$0$""
"PackagesAnnotationFilter.java:51"$0$""
"PackagesAnnotationFilter.java:52"$0$"	@Override"
"PackagesAnnotationFilter.java:53"$1$"	public boolean matches(String annotationType) {"
"PackagesAnnotationFilter.java:54"$1$"		for (String prefix : this.prefixes) {"
"PackagesAnnotationFilter.java:55"$1$"			if (annotationType.startsWith(prefix)) {"
"PackagesAnnotationFilter.java:56"$1$"				return true;"
"PackagesAnnotationFilter.java:57"$1$"			}"
"PackagesAnnotationFilter.java:58"$0$"		}"
"PackagesAnnotationFilter.java:59"$0$"		return false;"
"PackagesAnnotationFilter.java:60"$0$"	}"
"PackagesAnnotationFilter.java:61"$0$""
"PackagesAnnotationFilter.java:62"$0$""
"PackagesAnnotationFilter.java:63"$0$"	@Override"
"PackagesAnnotationFilter.java:64"$1$"	public boolean equals(@Nullable Object other) {"
"PackagesAnnotationFilter.java:65"$1$"		if (this == other) {"
"PackagesAnnotationFilter.java:66"$1$"			return true;"
"PackagesAnnotationFilter.java:67"$1$"		}"
"PackagesAnnotationFilter.java:68"$1$"		if (other == null || getClass() != other.getClass()) {"
"PackagesAnnotationFilter.java:69"$1$"			return false;"
"PackagesAnnotationFilter.java:70"$1$"		}"
"PackagesAnnotationFilter.java:71"$0$"		return Arrays.equals(this.prefixes, ((PackagesAnnotationFilter) other).prefixes);"
"PackagesAnnotationFilter.java:72"$0$"	}"
"PackagesAnnotationFilter.java:73"$0$""
"PackagesAnnotationFilter.java:74"$0$"	@Override"
"PackagesAnnotationFilter.java:75"$1$"	public int hashCode() {"
"PackagesAnnotationFilter.java:76"$1$"		return this.hashCode;"
"PackagesAnnotationFilter.java:77"$1$"	}"
"PackagesAnnotationFilter.java:78"$0$""
"PackagesAnnotationFilter.java:79"$0$"	@Override"
"PackagesAnnotationFilter.java:80"$1$"	public String toString() {"
"PackagesAnnotationFilter.java:81"$1$"		return ""Packages annotation filter: "" +"
"PackagesAnnotationFilter.java:82"$1$"				StringUtils.arrayToCommaDelimitedString(this.prefixes);"
"PackagesAnnotationFilter.java:83"$1$"	}"
"PackagesAnnotationFilter.java:84"$0$""
"PackagesAnnotationFilter.java:85"$0$"}"
"CollectionFactory.java:1"$0$"/*"
"CollectionFactory.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"CollectionFactory.java:3"$0$" *"
"CollectionFactory.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"CollectionFactory.java:5"$0$" * you may not use this file except in compliance with the License."
"CollectionFactory.java:6"$0$" * You may obtain a copy of the License at"
"CollectionFactory.java:7"$0$" *"
"CollectionFactory.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"CollectionFactory.java:9"$0$" *"
"CollectionFactory.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"CollectionFactory.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"CollectionFactory.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"CollectionFactory.java:13"$0$" * See the License for the specific language governing permissions and"
"CollectionFactory.java:14"$0$" * limitations under the License."
"CollectionFactory.java:15"$0$" */"
"CollectionFactory.java:16"$0$""
"CollectionFactory.java:17"$0$"package org.springframework.core;"
"CollectionFactory.java:18"$0$""
"CollectionFactory.java:19"$0$"import java.util.ArrayList;"
"CollectionFactory.java:20"$0$"import java.util.Collection;"
"CollectionFactory.java:21"$0$"import java.util.EnumMap;"
"CollectionFactory.java:22"$0$"import java.util.EnumSet;"
"CollectionFactory.java:23"$0$"import java.util.HashMap;"
"CollectionFactory.java:24"$0$"import java.util.HashSet;"
"CollectionFactory.java:25"$0$"import java.util.LinkedHashMap;"
"CollectionFactory.java:26"$0$"import java.util.LinkedHashSet;"
"CollectionFactory.java:27"$0$"import java.util.LinkedList;"
"CollectionFactory.java:28"$0$"import java.util.List;"
"CollectionFactory.java:29"$0$"import java.util.Map;"
"CollectionFactory.java:30"$0$"import java.util.NavigableMap;"
"CollectionFactory.java:31"$0$"import java.util.NavigableSet;"
"CollectionFactory.java:32"$0$"import java.util.Properties;"
"CollectionFactory.java:33"$0$"import java.util.Set;"
"CollectionFactory.java:34"$0$"import java.util.SortedMap;"
"CollectionFactory.java:35"$0$"import java.util.SortedSet;"
"CollectionFactory.java:36"$0$"import java.util.TreeMap;"
"CollectionFactory.java:37"$0$"import java.util.TreeSet;"
"CollectionFactory.java:38"$0$""
"CollectionFactory.java:39"$0$"import org.springframework.lang.Nullable;"
"CollectionFactory.java:40"$0$"import org.springframework.util.Assert;"
"CollectionFactory.java:41"$0$"import org.springframework.util.LinkedMultiValueMap;"
"CollectionFactory.java:42"$0$"import org.springframework.util.MultiValueMap;"
"CollectionFactory.java:43"$0$"import org.springframework.util.ReflectionUtils;"
"CollectionFactory.java:44"$0$""
"CollectionFactory.java:45"$0$"/**"
"CollectionFactory.java:46"$0$" * Factory for collections that is aware of common Java and Spring collection types."
"CollectionFactory.java:47"$0$" *"
"CollectionFactory.java:48"$0$" * <p>Mainly for internal use within the framework."
"CollectionFactory.java:49"$0$" *"
"CollectionFactory.java:50"$0$" * @author Juergen Hoeller"
"CollectionFactory.java:51"$0$" * @author Arjen Poutsma"
"CollectionFactory.java:52"$0$" * @author Oliver Gierke"
"CollectionFactory.java:53"$0$" * @author Sam Brannen"
"CollectionFactory.java:54"$0$" * @since 1.1.1"
"CollectionFactory.java:55"$0$" */"
"CollectionFactory.java:56"$1$"public final class CollectionFactory {"
"CollectionFactory.java:57"$1$""
"CollectionFactory.java:58"$1$"	private static final Set<Class<?>> approximableCollectionTypes = new HashSet<>();"
"CollectionFactory.java:59"$1$""
"CollectionFactory.java:60"$1$"	private static final Set<Class<?>> approximableMapTypes = new HashSet<>();"
"CollectionFactory.java:61"$1$""
"CollectionFactory.java:62"$1$""
"CollectionFactory.java:63"$1$"	static {"
"CollectionFactory.java:64"$0$"		// Standard collection interfaces"
"CollectionFactory.java:65"$1$"		approximableCollectionTypes.add(Collection.class);"
"CollectionFactory.java:66"$1$"		approximableCollectionTypes.add(List.class);"
"CollectionFactory.java:67"$1$"		approximableCollectionTypes.add(Set.class);"
"CollectionFactory.java:68"$1$"		approximableCollectionTypes.add(SortedSet.class);"
"CollectionFactory.java:69"$1$"		approximableCollectionTypes.add(NavigableSet.class);"
"CollectionFactory.java:70"$1$"		approximableMapTypes.add(Map.class);"
"CollectionFactory.java:71"$1$"		approximableMapTypes.add(SortedMap.class);"
"CollectionFactory.java:72"$1$"		approximableMapTypes.add(NavigableMap.class);"
"CollectionFactory.java:73"$1$""
"CollectionFactory.java:74"$0$"		// Common concrete collection classes"
"CollectionFactory.java:75"$1$"		approximableCollectionTypes.add(ArrayList.class);"
"CollectionFactory.java:76"$1$"		approximableCollectionTypes.add(LinkedList.class);"
"CollectionFactory.java:77"$1$"		approximableCollectionTypes.add(HashSet.class);"
"CollectionFactory.java:78"$1$"		approximableCollectionTypes.add(LinkedHashSet.class);"
"CollectionFactory.java:79"$1$"		approximableCollectionTypes.add(TreeSet.class);"
"CollectionFactory.java:80"$1$"		approximableCollectionTypes.add(EnumSet.class);"
"CollectionFactory.java:81"$1$"		approximableMapTypes.add(HashMap.class);"
"CollectionFactory.java:82"$1$"		approximableMapTypes.add(LinkedHashMap.class);"
"CollectionFactory.java:83"$1$"		approximableMapTypes.add(TreeMap.class);"
"CollectionFactory.java:84"$1$"		approximableMapTypes.add(EnumMap.class);"
"CollectionFactory.java:85"$1$"	}"
"CollectionFactory.java:86"$0$""
"CollectionFactory.java:87"$0$""
"CollectionFactory.java:88"$1$"	private CollectionFactory() {"
"CollectionFactory.java:89"$1$"	}"
"CollectionFactory.java:90"$0$""
"CollectionFactory.java:91"$0$""
"CollectionFactory.java:92"$0$"	/**"
"CollectionFactory.java:93"$0$"	 * Determine whether the given collection type is an <em>approximable</em> type,"
"CollectionFactory.java:94"$1$"	 * i.e. a type that {@link #createApproximateCollection} can approximate."
"CollectionFactory.java:95"$0$"	 * @param collectionType the collection type to check"
"CollectionFactory.java:96"$1$"	 * @return {@code true} if the type is <em>approximable</em>"
"CollectionFactory.java:97"$0$"	 */"
"CollectionFactory.java:98"$1$"	public static boolean isApproximableCollectionType(@Nullable Class<?> collectionType) {"
"CollectionFactory.java:99"$1$"		return (collectionType != null && approximableCollectionTypes.contains(collectionType));"
"CollectionFactory.java:100"$1$"	}"
"CollectionFactory.java:101"$0$""
"CollectionFactory.java:102"$0$"	/**"
"CollectionFactory.java:103"$0$"	 * Create the most approximate collection for the given collection."
"CollectionFactory.java:104"$1$"	 * <p><strong>Warning</strong>: Since the parameterized type {@code E} is"
"CollectionFactory.java:105"$0$"	 * not bound to the type of elements contained in the supplied"
"CollectionFactory.java:106"$1$"	 * {@code collection}, type safety cannot be guaranteed if the supplied"
"CollectionFactory.java:107"$1$"	 * {@code collection} is an {@link EnumSet}. In such scenarios, the caller"
"CollectionFactory.java:108"$0$"	 * is responsible for ensuring that the element type for the supplied"
"CollectionFactory.java:109"$1$"	 * {@code collection} is an enum type matching type {@code E}. As an"
"CollectionFactory.java:110"$0$"	 * alternative, the caller may wish to treat the return value as a raw"
"CollectionFactory.java:111"$1$"	 * collection or collection of {@link Object}."
"CollectionFactory.java:112"$1$"	 * @param collection the original collection object, potentially {@code null}"
"CollectionFactory.java:113"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:114"$0$"	 * @return a new, empty collection instance"
"CollectionFactory.java:115"$0$"	 * @see #isApproximableCollectionType"
"CollectionFactory.java:116"$0$"	 * @see java.util.LinkedList"
"CollectionFactory.java:117"$0$"	 * @see java.util.ArrayList"
"CollectionFactory.java:118"$0$"	 * @see java.util.EnumSet"
"CollectionFactory.java:119"$0$"	 * @see java.util.TreeSet"
"CollectionFactory.java:120"$0$"	 * @see java.util.LinkedHashSet"
"CollectionFactory.java:121"$0$"	 */"
"CollectionFactory.java:122"$1$"	@SuppressWarnings({""rawtypes"", ""unchecked"", ""cast""})"
"CollectionFactory.java:123"$1$"	public static <E> Collection<E> createApproximateCollection(@Nullable Object collection, int capacity) {"
"CollectionFactory.java:124"$1$"		if (collection instanceof LinkedList) {"
"CollectionFactory.java:125"$1$"			return new LinkedList<>();"
"CollectionFactory.java:126"$1$"		}"
"CollectionFactory.java:127"$1$"		else if (collection instanceof List) {"
"CollectionFactory.java:128"$1$"			return new ArrayList<>(capacity);"
"CollectionFactory.java:129"$1$"		}"
"CollectionFactory.java:130"$1$"		else if (collection instanceof EnumSet) {"
"CollectionFactory.java:131"$0$"			// Cast is necessary for compilation in Eclipse 4.4.1."
"CollectionFactory.java:132"$1$"			Collection<E> enumSet = (Collection<E>) EnumSet.copyOf((EnumSet) collection);"
"CollectionFactory.java:133"$1$"			enumSet.clear();"
"CollectionFactory.java:134"$1$"			return enumSet;"
"CollectionFactory.java:135"$1$"		}"
"CollectionFactory.java:136"$1$"		else if (collection instanceof SortedSet) {"
"CollectionFactory.java:137"$1$"			return new TreeSet<>(((SortedSet<E>) collection).comparator());"
"CollectionFactory.java:138"$1$"		}"
"CollectionFactory.java:139"$1$"		else {"
"CollectionFactory.java:140"$1$"			return new LinkedHashSet<>(capacity);"
"CollectionFactory.java:141"$1$"		}"
"CollectionFactory.java:142"$0$"	}"
"CollectionFactory.java:143"$0$""
"CollectionFactory.java:144"$0$"	/**"
"CollectionFactory.java:145"$0$"	 * Create the most appropriate collection for the given collection type."
"CollectionFactory.java:146"$1$"	 * <p>Delegates to {@link #createCollection(Class, Class, int)} with a"
"CollectionFactory.java:147"$1$"	 * {@code null} element type."
"CollectionFactory.java:148"$1$"	 * @param collectionType the desired type of the target collection (never {@code null})"
"CollectionFactory.java:149"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:150"$0$"	 * @return a new collection instance"
"CollectionFactory.java:151"$1$"	 * @throws IllegalArgumentException if the supplied {@code collectionType}"
"CollectionFactory.java:152"$1$"	 * is {@code null} or of type {@link EnumSet}"
"CollectionFactory.java:153"$0$"	 */"
"CollectionFactory.java:154"$1$"	public static <E> Collection<E> createCollection(Class<?> collectionType, int capacity) {"
"CollectionFactory.java:155"$1$"		return createCollection(collectionType, null, capacity);"
"CollectionFactory.java:156"$1$"	}"
"CollectionFactory.java:157"$0$""
"CollectionFactory.java:158"$0$"	/**"
"CollectionFactory.java:159"$0$"	 * Create the most appropriate collection for the given collection type."
"CollectionFactory.java:160"$1$"	 * <p><strong>Warning</strong>: Since the parameterized type {@code E} is"
"CollectionFactory.java:161"$1$"	 * not bound to the supplied {@code elementType}, type safety cannot be"
"CollectionFactory.java:162"$1$"	 * guaranteed if the desired {@code collectionType} is {@link EnumSet}."
"CollectionFactory.java:163"$0$"	 * In such scenarios, the caller is responsible for ensuring that the"
"CollectionFactory.java:164"$1$"	 * supplied {@code elementType} is an enum type matching type {@code E}."
"CollectionFactory.java:165"$0$"	 * As an alternative, the caller may wish to treat the return value as a"
"CollectionFactory.java:166"$1$"	 * raw collection or collection of {@link Object}."
"CollectionFactory.java:167"$1$"	 * @param collectionType the desired type of the target collection (never {@code null})"
"CollectionFactory.java:168"$1$"	 * @param elementType the collection's element type, or {@code null} if unknown"
"CollectionFactory.java:169"$1$"	 * (note: only relevant for {@link EnumSet} creation)"
"CollectionFactory.java:170"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:171"$0$"	 * @return a new collection instance"
"CollectionFactory.java:172"$0$"	 * @since 4.1.3"
"CollectionFactory.java:173"$0$"	 * @see java.util.LinkedHashSet"
"CollectionFactory.java:174"$0$"	 * @see java.util.ArrayList"
"CollectionFactory.java:175"$0$"	 * @see java.util.TreeSet"
"CollectionFactory.java:176"$0$"	 * @see java.util.EnumSet"
"CollectionFactory.java:177"$1$"	 * @throws IllegalArgumentException if the supplied {@code collectionType} is"
"CollectionFactory.java:178"$1$"	 * {@code null}; or if the desired {@code collectionType} is {@link EnumSet} and"
"CollectionFactory.java:179"$1$"	 * the supplied {@code elementType} is not a subtype of {@link Enum}"
"CollectionFactory.java:180"$0$"	 */"
"CollectionFactory.java:181"$1$"	@SuppressWarnings({""unchecked"", ""cast""})"
"CollectionFactory.java:182"$1$"	public static <E> Collection<E> createCollection(Class<?> collectionType, @Nullable Class<?> elementType, int capacity) {"
"CollectionFactory.java:183"$1$"		Assert.notNull(collectionType, ""Collection type must not be null"");"
"CollectionFactory.java:184"$1$"		if (collectionType.isInterface()) {"
"CollectionFactory.java:185"$1$"			if (Set.class == collectionType || Collection.class == collectionType) {"
"CollectionFactory.java:186"$1$"				return new LinkedHashSet<>(capacity);"
"CollectionFactory.java:187"$1$"			}"
"CollectionFactory.java:188"$1$"			else if (List.class == collectionType) {"
"CollectionFactory.java:189"$1$"				return new ArrayList<>(capacity);"
"CollectionFactory.java:190"$1$"			}"
"CollectionFactory.java:191"$1$"			else if (SortedSet.class == collectionType || NavigableSet.class == collectionType) {"
"CollectionFactory.java:192"$1$"				return new TreeSet<>();"
"CollectionFactory.java:193"$1$"			}"
"CollectionFactory.java:194"$1$"			else {"
"CollectionFactory.java:195"$1$"				throw new IllegalArgumentException(""Unsupported Collection interface: "" + collectionType.getName());"
"CollectionFactory.java:196"$1$"			}"
"CollectionFactory.java:197"$0$"		}"
"CollectionFactory.java:198"$1$"		else if (EnumSet.class.isAssignableFrom(collectionType)) {"
"CollectionFactory.java:199"$1$"			Assert.notNull(elementType, ""Cannot create EnumSet for unknown element type"");"
"CollectionFactory.java:200"$0$"			// Cast is necessary for compilation in Eclipse 4.4.1."
"CollectionFactory.java:201"$1$"			return (Collection<E>) EnumSet.noneOf(asEnumType(elementType));"
"CollectionFactory.java:202"$1$"		}"
"CollectionFactory.java:203"$1$"		else {"
"CollectionFactory.java:204"$1$"			if (!Collection.class.isAssignableFrom(collectionType)) {"
"CollectionFactory.java:205"$1$"				throw new IllegalArgumentException(""Unsupported Collection type: "" + collectionType.getName());"
"CollectionFactory.java:206"$1$"			}"
"CollectionFactory.java:207"$1$"			try {"
"CollectionFactory.java:208"$1$"				return (Collection<E>) ReflectionUtils.accessibleConstructor(collectionType).newInstance();"
"CollectionFactory.java:209"$1$"			}"
"CollectionFactory.java:210"$1$"			catch (Throwable ex) {"
"CollectionFactory.java:211"$1$"				throw new IllegalArgumentException("
"CollectionFactory.java:212"$1$"					""Could not instantiate Collection type: "" + collectionType.getName(), ex);"
"CollectionFactory.java:213"$1$"			}"
"CollectionFactory.java:214"$0$"		}"
"CollectionFactory.java:215"$0$"	}"
"CollectionFactory.java:216"$0$""
"CollectionFactory.java:217"$0$"	/**"
"CollectionFactory.java:218"$0$"	 * Determine whether the given map type is an <em>approximable</em> type,"
"CollectionFactory.java:219"$1$"	 * i.e. a type that {@link #createApproximateMap} can approximate."
"CollectionFactory.java:220"$0$"	 * @param mapType the map type to check"
"CollectionFactory.java:221"$1$"	 * @return {@code true} if the type is <em>approximable</em>"
"CollectionFactory.java:222"$0$"	 */"
"CollectionFactory.java:223"$1$"	public static boolean isApproximableMapType(@Nullable Class<?> mapType) {"
"CollectionFactory.java:224"$1$"		return (mapType != null && approximableMapTypes.contains(mapType));"
"CollectionFactory.java:225"$1$"	}"
"CollectionFactory.java:226"$0$""
"CollectionFactory.java:227"$0$"	/**"
"CollectionFactory.java:228"$0$"	 * Create the most approximate map for the given map."
"CollectionFactory.java:229"$1$"	 * <p><strong>Warning</strong>: Since the parameterized type {@code K} is"
"CollectionFactory.java:230"$1$"	 * not bound to the type of keys contained in the supplied {@code map},"
"CollectionFactory.java:231"$1$"	 * type safety cannot be guaranteed if the supplied {@code map} is an"
"CollectionFactory.java:232"$1$"	 * {@link EnumMap}. In such scenarios, the caller is responsible for"
"CollectionFactory.java:233"$1$"	 * ensuring that the key type in the supplied {@code map} is an enum type"
"CollectionFactory.java:234"$1$"	 * matching type {@code K}. As an alternative, the caller may wish to"
"CollectionFactory.java:235"$1$"	 * treat the return value as a raw map or map keyed by {@link Object}."
"CollectionFactory.java:236"$1$"	 * @param map the original map object, potentially {@code null}"
"CollectionFactory.java:237"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:238"$0$"	 * @return a new, empty map instance"
"CollectionFactory.java:239"$0$"	 * @see #isApproximableMapType"
"CollectionFactory.java:240"$0$"	 * @see java.util.EnumMap"
"CollectionFactory.java:241"$0$"	 * @see java.util.TreeMap"
"CollectionFactory.java:242"$0$"	 * @see java.util.LinkedHashMap"
"CollectionFactory.java:243"$0$"	 */"
"CollectionFactory.java:244"$1$"	@SuppressWarnings({""rawtypes"", ""unchecked""})"
"CollectionFactory.java:245"$1$"	public static <K, V> Map<K, V> createApproximateMap(@Nullable Object map, int capacity) {"
"CollectionFactory.java:246"$1$"		if (map instanceof EnumMap) {"
"CollectionFactory.java:247"$1$"			EnumMap enumMap = new EnumMap((EnumMap) map);"
"CollectionFactory.java:248"$1$"			enumMap.clear();"
"CollectionFactory.java:249"$1$"			return enumMap;"
"CollectionFactory.java:250"$1$"		}"
"CollectionFactory.java:251"$1$"		else if (map instanceof SortedMap) {"
"CollectionFactory.java:252"$1$"			return new TreeMap<>(((SortedMap<K, V>) map).comparator());"
"CollectionFactory.java:253"$1$"		}"
"CollectionFactory.java:254"$1$"		else {"
"CollectionFactory.java:255"$1$"			return new LinkedHashMap<>(capacity);"
"CollectionFactory.java:256"$1$"		}"
"CollectionFactory.java:257"$0$"	}"
"CollectionFactory.java:258"$0$""
"CollectionFactory.java:259"$0$"	/**"
"CollectionFactory.java:260"$0$"	 * Create the most appropriate map for the given map type."
"CollectionFactory.java:261"$1$"	 * <p>Delegates to {@link #createMap(Class, Class, int)} with a"
"CollectionFactory.java:262"$1$"	 * {@code null} key type."
"CollectionFactory.java:263"$0$"	 * @param mapType the desired type of the target map"
"CollectionFactory.java:264"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:265"$0$"	 * @return a new map instance"
"CollectionFactory.java:266"$1$"	 * @throws IllegalArgumentException if the supplied {@code mapType} is"
"CollectionFactory.java:267"$1$"	 * {@code null} or of type {@link EnumMap}"
"CollectionFactory.java:268"$0$"	 */"
"CollectionFactory.java:269"$1$"	public static <K, V> Map<K, V> createMap(Class<?> mapType, int capacity) {"
"CollectionFactory.java:270"$1$"		return createMap(mapType, null, capacity);"
"CollectionFactory.java:271"$1$"	}"
"CollectionFactory.java:272"$0$""
"CollectionFactory.java:273"$0$"	/**"
"CollectionFactory.java:274"$0$"	 * Create the most appropriate map for the given map type."
"CollectionFactory.java:275"$1$"	 * <p><strong>Warning</strong>: Since the parameterized type {@code K}"
"CollectionFactory.java:276"$1$"	 * is not bound to the supplied {@code keyType}, type safety cannot be"
"CollectionFactory.java:277"$1$"	 * guaranteed if the desired {@code mapType} is {@link EnumMap}. In such"
"CollectionFactory.java:278"$1$"	 * scenarios, the caller is responsible for ensuring that the {@code keyType}"
"CollectionFactory.java:279"$1$"	 * is an enum type matching type {@code K}. As an alternative, the caller"
"CollectionFactory.java:280"$0$"	 * may wish to treat the return value as a raw map or map keyed by"
"CollectionFactory.java:281"$1$"	 * {@link Object}. Similarly, type safety cannot be enforced if the"
"CollectionFactory.java:282"$1$"	 * desired {@code mapType} is {@link MultiValueMap}."
"CollectionFactory.java:283"$1$"	 * @param mapType the desired type of the target map (never {@code null})"
"CollectionFactory.java:284"$1$"	 * @param keyType the map's key type, or {@code null} if unknown"
"CollectionFactory.java:285"$1$"	 * (note: only relevant for {@link EnumMap} creation)"
"CollectionFactory.java:286"$0$"	 * @param capacity the initial capacity"
"CollectionFactory.java:287"$0$"	 * @return a new map instance"
"CollectionFactory.java:288"$0$"	 * @since 4.1.3"
"CollectionFactory.java:289"$0$"	 * @see java.util.LinkedHashMap"
"CollectionFactory.java:290"$0$"	 * @see java.util.TreeMap"
"CollectionFactory.java:291"$0$"	 * @see org.springframework.util.LinkedMultiValueMap"
"CollectionFactory.java:292"$0$"	 * @see java.util.EnumMap"
"CollectionFactory.java:293"$1$"	 * @throws IllegalArgumentException if the supplied {@code mapType} is"
"CollectionFactory.java:294"$1$"	 * {@code null}; or if the desired {@code mapType} is {@link EnumMap} and"
"CollectionFactory.java:295"$1$"	 * the supplied {@code keyType} is not a subtype of {@link Enum}"
"CollectionFactory.java:296"$0$"	 */"
"CollectionFactory.java:297"$1$"	@SuppressWarnings({""rawtypes"", ""unchecked""})"
"CollectionFactory.java:298"$1$"	public static <K, V> Map<K, V> createMap(Class<?> mapType, @Nullable Class<?> keyType, int capacity) {"
"CollectionFactory.java:299"$1$"		Assert.notNull(mapType, ""Map type must not be null"");"
"CollectionFactory.java:300"$1$"		if (mapType.isInterface()) {"
"CollectionFactory.java:301"$1$"			if (Map.class == mapType) {"
"CollectionFactory.java:302"$1$"				return new LinkedHashMap<>(capacity);"
"CollectionFactory.java:303"$1$"			}"
"CollectionFactory.java:304"$1$"			else if (SortedMap.class == mapType || NavigableMap.class == mapType) {"
"CollectionFactory.java:305"$1$"				return new TreeMap<>();"
"CollectionFactory.java:306"$1$"			}"
"CollectionFactory.java:307"$1$"			else if (MultiValueMap.class == mapType) {"
"CollectionFactory.java:308"$1$"				return new LinkedMultiValueMap();"
"CollectionFactory.java:309"$1$"			}"
"CollectionFactory.java:310"$1$"			else {"
"CollectionFactory.java:311"$1$"				throw new IllegalArgumentException(""Unsupported Map interface: "" + mapType.getName());"
"CollectionFactory.java:312"$1$"			}"
"CollectionFactory.java:313"$0$"		}"
"CollectionFactory.java:314"$1$"		else if (EnumMap.class == mapType) {"
"CollectionFactory.java:315"$1$"			Assert.notNull(keyType, ""Cannot create EnumMap for unknown key type"");"
"CollectionFactory.java:316"$1$"			return new EnumMap(asEnumType(keyType));"
"CollectionFactory.java:317"$1$"		}"
"CollectionFactory.java:318"$1$"		else {"
"CollectionFactory.java:319"$1$"			if (!Map.class.isAssignableFrom(mapType)) {"
"CollectionFactory.java:320"$1$"				throw new IllegalArgumentException(""Unsupported Map type: "" + mapType.getName());"
"CollectionFactory.java:321"$1$"			}"
"CollectionFactory.java:322"$1$"			try {"
"CollectionFactory.java:323"$1$"				return (Map<K, V>) ReflectionUtils.accessibleConstructor(mapType).newInstance();"
"CollectionFactory.java:324"$1$"			}"
"CollectionFactory.java:325"$1$"			catch (Throwable ex) {"
"CollectionFactory.java:326"$1$"				throw new IllegalArgumentException(""Could not instantiate Map type: "" + mapType.getName(), ex);"
"CollectionFactory.java:327"$1$"			}"
"CollectionFactory.java:328"$0$"		}"
"CollectionFactory.java:329"$0$"	}"
"CollectionFactory.java:330"$0$""
"CollectionFactory.java:331"$0$"	/**"
"CollectionFactory.java:332"$1$"	 * Create a variant of {@link java.util.Properties} that automatically adapts"
"CollectionFactory.java:333"$1$"	 * non-String values to String representations in {@link Properties#getProperty}."
"CollectionFactory.java:334"$1$"	 * <p>In addition, the returned {@code Properties} instance sorts properties"
"CollectionFactory.java:335"$0$"	 * alphanumerically based on their keys."
"CollectionFactory.java:336"$1$"	 * @return a new {@code Properties} instance"
"CollectionFactory.java:337"$0$"	 * @since 4.3.4"
"CollectionFactory.java:338"$0$"	 * @see #createSortedProperties(boolean)"
"CollectionFactory.java:339"$0$"	 * @see #createSortedProperties(Properties, boolean)"
"CollectionFactory.java:340"$0$"	 */"
"CollectionFactory.java:341"$0$"	@SuppressWarnings(""serial"")"
"CollectionFactory.java:342"$1$"	public static Properties createStringAdaptingProperties() {"
"CollectionFactory.java:343"$1$"		return new SortedProperties(false) {"
"CollectionFactory.java:344"$1$"			@Override"
"CollectionFactory.java:345"$1$"			@Nullable"
"CollectionFactory.java:346"$1$"			public String getProperty(String key) {"
"CollectionFactory.java:347"$1$"				Object value = get(key);"
"CollectionFactory.java:348"$1$"				return (value != null ? value.toString() : null);"
"CollectionFactory.java:349"$1$"			}"
"CollectionFactory.java:350"$0$"		};"
"CollectionFactory.java:351"$0$"	}"
"CollectionFactory.java:352"$0$""
"CollectionFactory.java:353"$0$"	/**"
"CollectionFactory.java:354"$1$"	 * Create a variant of {@link java.util.Properties} that sorts properties"
"CollectionFactory.java:355"$0$"	 * alphanumerically based on their keys."
"CollectionFactory.java:356"$1$"	 * <p>This can be useful when storing the {@link Properties} instance in a"
"CollectionFactory.java:357"$0$"	 * properties file, since it allows such files to be generated in a repeatable"
"CollectionFactory.java:358"$0$"	 * manner with consistent ordering of properties. Comments in generated"
"CollectionFactory.java:359"$0$"	 * properties files can also be optionally omitted."
"CollectionFactory.java:360"$1$"	 * @param omitComments {@code true} if comments should be omitted when"
"CollectionFactory.java:361"$0$"	 * storing properties in a file"
"CollectionFactory.java:362"$1$"	 * @return a new {@code Properties} instance"
"CollectionFactory.java:363"$0$"	 * @since 5.2"
"CollectionFactory.java:364"$0$"	 * @see #createStringAdaptingProperties()"
"CollectionFactory.java:365"$0$"	 * @see #createSortedProperties(Properties, boolean)"
"CollectionFactory.java:366"$0$"	 */"
"CollectionFactory.java:367"$1$"	public static Properties createSortedProperties(boolean omitComments) {"
"CollectionFactory.java:368"$1$"		return new SortedProperties(omitComments);"
"CollectionFactory.java:369"$1$"	}"
"CollectionFactory.java:370"$0$""
"CollectionFactory.java:371"$0$"	/**"
"CollectionFactory.java:372"$1$"	 * Create a variant of {@link java.util.Properties} that sorts properties"
"CollectionFactory.java:373"$0$"	 * alphanumerically based on their keys."
"CollectionFactory.java:374"$1$"	 * <p>This can be useful when storing the {@code Properties} instance in a"
"CollectionFactory.java:375"$0$"	 * properties file, since it allows such files to be generated in a repeatable"
"CollectionFactory.java:376"$0$"	 * manner with consistent ordering of properties. Comments in generated"
"CollectionFactory.java:377"$0$"	 * properties files can also be optionally omitted."
"CollectionFactory.java:378"$1$"	 * <p>The returned {@code Properties} instance will be populated with"
"CollectionFactory.java:379"$1$"	 * properties from the supplied {@code properties} object, but default"
"CollectionFactory.java:380"$1$"	 * properties from the supplied {@code properties} object will not be copied."
"CollectionFactory.java:381"$1$"	 * @param properties the {@code Properties} object from which to copy the"
"CollectionFactory.java:382"$0$"	 * initial properties"
"CollectionFactory.java:383"$1$"	 * @param omitComments {@code true} if comments should be omitted when"
"CollectionFactory.java:384"$0$"	 * storing properties in a file"
"CollectionFactory.java:385"$1$"	 * @return a new {@code Properties} instance"
"CollectionFactory.java:386"$0$"	 * @since 5.2"
"CollectionFactory.java:387"$0$"	 * @see #createStringAdaptingProperties()"
"CollectionFactory.java:388"$0$"	 * @see #createSortedProperties(boolean)"
"CollectionFactory.java:389"$0$"	 */"
"CollectionFactory.java:390"$1$"	public static Properties createSortedProperties(Properties properties, boolean omitComments) {"
"CollectionFactory.java:391"$1$"		return new SortedProperties(properties, omitComments);"
"CollectionFactory.java:392"$1$"	}"
"CollectionFactory.java:393"$0$""
"CollectionFactory.java:394"$0$"	/**"
"CollectionFactory.java:395"$1$"	 * Cast the given type to a subtype of {@link Enum}."
"CollectionFactory.java:396"$1$"	 * @param enumType the enum type, never {@code null}"
"CollectionFactory.java:397"$1$"	 * @return the given type as subtype of {@link Enum}"
"CollectionFactory.java:398"$1$"	 * @throws IllegalArgumentException if the given type is not a subtype of {@link Enum}"
"CollectionFactory.java:399"$0$"	 */"
"CollectionFactory.java:400"$0$"	@SuppressWarnings(""rawtypes"")"
"CollectionFactory.java:401"$1$"	private static Class<? extends Enum> asEnumType(Class<?> enumType) {"
"CollectionFactory.java:402"$1$"		Assert.notNull(enumType, ""Enum type must not be null"");"
"CollectionFactory.java:403"$1$"		if (!Enum.class.isAssignableFrom(enumType)) {"
"CollectionFactory.java:404"$1$"			throw new IllegalArgumentException(""Supplied type is not an enum: "" + enumType.getName());"
"CollectionFactory.java:405"$1$"		}"
"CollectionFactory.java:406"$0$"		return enumType.asSubclass(Enum.class);"
"CollectionFactory.java:407"$0$"	}"
"CollectionFactory.java:408"$0$""
"CollectionFactory.java:409"$0$"}"
"DomContentHandler.java:1"$0$"/*"
"DomContentHandler.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"DomContentHandler.java:3"$0$" *"
"DomContentHandler.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DomContentHandler.java:5"$0$" * you may not use this file except in compliance with the License."
"DomContentHandler.java:6"$0$" * You may obtain a copy of the License at"
"DomContentHandler.java:7"$0$" *"
"DomContentHandler.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DomContentHandler.java:9"$0$" *"
"DomContentHandler.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DomContentHandler.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DomContentHandler.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DomContentHandler.java:13"$0$" * See the License for the specific language governing permissions and"
"DomContentHandler.java:14"$0$" * limitations under the License."
"DomContentHandler.java:15"$0$" */"
"DomContentHandler.java:16"$0$""
"DomContentHandler.java:17"$0$"package org.springframework.util.xml;"
"DomContentHandler.java:18"$0$""
"DomContentHandler.java:19"$0$"import java.util.ArrayList;"
"DomContentHandler.java:20"$0$"import java.util.List;"
"DomContentHandler.java:21"$0$""
"DomContentHandler.java:22"$0$"import org.w3c.dom.Document;"
"DomContentHandler.java:23"$0$"import org.w3c.dom.Element;"
"DomContentHandler.java:24"$0$"import org.w3c.dom.Node;"
"DomContentHandler.java:25"$0$"import org.w3c.dom.ProcessingInstruction;"
"DomContentHandler.java:26"$0$"import org.w3c.dom.Text;"
"DomContentHandler.java:27"$0$"import org.xml.sax.Attributes;"
"DomContentHandler.java:28"$0$"import org.xml.sax.ContentHandler;"
"DomContentHandler.java:29"$0$"import org.xml.sax.Locator;"
"DomContentHandler.java:30"$0$""
"DomContentHandler.java:31"$0$"/**"
"DomContentHandler.java:32"$1$" * SAX {@code ContentHandler} that transforms callback calls to DOM {@code Node}s."
"DomContentHandler.java:33"$0$" *"
"DomContentHandler.java:34"$0$" * @author Arjen Poutsma"
"DomContentHandler.java:35"$0$" * @since 3.0"
"DomContentHandler.java:36"$0$" * @see org.w3c.dom.Node"
"DomContentHandler.java:37"$0$" */"
"DomContentHandler.java:38"$1$"class DomContentHandler implements ContentHandler {"
"DomContentHandler.java:39"$1$""
"DomContentHandler.java:40"$1$"	private final Document document;"
"DomContentHandler.java:41"$1$""
"DomContentHandler.java:42"$1$"	private final List<Element> elements = new ArrayList<>();"
"DomContentHandler.java:43"$1$""
"DomContentHandler.java:44"$1$"	private final Node node;"
"DomContentHandler.java:45"$1$""
"DomContentHandler.java:46"$1$""
"DomContentHandler.java:47"$1$"	/**"
"DomContentHandler.java:48"$1$"	 * Create a new instance of the {@code DomContentHandler} with the given node."
"DomContentHandler.java:49"$1$"	 * @param node the node to publish events to"
"DomContentHandler.java:50"$1$"	 */"
"DomContentHandler.java:51"$1$"	DomContentHandler(Node node) {"
"DomContentHandler.java:52"$1$"		this.node = node;"
"DomContentHandler.java:53"$1$"		if (node instanceof Document) {"
"DomContentHandler.java:54"$1$"			this.document = (Document) node;"
"DomContentHandler.java:55"$1$"		}"
"DomContentHandler.java:56"$1$"		else {"
"DomContentHandler.java:57"$1$"			this.document = node.getOwnerDocument();"
"DomContentHandler.java:58"$1$"		}"
"DomContentHandler.java:59"$0$"	}"
"DomContentHandler.java:60"$0$""
"DomContentHandler.java:61"$0$""
"DomContentHandler.java:62"$1$"	private Node getParent() {"
"DomContentHandler.java:63"$1$"		if (!this.elements.isEmpty()) {"
"DomContentHandler.java:64"$1$"			return this.elements.get(this.elements.size() - 1);"
"DomContentHandler.java:65"$1$"		}"
"DomContentHandler.java:66"$1$"		else {"
"DomContentHandler.java:67"$1$"			return this.node;"
"DomContentHandler.java:68"$1$"		}"
"DomContentHandler.java:69"$0$"	}"
"DomContentHandler.java:70"$0$""
"DomContentHandler.java:71"$0$"	@Override"
"DomContentHandler.java:72"$1$"	public void startElement(String uri, String localName, String qName, Attributes attributes) {"
"DomContentHandler.java:73"$1$"		Node parent = getParent();"
"DomContentHandler.java:74"$1$"		Element element = this.document.createElementNS(uri, qName);"
"DomContentHandler.java:75"$1$"		for (int i = 0; i < attributes.getLength(); i++) {"
"DomContentHandler.java:76"$1$"			String attrUri = attributes.getURI(i);"
"DomContentHandler.java:77"$1$"			String attrQname = attributes.getQName(i);"
"DomContentHandler.java:78"$1$"			String value = attributes.getValue(i);"
"DomContentHandler.java:79"$1$"			if (!attrQname.startsWith(""xmlns"")) {"
"DomContentHandler.java:80"$1$"				element.setAttributeNS(attrUri, attrQname, value);"
"DomContentHandler.java:81"$1$"			}"
"DomContentHandler.java:82"$0$"		}"
"DomContentHandler.java:83"$0$"		element = (Element) parent.appendChild(element);"
"DomContentHandler.java:84"$0$"		this.elements.add(element);"
"DomContentHandler.java:85"$0$"	}"
"DomContentHandler.java:86"$0$""
"DomContentHandler.java:87"$0$"	@Override"
"DomContentHandler.java:88"$1$"	public void endElement(String uri, String localName, String qName) {"
"DomContentHandler.java:89"$1$"		this.elements.remove(this.elements.size() - 1);"
"DomContentHandler.java:90"$1$"	}"
"DomContentHandler.java:91"$0$""
"DomContentHandler.java:92"$0$"	@Override"
"DomContentHandler.java:93"$1$"	public void characters(char[] ch, int start, int length) {"
"DomContentHandler.java:94"$1$"		String data = new String(ch, start, length);"
"DomContentHandler.java:95"$1$"		Node parent = getParent();"
"DomContentHandler.java:96"$1$"		Node lastChild = parent.getLastChild();"
"DomContentHandler.java:97"$1$"		if (lastChild != null && lastChild.getNodeType() == Node.TEXT_NODE) {"
"DomContentHandler.java:98"$1$"			((Text) lastChild).appendData(data);"
"DomContentHandler.java:99"$1$"		}"
"DomContentHandler.java:100"$1$"		else {"
"DomContentHandler.java:101"$1$"			Text text = this.document.createTextNode(data);"
"DomContentHandler.java:102"$1$"			parent.appendChild(text);"
"DomContentHandler.java:103"$1$"		}"
"DomContentHandler.java:104"$0$"	}"
"DomContentHandler.java:105"$0$""
"DomContentHandler.java:106"$0$"	@Override"
"DomContentHandler.java:107"$1$"	public void processingInstruction(String target, String data) {"
"DomContentHandler.java:108"$1$"		Node parent = getParent();"
"DomContentHandler.java:109"$1$"		ProcessingInstruction pi = this.document.createProcessingInstruction(target, data);"
"DomContentHandler.java:110"$1$"		parent.appendChild(pi);"
"DomContentHandler.java:111"$1$"	}"
"DomContentHandler.java:112"$0$""
"DomContentHandler.java:113"$0$""
"DomContentHandler.java:114"$0$"	// Unsupported"
"DomContentHandler.java:115"$0$""
"DomContentHandler.java:116"$0$"	@Override"
"DomContentHandler.java:117"$1$"	public void setDocumentLocator(Locator locator) {"
"DomContentHandler.java:118"$1$"	}"
"DomContentHandler.java:119"$0$""
"DomContentHandler.java:120"$0$"	@Override"
"DomContentHandler.java:121"$1$"	public void startDocument() {"
"DomContentHandler.java:122"$1$"	}"
"DomContentHandler.java:123"$0$""
"DomContentHandler.java:124"$0$"	@Override"
"DomContentHandler.java:125"$1$"	public void endDocument() {"
"DomContentHandler.java:126"$1$"	}"
"DomContentHandler.java:127"$0$""
"DomContentHandler.java:128"$0$"	@Override"
"DomContentHandler.java:129"$1$"	public void startPrefixMapping(String prefix, String uri) {"
"DomContentHandler.java:130"$1$"	}"
"DomContentHandler.java:131"$0$""
"DomContentHandler.java:132"$0$"	@Override"
"DomContentHandler.java:133"$1$"	public void endPrefixMapping(String prefix) {"
"DomContentHandler.java:134"$1$"	}"
"DomContentHandler.java:135"$0$""
"DomContentHandler.java:136"$0$"	@Override"
"DomContentHandler.java:137"$1$"	public void ignorableWhitespace(char[] ch, int start, int length) {"
"DomContentHandler.java:138"$1$"	}"
"DomContentHandler.java:139"$0$""
"DomContentHandler.java:140"$0$"	@Override"
"DomContentHandler.java:141"$1$"	public void skippedEntity(String name) {"
"DomContentHandler.java:142"$1$"	}"
"DomContentHandler.java:143"$0$""
"DomContentHandler.java:144"$0$"}"
"BridgeMethodResolver.java:1"$0$"/*"
"BridgeMethodResolver.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"BridgeMethodResolver.java:3"$0$" *"
"BridgeMethodResolver.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"BridgeMethodResolver.java:5"$0$" * you may not use this file except in compliance with the License."
"BridgeMethodResolver.java:6"$0$" * You may obtain a copy of the License at"
"BridgeMethodResolver.java:7"$0$" *"
"BridgeMethodResolver.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"BridgeMethodResolver.java:9"$0$" *"
"BridgeMethodResolver.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"BridgeMethodResolver.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"BridgeMethodResolver.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"BridgeMethodResolver.java:13"$0$" * See the License for the specific language governing permissions and"
"BridgeMethodResolver.java:14"$0$" * limitations under the License."
"BridgeMethodResolver.java:15"$0$" */"
"BridgeMethodResolver.java:16"$0$""
"BridgeMethodResolver.java:17"$0$"package org.springframework.core;"
"BridgeMethodResolver.java:18"$0$""
"BridgeMethodResolver.java:19"$0$"import java.lang.reflect.Method;"
"BridgeMethodResolver.java:20"$0$"import java.lang.reflect.Type;"
"BridgeMethodResolver.java:21"$0$"import java.util.ArrayList;"
"BridgeMethodResolver.java:22"$0$"import java.util.Arrays;"
"BridgeMethodResolver.java:23"$0$"import java.util.List;"
"BridgeMethodResolver.java:24"$0$"import java.util.Map;"
"BridgeMethodResolver.java:25"$0$""
"BridgeMethodResolver.java:26"$0$"import org.springframework.lang.Nullable;"
"BridgeMethodResolver.java:27"$0$"import org.springframework.util.ClassUtils;"
"BridgeMethodResolver.java:28"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"BridgeMethodResolver.java:29"$0$"import org.springframework.util.ReflectionUtils;"
"BridgeMethodResolver.java:30"$0$"import org.springframework.util.ReflectionUtils.MethodFilter;"
"BridgeMethodResolver.java:31"$0$""
"BridgeMethodResolver.java:32"$0$"/**"
"BridgeMethodResolver.java:33"$1$" * Helper for resolving synthetic {@link Method#isBridge bridge Methods} to the"
"BridgeMethodResolver.java:34"$1$" * {@link Method} being bridged."
"BridgeMethodResolver.java:35"$0$" *"
"BridgeMethodResolver.java:36"$1$" * <p>Given a synthetic {@link Method#isBridge bridge Method} returns the {@link Method}"
"BridgeMethodResolver.java:37"$0$" * being bridged. A bridge method may be created by the compiler when extending a"
"BridgeMethodResolver.java:38"$0$" * parameterized type whose methods have parameterized arguments. During runtime"
"BridgeMethodResolver.java:39"$1$" * invocation the bridge {@link Method} may be invoked and/or used via reflection."
"BridgeMethodResolver.java:40"$1$" * When attempting to locate annotations on {@link Method Methods}, it is wise to check"
"BridgeMethodResolver.java:41"$1$" * for bridge {@link Method Methods} as appropriate and find the bridged {@link Method}."
"BridgeMethodResolver.java:42"$0$" *"
"BridgeMethodResolver.java:43"$0$" * <p>See <a href=""https://java.sun.com/docs/books/jls/third_edition/html/expressions.html#15.12.4.5"">"
"BridgeMethodResolver.java:44"$0$" * The Java Language Specification</a> for more details on the use of bridge methods."
"BridgeMethodResolver.java:45"$0$" *"
"BridgeMethodResolver.java:46"$0$" * @author Rob Harrop"
"BridgeMethodResolver.java:47"$0$" * @author Juergen Hoeller"
"BridgeMethodResolver.java:48"$0$" * @author Phillip Webb"
"BridgeMethodResolver.java:49"$0$" * @since 2.0"
"BridgeMethodResolver.java:50"$0$" */"
"BridgeMethodResolver.java:51"$1$"public final class BridgeMethodResolver {"
"BridgeMethodResolver.java:52"$1$""
"BridgeMethodResolver.java:53"$1$"	private static final Map<Method, Method> cache = new ConcurrentReferenceHashMap<>();"
"BridgeMethodResolver.java:54"$1$""
"BridgeMethodResolver.java:55"$1$"	private BridgeMethodResolver() {"
"BridgeMethodResolver.java:56"$1$"	}"
"BridgeMethodResolver.java:57"$0$""
"BridgeMethodResolver.java:58"$0$""
"BridgeMethodResolver.java:59"$0$"	/**"
"BridgeMethodResolver.java:60"$1$"	 * Find the original method for the supplied {@link Method bridge Method}."
"BridgeMethodResolver.java:61"$1$"	 * <p>It is safe to call this method passing in a non-bridge {@link Method} instance."
"BridgeMethodResolver.java:62"$1$"	 * In such a case, the supplied {@link Method} instance is returned directly to the caller."
"BridgeMethodResolver.java:63"$0$"	 * Callers are <strong>not</strong> required to check for bridging before calling this method."
"BridgeMethodResolver.java:64"$0$"	 * @param bridgeMethod the method to introspect"
"BridgeMethodResolver.java:65"$0$"	 * @return the original method (either the bridged method or the passed-in method"
"BridgeMethodResolver.java:66"$0$"	 * if no more specific one could be found)"
"BridgeMethodResolver.java:67"$0$"	 */"
"BridgeMethodResolver.java:68"$1$"	public static Method findBridgedMethod(Method bridgeMethod) {"
"BridgeMethodResolver.java:69"$1$"		if (!bridgeMethod.isBridge()) {"
"BridgeMethodResolver.java:70"$1$"			return bridgeMethod;"
"BridgeMethodResolver.java:71"$1$"		}"
"BridgeMethodResolver.java:72"$0$"		Method bridgedMethod = cache.get(bridgeMethod);"
"BridgeMethodResolver.java:73"$1$"		if (bridgedMethod == null) {"
"BridgeMethodResolver.java:74"$0$"			// Gather all methods with matching name and parameter size."
"BridgeMethodResolver.java:75"$1$"			List<Method> candidateMethods = new ArrayList<>();"
"BridgeMethodResolver.java:76"$1$"			MethodFilter filter = candidateMethod ->"
"BridgeMethodResolver.java:77"$1$"					isBridgedCandidateFor(candidateMethod, bridgeMethod);"
"BridgeMethodResolver.java:78"$1$"			ReflectionUtils.doWithMethods(bridgeMethod.getDeclaringClass(), candidateMethods::add, filter);"
"BridgeMethodResolver.java:79"$1$"			if (!candidateMethods.isEmpty()) {"
"BridgeMethodResolver.java:80"$1$"				bridgedMethod = candidateMethods.size() == 1 ?"
"BridgeMethodResolver.java:81"$1$"						candidateMethods.get(0) :"
"BridgeMethodResolver.java:82"$1$"						searchCandidates(candidateMethods, bridgeMethod);"
"BridgeMethodResolver.java:83"$1$"			}"
"BridgeMethodResolver.java:84"$1$"			if (bridgedMethod == null) {"
"BridgeMethodResolver.java:85"$0$"				// A bridge method was passed in but we couldn't find the bridged method."
"BridgeMethodResolver.java:86"$0$"				// Let's proceed with the passed-in method and hope for the best..."
"BridgeMethodResolver.java:87"$1$"				bridgedMethod = bridgeMethod;"
"BridgeMethodResolver.java:88"$1$"			}"
"BridgeMethodResolver.java:89"$0$"			cache.put(bridgeMethod, bridgedMethod);"
"BridgeMethodResolver.java:90"$0$"		}"
"BridgeMethodResolver.java:91"$0$"		return bridgedMethod;"
"BridgeMethodResolver.java:92"$0$"	}"
"BridgeMethodResolver.java:93"$0$""
"BridgeMethodResolver.java:94"$0$"	/**"
"BridgeMethodResolver.java:95"$1$"	 * Returns {@code true} if the supplied '{@code candidateMethod}' can be"
"BridgeMethodResolver.java:96"$1$"	 * consider a validate candidate for the {@link Method} that is {@link Method#isBridge() bridged}"
"BridgeMethodResolver.java:97"$1$"	 * by the supplied {@link Method bridge Method}. This method performs inexpensive"
"BridgeMethodResolver.java:98"$0$"	 * checks and can be used quickly filter for a set of possible matches."
"BridgeMethodResolver.java:99"$0$"	 */"
"BridgeMethodResolver.java:100"$1$"	private static boolean isBridgedCandidateFor(Method candidateMethod, Method bridgeMethod) {"
"BridgeMethodResolver.java:101"$1$"		return (!candidateMethod.isBridge() && !candidateMethod.equals(bridgeMethod) &&"
"BridgeMethodResolver.java:102"$1$"				candidateMethod.getName().equals(bridgeMethod.getName()) &&"
"BridgeMethodResolver.java:103"$1$"				candidateMethod.getParameterCount() == bridgeMethod.getParameterCount());"
"BridgeMethodResolver.java:104"$1$"	}"
"BridgeMethodResolver.java:105"$0$""
"BridgeMethodResolver.java:106"$0$"	/**"
"BridgeMethodResolver.java:107"$0$"	 * Searches for the bridged method in the given candidates."
"BridgeMethodResolver.java:108"$0$"	 * @param candidateMethods the List of candidate Methods"
"BridgeMethodResolver.java:109"$0$"	 * @param bridgeMethod the bridge method"
"BridgeMethodResolver.java:110"$1$"	 * @return the bridged method, or {@code null} if none found"
"BridgeMethodResolver.java:111"$0$"	 */"
"BridgeMethodResolver.java:112"$0$"	@Nullable"
"BridgeMethodResolver.java:113"$1$"	private static Method searchCandidates(List<Method> candidateMethods, Method bridgeMethod) {"
"BridgeMethodResolver.java:114"$1$"		if (candidateMethods.isEmpty()) {"
"BridgeMethodResolver.java:115"$1$"			return null;"
"BridgeMethodResolver.java:116"$1$"		}"
"BridgeMethodResolver.java:117"$0$"		Method previousMethod = null;"
"BridgeMethodResolver.java:118"$0$"		boolean sameSig = true;"
"BridgeMethodResolver.java:119"$1$"		for (Method candidateMethod : candidateMethods) {"
"BridgeMethodResolver.java:120"$1$"			if (isBridgeMethodFor(bridgeMethod, candidateMethod, bridgeMethod.getDeclaringClass())) {"
"BridgeMethodResolver.java:121"$1$"				return candidateMethod;"
"BridgeMethodResolver.java:122"$1$"			}"
"BridgeMethodResolver.java:123"$1$"			else if (previousMethod != null) {"
"BridgeMethodResolver.java:124"$1$"				sameSig = sameSig &&"
"BridgeMethodResolver.java:125"$1$"						Arrays.equals(candidateMethod.getGenericParameterTypes(), previousMethod.getGenericParameterTypes());"
"BridgeMethodResolver.java:126"$1$"			}"
"BridgeMethodResolver.java:127"$0$"			previousMethod = candidateMethod;"
"BridgeMethodResolver.java:128"$0$"		}"
"BridgeMethodResolver.java:129"$0$"		return (sameSig ? candidateMethods.get(0) : null);"
"BridgeMethodResolver.java:130"$0$"	}"
"BridgeMethodResolver.java:131"$0$""
"BridgeMethodResolver.java:132"$0$"	/**"
"BridgeMethodResolver.java:133"$1$"	 * Determines whether or not the bridge {@link Method} is the bridge for the"
"BridgeMethodResolver.java:134"$1$"	 * supplied candidate {@link Method}."
"BridgeMethodResolver.java:135"$0$"	 */"
"BridgeMethodResolver.java:136"$1$"	static boolean isBridgeMethodFor(Method bridgeMethod, Method candidateMethod, Class<?> declaringClass) {"
"BridgeMethodResolver.java:137"$1$"		if (isResolvedTypeMatch(candidateMethod, bridgeMethod, declaringClass)) {"
"BridgeMethodResolver.java:138"$1$"			return true;"
"BridgeMethodResolver.java:139"$1$"		}"
"BridgeMethodResolver.java:140"$0$"		Method method = findGenericDeclaration(bridgeMethod);"
"BridgeMethodResolver.java:141"$0$"		return (method != null && isResolvedTypeMatch(method, candidateMethod, declaringClass));"
"BridgeMethodResolver.java:142"$0$"	}"
"BridgeMethodResolver.java:143"$0$""
"BridgeMethodResolver.java:144"$0$"	/**"
"BridgeMethodResolver.java:145"$1$"	 * Returns {@code true} if the {@link Type} signature of both the supplied"
"BridgeMethodResolver.java:146"$1$"	 * {@link Method#getGenericParameterTypes() generic Method} and concrete {@link Method}"
"BridgeMethodResolver.java:147"$0$"	 * are equal after resolving all types against the declaringType, otherwise"
"BridgeMethodResolver.java:148"$1$"	 * returns {@code false}."
"BridgeMethodResolver.java:149"$0$"	 */"
"BridgeMethodResolver.java:150"$1$"	private static boolean isResolvedTypeMatch(Method genericMethod, Method candidateMethod, Class<?> declaringClass) {"
"BridgeMethodResolver.java:151"$1$"		Type[] genericParameters = genericMethod.getGenericParameterTypes();"
"BridgeMethodResolver.java:152"$1$"		if (genericParameters.length != candidateMethod.getParameterCount()) {"
"BridgeMethodResolver.java:153"$1$"			return false;"
"BridgeMethodResolver.java:154"$1$"		}"
"BridgeMethodResolver.java:155"$0$"		Class<?>[] candidateParameters = candidateMethod.getParameterTypes();"
"BridgeMethodResolver.java:156"$1$"		for (int i = 0; i < candidateParameters.length; i++) {"
"BridgeMethodResolver.java:157"$1$"			ResolvableType genericParameter = ResolvableType.forMethodParameter(genericMethod, i, declaringClass);"
"BridgeMethodResolver.java:158"$1$"			Class<?> candidateParameter = candidateParameters[i];"
"BridgeMethodResolver.java:159"$1$"			if (candidateParameter.isArray()) {"
"BridgeMethodResolver.java:160"$0$"				// An array type: compare the component type."
"BridgeMethodResolver.java:161"$1$"				if (!candidateParameter.getComponentType().equals(genericParameter.getComponentType().toClass())) {"
"BridgeMethodResolver.java:162"$1$"					return false;"
"BridgeMethodResolver.java:163"$1$"				}"
"BridgeMethodResolver.java:164"$0$"			}"
"BridgeMethodResolver.java:165"$0$"			// A non-array type: compare the type itself."
"BridgeMethodResolver.java:166"$1$"			if (!candidateParameter.equals(genericParameter.toClass())) {"
"BridgeMethodResolver.java:167"$1$"				return false;"
"BridgeMethodResolver.java:168"$1$"			}"
"BridgeMethodResolver.java:169"$0$"		}"
"BridgeMethodResolver.java:170"$0$"		return true;"
"BridgeMethodResolver.java:171"$0$"	}"
"BridgeMethodResolver.java:172"$0$""
"BridgeMethodResolver.java:173"$0$"	/**"
"BridgeMethodResolver.java:174"$1$"	 * Searches for the generic {@link Method} declaration whose erased signature"
"BridgeMethodResolver.java:175"$0$"	 * matches that of the supplied bridge method."
"BridgeMethodResolver.java:176"$0$"	 * @throws IllegalStateException if the generic declaration cannot be found"
"BridgeMethodResolver.java:177"$0$"	 */"
"BridgeMethodResolver.java:178"$0$"	@Nullable"
"BridgeMethodResolver.java:179"$1$"	private static Method findGenericDeclaration(Method bridgeMethod) {"
"BridgeMethodResolver.java:180"$0$"		// Search parent types for method that has same signature as bridge."
"BridgeMethodResolver.java:181"$1$"		Class<?> superclass = bridgeMethod.getDeclaringClass().getSuperclass();"
"BridgeMethodResolver.java:182"$1$"		while (superclass != null && Object.class != superclass) {"
"BridgeMethodResolver.java:183"$1$"			Method method = searchForMatch(superclass, bridgeMethod);"
"BridgeMethodResolver.java:184"$1$"			if (method != null && !method.isBridge()) {"
"BridgeMethodResolver.java:185"$1$"				return method;"
"BridgeMethodResolver.java:186"$1$"			}"
"BridgeMethodResolver.java:187"$0$"			superclass = superclass.getSuperclass();"
"BridgeMethodResolver.java:188"$0$"		}"
"BridgeMethodResolver.java:189"$0$""
"BridgeMethodResolver.java:190"$0$"		Class<?>[] interfaces = ClassUtils.getAllInterfacesForClass(bridgeMethod.getDeclaringClass());"
"BridgeMethodResolver.java:191"$0$"		return searchInterfaces(interfaces, bridgeMethod);"
"BridgeMethodResolver.java:192"$0$"	}"
"BridgeMethodResolver.java:193"$0$""
"BridgeMethodResolver.java:194"$0$"	@Nullable"
"BridgeMethodResolver.java:195"$1$"	private static Method searchInterfaces(Class<?>[] interfaces, Method bridgeMethod) {"
"BridgeMethodResolver.java:196"$1$"		for (Class<?> ifc : interfaces) {"
"BridgeMethodResolver.java:197"$1$"			Method method = searchForMatch(ifc, bridgeMethod);"
"BridgeMethodResolver.java:198"$1$"			if (method != null && !method.isBridge()) {"
"BridgeMethodResolver.java:199"$1$"				return method;"
"BridgeMethodResolver.java:200"$1$"			}"
"BridgeMethodResolver.java:201"$1$"			else {"
"BridgeMethodResolver.java:202"$1$"				method = searchInterfaces(ifc.getInterfaces(), bridgeMethod);"
"BridgeMethodResolver.java:203"$1$"				if (method != null) {"
"BridgeMethodResolver.java:204"$1$"					return method;"
"BridgeMethodResolver.java:205"$1$"				}"
"BridgeMethodResolver.java:206"$0$"			}"
"BridgeMethodResolver.java:207"$0$"		}"
"BridgeMethodResolver.java:208"$0$"		return null;"
"BridgeMethodResolver.java:209"$0$"	}"
"BridgeMethodResolver.java:210"$0$""
"BridgeMethodResolver.java:211"$0$"	/**"
"BridgeMethodResolver.java:212"$1$"	 * If the supplied {@link Class} has a declared {@link Method} whose signature matches"
"BridgeMethodResolver.java:213"$1$"	 * that of the supplied {@link Method}, then this matching {@link Method} is returned,"
"BridgeMethodResolver.java:214"$1$"	 * otherwise {@code null} is returned."
"BridgeMethodResolver.java:215"$0$"	 */"
"BridgeMethodResolver.java:216"$0$"	@Nullable"
"BridgeMethodResolver.java:217"$1$"	private static Method searchForMatch(Class<?> type, Method bridgeMethod) {"
"BridgeMethodResolver.java:218"$1$"		try {"
"BridgeMethodResolver.java:219"$1$"			return type.getDeclaredMethod(bridgeMethod.getName(), bridgeMethod.getParameterTypes());"
"BridgeMethodResolver.java:220"$1$"		}"
"BridgeMethodResolver.java:221"$1$"		catch (NoSuchMethodException ex) {"
"BridgeMethodResolver.java:222"$1$"			return null;"
"BridgeMethodResolver.java:223"$1$"		}"
"BridgeMethodResolver.java:224"$0$"	}"
"BridgeMethodResolver.java:225"$0$""
"BridgeMethodResolver.java:226"$0$"	/**"
"BridgeMethodResolver.java:227"$0$"	 * Compare the signatures of the bridge method and the method which it bridges. If"
"BridgeMethodResolver.java:228"$0$"	 * the parameter and return types are the same, it is a 'visibility' bridge method"
"BridgeMethodResolver.java:229"$0$"	 * introduced in Java 6 to fix https://bugs.java.com/view_bug.do?bug_id=6342411."
"BridgeMethodResolver.java:230"$0$"	 * See also https://stas-blogspot.blogspot.com/2010/03/java-bridge-methods-explained.html"
"BridgeMethodResolver.java:231"$0$"	 * @return whether signatures match as described"
"BridgeMethodResolver.java:232"$0$"	 */"
"BridgeMethodResolver.java:233"$1$"	public static boolean isVisibilityBridgeMethodPair(Method bridgeMethod, Method bridgedMethod) {"
"BridgeMethodResolver.java:234"$1$"		if (bridgeMethod == bridgedMethod) {"
"BridgeMethodResolver.java:235"$1$"			return true;"
"BridgeMethodResolver.java:236"$1$"		}"
"BridgeMethodResolver.java:237"$0$"		return (bridgeMethod.getReturnType().equals(bridgedMethod.getReturnType()) &&"
"BridgeMethodResolver.java:238"$0$"				bridgeMethod.getParameterCount() == bridgedMethod.getParameterCount() &&"
"BridgeMethodResolver.java:239"$0$"				Arrays.equals(bridgeMethod.getParameterTypes(), bridgedMethod.getParameterTypes()));"
"BridgeMethodResolver.java:240"$0$"	}"
"BridgeMethodResolver.java:241"$0$""
"BridgeMethodResolver.java:242"$0$"}"
"ResourceArrayPropertyEditor.java:1"$0$"/*"
"ResourceArrayPropertyEditor.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ResourceArrayPropertyEditor.java:3"$0$" *"
"ResourceArrayPropertyEditor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceArrayPropertyEditor.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceArrayPropertyEditor.java:6"$0$" * You may obtain a copy of the License at"
"ResourceArrayPropertyEditor.java:7"$0$" *"
"ResourceArrayPropertyEditor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceArrayPropertyEditor.java:9"$0$" *"
"ResourceArrayPropertyEditor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceArrayPropertyEditor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceArrayPropertyEditor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceArrayPropertyEditor.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceArrayPropertyEditor.java:14"$0$" * limitations under the License."
"ResourceArrayPropertyEditor.java:15"$0$" */"
"ResourceArrayPropertyEditor.java:16"$0$""
"ResourceArrayPropertyEditor.java:17"$0$"package org.springframework.core.io.support;"
"ResourceArrayPropertyEditor.java:18"$0$""
"ResourceArrayPropertyEditor.java:19"$0$"import java.beans.PropertyEditorSupport;"
"ResourceArrayPropertyEditor.java:20"$0$"import java.io.IOException;"
"ResourceArrayPropertyEditor.java:21"$0$"import java.util.ArrayList;"
"ResourceArrayPropertyEditor.java:22"$0$"import java.util.Arrays;"
"ResourceArrayPropertyEditor.java:23"$0$"import java.util.Collection;"
"ResourceArrayPropertyEditor.java:24"$0$"import java.util.List;"
"ResourceArrayPropertyEditor.java:25"$0$""
"ResourceArrayPropertyEditor.java:26"$0$"import org.apache.commons.logging.Log;"
"ResourceArrayPropertyEditor.java:27"$0$"import org.apache.commons.logging.LogFactory;"
"ResourceArrayPropertyEditor.java:28"$0$""
"ResourceArrayPropertyEditor.java:29"$0$"import org.springframework.core.env.Environment;"
"ResourceArrayPropertyEditor.java:30"$0$"import org.springframework.core.env.PropertyResolver;"
"ResourceArrayPropertyEditor.java:31"$0$"import org.springframework.core.env.StandardEnvironment;"
"ResourceArrayPropertyEditor.java:32"$0$"import org.springframework.core.io.Resource;"
"ResourceArrayPropertyEditor.java:33"$0$"import org.springframework.lang.Nullable;"
"ResourceArrayPropertyEditor.java:34"$0$"import org.springframework.util.Assert;"
"ResourceArrayPropertyEditor.java:35"$0$""
"ResourceArrayPropertyEditor.java:36"$0$"/**"
"ResourceArrayPropertyEditor.java:37"$1$" * Editor for {@link org.springframework.core.io.Resource} arrays, to"
"ResourceArrayPropertyEditor.java:38"$1$" * automatically convert {@code String} location patterns"
"ResourceArrayPropertyEditor.java:39"$1$" * (e.g. {@code ""file:C:/my*.txt""} or {@code ""classpath*:myfile.txt""})"
"ResourceArrayPropertyEditor.java:40"$1$" * to {@code Resource} array properties. Can also translate a collection"
"ResourceArrayPropertyEditor.java:41"$0$" * or array of location patterns into a merged Resource array."
"ResourceArrayPropertyEditor.java:42"$0$" *"
"ResourceArrayPropertyEditor.java:43"$1$" * <p>A path may contain {@code ${...}} placeholders, to be"
"ResourceArrayPropertyEditor.java:44"$1$" * resolved as {@link org.springframework.core.env.Environment} properties:"
"ResourceArrayPropertyEditor.java:45"$1$" * e.g. {@code ${user.dir}}. Unresolvable placeholders are ignored by default."
"ResourceArrayPropertyEditor.java:46"$0$" *"
"ResourceArrayPropertyEditor.java:47"$1$" * <p>Delegates to a {@link ResourcePatternResolver},"
"ResourceArrayPropertyEditor.java:48"$1$" * by default using a {@link PathMatchingResourcePatternResolver}."
"ResourceArrayPropertyEditor.java:49"$0$" *"
"ResourceArrayPropertyEditor.java:50"$0$" * @author Juergen Hoeller"
"ResourceArrayPropertyEditor.java:51"$0$" * @author Chris Beams"
"ResourceArrayPropertyEditor.java:52"$0$" * @since 1.1.2"
"ResourceArrayPropertyEditor.java:53"$0$" * @see org.springframework.core.io.Resource"
"ResourceArrayPropertyEditor.java:54"$0$" * @see ResourcePatternResolver"
"ResourceArrayPropertyEditor.java:55"$0$" * @see PathMatchingResourcePatternResolver"
"ResourceArrayPropertyEditor.java:56"$0$" */"
"ResourceArrayPropertyEditor.java:57"$1$"public class ResourceArrayPropertyEditor extends PropertyEditorSupport {"
"ResourceArrayPropertyEditor.java:58"$1$""
"ResourceArrayPropertyEditor.java:59"$1$"	private static final Log logger = LogFactory.getLog(ResourceArrayPropertyEditor.class);"
"ResourceArrayPropertyEditor.java:60"$1$""
"ResourceArrayPropertyEditor.java:61"$1$"	private final ResourcePatternResolver resourcePatternResolver;"
"ResourceArrayPropertyEditor.java:62"$1$""
"ResourceArrayPropertyEditor.java:63"$1$"	@Nullable"
"ResourceArrayPropertyEditor.java:64"$1$"	private PropertyResolver propertyResolver;"
"ResourceArrayPropertyEditor.java:65"$1$""
"ResourceArrayPropertyEditor.java:66"$1$"	private final boolean ignoreUnresolvablePlaceholders;"
"ResourceArrayPropertyEditor.java:67"$1$""
"ResourceArrayPropertyEditor.java:68"$1$""
"ResourceArrayPropertyEditor.java:69"$1$"	/**"
"ResourceArrayPropertyEditor.java:70"$1$"	 * Create a new ResourceArrayPropertyEditor with a default"
"ResourceArrayPropertyEditor.java:71"$1$"	 * {@link PathMatchingResourcePatternResolver} and {@link StandardEnvironment}."
"ResourceArrayPropertyEditor.java:72"$1$"	 * @see PathMatchingResourcePatternResolver"
"ResourceArrayPropertyEditor.java:73"$1$"	 * @see Environment"
"ResourceArrayPropertyEditor.java:74"$1$"	 */"
"ResourceArrayPropertyEditor.java:75"$1$"	public ResourceArrayPropertyEditor() {"
"ResourceArrayPropertyEditor.java:76"$1$"		this(new PathMatchingResourcePatternResolver(), null, true);"
"ResourceArrayPropertyEditor.java:77"$1$"	}"
"ResourceArrayPropertyEditor.java:78"$0$""
"ResourceArrayPropertyEditor.java:79"$0$"	/**"
"ResourceArrayPropertyEditor.java:80"$1$"	 * Create a new ResourceArrayPropertyEditor with the given {@link ResourcePatternResolver}"
"ResourceArrayPropertyEditor.java:81"$1$"	 * and {@link PropertyResolver} (typically an {@link Environment})."
"ResourceArrayPropertyEditor.java:82"$0$"	 * @param resourcePatternResolver the ResourcePatternResolver to use"
"ResourceArrayPropertyEditor.java:83"$0$"	 * @param propertyResolver the PropertyResolver to use"
"ResourceArrayPropertyEditor.java:84"$0$"	 */"
"ResourceArrayPropertyEditor.java:85"$0$"	public ResourceArrayPropertyEditor("
"ResourceArrayPropertyEditor.java:86"$1$"			ResourcePatternResolver resourcePatternResolver, @Nullable PropertyResolver propertyResolver) {"
"ResourceArrayPropertyEditor.java:87"$1$""
"ResourceArrayPropertyEditor.java:88"$1$"		this(resourcePatternResolver, propertyResolver, true);"
"ResourceArrayPropertyEditor.java:89"$1$"	}"
"ResourceArrayPropertyEditor.java:90"$0$""
"ResourceArrayPropertyEditor.java:91"$0$"	/**"
"ResourceArrayPropertyEditor.java:92"$1$"	 * Create a new ResourceArrayPropertyEditor with the given {@link ResourcePatternResolver}"
"ResourceArrayPropertyEditor.java:93"$1$"	 * and {@link PropertyResolver} (typically an {@link Environment})."
"ResourceArrayPropertyEditor.java:94"$0$"	 * @param resourcePatternResolver the ResourcePatternResolver to use"
"ResourceArrayPropertyEditor.java:95"$0$"	 * @param propertyResolver the PropertyResolver to use"
"ResourceArrayPropertyEditor.java:96"$0$"	 * @param ignoreUnresolvablePlaceholders whether to ignore unresolvable placeholders"
"ResourceArrayPropertyEditor.java:97"$0$"	 * if no corresponding system property could be found"
"ResourceArrayPropertyEditor.java:98"$0$"	 */"
"ResourceArrayPropertyEditor.java:99"$0$"	public ResourceArrayPropertyEditor(ResourcePatternResolver resourcePatternResolver,"
"ResourceArrayPropertyEditor.java:100"$1$"			@Nullable PropertyResolver propertyResolver, boolean ignoreUnresolvablePlaceholders) {"
"ResourceArrayPropertyEditor.java:101"$1$""
"ResourceArrayPropertyEditor.java:102"$1$"		Assert.notNull(resourcePatternResolver, ""ResourcePatternResolver must not be null"");"
"ResourceArrayPropertyEditor.java:103"$1$"		this.resourcePatternResolver = resourcePatternResolver;"
"ResourceArrayPropertyEditor.java:104"$1$"		this.propertyResolver = propertyResolver;"
"ResourceArrayPropertyEditor.java:105"$1$"		this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;"
"ResourceArrayPropertyEditor.java:106"$1$"	}"
"ResourceArrayPropertyEditor.java:107"$0$""
"ResourceArrayPropertyEditor.java:108"$0$""
"ResourceArrayPropertyEditor.java:109"$0$"	/**"
"ResourceArrayPropertyEditor.java:110"$0$"	 * Treat the given text as a location pattern and convert it to a Resource array."
"ResourceArrayPropertyEditor.java:111"$0$"	 */"
"ResourceArrayPropertyEditor.java:112"$0$"	@Override"
"ResourceArrayPropertyEditor.java:113"$1$"	public void setAsText(String text) {"
"ResourceArrayPropertyEditor.java:114"$1$"		String pattern = resolvePath(text).trim();"
"ResourceArrayPropertyEditor.java:115"$1$"		try {"
"ResourceArrayPropertyEditor.java:116"$1$"			setValue(this.resourcePatternResolver.getResources(pattern));"
"ResourceArrayPropertyEditor.java:117"$1$"		}"
"ResourceArrayPropertyEditor.java:118"$1$"		catch (IOException ex) {"
"ResourceArrayPropertyEditor.java:119"$1$"			throw new IllegalArgumentException("
"ResourceArrayPropertyEditor.java:120"$1$"					""Could not resolve resource location pattern ["" + pattern + ""]: "" + ex.getMessage());"
"ResourceArrayPropertyEditor.java:121"$1$"		}"
"ResourceArrayPropertyEditor.java:122"$0$"	}"
"ResourceArrayPropertyEditor.java:123"$0$""
"ResourceArrayPropertyEditor.java:124"$0$"	/**"
"ResourceArrayPropertyEditor.java:125"$0$"	 * Treat the given value as a collection or array and convert it to a Resource array."
"ResourceArrayPropertyEditor.java:126"$0$"	 * Considers String elements as location patterns and takes Resource elements as-is."
"ResourceArrayPropertyEditor.java:127"$0$"	 */"
"ResourceArrayPropertyEditor.java:128"$0$"	@Override"
"ResourceArrayPropertyEditor.java:129"$1$"	public void setValue(Object value) throws IllegalArgumentException {"
"ResourceArrayPropertyEditor.java:130"$1$"		if (value instanceof Collection || (value instanceof Object[] && !(value instanceof Resource[]))) {"
"ResourceArrayPropertyEditor.java:131"$1$"			Collection<?> input = (value instanceof Collection ? (Collection<?>) value : Arrays.asList((Object[]) value));"
"ResourceArrayPropertyEditor.java:132"$1$"			List<Resource> merged = new ArrayList<>();"
"ResourceArrayPropertyEditor.java:133"$1$"			for (Object element : input) {"
"ResourceArrayPropertyEditor.java:134"$1$"				if (element instanceof String) {"
"ResourceArrayPropertyEditor.java:135"$0$"					// A location pattern: resolve it into a Resource array."
"ResourceArrayPropertyEditor.java:136"$0$"					// Might point to a single resource or to multiple resources."
"ResourceArrayPropertyEditor.java:137"$1$"					String pattern = resolvePath((String) element).trim();"
"ResourceArrayPropertyEditor.java:138"$1$"					try {"
"ResourceArrayPropertyEditor.java:139"$1$"						Resource[] resources = this.resourcePatternResolver.getResources(pattern);"
"ResourceArrayPropertyEditor.java:140"$1$"						for (Resource resource : resources) {"
"ResourceArrayPropertyEditor.java:141"$1$"							if (!merged.contains(resource)) {"
"ResourceArrayPropertyEditor.java:142"$1$"								merged.add(resource);"
"ResourceArrayPropertyEditor.java:143"$1$"							}"
"ResourceArrayPropertyEditor.java:144"$0$"						}"
"ResourceArrayPropertyEditor.java:145"$0$"					}"
"ResourceArrayPropertyEditor.java:146"$1$"					catch (IOException ex) {"
"ResourceArrayPropertyEditor.java:147"$0$"						// ignore - might be an unresolved placeholder or non-existing base directory"
"ResourceArrayPropertyEditor.java:148"$1$"						if (logger.isDebugEnabled()) {"
"ResourceArrayPropertyEditor.java:149"$1$"							logger.debug(""Could not retrieve resources for pattern '"" + pattern + ""'"", ex);"
"ResourceArrayPropertyEditor.java:150"$1$"						}"
"ResourceArrayPropertyEditor.java:151"$0$"					}"
"ResourceArrayPropertyEditor.java:152"$0$"				}"
"ResourceArrayPropertyEditor.java:153"$1$"				else if (element instanceof Resource) {"
"ResourceArrayPropertyEditor.java:154"$0$"					// A Resource object: add it to the result."
"ResourceArrayPropertyEditor.java:155"$1$"					Resource resource = (Resource) element;"
"ResourceArrayPropertyEditor.java:156"$1$"					if (!merged.contains(resource)) {"
"ResourceArrayPropertyEditor.java:157"$1$"						merged.add(resource);"
"ResourceArrayPropertyEditor.java:158"$1$"					}"
"ResourceArrayPropertyEditor.java:159"$0$"				}"
"ResourceArrayPropertyEditor.java:160"$1$"				else {"
"ResourceArrayPropertyEditor.java:161"$1$"					throw new IllegalArgumentException(""Cannot convert element ["" + element + ""] to ["" +"
"ResourceArrayPropertyEditor.java:162"$1$"							Resource.class.getName() + ""]: only location String and Resource object supported"");"
"ResourceArrayPropertyEditor.java:163"$1$"				}"
"ResourceArrayPropertyEditor.java:164"$0$"			}"
"ResourceArrayPropertyEditor.java:165"$0$"			super.setValue(merged.toArray(new Resource[0]));"
"ResourceArrayPropertyEditor.java:166"$0$"		}"
"ResourceArrayPropertyEditor.java:167"$0$""
"ResourceArrayPropertyEditor.java:168"$1$"		else {"
"ResourceArrayPropertyEditor.java:169"$0$"			// An arbitrary value: probably a String or a Resource array."
"ResourceArrayPropertyEditor.java:170"$0$"			// setAsText will be called for a String; a Resource array will be used as-is."
"ResourceArrayPropertyEditor.java:171"$1$"			super.setValue(value);"
"ResourceArrayPropertyEditor.java:172"$1$"		}"
"ResourceArrayPropertyEditor.java:173"$0$"	}"
"ResourceArrayPropertyEditor.java:174"$0$""
"ResourceArrayPropertyEditor.java:175"$0$"	/**"
"ResourceArrayPropertyEditor.java:176"$0$"	 * Resolve the given path, replacing placeholders with"
"ResourceArrayPropertyEditor.java:177"$0$"	 * corresponding system property values if necessary."
"ResourceArrayPropertyEditor.java:178"$0$"	 * @param path the original file path"
"ResourceArrayPropertyEditor.java:179"$0$"	 * @return the resolved file path"
"ResourceArrayPropertyEditor.java:180"$0$"	 * @see PropertyResolver#resolvePlaceholders"
"ResourceArrayPropertyEditor.java:181"$0$"	 * @see PropertyResolver#resolveRequiredPlaceholders(String)"
"ResourceArrayPropertyEditor.java:182"$0$"	 */"
"ResourceArrayPropertyEditor.java:183"$1$"	protected String resolvePath(String path) {"
"ResourceArrayPropertyEditor.java:184"$1$"		if (this.propertyResolver == null) {"
"ResourceArrayPropertyEditor.java:185"$1$"			this.propertyResolver = new StandardEnvironment();"
"ResourceArrayPropertyEditor.java:186"$1$"		}"
"ResourceArrayPropertyEditor.java:187"$0$"		return (this.ignoreUnresolvablePlaceholders ? this.propertyResolver.resolvePlaceholders(path) :"
"ResourceArrayPropertyEditor.java:188"$0$"				this.propertyResolver.resolveRequiredPlaceholders(path));"
"ResourceArrayPropertyEditor.java:189"$0$"	}"
"ResourceArrayPropertyEditor.java:190"$0$""
"ResourceArrayPropertyEditor.java:191"$0$"}"
"ConcurrentReferenceHashMap.java:1"$0$"/*"
"ConcurrentReferenceHashMap.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"ConcurrentReferenceHashMap.java:3"$0$" *"
"ConcurrentReferenceHashMap.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ConcurrentReferenceHashMap.java:5"$0$" * you may not use this file except in compliance with the License."
"ConcurrentReferenceHashMap.java:6"$0$" * You may obtain a copy of the License at"
"ConcurrentReferenceHashMap.java:7"$0$" *"
"ConcurrentReferenceHashMap.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ConcurrentReferenceHashMap.java:9"$0$" *"
"ConcurrentReferenceHashMap.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ConcurrentReferenceHashMap.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ConcurrentReferenceHashMap.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ConcurrentReferenceHashMap.java:13"$0$" * See the License for the specific language governing permissions and"
"ConcurrentReferenceHashMap.java:14"$0$" * limitations under the License."
"ConcurrentReferenceHashMap.java:15"$0$" */"
"ConcurrentReferenceHashMap.java:16"$0$""
"ConcurrentReferenceHashMap.java:17"$0$"package org.springframework.util;"
"ConcurrentReferenceHashMap.java:18"$0$""
"ConcurrentReferenceHashMap.java:19"$0$"import java.lang.ref.ReferenceQueue;"
"ConcurrentReferenceHashMap.java:20"$0$"import java.lang.ref.SoftReference;"
"ConcurrentReferenceHashMap.java:21"$0$"import java.lang.ref.WeakReference;"
"ConcurrentReferenceHashMap.java:22"$0$"import java.lang.reflect.Array;"
"ConcurrentReferenceHashMap.java:23"$0$"import java.util.AbstractMap;"
"ConcurrentReferenceHashMap.java:24"$0$"import java.util.AbstractSet;"
"ConcurrentReferenceHashMap.java:25"$0$"import java.util.Collections;"
"ConcurrentReferenceHashMap.java:26"$0$"import java.util.EnumSet;"
"ConcurrentReferenceHashMap.java:27"$0$"import java.util.HashSet;"
"ConcurrentReferenceHashMap.java:28"$0$"import java.util.Iterator;"
"ConcurrentReferenceHashMap.java:29"$0$"import java.util.Map;"
"ConcurrentReferenceHashMap.java:30"$0$"import java.util.NoSuchElementException;"
"ConcurrentReferenceHashMap.java:31"$0$"import java.util.Set;"
"ConcurrentReferenceHashMap.java:32"$0$"import java.util.concurrent.ConcurrentHashMap;"
"ConcurrentReferenceHashMap.java:33"$0$"import java.util.concurrent.ConcurrentMap;"
"ConcurrentReferenceHashMap.java:34"$0$"import java.util.concurrent.atomic.AtomicInteger;"
"ConcurrentReferenceHashMap.java:35"$0$"import java.util.concurrent.locks.ReentrantLock;"
"ConcurrentReferenceHashMap.java:36"$0$""
"ConcurrentReferenceHashMap.java:37"$0$"import org.springframework.lang.Nullable;"
"ConcurrentReferenceHashMap.java:38"$0$""
"ConcurrentReferenceHashMap.java:39"$0$"/**"
"ConcurrentReferenceHashMap.java:40"$1$" * A {@link ConcurrentHashMap} that uses {@link ReferenceType#SOFT soft} or"
"ConcurrentReferenceHashMap.java:41"$1$" * {@linkplain ReferenceType#WEAK weak} references for both {@code keys} and {@code values}."
"ConcurrentReferenceHashMap.java:42"$0$" *"
"ConcurrentReferenceHashMap.java:43"$0$" * <p>This class can be used as an alternative to"
"ConcurrentReferenceHashMap.java:44"$1$" * {@code Collections.synchronizedMap(new WeakHashMap<K, Reference<V>>())} in order to"
"ConcurrentReferenceHashMap.java:45"$0$" * support better performance when accessed concurrently. This implementation follows the"
"ConcurrentReferenceHashMap.java:46"$1$" * same design constraints as {@link ConcurrentHashMap} with the exception that"
"ConcurrentReferenceHashMap.java:47"$1$" * {@code null} values and {@code null} keys are supported."
"ConcurrentReferenceHashMap.java:48"$0$" *"
"ConcurrentReferenceHashMap.java:49"$0$" * <p><b>NOTE:</b> The use of references means that there is no guarantee that items"
"ConcurrentReferenceHashMap.java:50"$0$" * placed into the map will be subsequently available. The garbage collector may discard"
"ConcurrentReferenceHashMap.java:51"$0$" * references at any time, so it may appear that an unknown thread is silently removing"
"ConcurrentReferenceHashMap.java:52"$0$" * entries."
"ConcurrentReferenceHashMap.java:53"$0$" *"
"ConcurrentReferenceHashMap.java:54"$0$" * <p>If not explicitly specified, this implementation will use"
"ConcurrentReferenceHashMap.java:55"$1$" * {@linkplain SoftReference soft entry references}."
"ConcurrentReferenceHashMap.java:56"$0$" *"
"ConcurrentReferenceHashMap.java:57"$0$" * @author Phillip Webb"
"ConcurrentReferenceHashMap.java:58"$0$" * @author Juergen Hoeller"
"ConcurrentReferenceHashMap.java:59"$0$" * @since 3.2"
"ConcurrentReferenceHashMap.java:60"$0$" * @param <K> the key type"
"ConcurrentReferenceHashMap.java:61"$0$" * @param <V> the value type"
"ConcurrentReferenceHashMap.java:62"$0$" */"
"ConcurrentReferenceHashMap.java:63"$1$"public class ConcurrentReferenceHashMap<K, V> extends AbstractMap<K, V> implements ConcurrentMap<K, V> {"
"ConcurrentReferenceHashMap.java:64"$1$""
"ConcurrentReferenceHashMap.java:65"$1$"	private static final int DEFAULT_INITIAL_CAPACITY = 16;"
"ConcurrentReferenceHashMap.java:66"$1$""
"ConcurrentReferenceHashMap.java:67"$1$"	private static final float DEFAULT_LOAD_FACTOR = 0.75f;"
"ConcurrentReferenceHashMap.java:68"$1$""
"ConcurrentReferenceHashMap.java:69"$1$"	private static final int DEFAULT_CONCURRENCY_LEVEL = 16;"
"ConcurrentReferenceHashMap.java:70"$1$""
"ConcurrentReferenceHashMap.java:71"$1$"	private static final ReferenceType DEFAULT_REFERENCE_TYPE = ReferenceType.SOFT;"
"ConcurrentReferenceHashMap.java:72"$1$""
"ConcurrentReferenceHashMap.java:73"$1$"	private static final int MAXIMUM_CONCURRENCY_LEVEL = 1 << 16;"
"ConcurrentReferenceHashMap.java:74"$1$""
"ConcurrentReferenceHashMap.java:75"$1$"	private static final int MAXIMUM_SEGMENT_SIZE = 1 << 30;"
"ConcurrentReferenceHashMap.java:76"$1$""
"ConcurrentReferenceHashMap.java:77"$1$""
"ConcurrentReferenceHashMap.java:78"$1$"	/**"
"ConcurrentReferenceHashMap.java:79"$1$"	 * Array of segments indexed using the high order bits from the hash."
"ConcurrentReferenceHashMap.java:80"$1$"	 */"
"ConcurrentReferenceHashMap.java:81"$1$"	private final Segment[] segments;"
"ConcurrentReferenceHashMap.java:82"$1$""
"ConcurrentReferenceHashMap.java:83"$1$"	/**"
"ConcurrentReferenceHashMap.java:84"$1$"	 * When the average number of references per table exceeds this value resize will be attempted."
"ConcurrentReferenceHashMap.java:85"$1$"	 */"
"ConcurrentReferenceHashMap.java:86"$1$"	private final float loadFactor;"
"ConcurrentReferenceHashMap.java:87"$1$""
"ConcurrentReferenceHashMap.java:88"$1$"	/**"
"ConcurrentReferenceHashMap.java:89"$1$"	 * The reference type: SOFT or WEAK."
"ConcurrentReferenceHashMap.java:90"$1$"	 */"
"ConcurrentReferenceHashMap.java:91"$1$"	private final ReferenceType referenceType;"
"ConcurrentReferenceHashMap.java:92"$1$""
"ConcurrentReferenceHashMap.java:93"$1$"	/**"
"ConcurrentReferenceHashMap.java:94"$1$"	 * The shift value used to calculate the size of the segments array and an index from the hash."
"ConcurrentReferenceHashMap.java:95"$1$"	 */"
"ConcurrentReferenceHashMap.java:96"$1$"	private final int shift;"
"ConcurrentReferenceHashMap.java:97"$1$""
"ConcurrentReferenceHashMap.java:98"$1$"	/**"
"ConcurrentReferenceHashMap.java:99"$1$"	 * Late binding entry set."
"ConcurrentReferenceHashMap.java:100"$1$"	 */"
"ConcurrentReferenceHashMap.java:101"$1$"	@Nullable"
"ConcurrentReferenceHashMap.java:102"$1$"	private volatile Set<Map.Entry<K, V>> entrySet;"
"ConcurrentReferenceHashMap.java:103"$1$""
"ConcurrentReferenceHashMap.java:104"$1$""
"ConcurrentReferenceHashMap.java:105"$1$"	/**"
"ConcurrentReferenceHashMap.java:106"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:107"$1$"	 */"
"ConcurrentReferenceHashMap.java:108"$1$"	public ConcurrentReferenceHashMap() {"
"ConcurrentReferenceHashMap.java:109"$1$"		this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);"
"ConcurrentReferenceHashMap.java:110"$1$"	}"
"ConcurrentReferenceHashMap.java:111"$0$""
"ConcurrentReferenceHashMap.java:112"$0$"	/**"
"ConcurrentReferenceHashMap.java:113"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:114"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:115"$0$"	 */"
"ConcurrentReferenceHashMap.java:116"$1$"	public ConcurrentReferenceHashMap(int initialCapacity) {"
"ConcurrentReferenceHashMap.java:117"$1$"		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);"
"ConcurrentReferenceHashMap.java:118"$1$"	}"
"ConcurrentReferenceHashMap.java:119"$0$""
"ConcurrentReferenceHashMap.java:120"$0$"	/**"
"ConcurrentReferenceHashMap.java:121"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:122"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:123"$0$"	 * @param loadFactor the load factor. When the average number of references per table"
"ConcurrentReferenceHashMap.java:124"$0$"	 * exceeds this value resize will be attempted"
"ConcurrentReferenceHashMap.java:125"$0$"	 */"
"ConcurrentReferenceHashMap.java:126"$1$"	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor) {"
"ConcurrentReferenceHashMap.java:127"$1$"		this(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL, DEFAULT_REFERENCE_TYPE);"
"ConcurrentReferenceHashMap.java:128"$1$"	}"
"ConcurrentReferenceHashMap.java:129"$0$""
"ConcurrentReferenceHashMap.java:130"$0$"	/**"
"ConcurrentReferenceHashMap.java:131"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:132"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:133"$0$"	 * @param concurrencyLevel the expected number of threads that will concurrently"
"ConcurrentReferenceHashMap.java:134"$0$"	 * write to the map"
"ConcurrentReferenceHashMap.java:135"$0$"	 */"
"ConcurrentReferenceHashMap.java:136"$1$"	public ConcurrentReferenceHashMap(int initialCapacity, int concurrencyLevel) {"
"ConcurrentReferenceHashMap.java:137"$1$"		this(initialCapacity, DEFAULT_LOAD_FACTOR, concurrencyLevel, DEFAULT_REFERENCE_TYPE);"
"ConcurrentReferenceHashMap.java:138"$1$"	}"
"ConcurrentReferenceHashMap.java:139"$0$""
"ConcurrentReferenceHashMap.java:140"$0$"	/**"
"ConcurrentReferenceHashMap.java:141"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:142"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:143"$0$"	 * @param referenceType the reference type used for entries (soft or weak)"
"ConcurrentReferenceHashMap.java:144"$0$"	 */"
"ConcurrentReferenceHashMap.java:145"$1$"	public ConcurrentReferenceHashMap(int initialCapacity, ReferenceType referenceType) {"
"ConcurrentReferenceHashMap.java:146"$1$"		this(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL, referenceType);"
"ConcurrentReferenceHashMap.java:147"$1$"	}"
"ConcurrentReferenceHashMap.java:148"$0$""
"ConcurrentReferenceHashMap.java:149"$0$"	/**"
"ConcurrentReferenceHashMap.java:150"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:151"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:152"$0$"	 * @param loadFactor the load factor. When the average number of references per"
"ConcurrentReferenceHashMap.java:153"$0$"	 * table exceeds this value, resize will be attempted."
"ConcurrentReferenceHashMap.java:154"$0$"	 * @param concurrencyLevel the expected number of threads that will concurrently"
"ConcurrentReferenceHashMap.java:155"$0$"	 * write to the map"
"ConcurrentReferenceHashMap.java:156"$0$"	 */"
"ConcurrentReferenceHashMap.java:157"$1$"	public ConcurrentReferenceHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {"
"ConcurrentReferenceHashMap.java:158"$1$"		this(initialCapacity, loadFactor, concurrencyLevel, DEFAULT_REFERENCE_TYPE);"
"ConcurrentReferenceHashMap.java:159"$1$"	}"
"ConcurrentReferenceHashMap.java:160"$0$""
"ConcurrentReferenceHashMap.java:161"$0$"	/**"
"ConcurrentReferenceHashMap.java:162"$1$"	 * Create a new {@code ConcurrentReferenceHashMap} instance."
"ConcurrentReferenceHashMap.java:163"$0$"	 * @param initialCapacity the initial capacity of the map"
"ConcurrentReferenceHashMap.java:164"$0$"	 * @param loadFactor the load factor. When the average number of references per"
"ConcurrentReferenceHashMap.java:165"$0$"	 * table exceeds this value, resize will be attempted."
"ConcurrentReferenceHashMap.java:166"$0$"	 * @param concurrencyLevel the expected number of threads that will concurrently"
"ConcurrentReferenceHashMap.java:167"$0$"	 * write to the map"
"ConcurrentReferenceHashMap.java:168"$0$"	 * @param referenceType the reference type used for entries (soft or weak)"
"ConcurrentReferenceHashMap.java:169"$0$"	 */"
"ConcurrentReferenceHashMap.java:170"$0$"	@SuppressWarnings(""unchecked"")"
"ConcurrentReferenceHashMap.java:171"$0$"	public ConcurrentReferenceHashMap("
"ConcurrentReferenceHashMap.java:172"$1$"			int initialCapacity, float loadFactor, int concurrencyLevel, ReferenceType referenceType) {"
"ConcurrentReferenceHashMap.java:173"$1$""
"ConcurrentReferenceHashMap.java:174"$1$"		Assert.isTrue(initialCapacity >= 0, ""Initial capacity must not be negative"");"
"ConcurrentReferenceHashMap.java:175"$1$"		Assert.isTrue(loadFactor > 0f, ""Load factor must be positive"");"
"ConcurrentReferenceHashMap.java:176"$1$"		Assert.isTrue(concurrencyLevel > 0, ""Concurrency level must be positive"");"
"ConcurrentReferenceHashMap.java:177"$1$"		Assert.notNull(referenceType, ""Reference type must not be null"");"
"ConcurrentReferenceHashMap.java:178"$1$"		this.loadFactor = loadFactor;"
"ConcurrentReferenceHashMap.java:179"$1$"		this.shift = calculateShift(concurrencyLevel, MAXIMUM_CONCURRENCY_LEVEL);"
"ConcurrentReferenceHashMap.java:180"$1$"		int size = 1 << this.shift;"
"ConcurrentReferenceHashMap.java:181"$1$"		this.referenceType = referenceType;"
"ConcurrentReferenceHashMap.java:182"$1$"		int roundedUpSegmentCapacity = (int) ((initialCapacity + size - 1L) / size);"
"ConcurrentReferenceHashMap.java:183"$1$"		int initialSize = 1 << calculateShift(roundedUpSegmentCapacity, MAXIMUM_SEGMENT_SIZE);"
"ConcurrentReferenceHashMap.java:184"$1$"		Segment[] segments = (Segment[]) Array.newInstance(Segment.class, size);"
"ConcurrentReferenceHashMap.java:185"$1$"		int resizeThreshold = (int) (initialSize * getLoadFactor());"
"ConcurrentReferenceHashMap.java:186"$1$"		for (int i = 0; i < segments.length; i++) {"
"ConcurrentReferenceHashMap.java:187"$1$"			segments[i] = new Segment(initialSize, resizeThreshold);"
"ConcurrentReferenceHashMap.java:188"$1$"		}"
"ConcurrentReferenceHashMap.java:189"$0$"		this.segments = segments;"
"ConcurrentReferenceHashMap.java:190"$0$"	}"
"ConcurrentReferenceHashMap.java:191"$0$""
"ConcurrentReferenceHashMap.java:192"$0$""
"ConcurrentReferenceHashMap.java:193"$1$"	protected final float getLoadFactor() {"
"ConcurrentReferenceHashMap.java:194"$1$"		return this.loadFactor;"
"ConcurrentReferenceHashMap.java:195"$1$"	}"
"ConcurrentReferenceHashMap.java:196"$0$""
"ConcurrentReferenceHashMap.java:197"$1$"	protected final int getSegmentsSize() {"
"ConcurrentReferenceHashMap.java:198"$1$"		return this.segments.length;"
"ConcurrentReferenceHashMap.java:199"$1$"	}"
"ConcurrentReferenceHashMap.java:200"$0$""
"ConcurrentReferenceHashMap.java:201"$1$"	protected final Segment getSegment(int index) {"
"ConcurrentReferenceHashMap.java:202"$1$"		return this.segments[index];"
"ConcurrentReferenceHashMap.java:203"$1$"	}"
"ConcurrentReferenceHashMap.java:204"$0$""
"ConcurrentReferenceHashMap.java:205"$0$"	/**"
"ConcurrentReferenceHashMap.java:206"$1$"	 * Factory method that returns the {@link ReferenceManager}."
"ConcurrentReferenceHashMap.java:207"$1$"	 * This method will be called once for each {@link Segment}."
"ConcurrentReferenceHashMap.java:208"$0$"	 * @return a new reference manager"
"ConcurrentReferenceHashMap.java:209"$0$"	 */"
"ConcurrentReferenceHashMap.java:210"$1$"	protected ReferenceManager createReferenceManager() {"
"ConcurrentReferenceHashMap.java:211"$1$"		return new ReferenceManager();"
"ConcurrentReferenceHashMap.java:212"$1$"	}"
"ConcurrentReferenceHashMap.java:213"$0$""
"ConcurrentReferenceHashMap.java:214"$0$"	/**"
"ConcurrentReferenceHashMap.java:215"$0$"	 * Get the hash for a given object, apply an additional hash function to reduce"
"ConcurrentReferenceHashMap.java:216"$0$"	 * collisions. This implementation uses the same Wang/Jenkins algorithm as"
"ConcurrentReferenceHashMap.java:217"$1$"	 * {@link ConcurrentHashMap}. Subclasses can override to provide alternative hashing."
"ConcurrentReferenceHashMap.java:218"$0$"	 * @param o the object to hash (may be null)"
"ConcurrentReferenceHashMap.java:219"$0$"	 * @return the resulting hash code"
"ConcurrentReferenceHashMap.java:220"$0$"	 */"
"ConcurrentReferenceHashMap.java:221"$1$"	protected int getHash(@Nullable Object o) {"
"ConcurrentReferenceHashMap.java:222"$1$"		int hash = (o != null ? o.hashCode() : 0);"
"ConcurrentReferenceHashMap.java:223"$1$"		hash += (hash << 15) ^ 0xffffcd7d;"
"ConcurrentReferenceHashMap.java:224"$1$"		hash ^= (hash >>> 10);"
"ConcurrentReferenceHashMap.java:225"$1$"		hash += (hash << 3);"
"ConcurrentReferenceHashMap.java:226"$1$"		hash ^= (hash >>> 6);"
"ConcurrentReferenceHashMap.java:227"$1$"		hash += (hash << 2) + (hash << 14);"
"ConcurrentReferenceHashMap.java:228"$1$"		hash ^= (hash >>> 16);"
"ConcurrentReferenceHashMap.java:229"$1$"		return hash;"
"ConcurrentReferenceHashMap.java:230"$1$"	}"
"ConcurrentReferenceHashMap.java:231"$0$""
"ConcurrentReferenceHashMap.java:232"$0$"	@Override"
"ConcurrentReferenceHashMap.java:233"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:234"$1$"	public V get(@Nullable Object key) {"
"ConcurrentReferenceHashMap.java:235"$1$"		Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);"
"ConcurrentReferenceHashMap.java:236"$1$"		Entry<K, V> entry = (ref != null ? ref.get() : null);"
"ConcurrentReferenceHashMap.java:237"$1$"		return (entry != null ? entry.getValue() : null);"
"ConcurrentReferenceHashMap.java:238"$1$"	}"
"ConcurrentReferenceHashMap.java:239"$0$""
"ConcurrentReferenceHashMap.java:240"$0$"	@Override"
"ConcurrentReferenceHashMap.java:241"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:242"$1$"	public V getOrDefault(@Nullable Object key, @Nullable V defaultValue) {"
"ConcurrentReferenceHashMap.java:243"$1$"		Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);"
"ConcurrentReferenceHashMap.java:244"$1$"		Entry<K, V> entry = (ref != null ? ref.get() : null);"
"ConcurrentReferenceHashMap.java:245"$1$"		return (entry != null ? entry.getValue() : defaultValue);"
"ConcurrentReferenceHashMap.java:246"$1$"	}"
"ConcurrentReferenceHashMap.java:247"$0$""
"ConcurrentReferenceHashMap.java:248"$0$"	@Override"
"ConcurrentReferenceHashMap.java:249"$1$"	public boolean containsKey(@Nullable Object key) {"
"ConcurrentReferenceHashMap.java:250"$1$"		Reference<K, V> ref = getReference(key, Restructure.WHEN_NECESSARY);"
"ConcurrentReferenceHashMap.java:251"$1$"		Entry<K, V> entry = (ref != null ? ref.get() : null);"
"ConcurrentReferenceHashMap.java:252"$1$"		return (entry != null && ObjectUtils.nullSafeEquals(entry.getKey(), key));"
"ConcurrentReferenceHashMap.java:253"$1$"	}"
"ConcurrentReferenceHashMap.java:254"$0$""
"ConcurrentReferenceHashMap.java:255"$0$"	/**"
"ConcurrentReferenceHashMap.java:256"$1$"	 * Return a {@link Reference} to the {@link Entry} for the specified {@code key},"
"ConcurrentReferenceHashMap.java:257"$1$"	 * or {@code null} if not found."
"ConcurrentReferenceHashMap.java:258"$1$"	 * @param key the key (can be {@code null})"
"ConcurrentReferenceHashMap.java:259"$0$"	 * @param restructure types of restructure allowed during this call"
"ConcurrentReferenceHashMap.java:260"$1$"	 * @return the reference, or {@code null} if not found"
"ConcurrentReferenceHashMap.java:261"$0$"	 */"
"ConcurrentReferenceHashMap.java:262"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:263"$1$"	protected final Reference<K, V> getReference(@Nullable Object key, Restructure restructure) {"
"ConcurrentReferenceHashMap.java:264"$1$"		int hash = getHash(key);"
"ConcurrentReferenceHashMap.java:265"$1$"		return getSegmentForHash(hash).getReference(key, hash, restructure);"
"ConcurrentReferenceHashMap.java:266"$1$"	}"
"ConcurrentReferenceHashMap.java:267"$0$""
"ConcurrentReferenceHashMap.java:268"$0$"	@Override"
"ConcurrentReferenceHashMap.java:269"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:270"$1$"	public V put(@Nullable K key, @Nullable V value) {"
"ConcurrentReferenceHashMap.java:271"$1$"		return put(key, value, true);"
"ConcurrentReferenceHashMap.java:272"$1$"	}"
"ConcurrentReferenceHashMap.java:273"$0$""
"ConcurrentReferenceHashMap.java:274"$0$"	@Override"
"ConcurrentReferenceHashMap.java:275"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:276"$1$"	public V putIfAbsent(@Nullable K key, @Nullable V value) {"
"ConcurrentReferenceHashMap.java:277"$1$"		return put(key, value, false);"
"ConcurrentReferenceHashMap.java:278"$1$"	}"
"ConcurrentReferenceHashMap.java:279"$0$""
"ConcurrentReferenceHashMap.java:280"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:281"$1$"	private V put(@Nullable final K key, @Nullable final V value, final boolean overwriteExisting) {"
"ConcurrentReferenceHashMap.java:282"$1$"		return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.RESIZE) {"
"ConcurrentReferenceHashMap.java:283"$1$"			@Override"
"ConcurrentReferenceHashMap.java:284"$1$"			@Nullable"
"ConcurrentReferenceHashMap.java:285"$1$"			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {"
"ConcurrentReferenceHashMap.java:286"$1$"				if (entry != null) {"
"ConcurrentReferenceHashMap.java:287"$1$"					V oldValue = entry.getValue();"
"ConcurrentReferenceHashMap.java:288"$1$"					if (overwriteExisting) {"
"ConcurrentReferenceHashMap.java:289"$1$"						entry.setValue(value);"
"ConcurrentReferenceHashMap.java:290"$1$"					}"
"ConcurrentReferenceHashMap.java:291"$0$"					return oldValue;"
"ConcurrentReferenceHashMap.java:292"$0$"				}"
"ConcurrentReferenceHashMap.java:293"$0$"				Assert.state(entries != null, ""No entries segment"");"
"ConcurrentReferenceHashMap.java:294"$0$"				entries.add(value);"
"ConcurrentReferenceHashMap.java:295"$0$"				return null;"
"ConcurrentReferenceHashMap.java:296"$0$"			}"
"ConcurrentReferenceHashMap.java:297"$0$"		});"
"ConcurrentReferenceHashMap.java:298"$0$"	}"
"ConcurrentReferenceHashMap.java:299"$0$""
"ConcurrentReferenceHashMap.java:300"$0$"	@Override"
"ConcurrentReferenceHashMap.java:301"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:302"$1$"	public V remove(Object key) {"
"ConcurrentReferenceHashMap.java:303"$1$"		return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {"
"ConcurrentReferenceHashMap.java:304"$1$"			@Override"
"ConcurrentReferenceHashMap.java:305"$1$"			@Nullable"
"ConcurrentReferenceHashMap.java:306"$1$"			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {"
"ConcurrentReferenceHashMap.java:307"$1$"				if (entry != null) {"
"ConcurrentReferenceHashMap.java:308"$1$"					if (ref != null) {"
"ConcurrentReferenceHashMap.java:309"$1$"						ref.release();"
"ConcurrentReferenceHashMap.java:310"$1$"					}"
"ConcurrentReferenceHashMap.java:311"$0$"					return entry.value;"
"ConcurrentReferenceHashMap.java:312"$0$"				}"
"ConcurrentReferenceHashMap.java:313"$0$"				return null;"
"ConcurrentReferenceHashMap.java:314"$0$"			}"
"ConcurrentReferenceHashMap.java:315"$0$"		});"
"ConcurrentReferenceHashMap.java:316"$0$"	}"
"ConcurrentReferenceHashMap.java:317"$0$""
"ConcurrentReferenceHashMap.java:318"$0$"	@Override"
"ConcurrentReferenceHashMap.java:319"$1$"	public boolean remove(Object key, final Object value) {"
"ConcurrentReferenceHashMap.java:320"$1$"		Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_AFTER, TaskOption.SKIP_IF_EMPTY) {"
"ConcurrentReferenceHashMap.java:321"$1$"			@Override"
"ConcurrentReferenceHashMap.java:322"$1$"			protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {"
"ConcurrentReferenceHashMap.java:323"$1$"				if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), value)) {"
"ConcurrentReferenceHashMap.java:324"$1$"					if (ref != null) {"
"ConcurrentReferenceHashMap.java:325"$1$"						ref.release();"
"ConcurrentReferenceHashMap.java:326"$1$"					}"
"ConcurrentReferenceHashMap.java:327"$0$"					return true;"
"ConcurrentReferenceHashMap.java:328"$0$"				}"
"ConcurrentReferenceHashMap.java:329"$0$"				return false;"
"ConcurrentReferenceHashMap.java:330"$0$"			}"
"ConcurrentReferenceHashMap.java:331"$0$"		});"
"ConcurrentReferenceHashMap.java:332"$0$"		return (Boolean.TRUE.equals(result));"
"ConcurrentReferenceHashMap.java:333"$0$"	}"
"ConcurrentReferenceHashMap.java:334"$0$""
"ConcurrentReferenceHashMap.java:335"$0$"	@Override"
"ConcurrentReferenceHashMap.java:336"$1$"	public boolean replace(K key, final V oldValue, final V newValue) {"
"ConcurrentReferenceHashMap.java:337"$1$"		Boolean result = doTask(key, new Task<Boolean>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {"
"ConcurrentReferenceHashMap.java:338"$1$"			@Override"
"ConcurrentReferenceHashMap.java:339"$1$"			protected Boolean execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {"
"ConcurrentReferenceHashMap.java:340"$1$"				if (entry != null && ObjectUtils.nullSafeEquals(entry.getValue(), oldValue)) {"
"ConcurrentReferenceHashMap.java:341"$1$"					entry.setValue(newValue);"
"ConcurrentReferenceHashMap.java:342"$1$"					return true;"
"ConcurrentReferenceHashMap.java:343"$1$"				}"
"ConcurrentReferenceHashMap.java:344"$0$"				return false;"
"ConcurrentReferenceHashMap.java:345"$0$"			}"
"ConcurrentReferenceHashMap.java:346"$0$"		});"
"ConcurrentReferenceHashMap.java:347"$0$"		return (Boolean.TRUE.equals(result));"
"ConcurrentReferenceHashMap.java:348"$0$"	}"
"ConcurrentReferenceHashMap.java:349"$0$""
"ConcurrentReferenceHashMap.java:350"$0$"	@Override"
"ConcurrentReferenceHashMap.java:351"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:352"$1$"	public V replace(K key, final V value) {"
"ConcurrentReferenceHashMap.java:353"$1$"		return doTask(key, new Task<V>(TaskOption.RESTRUCTURE_BEFORE, TaskOption.SKIP_IF_EMPTY) {"
"ConcurrentReferenceHashMap.java:354"$1$"			@Override"
"ConcurrentReferenceHashMap.java:355"$1$"			@Nullable"
"ConcurrentReferenceHashMap.java:356"$1$"			protected V execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {"
"ConcurrentReferenceHashMap.java:357"$1$"				if (entry != null) {"
"ConcurrentReferenceHashMap.java:358"$1$"					V oldValue = entry.getValue();"
"ConcurrentReferenceHashMap.java:359"$1$"					entry.setValue(value);"
"ConcurrentReferenceHashMap.java:360"$1$"					return oldValue;"
"ConcurrentReferenceHashMap.java:361"$1$"				}"
"ConcurrentReferenceHashMap.java:362"$0$"				return null;"
"ConcurrentReferenceHashMap.java:363"$0$"			}"
"ConcurrentReferenceHashMap.java:364"$0$"		});"
"ConcurrentReferenceHashMap.java:365"$0$"	}"
"ConcurrentReferenceHashMap.java:366"$0$""
"ConcurrentReferenceHashMap.java:367"$0$"	@Override"
"ConcurrentReferenceHashMap.java:368"$1$"	public void clear() {"
"ConcurrentReferenceHashMap.java:369"$1$"		for (Segment segment : this.segments) {"
"ConcurrentReferenceHashMap.java:370"$1$"			segment.clear();"
"ConcurrentReferenceHashMap.java:371"$1$"		}"
"ConcurrentReferenceHashMap.java:372"$0$"	}"
"ConcurrentReferenceHashMap.java:373"$0$""
"ConcurrentReferenceHashMap.java:374"$0$"	/**"
"ConcurrentReferenceHashMap.java:375"$0$"	 * Remove any entries that have been garbage collected and are no longer referenced."
"ConcurrentReferenceHashMap.java:376"$0$"	 * Under normal circumstances garbage collected entries are automatically purged as"
"ConcurrentReferenceHashMap.java:377"$0$"	 * items are added or removed from the Map. This method can be used to force a purge,"
"ConcurrentReferenceHashMap.java:378"$0$"	 * and is useful when the Map is read frequently but updated less often."
"ConcurrentReferenceHashMap.java:379"$0$"	 */"
"ConcurrentReferenceHashMap.java:380"$1$"	public void purgeUnreferencedEntries() {"
"ConcurrentReferenceHashMap.java:381"$1$"		for (Segment segment : this.segments) {"
"ConcurrentReferenceHashMap.java:382"$1$"			segment.restructureIfNecessary(false);"
"ConcurrentReferenceHashMap.java:383"$1$"		}"
"ConcurrentReferenceHashMap.java:384"$0$"	}"
"ConcurrentReferenceHashMap.java:385"$0$""
"ConcurrentReferenceHashMap.java:386"$0$""
"ConcurrentReferenceHashMap.java:387"$0$"	@Override"
"ConcurrentReferenceHashMap.java:388"$1$"	public int size() {"
"ConcurrentReferenceHashMap.java:389"$1$"		int size = 0;"
"ConcurrentReferenceHashMap.java:390"$1$"		for (Segment segment : this.segments) {"
"ConcurrentReferenceHashMap.java:391"$1$"			size += segment.getCount();"
"ConcurrentReferenceHashMap.java:392"$1$"		}"
"ConcurrentReferenceHashMap.java:393"$0$"		return size;"
"ConcurrentReferenceHashMap.java:394"$0$"	}"
"ConcurrentReferenceHashMap.java:395"$0$""
"ConcurrentReferenceHashMap.java:396"$0$"	@Override"
"ConcurrentReferenceHashMap.java:397"$1$"	public boolean isEmpty() {"
"ConcurrentReferenceHashMap.java:398"$1$"		for (Segment segment : this.segments) {"
"ConcurrentReferenceHashMap.java:399"$1$"			if (segment.getCount() > 0) {"
"ConcurrentReferenceHashMap.java:400"$1$"				return false;"
"ConcurrentReferenceHashMap.java:401"$1$"			}"
"ConcurrentReferenceHashMap.java:402"$0$"		}"
"ConcurrentReferenceHashMap.java:403"$0$"		return true;"
"ConcurrentReferenceHashMap.java:404"$0$"	}"
"ConcurrentReferenceHashMap.java:405"$0$""
"ConcurrentReferenceHashMap.java:406"$0$"	@Override"
"ConcurrentReferenceHashMap.java:407"$1$"	public Set<Map.Entry<K, V>> entrySet() {"
"ConcurrentReferenceHashMap.java:408"$1$"		Set<Map.Entry<K, V>> entrySet = this.entrySet;"
"ConcurrentReferenceHashMap.java:409"$1$"		if (entrySet == null) {"
"ConcurrentReferenceHashMap.java:410"$1$"			entrySet = new EntrySet();"
"ConcurrentReferenceHashMap.java:411"$1$"			this.entrySet = entrySet;"
"ConcurrentReferenceHashMap.java:412"$1$"		}"
"ConcurrentReferenceHashMap.java:413"$0$"		return entrySet;"
"ConcurrentReferenceHashMap.java:414"$0$"	}"
"ConcurrentReferenceHashMap.java:415"$0$""
"ConcurrentReferenceHashMap.java:416"$0$"	@Nullable"
"ConcurrentReferenceHashMap.java:417"$1$"	private <T> T doTask(@Nullable Object key, Task<T> task) {"
"ConcurrentReferenceHashMap.java:418"$1$"		int hash = getHash(key);"
"ConcurrentReferenceHashMap.java:419"$1$"		return getSegmentForHash(hash).doTask(hash, key, task);"
"ConcurrentReferenceHashMap.java:420"$1$"	}"
"ConcurrentReferenceHashMap.java:421"$0$""
"ConcurrentReferenceHashMap.java:422"$1$"	private Segment getSegmentForHash(int hash) {"
"ConcurrentReferenceHashMap.java:423"$1$"		return this.segments[(hash >>> (32 - this.shift)) & (this.segments.length - 1)];"
"ConcurrentReferenceHashMap.java:424"$1$"	}"
"ConcurrentReferenceHashMap.java:425"$0$""
"ConcurrentReferenceHashMap.java:426"$0$"	/**"
"ConcurrentReferenceHashMap.java:427"$0$"	 * Calculate a shift value that can be used to create a power-of-two value between"
"ConcurrentReferenceHashMap.java:428"$0$"	 * the specified maximum and minimum values."
"ConcurrentReferenceHashMap.java:429"$0$"	 * @param minimumValue the minimum value"
"ConcurrentReferenceHashMap.java:430"$0$"	 * @param maximumValue the maximum value"
"ConcurrentReferenceHashMap.java:431"$1$"	 * @return the calculated shift (use {@code 1 << shift} to obtain a value)"
"ConcurrentReferenceHashMap.java:432"$0$"	 */"
"ConcurrentReferenceHashMap.java:433"$1$"	protected static int calculateShift(int minimumValue, int maximumValue) {"
"ConcurrentReferenceHashMap.java:434"$1$"		int shift = 0;"
"ConcurrentReferenceHashMap.java:435"$1$"		int value = 1;"
"ConcurrentReferenceHashMap.java:436"$1$"		while (value < minimumValue && value < maximumValue) {"
"ConcurrentReferenceHashMap.java:437"$1$"			value <<= 1;"
"ConcurrentReferenceHashMap.java:438"$1$"			shift++;"
"ConcurrentReferenceHashMap.java:439"$1$"		}"
"ConcurrentReferenceHashMap.java:440"$0$"		return shift;"
"ConcurrentReferenceHashMap.java:441"$0$"	}"
"ConcurrentReferenceHashMap.java:442"$0$""
"ConcurrentReferenceHashMap.java:443"$0$""
"ConcurrentReferenceHashMap.java:444"$0$"	/**"
"ConcurrentReferenceHashMap.java:445"$0$"	 * Various reference types supported by this map."
"ConcurrentReferenceHashMap.java:446"$0$"	 */"
"ConcurrentReferenceHashMap.java:447"$1$"	public enum ReferenceType {"
"ConcurrentReferenceHashMap.java:448"$1$""
"ConcurrentReferenceHashMap.java:449"$1$"		/** Use {@link SoftReference SoftReferences}. */"
"ConcurrentReferenceHashMap.java:450"$1$"		SOFT,"
"ConcurrentReferenceHashMap.java:451"$1$""
"ConcurrentReferenceHashMap.java:452"$1$"		/** Use {@link WeakReference WeakReferences}. */"
"ConcurrentReferenceHashMap.java:453"$1$"		WEAK"
"ConcurrentReferenceHashMap.java:454"$1$"	}"
"ConcurrentReferenceHashMap.java:455"$0$""
"ConcurrentReferenceHashMap.java:456"$0$""
"ConcurrentReferenceHashMap.java:457"$0$"	/**"
"ConcurrentReferenceHashMap.java:458"$0$"	 * A single segment used to divide the map to allow better concurrent performance."
"ConcurrentReferenceHashMap.java:459"$0$"	 */"
"ConcurrentReferenceHashMap.java:460"$0$"	@SuppressWarnings(""serial"")"
"ConcurrentReferenceHashMap.java:461"$1$"	protected final class Segment extends ReentrantLock {"
"ConcurrentReferenceHashMap.java:462"$1$""
"ConcurrentReferenceHashMap.java:463"$1$"		private final ReferenceManager referenceManager;"
"ConcurrentReferenceHashMap.java:464"$1$""
"ConcurrentReferenceHashMap.java:465"$1$"		private final int initialSize;"
"ConcurrentReferenceHashMap.java:466"$1$""
"ConcurrentReferenceHashMap.java:467"$1$"		/**"
"ConcurrentReferenceHashMap.java:468"$1$"		 * Array of references indexed using the low order bits from the hash."
"ConcurrentReferenceHashMap.java:469"$1$"		 * This property should only be set along with {@code resizeThreshold}."
"ConcurrentReferenceHashMap.java:470"$1$"		 */"
"ConcurrentReferenceHashMap.java:471"$1$"		private volatile Reference<K, V>[] references;"
"ConcurrentReferenceHashMap.java:472"$1$""
"ConcurrentReferenceHashMap.java:473"$1$"		/**"
"ConcurrentReferenceHashMap.java:474"$1$"		 * The total number of references contained in this segment. This includes chained"
"ConcurrentReferenceHashMap.java:475"$1$"		 * references and references that have been garbage collected but not purged."
"ConcurrentReferenceHashMap.java:476"$1$"		 */"
"ConcurrentReferenceHashMap.java:477"$1$"		private final AtomicInteger count = new AtomicInteger(0);"
"ConcurrentReferenceHashMap.java:478"$1$""
"ConcurrentReferenceHashMap.java:479"$1$"		/**"
"ConcurrentReferenceHashMap.java:480"$1$"		 * The threshold when resizing of the references should occur. When {@code count}"
"ConcurrentReferenceHashMap.java:481"$1$"		 * exceeds this value references will be resized."
"ConcurrentReferenceHashMap.java:482"$1$"		 */"
"ConcurrentReferenceHashMap.java:483"$1$"		private int resizeThreshold;"
"ConcurrentReferenceHashMap.java:484"$1$""
"ConcurrentReferenceHashMap.java:485"$1$"		public Segment(int initialSize, int resizeThreshold) {"
"ConcurrentReferenceHashMap.java:486"$1$"			this.referenceManager = createReferenceManager();"
"ConcurrentReferenceHashMap.java:487"$1$"			this.initialSize = initialSize;"
"ConcurrentReferenceHashMap.java:488"$1$"			this.references = createReferenceArray(initialSize);"
"ConcurrentReferenceHashMap.java:489"$1$"			this.resizeThreshold = resizeThreshold;"
"ConcurrentReferenceHashMap.java:490"$1$"		}"
"ConcurrentReferenceHashMap.java:491"$0$""
"ConcurrentReferenceHashMap.java:492"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:493"$1$"		public Reference<K, V> getReference(@Nullable Object key, int hash, Restructure restructure) {"
"ConcurrentReferenceHashMap.java:494"$1$"			if (restructure == Restructure.WHEN_NECESSARY) {"
"ConcurrentReferenceHashMap.java:495"$1$"				restructureIfNecessary(false);"
"ConcurrentReferenceHashMap.java:496"$1$"			}"
"ConcurrentReferenceHashMap.java:497"$1$"			if (this.count.get() == 0) {"
"ConcurrentReferenceHashMap.java:498"$1$"				return null;"
"ConcurrentReferenceHashMap.java:499"$1$"			}"
"ConcurrentReferenceHashMap.java:500"$0$"			// Use a local copy to protect against other threads writing"
"ConcurrentReferenceHashMap.java:501"$0$"			Reference<K, V>[] references = this.references;"
"ConcurrentReferenceHashMap.java:502"$0$"			int index = getIndex(hash, references);"
"ConcurrentReferenceHashMap.java:503"$0$"			Reference<K, V> head = references[index];"
"ConcurrentReferenceHashMap.java:504"$0$"			return findInChain(head, key, hash);"
"ConcurrentReferenceHashMap.java:505"$0$"		}"
"ConcurrentReferenceHashMap.java:506"$0$""
"ConcurrentReferenceHashMap.java:507"$0$"		/**"
"ConcurrentReferenceHashMap.java:508"$0$"		 * Apply an update operation to this segment."
"ConcurrentReferenceHashMap.java:509"$0$"		 * The segment will be locked during the update."
"ConcurrentReferenceHashMap.java:510"$0$"		 * @param hash the hash of the key"
"ConcurrentReferenceHashMap.java:511"$0$"		 * @param key the key"
"ConcurrentReferenceHashMap.java:512"$0$"		 * @param task the update operation"
"ConcurrentReferenceHashMap.java:513"$0$"		 * @return the result of the operation"
"ConcurrentReferenceHashMap.java:514"$0$"		 */"
"ConcurrentReferenceHashMap.java:515"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:516"$1$"		public <T> T doTask(final int hash, @Nullable final Object key, final Task<T> task) {"
"ConcurrentReferenceHashMap.java:517"$1$"			boolean resize = task.hasOption(TaskOption.RESIZE);"
"ConcurrentReferenceHashMap.java:518"$1$"			if (task.hasOption(TaskOption.RESTRUCTURE_BEFORE)) {"
"ConcurrentReferenceHashMap.java:519"$1$"				restructureIfNecessary(resize);"
"ConcurrentReferenceHashMap.java:520"$1$"			}"
"ConcurrentReferenceHashMap.java:521"$1$"			if (task.hasOption(TaskOption.SKIP_IF_EMPTY) && this.count.get() == 0) {"
"ConcurrentReferenceHashMap.java:522"$1$"				return task.execute(null, null, null);"
"ConcurrentReferenceHashMap.java:523"$1$"			}"
"ConcurrentReferenceHashMap.java:524"$0$"			lock();"
"ConcurrentReferenceHashMap.java:525"$1$"			try {"
"ConcurrentReferenceHashMap.java:526"$1$"				final int index = getIndex(hash, this.references);"
"ConcurrentReferenceHashMap.java:527"$1$"				final Reference<K, V> head = this.references[index];"
"ConcurrentReferenceHashMap.java:528"$1$"				Reference<K, V> ref = findInChain(head, key, hash);"
"ConcurrentReferenceHashMap.java:529"$1$"				Entry<K, V> entry = (ref != null ? ref.get() : null);"
"ConcurrentReferenceHashMap.java:530"$1$"				Entries<V> entries = value -> {"
"ConcurrentReferenceHashMap.java:531"$1$"					@SuppressWarnings(""unchecked"")"
"ConcurrentReferenceHashMap.java:532"$1$"					Entry<K, V> newEntry = new Entry<>((K) key, value);"
"ConcurrentReferenceHashMap.java:533"$1$"					Reference<K, V> newReference = Segment.this.referenceManager.createReference(newEntry, hash, head);"
"ConcurrentReferenceHashMap.java:534"$1$"					Segment.this.references[index] = newReference;"
"ConcurrentReferenceHashMap.java:535"$1$"					Segment.this.count.incrementAndGet();"
"ConcurrentReferenceHashMap.java:536"$1$"				};"
"ConcurrentReferenceHashMap.java:537"$0$"				return task.execute(ref, entry, entries);"
"ConcurrentReferenceHashMap.java:538"$0$"			}"
"ConcurrentReferenceHashMap.java:539"$1$"			finally {"
"ConcurrentReferenceHashMap.java:540"$1$"				unlock();"
"ConcurrentReferenceHashMap.java:541"$1$"				if (task.hasOption(TaskOption.RESTRUCTURE_AFTER)) {"
"ConcurrentReferenceHashMap.java:542"$1$"					restructureIfNecessary(resize);"
"ConcurrentReferenceHashMap.java:543"$1$"				}"
"ConcurrentReferenceHashMap.java:544"$0$"			}"
"ConcurrentReferenceHashMap.java:545"$0$"		}"
"ConcurrentReferenceHashMap.java:546"$0$""
"ConcurrentReferenceHashMap.java:547"$0$"		/**"
"ConcurrentReferenceHashMap.java:548"$0$"		 * Clear all items from this segment."
"ConcurrentReferenceHashMap.java:549"$0$"		 */"
"ConcurrentReferenceHashMap.java:550"$1$"		public void clear() {"
"ConcurrentReferenceHashMap.java:551"$1$"			if (this.count.get() == 0) {"
"ConcurrentReferenceHashMap.java:552"$1$"				return;"
"ConcurrentReferenceHashMap.java:553"$1$"			}"
"ConcurrentReferenceHashMap.java:554"$0$"			lock();"
"ConcurrentReferenceHashMap.java:555"$1$"			try {"
"ConcurrentReferenceHashMap.java:556"$1$"				this.references = createReferenceArray(this.initialSize);"
"ConcurrentReferenceHashMap.java:557"$1$"				this.resizeThreshold = (int) (this.references.length * getLoadFactor());"
"ConcurrentReferenceHashMap.java:558"$1$"				this.count.set(0);"
"ConcurrentReferenceHashMap.java:559"$1$"			}"
"ConcurrentReferenceHashMap.java:560"$1$"			finally {"
"ConcurrentReferenceHashMap.java:561"$1$"				unlock();"
"ConcurrentReferenceHashMap.java:562"$1$"			}"
"ConcurrentReferenceHashMap.java:563"$0$"		}"
"ConcurrentReferenceHashMap.java:564"$0$""
"ConcurrentReferenceHashMap.java:565"$0$"		/**"
"ConcurrentReferenceHashMap.java:566"$0$"		 * Restructure the underlying data structure when it becomes necessary. This"
"ConcurrentReferenceHashMap.java:567"$0$"		 * method can increase the size of the references table as well as purge any"
"ConcurrentReferenceHashMap.java:568"$0$"		 * references that have been garbage collected."
"ConcurrentReferenceHashMap.java:569"$0$"		 * @param allowResize if resizing is permitted"
"ConcurrentReferenceHashMap.java:570"$0$"		 */"
"ConcurrentReferenceHashMap.java:571"$1$"		protected final void restructureIfNecessary(boolean allowResize) {"
"ConcurrentReferenceHashMap.java:572"$1$"			int currCount = this.count.get();"
"ConcurrentReferenceHashMap.java:573"$1$"			boolean needsResize = allowResize && (currCount > 0 && currCount >= this.resizeThreshold);"
"ConcurrentReferenceHashMap.java:574"$1$"			Reference<K, V> ref = this.referenceManager.pollForPurge();"
"ConcurrentReferenceHashMap.java:575"$1$"			if (ref != null || (needsResize)) {"
"ConcurrentReferenceHashMap.java:576"$1$"				restructure(allowResize, ref);"
"ConcurrentReferenceHashMap.java:577"$1$"			}"
"ConcurrentReferenceHashMap.java:578"$0$"		}"
"ConcurrentReferenceHashMap.java:579"$0$""
"ConcurrentReferenceHashMap.java:580"$1$"		private void restructure(boolean allowResize, @Nullable Reference<K, V> ref) {"
"ConcurrentReferenceHashMap.java:581"$1$"			boolean needsResize;"
"ConcurrentReferenceHashMap.java:582"$1$"			lock();"
"ConcurrentReferenceHashMap.java:583"$1$"			try {"
"ConcurrentReferenceHashMap.java:584"$1$"				int countAfterRestructure = this.count.get();"
"ConcurrentReferenceHashMap.java:585"$1$"				Set<Reference<K, V>> toPurge = Collections.emptySet();"
"ConcurrentReferenceHashMap.java:586"$1$"				if (ref != null) {"
"ConcurrentReferenceHashMap.java:587"$1$"					toPurge = new HashSet<>();"
"ConcurrentReferenceHashMap.java:588"$1$"					while (ref != null) {"
"ConcurrentReferenceHashMap.java:589"$1$"						toPurge.add(ref);"
"ConcurrentReferenceHashMap.java:590"$1$"						ref = this.referenceManager.pollForPurge();"
"ConcurrentReferenceHashMap.java:591"$1$"					}"
"ConcurrentReferenceHashMap.java:592"$0$"				}"
"ConcurrentReferenceHashMap.java:593"$0$"				countAfterRestructure -= toPurge.size();"
"ConcurrentReferenceHashMap.java:594"$0$""
"ConcurrentReferenceHashMap.java:595"$0$"				// Recalculate taking into account count inside lock and items that"
"ConcurrentReferenceHashMap.java:596"$0$"				// will be purged"
"ConcurrentReferenceHashMap.java:597"$0$"				needsResize = (countAfterRestructure > 0 && countAfterRestructure >= this.resizeThreshold);"
"ConcurrentReferenceHashMap.java:598"$0$"				boolean resizing = false;"
"ConcurrentReferenceHashMap.java:599"$0$"				int restructureSize = this.references.length;"
"ConcurrentReferenceHashMap.java:600"$1$"				if (allowResize && needsResize && restructureSize < MAXIMUM_SEGMENT_SIZE) {"
"ConcurrentReferenceHashMap.java:601"$1$"					restructureSize <<= 1;"
"ConcurrentReferenceHashMap.java:602"$1$"					resizing = true;"
"ConcurrentReferenceHashMap.java:603"$1$"				}"
"ConcurrentReferenceHashMap.java:604"$0$""
"ConcurrentReferenceHashMap.java:605"$0$"				// Either create a new table or reuse the existing one"
"ConcurrentReferenceHashMap.java:606"$0$"				Reference<K, V>[] restructured ="
"ConcurrentReferenceHashMap.java:607"$0$"						(resizing ? createReferenceArray(restructureSize) : this.references);"
"ConcurrentReferenceHashMap.java:608"$0$""
"ConcurrentReferenceHashMap.java:609"$0$"				// Restructure"
"ConcurrentReferenceHashMap.java:610"$1$"				for (int i = 0; i < this.references.length; i++) {"
"ConcurrentReferenceHashMap.java:611"$1$"					ref = this.references[i];"
"ConcurrentReferenceHashMap.java:612"$1$"					if (!resizing) {"
"ConcurrentReferenceHashMap.java:613"$1$"						restructured[i] = null;"
"ConcurrentReferenceHashMap.java:614"$1$"					}"
"ConcurrentReferenceHashMap.java:615"$1$"					while (ref != null) {"
"ConcurrentReferenceHashMap.java:616"$1$"						if (!toPurge.contains(ref)) {"
"ConcurrentReferenceHashMap.java:617"$1$"							Entry<K, V> entry = ref.get();"
"ConcurrentReferenceHashMap.java:618"$1$"							if (entry != null) {"
"ConcurrentReferenceHashMap.java:619"$1$"								int index = getIndex(ref.getHash(), restructured);"
"ConcurrentReferenceHashMap.java:620"$1$"								restructured[index] = this.referenceManager.createReference("
"ConcurrentReferenceHashMap.java:621"$1$"										entry, ref.getHash(), restructured[index]);"
"ConcurrentReferenceHashMap.java:622"$1$"							}"
"ConcurrentReferenceHashMap.java:623"$0$"						}"
"ConcurrentReferenceHashMap.java:624"$0$"						ref = ref.getNext();"
"ConcurrentReferenceHashMap.java:625"$0$"					}"
"ConcurrentReferenceHashMap.java:626"$0$"				}"
"ConcurrentReferenceHashMap.java:627"$0$""
"ConcurrentReferenceHashMap.java:628"$0$"				// Replace volatile members"
"ConcurrentReferenceHashMap.java:629"$1$"				if (resizing) {"
"ConcurrentReferenceHashMap.java:630"$1$"					this.references = restructured;"
"ConcurrentReferenceHashMap.java:631"$1$"					this.resizeThreshold = (int) (this.references.length * getLoadFactor());"
"ConcurrentReferenceHashMap.java:632"$1$"				}"
"ConcurrentReferenceHashMap.java:633"$0$"				this.count.set(Math.max(countAfterRestructure, 0));"
"ConcurrentReferenceHashMap.java:634"$0$"			}"
"ConcurrentReferenceHashMap.java:635"$1$"			finally {"
"ConcurrentReferenceHashMap.java:636"$1$"				unlock();"
"ConcurrentReferenceHashMap.java:637"$1$"			}"
"ConcurrentReferenceHashMap.java:638"$0$"		}"
"ConcurrentReferenceHashMap.java:639"$0$""
"ConcurrentReferenceHashMap.java:640"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:641"$1$"		private Reference<K, V> findInChain(Reference<K, V> ref, @Nullable Object key, int hash) {"
"ConcurrentReferenceHashMap.java:642"$1$"			Reference<K, V> currRef = ref;"
"ConcurrentReferenceHashMap.java:643"$1$"			while (currRef != null) {"
"ConcurrentReferenceHashMap.java:644"$1$"				if (currRef.getHash() == hash) {"
"ConcurrentReferenceHashMap.java:645"$1$"					Entry<K, V> entry = currRef.get();"
"ConcurrentReferenceHashMap.java:646"$1$"					if (entry != null) {"
"ConcurrentReferenceHashMap.java:647"$1$"						K entryKey = entry.getKey();"
"ConcurrentReferenceHashMap.java:648"$1$"						if (ObjectUtils.nullSafeEquals(entryKey, key)) {"
"ConcurrentReferenceHashMap.java:649"$1$"							return currRef;"
"ConcurrentReferenceHashMap.java:650"$1$"						}"
"ConcurrentReferenceHashMap.java:651"$0$"					}"
"ConcurrentReferenceHashMap.java:652"$0$"				}"
"ConcurrentReferenceHashMap.java:653"$0$"				currRef = currRef.getNext();"
"ConcurrentReferenceHashMap.java:654"$0$"			}"
"ConcurrentReferenceHashMap.java:655"$0$"			return null;"
"ConcurrentReferenceHashMap.java:656"$0$"		}"
"ConcurrentReferenceHashMap.java:657"$0$""
"ConcurrentReferenceHashMap.java:658"$1$"		@SuppressWarnings({""rawtypes"", ""unchecked""})"
"ConcurrentReferenceHashMap.java:659"$1$"		private Reference<K, V>[] createReferenceArray(int size) {"
"ConcurrentReferenceHashMap.java:660"$1$"			return new Reference[size];"
"ConcurrentReferenceHashMap.java:661"$1$"		}"
"ConcurrentReferenceHashMap.java:662"$0$""
"ConcurrentReferenceHashMap.java:663"$1$"		private int getIndex(int hash, Reference<K, V>[] references) {"
"ConcurrentReferenceHashMap.java:664"$1$"			return (hash & (references.length - 1));"
"ConcurrentReferenceHashMap.java:665"$1$"		}"
"ConcurrentReferenceHashMap.java:666"$0$""
"ConcurrentReferenceHashMap.java:667"$0$"		/**"
"ConcurrentReferenceHashMap.java:668"$0$"		 * Return the size of the current references array."
"ConcurrentReferenceHashMap.java:669"$0$"		 */"
"ConcurrentReferenceHashMap.java:670"$1$"		public final int getSize() {"
"ConcurrentReferenceHashMap.java:671"$1$"			return this.references.length;"
"ConcurrentReferenceHashMap.java:672"$1$"		}"
"ConcurrentReferenceHashMap.java:673"$0$""
"ConcurrentReferenceHashMap.java:674"$0$"		/**"
"ConcurrentReferenceHashMap.java:675"$0$"		 * Return the total number of references in this segment."
"ConcurrentReferenceHashMap.java:676"$0$"		 */"
"ConcurrentReferenceHashMap.java:677"$1$"		public final int getCount() {"
"ConcurrentReferenceHashMap.java:678"$1$"			return this.count.get();"
"ConcurrentReferenceHashMap.java:679"$1$"		}"
"ConcurrentReferenceHashMap.java:680"$0$"	}"
"ConcurrentReferenceHashMap.java:681"$0$""
"ConcurrentReferenceHashMap.java:682"$0$""
"ConcurrentReferenceHashMap.java:683"$0$"	/**"
"ConcurrentReferenceHashMap.java:684"$1$"	 * A reference to an {@link Entry} contained in the map. Implementations are usually"
"ConcurrentReferenceHashMap.java:685"$1$"	 * wrappers around specific Java reference implementations (e.g., {@link SoftReference})."
"ConcurrentReferenceHashMap.java:686"$0$"	 * @param <K> the key type"
"ConcurrentReferenceHashMap.java:687"$0$"	 * @param <V> the value type"
"ConcurrentReferenceHashMap.java:688"$0$"	 */"
"ConcurrentReferenceHashMap.java:689"$1$"	protected interface Reference<K, V> {"
"ConcurrentReferenceHashMap.java:690"$1$""
"ConcurrentReferenceHashMap.java:691"$1$"		/**"
"ConcurrentReferenceHashMap.java:692"$1$"		 * Return the referenced entry, or {@code null} if the entry is no longer available."
"ConcurrentReferenceHashMap.java:693"$1$"		 */"
"ConcurrentReferenceHashMap.java:694"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:695"$1$"		Entry<K, V> get();"
"ConcurrentReferenceHashMap.java:696"$1$""
"ConcurrentReferenceHashMap.java:697"$1$"		/**"
"ConcurrentReferenceHashMap.java:698"$1$"		 * Return the hash for the reference."
"ConcurrentReferenceHashMap.java:699"$1$"		 */"
"ConcurrentReferenceHashMap.java:700"$1$"		int getHash();"
"ConcurrentReferenceHashMap.java:701"$1$""
"ConcurrentReferenceHashMap.java:702"$1$"		/**"
"ConcurrentReferenceHashMap.java:703"$1$"		 * Return the next reference in the chain, or {@code null} if none."
"ConcurrentReferenceHashMap.java:704"$1$"		 */"
"ConcurrentReferenceHashMap.java:705"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:706"$1$"		Reference<K, V> getNext();"
"ConcurrentReferenceHashMap.java:707"$1$""
"ConcurrentReferenceHashMap.java:708"$1$"		/**"
"ConcurrentReferenceHashMap.java:709"$1$"		 * Release this entry and ensure that it will be returned from"
"ConcurrentReferenceHashMap.java:710"$1$"		 * {@code ReferenceManager#pollForPurge()}."
"ConcurrentReferenceHashMap.java:711"$1$"		 */"
"ConcurrentReferenceHashMap.java:712"$1$"		void release();"
"ConcurrentReferenceHashMap.java:713"$1$"	}"
"ConcurrentReferenceHashMap.java:714"$0$""
"ConcurrentReferenceHashMap.java:715"$0$""
"ConcurrentReferenceHashMap.java:716"$0$"	/**"
"ConcurrentReferenceHashMap.java:717"$0$"	 * A single map entry."
"ConcurrentReferenceHashMap.java:718"$0$"	 * @param <K> the key type"
"ConcurrentReferenceHashMap.java:719"$0$"	 * @param <V> the value type"
"ConcurrentReferenceHashMap.java:720"$0$"	 */"
"ConcurrentReferenceHashMap.java:721"$1$"	protected static final class Entry<K, V> implements Map.Entry<K, V> {"
"ConcurrentReferenceHashMap.java:722"$1$""
"ConcurrentReferenceHashMap.java:723"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:724"$1$"		private final K key;"
"ConcurrentReferenceHashMap.java:725"$1$""
"ConcurrentReferenceHashMap.java:726"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:727"$1$"		private volatile V value;"
"ConcurrentReferenceHashMap.java:728"$1$""
"ConcurrentReferenceHashMap.java:729"$1$"		public Entry(@Nullable K key, @Nullable V value) {"
"ConcurrentReferenceHashMap.java:730"$1$"			this.key = key;"
"ConcurrentReferenceHashMap.java:731"$1$"			this.value = value;"
"ConcurrentReferenceHashMap.java:732"$1$"		}"
"ConcurrentReferenceHashMap.java:733"$0$""
"ConcurrentReferenceHashMap.java:734"$0$"		@Override"
"ConcurrentReferenceHashMap.java:735"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:736"$1$"		public K getKey() {"
"ConcurrentReferenceHashMap.java:737"$1$"			return this.key;"
"ConcurrentReferenceHashMap.java:738"$1$"		}"
"ConcurrentReferenceHashMap.java:739"$0$""
"ConcurrentReferenceHashMap.java:740"$0$"		@Override"
"ConcurrentReferenceHashMap.java:741"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:742"$1$"		public V getValue() {"
"ConcurrentReferenceHashMap.java:743"$1$"			return this.value;"
"ConcurrentReferenceHashMap.java:744"$1$"		}"
"ConcurrentReferenceHashMap.java:745"$0$""
"ConcurrentReferenceHashMap.java:746"$0$"		@Override"
"ConcurrentReferenceHashMap.java:747"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:748"$1$"		public V setValue(@Nullable V value) {"
"ConcurrentReferenceHashMap.java:749"$1$"			V previous = this.value;"
"ConcurrentReferenceHashMap.java:750"$1$"			this.value = value;"
"ConcurrentReferenceHashMap.java:751"$1$"			return previous;"
"ConcurrentReferenceHashMap.java:752"$1$"		}"
"ConcurrentReferenceHashMap.java:753"$0$""
"ConcurrentReferenceHashMap.java:754"$0$"		@Override"
"ConcurrentReferenceHashMap.java:755"$1$"		public String toString() {"
"ConcurrentReferenceHashMap.java:756"$1$"			return (this.key + ""="" + this.value);"
"ConcurrentReferenceHashMap.java:757"$1$"		}"
"ConcurrentReferenceHashMap.java:758"$0$""
"ConcurrentReferenceHashMap.java:759"$0$"		@Override"
"ConcurrentReferenceHashMap.java:760"$0$"		@SuppressWarnings(""rawtypes"")"
"ConcurrentReferenceHashMap.java:761"$1$"		public final boolean equals(@Nullable Object other) {"
"ConcurrentReferenceHashMap.java:762"$1$"			if (this == other) {"
"ConcurrentReferenceHashMap.java:763"$1$"				return true;"
"ConcurrentReferenceHashMap.java:764"$1$"			}"
"ConcurrentReferenceHashMap.java:765"$1$"			if (!(other instanceof Map.Entry)) {"
"ConcurrentReferenceHashMap.java:766"$1$"				return false;"
"ConcurrentReferenceHashMap.java:767"$1$"			}"
"ConcurrentReferenceHashMap.java:768"$0$"			Map.Entry otherEntry = (Map.Entry) other;"
"ConcurrentReferenceHashMap.java:769"$0$"			return (ObjectUtils.nullSafeEquals(getKey(), otherEntry.getKey()) &&"
"ConcurrentReferenceHashMap.java:770"$0$"					ObjectUtils.nullSafeEquals(getValue(), otherEntry.getValue()));"
"ConcurrentReferenceHashMap.java:771"$0$"		}"
"ConcurrentReferenceHashMap.java:772"$0$""
"ConcurrentReferenceHashMap.java:773"$0$"		@Override"
"ConcurrentReferenceHashMap.java:774"$1$"		public final int hashCode() {"
"ConcurrentReferenceHashMap.java:775"$1$"			return (ObjectUtils.nullSafeHashCode(this.key) ^ ObjectUtils.nullSafeHashCode(this.value));"
"ConcurrentReferenceHashMap.java:776"$1$"		}"
"ConcurrentReferenceHashMap.java:777"$0$"	}"
"ConcurrentReferenceHashMap.java:778"$0$""
"ConcurrentReferenceHashMap.java:779"$0$""
"ConcurrentReferenceHashMap.java:780"$0$"	/**"
"ConcurrentReferenceHashMap.java:781"$1$"	 * A task that can be {@link Segment#doTask run} against a {@link Segment}."
"ConcurrentReferenceHashMap.java:782"$0$"	 */"
"ConcurrentReferenceHashMap.java:783"$1$"	private abstract class Task<T> {"
"ConcurrentReferenceHashMap.java:784"$1$""
"ConcurrentReferenceHashMap.java:785"$1$"		private final EnumSet<TaskOption> options;"
"ConcurrentReferenceHashMap.java:786"$1$""
"ConcurrentReferenceHashMap.java:787"$1$"		public Task(TaskOption... options) {"
"ConcurrentReferenceHashMap.java:788"$1$"			this.options = (options.length == 0 ? EnumSet.noneOf(TaskOption.class) : EnumSet.of(options[0], options));"
"ConcurrentReferenceHashMap.java:789"$1$"		}"
"ConcurrentReferenceHashMap.java:790"$0$""
"ConcurrentReferenceHashMap.java:791"$1$"		public boolean hasOption(TaskOption option) {"
"ConcurrentReferenceHashMap.java:792"$1$"			return this.options.contains(option);"
"ConcurrentReferenceHashMap.java:793"$1$"		}"
"ConcurrentReferenceHashMap.java:794"$0$""
"ConcurrentReferenceHashMap.java:795"$0$"		/**"
"ConcurrentReferenceHashMap.java:796"$0$"		 * Execute the task."
"ConcurrentReferenceHashMap.java:797"$1$"		 * @param ref the found reference (or {@code null})"
"ConcurrentReferenceHashMap.java:798"$1$"		 * @param entry the found entry (or {@code null})"
"ConcurrentReferenceHashMap.java:799"$0$"		 * @param entries access to the underlying entries"
"ConcurrentReferenceHashMap.java:800"$0$"		 * @return the result of the task"
"ConcurrentReferenceHashMap.java:801"$0$"		 * @see #execute(Reference, Entry)"
"ConcurrentReferenceHashMap.java:802"$0$"		 */"
"ConcurrentReferenceHashMap.java:803"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:804"$1$"		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry, @Nullable Entries<V> entries) {"
"ConcurrentReferenceHashMap.java:805"$1$"			return execute(ref, entry);"
"ConcurrentReferenceHashMap.java:806"$1$"		}"
"ConcurrentReferenceHashMap.java:807"$0$""
"ConcurrentReferenceHashMap.java:808"$0$"		/**"
"ConcurrentReferenceHashMap.java:809"$1$"		 * Convenience method that can be used for tasks that do not need access to {@link Entries}."
"ConcurrentReferenceHashMap.java:810"$1$"		 * @param ref the found reference (or {@code null})"
"ConcurrentReferenceHashMap.java:811"$1$"		 * @param entry the found entry (or {@code null})"
"ConcurrentReferenceHashMap.java:812"$0$"		 * @return the result of the task"
"ConcurrentReferenceHashMap.java:813"$0$"		 * @see #execute(Reference, Entry, Entries)"
"ConcurrentReferenceHashMap.java:814"$0$"		 */"
"ConcurrentReferenceHashMap.java:815"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:816"$1$"		protected T execute(@Nullable Reference<K, V> ref, @Nullable Entry<K, V> entry) {"
"ConcurrentReferenceHashMap.java:817"$1$"			return null;"
"ConcurrentReferenceHashMap.java:818"$1$"		}"
"ConcurrentReferenceHashMap.java:819"$0$"	}"
"ConcurrentReferenceHashMap.java:820"$0$""
"ConcurrentReferenceHashMap.java:821"$0$""
"ConcurrentReferenceHashMap.java:822"$0$"	/**"
"ConcurrentReferenceHashMap.java:823"$1$"	 * Various options supported by a {@code Task}."
"ConcurrentReferenceHashMap.java:824"$0$"	 */"
"ConcurrentReferenceHashMap.java:825"$1$"	private enum TaskOption {"
"ConcurrentReferenceHashMap.java:826"$1$""
"ConcurrentReferenceHashMap.java:827"$1$"		RESTRUCTURE_BEFORE, RESTRUCTURE_AFTER, SKIP_IF_EMPTY, RESIZE"
"ConcurrentReferenceHashMap.java:828"$1$"	}"
"ConcurrentReferenceHashMap.java:829"$0$""
"ConcurrentReferenceHashMap.java:830"$0$""
"ConcurrentReferenceHashMap.java:831"$0$"	/**"
"ConcurrentReferenceHashMap.java:832"$1$"	 * Allows a task access to {@link ConcurrentReferenceHashMap.Segment} entries."
"ConcurrentReferenceHashMap.java:833"$0$"	 */"
"ConcurrentReferenceHashMap.java:834"$1$"	private interface Entries<V> {"
"ConcurrentReferenceHashMap.java:835"$1$""
"ConcurrentReferenceHashMap.java:836"$1$"		/**"
"ConcurrentReferenceHashMap.java:837"$1$"		 * Add a new entry with the specified value."
"ConcurrentReferenceHashMap.java:838"$1$"		 * @param value the value to add"
"ConcurrentReferenceHashMap.java:839"$1$"		 */"
"ConcurrentReferenceHashMap.java:840"$1$"		void add(@Nullable V value);"
"ConcurrentReferenceHashMap.java:841"$1$"	}"
"ConcurrentReferenceHashMap.java:842"$0$""
"ConcurrentReferenceHashMap.java:843"$0$""
"ConcurrentReferenceHashMap.java:844"$0$"	/**"
"ConcurrentReferenceHashMap.java:845"$0$"	 * Internal entry-set implementation."
"ConcurrentReferenceHashMap.java:846"$0$"	 */"
"ConcurrentReferenceHashMap.java:847"$1$"	private class EntrySet extends AbstractSet<Map.Entry<K, V>> {"
"ConcurrentReferenceHashMap.java:848"$1$""
"ConcurrentReferenceHashMap.java:849"$1$"		@Override"
"ConcurrentReferenceHashMap.java:850"$1$"		public Iterator<Map.Entry<K, V>> iterator() {"
"ConcurrentReferenceHashMap.java:851"$1$"			return new EntryIterator();"
"ConcurrentReferenceHashMap.java:852"$1$"		}"
"ConcurrentReferenceHashMap.java:853"$0$""
"ConcurrentReferenceHashMap.java:854"$0$"		@Override"
"ConcurrentReferenceHashMap.java:855"$1$"		public boolean contains(@Nullable Object o) {"
"ConcurrentReferenceHashMap.java:856"$1$"			if (o instanceof Map.Entry<?, ?>) {"
"ConcurrentReferenceHashMap.java:857"$1$"				Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;"
"ConcurrentReferenceHashMap.java:858"$1$"				Reference<K, V> ref = ConcurrentReferenceHashMap.this.getReference(entry.getKey(), Restructure.NEVER);"
"ConcurrentReferenceHashMap.java:859"$1$"				Entry<K, V> otherEntry = (ref != null ? ref.get() : null);"
"ConcurrentReferenceHashMap.java:860"$1$"				if (otherEntry != null) {"
"ConcurrentReferenceHashMap.java:861"$1$"					return ObjectUtils.nullSafeEquals(otherEntry.getValue(), otherEntry.getValue());"
"ConcurrentReferenceHashMap.java:862"$1$"				}"
"ConcurrentReferenceHashMap.java:863"$0$"			}"
"ConcurrentReferenceHashMap.java:864"$0$"			return false;"
"ConcurrentReferenceHashMap.java:865"$0$"		}"
"ConcurrentReferenceHashMap.java:866"$0$""
"ConcurrentReferenceHashMap.java:867"$0$"		@Override"
"ConcurrentReferenceHashMap.java:868"$1$"		public boolean remove(Object o) {"
"ConcurrentReferenceHashMap.java:869"$1$"			if (o instanceof Map.Entry<?, ?>) {"
"ConcurrentReferenceHashMap.java:870"$1$"				Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;"
"ConcurrentReferenceHashMap.java:871"$1$"				return ConcurrentReferenceHashMap.this.remove(entry.getKey(), entry.getValue());"
"ConcurrentReferenceHashMap.java:872"$1$"			}"
"ConcurrentReferenceHashMap.java:873"$0$"			return false;"
"ConcurrentReferenceHashMap.java:874"$0$"		}"
"ConcurrentReferenceHashMap.java:875"$0$""
"ConcurrentReferenceHashMap.java:876"$0$"		@Override"
"ConcurrentReferenceHashMap.java:877"$1$"		public int size() {"
"ConcurrentReferenceHashMap.java:878"$1$"			return ConcurrentReferenceHashMap.this.size();"
"ConcurrentReferenceHashMap.java:879"$1$"		}"
"ConcurrentReferenceHashMap.java:880"$0$""
"ConcurrentReferenceHashMap.java:881"$0$"		@Override"
"ConcurrentReferenceHashMap.java:882"$1$"		public void clear() {"
"ConcurrentReferenceHashMap.java:883"$1$"			ConcurrentReferenceHashMap.this.clear();"
"ConcurrentReferenceHashMap.java:884"$1$"		}"
"ConcurrentReferenceHashMap.java:885"$0$"	}"
"ConcurrentReferenceHashMap.java:886"$0$""
"ConcurrentReferenceHashMap.java:887"$0$""
"ConcurrentReferenceHashMap.java:888"$0$"	/**"
"ConcurrentReferenceHashMap.java:889"$0$"	 * Internal entry iterator implementation."
"ConcurrentReferenceHashMap.java:890"$0$"	 */"
"ConcurrentReferenceHashMap.java:891"$1$"	private class EntryIterator implements Iterator<Map.Entry<K, V>> {"
"ConcurrentReferenceHashMap.java:892"$1$""
"ConcurrentReferenceHashMap.java:893"$1$"		private int segmentIndex;"
"ConcurrentReferenceHashMap.java:894"$1$""
"ConcurrentReferenceHashMap.java:895"$1$"		private int referenceIndex;"
"ConcurrentReferenceHashMap.java:896"$1$""
"ConcurrentReferenceHashMap.java:897"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:898"$1$"		private Reference<K, V>[] references;"
"ConcurrentReferenceHashMap.java:899"$1$""
"ConcurrentReferenceHashMap.java:900"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:901"$1$"		private Reference<K, V> reference;"
"ConcurrentReferenceHashMap.java:902"$1$""
"ConcurrentReferenceHashMap.java:903"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:904"$1$"		private Entry<K, V> next;"
"ConcurrentReferenceHashMap.java:905"$1$""
"ConcurrentReferenceHashMap.java:906"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:907"$1$"		private Entry<K, V> last;"
"ConcurrentReferenceHashMap.java:908"$1$""
"ConcurrentReferenceHashMap.java:909"$1$"		public EntryIterator() {"
"ConcurrentReferenceHashMap.java:910"$1$"			moveToNextSegment();"
"ConcurrentReferenceHashMap.java:911"$1$"		}"
"ConcurrentReferenceHashMap.java:912"$0$""
"ConcurrentReferenceHashMap.java:913"$0$"		@Override"
"ConcurrentReferenceHashMap.java:914"$1$"		public boolean hasNext() {"
"ConcurrentReferenceHashMap.java:915"$1$"			getNextIfNecessary();"
"ConcurrentReferenceHashMap.java:916"$1$"			return (this.next != null);"
"ConcurrentReferenceHashMap.java:917"$1$"		}"
"ConcurrentReferenceHashMap.java:918"$0$""
"ConcurrentReferenceHashMap.java:919"$0$"		@Override"
"ConcurrentReferenceHashMap.java:920"$1$"		public Entry<K, V> next() {"
"ConcurrentReferenceHashMap.java:921"$1$"			getNextIfNecessary();"
"ConcurrentReferenceHashMap.java:922"$1$"			if (this.next == null) {"
"ConcurrentReferenceHashMap.java:923"$1$"				throw new NoSuchElementException();"
"ConcurrentReferenceHashMap.java:924"$1$"			}"
"ConcurrentReferenceHashMap.java:925"$0$"			this.last = this.next;"
"ConcurrentReferenceHashMap.java:926"$0$"			this.next = null;"
"ConcurrentReferenceHashMap.java:927"$0$"			return this.last;"
"ConcurrentReferenceHashMap.java:928"$0$"		}"
"ConcurrentReferenceHashMap.java:929"$0$""
"ConcurrentReferenceHashMap.java:930"$1$"		private void getNextIfNecessary() {"
"ConcurrentReferenceHashMap.java:931"$1$"			while (this.next == null) {"
"ConcurrentReferenceHashMap.java:932"$1$"				moveToNextReference();"
"ConcurrentReferenceHashMap.java:933"$1$"				if (this.reference == null) {"
"ConcurrentReferenceHashMap.java:934"$1$"					return;"
"ConcurrentReferenceHashMap.java:935"$1$"				}"
"ConcurrentReferenceHashMap.java:936"$0$"				this.next = this.reference.get();"
"ConcurrentReferenceHashMap.java:937"$0$"			}"
"ConcurrentReferenceHashMap.java:938"$0$"		}"
"ConcurrentReferenceHashMap.java:939"$0$""
"ConcurrentReferenceHashMap.java:940"$1$"		private void moveToNextReference() {"
"ConcurrentReferenceHashMap.java:941"$1$"			if (this.reference != null) {"
"ConcurrentReferenceHashMap.java:942"$1$"				this.reference = this.reference.getNext();"
"ConcurrentReferenceHashMap.java:943"$1$"			}"
"ConcurrentReferenceHashMap.java:944"$1$"			while (this.reference == null && this.references != null) {"
"ConcurrentReferenceHashMap.java:945"$1$"				if (this.referenceIndex >= this.references.length) {"
"ConcurrentReferenceHashMap.java:946"$1$"					moveToNextSegment();"
"ConcurrentReferenceHashMap.java:947"$1$"					this.referenceIndex = 0;"
"ConcurrentReferenceHashMap.java:948"$1$"				}"
"ConcurrentReferenceHashMap.java:949"$1$"				else {"
"ConcurrentReferenceHashMap.java:950"$1$"					this.reference = this.references[this.referenceIndex];"
"ConcurrentReferenceHashMap.java:951"$1$"					this.referenceIndex++;"
"ConcurrentReferenceHashMap.java:952"$1$"				}"
"ConcurrentReferenceHashMap.java:953"$0$"			}"
"ConcurrentReferenceHashMap.java:954"$0$"		}"
"ConcurrentReferenceHashMap.java:955"$0$""
"ConcurrentReferenceHashMap.java:956"$1$"		private void moveToNextSegment() {"
"ConcurrentReferenceHashMap.java:957"$1$"			this.reference = null;"
"ConcurrentReferenceHashMap.java:958"$1$"			this.references = null;"
"ConcurrentReferenceHashMap.java:959"$1$"			if (this.segmentIndex < ConcurrentReferenceHashMap.this.segments.length) {"
"ConcurrentReferenceHashMap.java:960"$1$"				this.references = ConcurrentReferenceHashMap.this.segments[this.segmentIndex].references;"
"ConcurrentReferenceHashMap.java:961"$1$"				this.segmentIndex++;"
"ConcurrentReferenceHashMap.java:962"$1$"			}"
"ConcurrentReferenceHashMap.java:963"$0$"		}"
"ConcurrentReferenceHashMap.java:964"$0$""
"ConcurrentReferenceHashMap.java:965"$0$"		@Override"
"ConcurrentReferenceHashMap.java:966"$1$"		public void remove() {"
"ConcurrentReferenceHashMap.java:967"$1$"			Assert.state(this.last != null, ""No element to remove"");"
"ConcurrentReferenceHashMap.java:968"$1$"			ConcurrentReferenceHashMap.this.remove(this.last.getKey());"
"ConcurrentReferenceHashMap.java:969"$1$"		}"
"ConcurrentReferenceHashMap.java:970"$0$"	}"
"ConcurrentReferenceHashMap.java:971"$0$""
"ConcurrentReferenceHashMap.java:972"$0$""
"ConcurrentReferenceHashMap.java:973"$0$"	/**"
"ConcurrentReferenceHashMap.java:974"$0$"	 * The types of restructuring that can be performed."
"ConcurrentReferenceHashMap.java:975"$0$"	 */"
"ConcurrentReferenceHashMap.java:976"$1$"	protected enum Restructure {"
"ConcurrentReferenceHashMap.java:977"$1$""
"ConcurrentReferenceHashMap.java:978"$1$"		WHEN_NECESSARY, NEVER"
"ConcurrentReferenceHashMap.java:979"$1$"	}"
"ConcurrentReferenceHashMap.java:980"$0$""
"ConcurrentReferenceHashMap.java:981"$0$""
"ConcurrentReferenceHashMap.java:982"$0$"	/**"
"ConcurrentReferenceHashMap.java:983"$1$"	 * Strategy class used to manage {@link Reference References}."
"ConcurrentReferenceHashMap.java:984"$0$"	 * This class can be overridden if alternative reference types need to be supported."
"ConcurrentReferenceHashMap.java:985"$0$"	 */"
"ConcurrentReferenceHashMap.java:986"$1$"	protected class ReferenceManager {"
"ConcurrentReferenceHashMap.java:987"$1$""
"ConcurrentReferenceHashMap.java:988"$1$"		private final ReferenceQueue<Entry<K, V>> queue = new ReferenceQueue<>();"
"ConcurrentReferenceHashMap.java:989"$1$""
"ConcurrentReferenceHashMap.java:990"$1$"		/**"
"ConcurrentReferenceHashMap.java:991"$1$"		 * Factory method used to create a new {@link Reference}."
"ConcurrentReferenceHashMap.java:992"$1$"		 * @param entry the entry contained in the reference"
"ConcurrentReferenceHashMap.java:993"$1$"		 * @param hash the hash"
"ConcurrentReferenceHashMap.java:994"$1$"		 * @param next the next reference in the chain, or {@code null} if none"
"ConcurrentReferenceHashMap.java:995"$1$"		 * @return a new {@link Reference}"
"ConcurrentReferenceHashMap.java:996"$1$"		 */"
"ConcurrentReferenceHashMap.java:997"$1$"		public Reference<K, V> createReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next) {"
"ConcurrentReferenceHashMap.java:998"$1$"			if (ConcurrentReferenceHashMap.this.referenceType == ReferenceType.WEAK) {"
"ConcurrentReferenceHashMap.java:999"$1$"				return new WeakEntryReference<>(entry, hash, next, this.queue);"
"ConcurrentReferenceHashMap.java:1000"$1$"			}"
"ConcurrentReferenceHashMap.java:1001"$0$"			return new SoftEntryReference<>(entry, hash, next, this.queue);"
"ConcurrentReferenceHashMap.java:1002"$0$"		}"
"ConcurrentReferenceHashMap.java:1003"$0$""
"ConcurrentReferenceHashMap.java:1004"$0$"		/**"
"ConcurrentReferenceHashMap.java:1005"$0$"		 * Return any reference that has been garbage collected and can be purged from the"
"ConcurrentReferenceHashMap.java:1006"$1$"		 * underlying structure or {@code null} if no references need purging. This"
"ConcurrentReferenceHashMap.java:1007"$0$"		 * method must be thread safe and ideally should not block when returning"
"ConcurrentReferenceHashMap.java:1008"$1$"		 * {@code null}. References should be returned once and only once."
"ConcurrentReferenceHashMap.java:1009"$1$"		 * @return a reference to purge or {@code null}"
"ConcurrentReferenceHashMap.java:1010"$0$"		 */"
"ConcurrentReferenceHashMap.java:1011"$0$"		@SuppressWarnings(""unchecked"")"
"ConcurrentReferenceHashMap.java:1012"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:1013"$1$"		public Reference<K, V> pollForPurge() {"
"ConcurrentReferenceHashMap.java:1014"$1$"			return (Reference<K, V>) this.queue.poll();"
"ConcurrentReferenceHashMap.java:1015"$1$"		}"
"ConcurrentReferenceHashMap.java:1016"$0$"	}"
"ConcurrentReferenceHashMap.java:1017"$0$""
"ConcurrentReferenceHashMap.java:1018"$0$""
"ConcurrentReferenceHashMap.java:1019"$0$"	/**"
"ConcurrentReferenceHashMap.java:1020"$1$"	 * Internal {@link Reference} implementation for {@link SoftReference SoftReferences}."
"ConcurrentReferenceHashMap.java:1021"$0$"	 */"
"ConcurrentReferenceHashMap.java:1022"$1$"	private static final class SoftEntryReference<K, V> extends SoftReference<Entry<K, V>> implements Reference<K, V> {"
"ConcurrentReferenceHashMap.java:1023"$1$""
"ConcurrentReferenceHashMap.java:1024"$1$"		private final int hash;"
"ConcurrentReferenceHashMap.java:1025"$1$""
"ConcurrentReferenceHashMap.java:1026"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:1027"$1$"		private final Reference<K, V> nextReference;"
"ConcurrentReferenceHashMap.java:1028"$1$""
"ConcurrentReferenceHashMap.java:1029"$1$"		public SoftEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next,"
"ConcurrentReferenceHashMap.java:1030"$1$"				ReferenceQueue<Entry<K, V>> queue) {"
"ConcurrentReferenceHashMap.java:1031"$1$""
"ConcurrentReferenceHashMap.java:1032"$1$"			super(entry, queue);"
"ConcurrentReferenceHashMap.java:1033"$1$"			this.hash = hash;"
"ConcurrentReferenceHashMap.java:1034"$1$"			this.nextReference = next;"
"ConcurrentReferenceHashMap.java:1035"$1$"		}"
"ConcurrentReferenceHashMap.java:1036"$0$""
"ConcurrentReferenceHashMap.java:1037"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1038"$1$"		public int getHash() {"
"ConcurrentReferenceHashMap.java:1039"$1$"			return this.hash;"
"ConcurrentReferenceHashMap.java:1040"$1$"		}"
"ConcurrentReferenceHashMap.java:1041"$0$""
"ConcurrentReferenceHashMap.java:1042"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1043"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:1044"$1$"		public Reference<K, V> getNext() {"
"ConcurrentReferenceHashMap.java:1045"$1$"			return this.nextReference;"
"ConcurrentReferenceHashMap.java:1046"$1$"		}"
"ConcurrentReferenceHashMap.java:1047"$0$""
"ConcurrentReferenceHashMap.java:1048"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1049"$1$"		public void release() {"
"ConcurrentReferenceHashMap.java:1050"$1$"			enqueue();"
"ConcurrentReferenceHashMap.java:1051"$1$"			clear();"
"ConcurrentReferenceHashMap.java:1052"$1$"		}"
"ConcurrentReferenceHashMap.java:1053"$0$"	}"
"ConcurrentReferenceHashMap.java:1054"$0$""
"ConcurrentReferenceHashMap.java:1055"$0$""
"ConcurrentReferenceHashMap.java:1056"$0$"	/**"
"ConcurrentReferenceHashMap.java:1057"$1$"	 * Internal {@link Reference} implementation for {@link WeakReference WeakReferences}."
"ConcurrentReferenceHashMap.java:1058"$0$"	 */"
"ConcurrentReferenceHashMap.java:1059"$1$"	private static final class WeakEntryReference<K, V> extends WeakReference<Entry<K, V>> implements Reference<K, V> {"
"ConcurrentReferenceHashMap.java:1060"$1$""
"ConcurrentReferenceHashMap.java:1061"$1$"		private final int hash;"
"ConcurrentReferenceHashMap.java:1062"$1$""
"ConcurrentReferenceHashMap.java:1063"$1$"		@Nullable"
"ConcurrentReferenceHashMap.java:1064"$1$"		private final Reference<K, V> nextReference;"
"ConcurrentReferenceHashMap.java:1065"$1$""
"ConcurrentReferenceHashMap.java:1066"$1$"		public WeakEntryReference(Entry<K, V> entry, int hash, @Nullable Reference<K, V> next,"
"ConcurrentReferenceHashMap.java:1067"$1$"				ReferenceQueue<Entry<K, V>> queue) {"
"ConcurrentReferenceHashMap.java:1068"$1$""
"ConcurrentReferenceHashMap.java:1069"$1$"			super(entry, queue);"
"ConcurrentReferenceHashMap.java:1070"$1$"			this.hash = hash;"
"ConcurrentReferenceHashMap.java:1071"$1$"			this.nextReference = next;"
"ConcurrentReferenceHashMap.java:1072"$1$"		}"
"ConcurrentReferenceHashMap.java:1073"$0$""
"ConcurrentReferenceHashMap.java:1074"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1075"$1$"		public int getHash() {"
"ConcurrentReferenceHashMap.java:1076"$1$"			return this.hash;"
"ConcurrentReferenceHashMap.java:1077"$1$"		}"
"ConcurrentReferenceHashMap.java:1078"$0$""
"ConcurrentReferenceHashMap.java:1079"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1080"$0$"		@Nullable"
"ConcurrentReferenceHashMap.java:1081"$1$"		public Reference<K, V> getNext() {"
"ConcurrentReferenceHashMap.java:1082"$1$"			return this.nextReference;"
"ConcurrentReferenceHashMap.java:1083"$1$"		}"
"ConcurrentReferenceHashMap.java:1084"$0$""
"ConcurrentReferenceHashMap.java:1085"$0$"		@Override"
"ConcurrentReferenceHashMap.java:1086"$1$"		public void release() {"
"ConcurrentReferenceHashMap.java:1087"$1$"			enqueue();"
"ConcurrentReferenceHashMap.java:1088"$1$"			clear();"
"ConcurrentReferenceHashMap.java:1089"$1$"		}"
"ConcurrentReferenceHashMap.java:1090"$0$"	}"
"ConcurrentReferenceHashMap.java:1091"$0$""
"ConcurrentReferenceHashMap.java:1092"$0$"}"
"StaxEventHandler.java:1"$0$"/*"
"StaxEventHandler.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"StaxEventHandler.java:3"$0$" *"
"StaxEventHandler.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StaxEventHandler.java:5"$0$" * you may not use this file except in compliance with the License."
"StaxEventHandler.java:6"$0$" * You may obtain a copy of the License at"
"StaxEventHandler.java:7"$0$" *"
"StaxEventHandler.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StaxEventHandler.java:9"$0$" *"
"StaxEventHandler.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StaxEventHandler.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StaxEventHandler.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StaxEventHandler.java:13"$0$" * See the License for the specific language governing permissions and"
"StaxEventHandler.java:14"$0$" * limitations under the License."
"StaxEventHandler.java:15"$0$" */"
"StaxEventHandler.java:16"$0$""
"StaxEventHandler.java:17"$0$"package org.springframework.util.xml;"
"StaxEventHandler.java:18"$0$""
"StaxEventHandler.java:19"$0$"import java.util.ArrayList;"
"StaxEventHandler.java:20"$0$"import java.util.List;"
"StaxEventHandler.java:21"$0$"import java.util.Map;"
"StaxEventHandler.java:22"$0$""
"StaxEventHandler.java:23"$0$"import javax.xml.namespace.QName;"
"StaxEventHandler.java:24"$0$"import javax.xml.stream.Location;"
"StaxEventHandler.java:25"$0$"import javax.xml.stream.XMLEventFactory;"
"StaxEventHandler.java:26"$0$"import javax.xml.stream.XMLEventWriter;"
"StaxEventHandler.java:27"$0$"import javax.xml.stream.XMLStreamException;"
"StaxEventHandler.java:28"$0$"import javax.xml.stream.events.Attribute;"
"StaxEventHandler.java:29"$0$"import javax.xml.stream.events.Namespace;"
"StaxEventHandler.java:30"$0$""
"StaxEventHandler.java:31"$0$"import org.xml.sax.Attributes;"
"StaxEventHandler.java:32"$0$"import org.xml.sax.Locator;"
"StaxEventHandler.java:33"$0$"import org.xml.sax.ext.LexicalHandler;"
"StaxEventHandler.java:34"$0$""
"StaxEventHandler.java:35"$0$"import org.springframework.lang.Nullable;"
"StaxEventHandler.java:36"$0$""
"StaxEventHandler.java:37"$0$"/**"
"StaxEventHandler.java:38"$1$" * SAX {@link org.xml.sax.ContentHandler} and {@link LexicalHandler}"
"StaxEventHandler.java:39"$1$" * that writes to a {@link javax.xml.stream.util.XMLEventConsumer}."
"StaxEventHandler.java:40"$0$" *"
"StaxEventHandler.java:41"$0$" * @author Arjen Poutsma"
"StaxEventHandler.java:42"$0$" * @since 4.0.3"
"StaxEventHandler.java:43"$0$" */"
"StaxEventHandler.java:44"$1$"class StaxEventHandler extends AbstractStaxHandler {"
"StaxEventHandler.java:45"$1$""
"StaxEventHandler.java:46"$1$"	private final XMLEventFactory eventFactory;"
"StaxEventHandler.java:47"$1$""
"StaxEventHandler.java:48"$1$"	private final XMLEventWriter eventWriter;"
"StaxEventHandler.java:49"$1$""
"StaxEventHandler.java:50"$1$""
"StaxEventHandler.java:51"$1$"	/**"
"StaxEventHandler.java:52"$1$"	 * Construct a new instance of the {@code StaxEventContentHandler} that writes to the"
"StaxEventHandler.java:53"$1$"	 * given {@code XMLEventWriter}. A default {@code XMLEventFactory} will be created."
"StaxEventHandler.java:54"$1$"	 * @param eventWriter the writer to write events to"
"StaxEventHandler.java:55"$1$"	 */"
"StaxEventHandler.java:56"$1$"	public StaxEventHandler(XMLEventWriter eventWriter) {"
"StaxEventHandler.java:57"$1$"		this.eventFactory = XMLEventFactory.newInstance();"
"StaxEventHandler.java:58"$1$"		this.eventWriter = eventWriter;"
"StaxEventHandler.java:59"$1$"	}"
"StaxEventHandler.java:60"$0$""
"StaxEventHandler.java:61"$0$"	/**"
"StaxEventHandler.java:62"$1$"	 * Construct a new instance of the {@code StaxEventContentHandler} that uses the given"
"StaxEventHandler.java:63"$1$"	 * event factory to create events and writes to the given {@code XMLEventConsumer}."
"StaxEventHandler.java:64"$0$"	 * @param eventWriter the writer to write events to"
"StaxEventHandler.java:65"$0$"	 * @param factory the factory used to create events"
"StaxEventHandler.java:66"$0$"	 */"
"StaxEventHandler.java:67"$1$"	public StaxEventHandler(XMLEventWriter eventWriter, XMLEventFactory factory) {"
"StaxEventHandler.java:68"$1$"		this.eventFactory = factory;"
"StaxEventHandler.java:69"$1$"		this.eventWriter = eventWriter;"
"StaxEventHandler.java:70"$1$"	}"
"StaxEventHandler.java:71"$0$""
"StaxEventHandler.java:72"$0$""
"StaxEventHandler.java:73"$0$"	@Override"
"StaxEventHandler.java:74"$1$"	public void setDocumentLocator(@Nullable Locator locator) {"
"StaxEventHandler.java:75"$1$"		if (locator != null) {"
"StaxEventHandler.java:76"$1$"			this.eventFactory.setLocation(new LocatorLocationAdapter(locator));"
"StaxEventHandler.java:77"$1$"		}"
"StaxEventHandler.java:78"$0$"	}"
"StaxEventHandler.java:79"$0$""
"StaxEventHandler.java:80"$0$"	@Override"
"StaxEventHandler.java:81"$1$"	protected void startDocumentInternal() throws XMLStreamException {"
"StaxEventHandler.java:82"$1$"		this.eventWriter.add(this.eventFactory.createStartDocument());"
"StaxEventHandler.java:83"$1$"	}"
"StaxEventHandler.java:84"$0$""
"StaxEventHandler.java:85"$0$"	@Override"
"StaxEventHandler.java:86"$1$"	protected void endDocumentInternal() throws XMLStreamException {"
"StaxEventHandler.java:87"$1$"		this.eventWriter.add(this.eventFactory.createEndDocument());"
"StaxEventHandler.java:88"$1$"	}"
"StaxEventHandler.java:89"$0$""
"StaxEventHandler.java:90"$0$"	@Override"
"StaxEventHandler.java:91"$0$"	protected void startElementInternal(QName name, Attributes atts,"
"StaxEventHandler.java:92"$1$"			Map<String, String> namespaceMapping) throws XMLStreamException {"
"StaxEventHandler.java:93"$1$""
"StaxEventHandler.java:94"$1$"		List<Attribute> attributes = getAttributes(atts);"
"StaxEventHandler.java:95"$1$"		List<Namespace> namespaces = getNamespaces(namespaceMapping);"
"StaxEventHandler.java:96"$1$"		this.eventWriter.add("
"StaxEventHandler.java:97"$1$"				this.eventFactory.createStartElement(name, attributes.iterator(), namespaces.iterator()));"
"StaxEventHandler.java:98"$1$""
"StaxEventHandler.java:99"$1$"	}"
"StaxEventHandler.java:100"$0$""
"StaxEventHandler.java:101"$1$"	private List<Namespace> getNamespaces(Map<String, String> namespaceMappings) {"
"StaxEventHandler.java:102"$1$"		List<Namespace> result = new ArrayList<>(namespaceMappings.size());"
"StaxEventHandler.java:103"$1$"		namespaceMappings.forEach((prefix, namespaceUri) ->"
"StaxEventHandler.java:104"$1$"				result.add(this.eventFactory.createNamespace(prefix, namespaceUri)));"
"StaxEventHandler.java:105"$1$"		return result;"
"StaxEventHandler.java:106"$1$"	}"
"StaxEventHandler.java:107"$0$""
"StaxEventHandler.java:108"$1$"	private List<Attribute> getAttributes(Attributes attributes) {"
"StaxEventHandler.java:109"$1$"		int attrLength = attributes.getLength();"
"StaxEventHandler.java:110"$1$"		List<Attribute> result = new ArrayList<>(attrLength);"
"StaxEventHandler.java:111"$1$"		for (int i = 0; i < attrLength; i++) {"
"StaxEventHandler.java:112"$1$"			QName attrName = toQName(attributes.getURI(i), attributes.getQName(i));"
"StaxEventHandler.java:113"$1$"			if (!isNamespaceDeclaration(attrName)) {"
"StaxEventHandler.java:114"$1$"				result.add(this.eventFactory.createAttribute(attrName, attributes.getValue(i)));"
"StaxEventHandler.java:115"$1$"			}"
"StaxEventHandler.java:116"$0$"		}"
"StaxEventHandler.java:117"$0$"		return result;"
"StaxEventHandler.java:118"$0$"	}"
"StaxEventHandler.java:119"$0$""
"StaxEventHandler.java:120"$0$"	@Override"
"StaxEventHandler.java:121"$1$"	protected void endElementInternal(QName name, Map<String, String> namespaceMapping) throws XMLStreamException {"
"StaxEventHandler.java:122"$1$"		List<Namespace> namespaces = getNamespaces(namespaceMapping);"
"StaxEventHandler.java:123"$1$"		this.eventWriter.add(this.eventFactory.createEndElement(name, namespaces.iterator()));"
"StaxEventHandler.java:124"$1$"	}"
"StaxEventHandler.java:125"$0$""
"StaxEventHandler.java:126"$0$"	@Override"
"StaxEventHandler.java:127"$1$"	protected void charactersInternal(String data) throws XMLStreamException {"
"StaxEventHandler.java:128"$1$"		this.eventWriter.add(this.eventFactory.createCharacters(data));"
"StaxEventHandler.java:129"$1$"	}"
"StaxEventHandler.java:130"$0$""
"StaxEventHandler.java:131"$0$"	@Override"
"StaxEventHandler.java:132"$1$"	protected void cDataInternal(String data) throws XMLStreamException {"
"StaxEventHandler.java:133"$1$"		this.eventWriter.add(this.eventFactory.createCData(data));"
"StaxEventHandler.java:134"$1$"	}"
"StaxEventHandler.java:135"$0$""
"StaxEventHandler.java:136"$0$"	@Override"
"StaxEventHandler.java:137"$1$"	protected void ignorableWhitespaceInternal(String data) throws XMLStreamException {"
"StaxEventHandler.java:138"$1$"		this.eventWriter.add(this.eventFactory.createIgnorableSpace(data));"
"StaxEventHandler.java:139"$1$"	}"
"StaxEventHandler.java:140"$0$""
"StaxEventHandler.java:141"$0$"	@Override"
"StaxEventHandler.java:142"$1$"	protected void processingInstructionInternal(String target, String data) throws XMLStreamException {"
"StaxEventHandler.java:143"$1$"		this.eventWriter.add(this.eventFactory.createProcessingInstruction(target, data));"
"StaxEventHandler.java:144"$1$"	}"
"StaxEventHandler.java:145"$0$""
"StaxEventHandler.java:146"$0$"	@Override"
"StaxEventHandler.java:147"$1$"	protected void dtdInternal(String dtd) throws XMLStreamException {"
"StaxEventHandler.java:148"$1$"		this.eventWriter.add(this.eventFactory.createDTD(dtd));"
"StaxEventHandler.java:149"$1$"	}"
"StaxEventHandler.java:150"$0$""
"StaxEventHandler.java:151"$0$"	@Override"
"StaxEventHandler.java:152"$1$"	protected void commentInternal(String comment) throws XMLStreamException {"
"StaxEventHandler.java:153"$1$"		this.eventWriter.add(this.eventFactory.createComment(comment));"
"StaxEventHandler.java:154"$1$"	}"
"StaxEventHandler.java:155"$0$""
"StaxEventHandler.java:156"$0$"	// Ignored"
"StaxEventHandler.java:157"$0$"	@Override"
"StaxEventHandler.java:158"$1$"	protected void skippedEntityInternal(String name) {"
"StaxEventHandler.java:159"$1$"	}"
"StaxEventHandler.java:160"$0$""
"StaxEventHandler.java:161"$0$""
"StaxEventHandler.java:162"$1$"	private static final class LocatorLocationAdapter implements Location {"
"StaxEventHandler.java:163"$1$""
"StaxEventHandler.java:164"$1$"		private final Locator locator;"
"StaxEventHandler.java:165"$1$""
"StaxEventHandler.java:166"$1$"		public LocatorLocationAdapter(Locator locator) {"
"StaxEventHandler.java:167"$1$"			this.locator = locator;"
"StaxEventHandler.java:168"$1$"		}"
"StaxEventHandler.java:169"$0$""
"StaxEventHandler.java:170"$0$"		@Override"
"StaxEventHandler.java:171"$1$"		public int getLineNumber() {"
"StaxEventHandler.java:172"$1$"			return this.locator.getLineNumber();"
"StaxEventHandler.java:173"$1$"		}"
"StaxEventHandler.java:174"$0$""
"StaxEventHandler.java:175"$0$"		@Override"
"StaxEventHandler.java:176"$1$"		public int getColumnNumber() {"
"StaxEventHandler.java:177"$1$"			return this.locator.getColumnNumber();"
"StaxEventHandler.java:178"$1$"		}"
"StaxEventHandler.java:179"$0$""
"StaxEventHandler.java:180"$0$"		@Override"
"StaxEventHandler.java:181"$1$"		public int getCharacterOffset() {"
"StaxEventHandler.java:182"$1$"			return -1;"
"StaxEventHandler.java:183"$1$"		}"
"StaxEventHandler.java:184"$0$""
"StaxEventHandler.java:185"$0$"		@Override"
"StaxEventHandler.java:186"$1$"		public String getPublicId() {"
"StaxEventHandler.java:187"$1$"			return this.locator.getPublicId();"
"StaxEventHandler.java:188"$1$"		}"
"StaxEventHandler.java:189"$0$""
"StaxEventHandler.java:190"$0$"		@Override"
"StaxEventHandler.java:191"$1$"		public String getSystemId() {"
"StaxEventHandler.java:192"$1$"			return this.locator.getSystemId();"
"StaxEventHandler.java:193"$1$"		}"
"StaxEventHandler.java:194"$0$"	}"
"StaxEventHandler.java:195"$0$""
"StaxEventHandler.java:196"$0$"}"
"ResolvableType.java:1"$0$"/*"
"ResolvableType.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ResolvableType.java:3"$0$" *"
"ResolvableType.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResolvableType.java:5"$0$" * you may not use this file except in compliance with the License."
"ResolvableType.java:6"$0$" * You may obtain a copy of the License at"
"ResolvableType.java:7"$0$" *"
"ResolvableType.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResolvableType.java:9"$0$" *"
"ResolvableType.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResolvableType.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResolvableType.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResolvableType.java:13"$0$" * See the License for the specific language governing permissions and"
"ResolvableType.java:14"$0$" * limitations under the License."
"ResolvableType.java:15"$0$" */"
"ResolvableType.java:16"$0$""
"ResolvableType.java:17"$0$"package org.springframework.core;"
"ResolvableType.java:18"$0$""
"ResolvableType.java:19"$0$"import java.io.Serializable;"
"ResolvableType.java:20"$0$"import java.lang.reflect.Array;"
"ResolvableType.java:21"$0$"import java.lang.reflect.Constructor;"
"ResolvableType.java:22"$0$"import java.lang.reflect.Field;"
"ResolvableType.java:23"$0$"import java.lang.reflect.GenericArrayType;"
"ResolvableType.java:24"$0$"import java.lang.reflect.Method;"
"ResolvableType.java:25"$0$"import java.lang.reflect.ParameterizedType;"
"ResolvableType.java:26"$0$"import java.lang.reflect.Type;"
"ResolvableType.java:27"$0$"import java.lang.reflect.TypeVariable;"
"ResolvableType.java:28"$0$"import java.lang.reflect.WildcardType;"
"ResolvableType.java:29"$0$"import java.util.Arrays;"
"ResolvableType.java:30"$0$"import java.util.Collection;"
"ResolvableType.java:31"$0$"import java.util.IdentityHashMap;"
"ResolvableType.java:32"$0$"import java.util.Map;"
"ResolvableType.java:33"$0$"import java.util.StringJoiner;"
"ResolvableType.java:34"$0$""
"ResolvableType.java:35"$0$"import org.springframework.core.SerializableTypeWrapper.FieldTypeProvider;"
"ResolvableType.java:36"$0$"import org.springframework.core.SerializableTypeWrapper.MethodParameterTypeProvider;"
"ResolvableType.java:37"$0$"import org.springframework.core.SerializableTypeWrapper.TypeProvider;"
"ResolvableType.java:38"$0$"import org.springframework.lang.Nullable;"
"ResolvableType.java:39"$0$"import org.springframework.util.Assert;"
"ResolvableType.java:40"$0$"import org.springframework.util.ClassUtils;"
"ResolvableType.java:41"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"ResolvableType.java:42"$0$"import org.springframework.util.ObjectUtils;"
"ResolvableType.java:43"$0$"import org.springframework.util.StringUtils;"
"ResolvableType.java:44"$0$""
"ResolvableType.java:45"$0$"/**"
"ResolvableType.java:46"$1$" * Encapsulates a Java {@link java.lang.reflect.Type}, providing access to"
"ResolvableType.java:47"$1$" * {@link #getSuperType() supertypes}, {@link #getInterfaces() interfaces}, and"
"ResolvableType.java:48"$1$" * {@link #getGeneric(int...) generic parameters} along with the ability to ultimately"
"ResolvableType.java:49"$1$" * {@link #resolve() resolve} to a {@link java.lang.Class}."
"ResolvableType.java:50"$0$" *"
"ResolvableType.java:51"$1$" * <p>{@code ResolvableTypes} may be obtained from {@link #forField(Field) fields},"
"ResolvableType.java:52"$1$" * {@link #forMethodParameter(Method, int) method parameters},"
"ResolvableType.java:53"$1$" * {@link #forMethodReturnType(Method) method returns} or"
"ResolvableType.java:54"$1$" * {@link #forClass(Class) classes}. Most methods on this class will themselves return"
"ResolvableType.java:55"$1$" * {@link ResolvableType ResolvableTypes}, allowing easy navigation. For example:"
"ResolvableType.java:56"$0$" * <pre class=""code"">"
"ResolvableType.java:57"$0$" * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;"
"ResolvableType.java:58"$0$" *"
"ResolvableType.java:59"$1$" * public void example() {"
"ResolvableType.java:60"$1$" *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(""myMap""));"
"ResolvableType.java:61"$1$" *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;"
"ResolvableType.java:62"$1$" *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;"
"ResolvableType.java:63"$1$" *     t.getGeneric(0).resolve(); // Integer"
"ResolvableType.java:64"$1$" *     t.getGeneric(1).resolve(); // List"
"ResolvableType.java:65"$1$" *     t.getGeneric(1); // List&lt;String&gt;"
"ResolvableType.java:66"$1$" *     t.resolveGeneric(1, 0); // String"
"ResolvableType.java:67"$1$" * }"
"ResolvableType.java:68"$0$" * </pre>"
"ResolvableType.java:69"$0$" *"
"ResolvableType.java:70"$0$" * @author Phillip Webb"
"ResolvableType.java:71"$0$" * @author Juergen Hoeller"
"ResolvableType.java:72"$0$" * @author Stephane Nicoll"
"ResolvableType.java:73"$0$" * @since 4.0"
"ResolvableType.java:74"$0$" * @see #forField(Field)"
"ResolvableType.java:75"$0$" * @see #forMethodParameter(Method, int)"
"ResolvableType.java:76"$0$" * @see #forMethodReturnType(Method)"
"ResolvableType.java:77"$0$" * @see #forConstructorParameter(Constructor, int)"
"ResolvableType.java:78"$0$" * @see #forClass(Class)"
"ResolvableType.java:79"$0$" * @see #forType(Type)"
"ResolvableType.java:80"$0$" * @see #forInstance(Object)"
"ResolvableType.java:81"$0$" * @see ResolvableTypeProvider"
"ResolvableType.java:82"$0$" */"
"ResolvableType.java:83"$0$"SuppressWarnings(""serial"")"
"ResolvableType.java:84"$1$"public class ResolvableType implements Serializable {"
"ResolvableType.java:85"$1$""
"ResolvableType.java:86"$1$"	/**"
"ResolvableType.java:87"$1$"	 * {@code ResolvableType} returned when no value is available. {@code NONE} is used"
"ResolvableType.java:88"$1$"	 * in preference to {@code null} so that multiple method calls can be safely chained."
"ResolvableType.java:89"$1$"	 */"
"ResolvableType.java:90"$1$"	public static final ResolvableType NONE = new ResolvableType(EmptyType.INSTANCE, null, null, 0);"
"ResolvableType.java:91"$1$""
"ResolvableType.java:92"$1$"	private static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0];"
"ResolvableType.java:93"$1$""
"ResolvableType.java:94"$1$"	private static final ConcurrentReferenceHashMap<ResolvableType, ResolvableType> cache ="
"ResolvableType.java:95"$1$"			new ConcurrentReferenceHashMap<>(256);"
"ResolvableType.java:96"$1$""
"ResolvableType.java:97"$1$""
"ResolvableType.java:98"$1$"	/**"
"ResolvableType.java:99"$1$"	 * The underlying Java type being managed."
"ResolvableType.java:100"$1$"	 */"
"ResolvableType.java:101"$1$"	private final Type type;"
"ResolvableType.java:102"$1$""
"ResolvableType.java:103"$1$"	/**"
"ResolvableType.java:104"$1$"	 * Optional provider for the type."
"ResolvableType.java:105"$1$"	 */"
"ResolvableType.java:106"$1$"	@Nullable"
"ResolvableType.java:107"$1$"	private final TypeProvider typeProvider;"
"ResolvableType.java:108"$1$""
"ResolvableType.java:109"$1$"	/**"
"ResolvableType.java:110"$1$"	 * The {@code VariableResolver} to use or {@code null} if no resolver is available."
"ResolvableType.java:111"$1$"	 */"
"ResolvableType.java:112"$1$"	@Nullable"
"ResolvableType.java:113"$1$"	private final VariableResolver variableResolver;"
"ResolvableType.java:114"$1$""
"ResolvableType.java:115"$1$"	/**"
"ResolvableType.java:116"$1$"	 * The component type for an array or {@code null} if the type should be deduced."
"ResolvableType.java:117"$1$"	 */"
"ResolvableType.java:118"$1$"	@Nullable"
"ResolvableType.java:119"$1$"	private final ResolvableType componentType;"
"ResolvableType.java:120"$1$""
"ResolvableType.java:121"$1$"	@Nullable"
"ResolvableType.java:122"$1$"	private final Integer hash;"
"ResolvableType.java:123"$1$""
"ResolvableType.java:124"$1$"	@Nullable"
"ResolvableType.java:125"$1$"	private Class<?> resolved;"
"ResolvableType.java:126"$1$""
"ResolvableType.java:127"$1$"	@Nullable"
"ResolvableType.java:128"$1$"	private volatile ResolvableType superType;"
"ResolvableType.java:129"$1$""
"ResolvableType.java:130"$1$"	@Nullable"
"ResolvableType.java:131"$1$"	private volatile ResolvableType[] interfaces;"
"ResolvableType.java:132"$1$""
"ResolvableType.java:133"$1$"	@Nullable"
"ResolvableType.java:134"$1$"	private volatile ResolvableType[] generics;"
"ResolvableType.java:135"$1$""
"ResolvableType.java:136"$1$""
"ResolvableType.java:137"$1$"	/**"
"ResolvableType.java:138"$1$"	 * Private constructor used to create a new {@link ResolvableType} for cache key purposes,"
"ResolvableType.java:139"$1$"	 * with no upfront resolution."
"ResolvableType.java:140"$1$"	 */"
"ResolvableType.java:141"$1$"	private ResolvableType("
"ResolvableType.java:142"$1$"			Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {"
"ResolvableType.java:143"$1$""
"ResolvableType.java:144"$1$"		this.type = type;"
"ResolvableType.java:145"$1$"		this.typeProvider = typeProvider;"
"ResolvableType.java:146"$1$"		this.variableResolver = variableResolver;"
"ResolvableType.java:147"$1$"		this.componentType = null;"
"ResolvableType.java:148"$1$"		this.hash = calculateHashCode();"
"ResolvableType.java:149"$1$"		this.resolved = null;"
"ResolvableType.java:150"$1$"	}"
"ResolvableType.java:151"$0$""
"ResolvableType.java:152"$0$"	/**"
"ResolvableType.java:153"$1$"	 * Private constructor used to create a new {@link ResolvableType} for cache value purposes,"
"ResolvableType.java:154"$0$"	 * with upfront resolution and a pre-calculated hash."
"ResolvableType.java:155"$0$"	 * @since 4.2"
"ResolvableType.java:156"$0$"	 */"
"ResolvableType.java:157"$0$"	private ResolvableType(Type type, @Nullable TypeProvider typeProvider,"
"ResolvableType.java:158"$1$"			@Nullable VariableResolver variableResolver, @Nullable Integer hash) {"
"ResolvableType.java:159"$1$""
"ResolvableType.java:160"$1$"		this.type = type;"
"ResolvableType.java:161"$1$"		this.typeProvider = typeProvider;"
"ResolvableType.java:162"$1$"		this.variableResolver = variableResolver;"
"ResolvableType.java:163"$1$"		this.componentType = null;"
"ResolvableType.java:164"$1$"		this.hash = hash;"
"ResolvableType.java:165"$1$"		this.resolved = resolveClass();"
"ResolvableType.java:166"$1$"	}"
"ResolvableType.java:167"$0$""
"ResolvableType.java:168"$0$"	/**"
"ResolvableType.java:169"$1$"	 * Private constructor used to create a new {@link ResolvableType} for uncached purposes,"
"ResolvableType.java:170"$0$"	 * with upfront resolution but lazily calculated hash."
"ResolvableType.java:171"$0$"	 */"
"ResolvableType.java:172"$0$"	private ResolvableType(Type type, @Nullable TypeProvider typeProvider,"
"ResolvableType.java:173"$1$"			@Nullable VariableResolver variableResolver, @Nullable ResolvableType componentType) {"
"ResolvableType.java:174"$1$""
"ResolvableType.java:175"$1$"		this.type = type;"
"ResolvableType.java:176"$1$"		this.typeProvider = typeProvider;"
"ResolvableType.java:177"$1$"		this.variableResolver = variableResolver;"
"ResolvableType.java:178"$1$"		this.componentType = componentType;"
"ResolvableType.java:179"$1$"		this.hash = null;"
"ResolvableType.java:180"$1$"		this.resolved = resolveClass();"
"ResolvableType.java:181"$1$"	}"
"ResolvableType.java:182"$0$""
"ResolvableType.java:183"$0$"	/**"
"ResolvableType.java:184"$1$"	 * Private constructor used to create a new {@link ResolvableType} on a {@link Class} basis."
"ResolvableType.java:185"$1$"	 * Avoids all {@code instanceof} checks in order to create a straight {@link Class} wrapper."
"ResolvableType.java:186"$0$"	 * @since 4.2"
"ResolvableType.java:187"$0$"	 */"
"ResolvableType.java:188"$1$"	private ResolvableType(@Nullable Class<?> clazz) {"
"ResolvableType.java:189"$1$"		this.resolved = (clazz != null ? clazz : Object.class);"
"ResolvableType.java:190"$1$"		this.type = this.resolved;"
"ResolvableType.java:191"$1$"		this.typeProvider = null;"
"ResolvableType.java:192"$1$"		this.variableResolver = null;"
"ResolvableType.java:193"$1$"		this.componentType = null;"
"ResolvableType.java:194"$1$"		this.hash = null;"
"ResolvableType.java:195"$1$"	}"
"ResolvableType.java:196"$0$""
"ResolvableType.java:197"$0$""
"ResolvableType.java:198"$0$"	/**"
"ResolvableType.java:199"$1$"	 * Return the underling Java {@link Type} being managed."
"ResolvableType.java:200"$0$"	 */"
"ResolvableType.java:201"$1$"	public Type getType() {"
"ResolvableType.java:202"$1$"		return SerializableTypeWrapper.unwrap(this.type);"
"ResolvableType.java:203"$1$"	}"
"ResolvableType.java:204"$0$""
"ResolvableType.java:205"$0$"	/**"
"ResolvableType.java:206"$1$"	 * Return the underlying Java {@link Class} being managed, if available;"
"ResolvableType.java:207"$1$"	 * otherwise {@code null}."
"ResolvableType.java:208"$0$"	 */"
"ResolvableType.java:209"$0$"	@Nullable"
"ResolvableType.java:210"$1$"	public Class<?> getRawClass() {"
"ResolvableType.java:211"$1$"		if (this.type == this.resolved) {"
"ResolvableType.java:212"$1$"			return this.resolved;"
"ResolvableType.java:213"$1$"		}"
"ResolvableType.java:214"$0$"		Type rawType = this.type;"
"ResolvableType.java:215"$1$"		if (rawType instanceof ParameterizedType) {"
"ResolvableType.java:216"$1$"			rawType = ((ParameterizedType) rawType).getRawType();"
"ResolvableType.java:217"$1$"		}"
"ResolvableType.java:218"$0$"		return (rawType instanceof Class ? (Class<?>) rawType : null);"
"ResolvableType.java:219"$0$"	}"
"ResolvableType.java:220"$0$""
"ResolvableType.java:221"$0$"	/**"
"ResolvableType.java:222"$1$"	 * Return the underlying source of the resolvable type. Will return a {@link Field},"
"ResolvableType.java:223"$1$"	 * {@link MethodParameter} or {@link Type} depending on how the {@link ResolvableType}"
"ResolvableType.java:224"$1$"	 * was constructed. With the exception of the {@link #NONE} constant, this method will"
"ResolvableType.java:225"$1$"	 * never return {@code null}. This method is primarily to provide access to additional"
"ResolvableType.java:226"$0$"	 * type information or meta-data that alternative JVM languages may provide."
"ResolvableType.java:227"$0$"	 */"
"ResolvableType.java:228"$1$"	public Object getSource() {"
"ResolvableType.java:229"$1$"		Object source = (this.typeProvider != null ? this.typeProvider.getSource() : null);"
"ResolvableType.java:230"$1$"		return (source != null ? source : this.type);"
"ResolvableType.java:231"$1$"	}"
"ResolvableType.java:232"$0$""
"ResolvableType.java:233"$0$"	/**"
"ResolvableType.java:234"$1$"	 * Return this type as a resolved {@code Class}, falling back to"
"ResolvableType.java:235"$1$"	 * {@link java.lang.Object} if no specific class can be resolved."
"ResolvableType.java:236"$1$"	 * @return the resolved {@link Class} or the {@code Object} fallback"
"ResolvableType.java:237"$0$"	 * @since 5.1"
"ResolvableType.java:238"$0$"	 * @see #getRawClass()"
"ResolvableType.java:239"$0$"	 * @see #resolve(Class)"
"ResolvableType.java:240"$0$"	 */"
"ResolvableType.java:241"$1$"	public Class<?> toClass() {"
"ResolvableType.java:242"$1$"		return resolve(Object.class);"
"ResolvableType.java:243"$1$"	}"
"ResolvableType.java:244"$0$""
"ResolvableType.java:245"$0$"	/**"
"ResolvableType.java:246"$1$"	 * Determine whether the given object is an instance of this {@code ResolvableType}."
"ResolvableType.java:247"$0$"	 * @param obj the object to check"
"ResolvableType.java:248"$0$"	 * @since 4.2"
"ResolvableType.java:249"$0$"	 * @see #isAssignableFrom(Class)"
"ResolvableType.java:250"$0$"	 */"
"ResolvableType.java:251"$1$"	public boolean isInstance(@Nullable Object obj) {"
"ResolvableType.java:252"$1$"		return (obj != null && isAssignableFrom(obj.getClass()));"
"ResolvableType.java:253"$1$"	}"
"ResolvableType.java:254"$0$""
"ResolvableType.java:255"$0$"	/**"
"ResolvableType.java:256"$1$"	 * Determine whether this {@code ResolvableType} is assignable from the"
"ResolvableType.java:257"$0$"	 * specified other type."
"ResolvableType.java:258"$1$"	 * @param other the type to be checked against (as a {@code Class})"
"ResolvableType.java:259"$0$"	 * @since 4.2"
"ResolvableType.java:260"$0$"	 * @see #isAssignableFrom(ResolvableType)"
"ResolvableType.java:261"$0$"	 */"
"ResolvableType.java:262"$1$"	public boolean isAssignableFrom(Class<?> other) {"
"ResolvableType.java:263"$1$"		return isAssignableFrom(forClass(other), null);"
"ResolvableType.java:264"$1$"	}"
"ResolvableType.java:265"$0$""
"ResolvableType.java:266"$0$"	/**"
"ResolvableType.java:267"$1$"	 * Determine whether this {@code ResolvableType} is assignable from the"
"ResolvableType.java:268"$0$"	 * specified other type."
"ResolvableType.java:269"$0$"	 * <p>Attempts to follow the same rules as the Java compiler, considering"
"ResolvableType.java:270"$1$"	 * whether both the {@link #resolve() resolved} {@code Class} is"
"ResolvableType.java:271"$1$"	 * {@link Class#isAssignableFrom(Class) assignable from} the given type"
"ResolvableType.java:272"$1$"	 * as well as whether all {@link #getGenerics() generics} are assignable."
"ResolvableType.java:273"$1$"	 * @param other the type to be checked against (as a {@code ResolvableType})"
"ResolvableType.java:274"$1$"	 * @return {@code true} if the specified other type can be assigned to this"
"ResolvableType.java:275"$1$"	 * {@code ResolvableType}; {@code false} otherwise"
"ResolvableType.java:276"$0$"	 */"
"ResolvableType.java:277"$1$"	public boolean isAssignableFrom(ResolvableType other) {"
"ResolvableType.java:278"$1$"		return isAssignableFrom(other, null);"
"ResolvableType.java:279"$1$"	}"
"ResolvableType.java:280"$0$""
"ResolvableType.java:281"$1$"	private boolean isAssignableFrom(ResolvableType other, @Nullable Map<Type, Type> matchedBefore) {"
"ResolvableType.java:282"$1$"		Assert.notNull(other, ""ResolvableType must not be null"");"
"ResolvableType.java:283"$1$""
"ResolvableType.java:284"$0$"		// If we cannot resolve types, we are not assignable"
"ResolvableType.java:285"$1$"		if (this == NONE || other == NONE) {"
"ResolvableType.java:286"$1$"			return false;"
"ResolvableType.java:287"$1$"		}"
"ResolvableType.java:288"$0$""
"ResolvableType.java:289"$0$"		// Deal with array by delegating to the component type"
"ResolvableType.java:290"$1$"		if (isArray()) {"
"ResolvableType.java:291"$1$"			return (other.isArray() && getComponentType().isAssignableFrom(other.getComponentType()));"
"ResolvableType.java:292"$1$"		}"
"ResolvableType.java:293"$0$""
"ResolvableType.java:294"$1$"		if (matchedBefore != null && matchedBefore.get(this.type) == other.type) {"
"ResolvableType.java:295"$1$"			return true;"
"ResolvableType.java:296"$1$"		}"
"ResolvableType.java:297"$0$""
"ResolvableType.java:298"$0$"		// Deal with wildcard bounds"
"ResolvableType.java:299"$0$"		WildcardBounds ourBounds = WildcardBounds.get(this);"
"ResolvableType.java:300"$0$"		WildcardBounds typeBounds = WildcardBounds.get(other);"
"ResolvableType.java:301"$0$""
"ResolvableType.java:302"$0$"		// In the form X is assignable to <? extends Number>"
"ResolvableType.java:303"$1$"		if (typeBounds != null) {"
"ResolvableType.java:304"$1$"			return (ourBounds != null && ourBounds.isSameKind(typeBounds) &&"
"ResolvableType.java:305"$1$"					ourBounds.isAssignableFrom(typeBounds.getBounds()));"
"ResolvableType.java:306"$1$"		}"
"ResolvableType.java:307"$0$""
"ResolvableType.java:308"$0$"		// In the form <? extends Number> is assignable to X..."
"ResolvableType.java:309"$1$"		if (ourBounds != null) {"
"ResolvableType.java:310"$1$"			return ourBounds.isAssignableFrom(other);"
"ResolvableType.java:311"$1$"		}"
"ResolvableType.java:312"$0$""
"ResolvableType.java:313"$0$"		// Main assignability check about to follow"
"ResolvableType.java:314"$0$"		boolean exactMatch = (matchedBefore != null);  // We're checking nested generic variables now..."
"ResolvableType.java:315"$0$"		boolean checkGenerics = true;"
"ResolvableType.java:316"$0$"		Class<?> ourResolved = null;"
"ResolvableType.java:317"$1$"		if (this.type instanceof TypeVariable) {"
"ResolvableType.java:318"$1$"			TypeVariable<?> variable = (TypeVariable<?>) this.type;"
"ResolvableType.java:319"$0$"			// Try default variable resolution"
"ResolvableType.java:320"$1$"			if (this.variableResolver != null) {"
"ResolvableType.java:321"$1$"				ResolvableType resolved = this.variableResolver.resolveVariable(variable);"
"ResolvableType.java:322"$1$"				if (resolved != null) {"
"ResolvableType.java:323"$1$"					ourResolved = resolved.resolve();"
"ResolvableType.java:324"$1$"				}"
"ResolvableType.java:325"$0$"			}"
"ResolvableType.java:326"$1$"			if (ourResolved == null) {"
"ResolvableType.java:327"$0$"				// Try variable resolution against target type"
"ResolvableType.java:328"$1$"				if (other.variableResolver != null) {"
"ResolvableType.java:329"$1$"					ResolvableType resolved = other.variableResolver.resolveVariable(variable);"
"ResolvableType.java:330"$1$"					if (resolved != null) {"
"ResolvableType.java:331"$1$"						ourResolved = resolved.resolve();"
"ResolvableType.java:332"$1$"						checkGenerics = false;"
"ResolvableType.java:333"$1$"					}"
"ResolvableType.java:334"$0$"				}"
"ResolvableType.java:335"$0$"			}"
"ResolvableType.java:336"$1$"			if (ourResolved == null) {"
"ResolvableType.java:337"$0$"				// Unresolved type variable, potentially nested -> never insist on exact match"
"ResolvableType.java:338"$1$"				exactMatch = false;"
"ResolvableType.java:339"$1$"			}"
"ResolvableType.java:340"$0$"		}"
"ResolvableType.java:341"$1$"		if (ourResolved == null) {"
"ResolvableType.java:342"$1$"			ourResolved = resolve(Object.class);"
"ResolvableType.java:343"$1$"		}"
"ResolvableType.java:344"$0$"		Class<?> otherResolved = other.toClass();"
"ResolvableType.java:345"$0$""
"ResolvableType.java:346"$0$"		// We need an exact type match for generics"
"ResolvableType.java:347"$0$"		// List<CharSequence> is not assignable from List<String>"
"ResolvableType.java:348"$1$"		if (exactMatch ? !ourResolved.equals(otherResolved) : !ClassUtils.isAssignable(ourResolved, otherResolved)) {"
"ResolvableType.java:349"$1$"			return false;"
"ResolvableType.java:350"$1$"		}"
"ResolvableType.java:351"$0$""
"ResolvableType.java:352"$1$"		if (checkGenerics) {"
"ResolvableType.java:353"$0$"			// Recursively check each generic"
"ResolvableType.java:354"$1$"			ResolvableType[] ourGenerics = getGenerics();"
"ResolvableType.java:355"$1$"			ResolvableType[] typeGenerics = other.as(ourResolved).getGenerics();"
"ResolvableType.java:356"$1$"			if (ourGenerics.length != typeGenerics.length) {"
"ResolvableType.java:357"$1$"				return false;"
"ResolvableType.java:358"$1$"			}"
"ResolvableType.java:359"$1$"			if (matchedBefore == null) {"
"ResolvableType.java:360"$1$"				matchedBefore = new IdentityHashMap<>(1);"
"ResolvableType.java:361"$1$"			}"
"ResolvableType.java:362"$0$"			matchedBefore.put(this.type, other.type);"
"ResolvableType.java:363"$1$"			for (int i = 0; i < ourGenerics.length; i++) {"
"ResolvableType.java:364"$1$"				if (!ourGenerics[i].isAssignableFrom(typeGenerics[i], matchedBefore)) {"
"ResolvableType.java:365"$1$"					return false;"
"ResolvableType.java:366"$1$"				}"
"ResolvableType.java:367"$0$"			}"
"ResolvableType.java:368"$0$"		}"
"ResolvableType.java:369"$0$""
"ResolvableType.java:370"$0$"		return true;"
"ResolvableType.java:371"$0$"	}"
"ResolvableType.java:372"$0$""
"ResolvableType.java:373"$0$"	/**"
"ResolvableType.java:374"$1$"	 * Return {@code true} if this type resolves to a Class that represents an array."
"ResolvableType.java:375"$0$"	 * @see #getComponentType()"
"ResolvableType.java:376"$0$"	 */"
"ResolvableType.java:377"$1$"	public boolean isArray() {"
"ResolvableType.java:378"$1$"		if (this == NONE) {"
"ResolvableType.java:379"$1$"			return false;"
"ResolvableType.java:380"$1$"		}"
"ResolvableType.java:381"$0$"		return ((this.type instanceof Class && ((Class<?>) this.type).isArray()) ||"
"ResolvableType.java:382"$0$"				this.type instanceof GenericArrayType || resolveType().isArray());"
"ResolvableType.java:383"$0$"	}"
"ResolvableType.java:384"$0$""
"ResolvableType.java:385"$0$"	/**"
"ResolvableType.java:386"$0$"	 * Return the ResolvableType representing the component type of the array or"
"ResolvableType.java:387"$1$"	 * {@link #NONE} if this type does not represent an array."
"ResolvableType.java:388"$0$"	 * @see #isArray()"
"ResolvableType.java:389"$0$"	 */"
"ResolvableType.java:390"$1$"	public ResolvableType getComponentType() {"
"ResolvableType.java:391"$1$"		if (this == NONE) {"
"ResolvableType.java:392"$1$"			return NONE;"
"ResolvableType.java:393"$1$"		}"
"ResolvableType.java:394"$1$"		if (this.componentType != null) {"
"ResolvableType.java:395"$1$"			return this.componentType;"
"ResolvableType.java:396"$1$"		}"
"ResolvableType.java:397"$1$"		if (this.type instanceof Class) {"
"ResolvableType.java:398"$1$"			Class<?> componentType = ((Class<?>) this.type).getComponentType();"
"ResolvableType.java:399"$1$"			return forType(componentType, this.variableResolver);"
"ResolvableType.java:400"$1$"		}"
"ResolvableType.java:401"$1$"		if (this.type instanceof GenericArrayType) {"
"ResolvableType.java:402"$1$"			return forType(((GenericArrayType) this.type).getGenericComponentType(), this.variableResolver);"
"ResolvableType.java:403"$1$"		}"
"ResolvableType.java:404"$0$"		return resolveType().getComponentType();"
"ResolvableType.java:405"$0$"	}"
"ResolvableType.java:406"$0$""
"ResolvableType.java:407"$0$"	/**"
"ResolvableType.java:408"$1$"	 * Convenience method to return this type as a resolvable {@link Collection} type."
"ResolvableType.java:409"$1$"	 * Returns {@link #NONE} if this type does not implement or extend"
"ResolvableType.java:410"$1$"	 * {@link Collection}."
"ResolvableType.java:411"$0$"	 * @see #as(Class)"
"ResolvableType.java:412"$0$"	 * @see #asMap()"
"ResolvableType.java:413"$0$"	 */"
"ResolvableType.java:414"$1$"	public ResolvableType asCollection() {"
"ResolvableType.java:415"$1$"		return as(Collection.class);"
"ResolvableType.java:416"$1$"	}"
"ResolvableType.java:417"$0$""
"ResolvableType.java:418"$0$"	/**"
"ResolvableType.java:419"$1$"	 * Convenience method to return this type as a resolvable {@link Map} type."
"ResolvableType.java:420"$1$"	 * Returns {@link #NONE} if this type does not implement or extend"
"ResolvableType.java:421"$1$"	 * {@link Map}."
"ResolvableType.java:422"$0$"	 * @see #as(Class)"
"ResolvableType.java:423"$0$"	 * @see #asCollection()"
"ResolvableType.java:424"$0$"	 */"
"ResolvableType.java:425"$1$"	public ResolvableType asMap() {"
"ResolvableType.java:426"$1$"		return as(Map.class);"
"ResolvableType.java:427"$1$"	}"
"ResolvableType.java:428"$0$""
"ResolvableType.java:429"$0$"	/**"
"ResolvableType.java:430"$1$"	 * Return this type as a {@link ResolvableType} of the specified class. Searches"
"ResolvableType.java:431"$1$"	 * {@link #getSuperType() supertype} and {@link #getInterfaces() interface}"
"ResolvableType.java:432"$1$"	 * hierarchies to find a match, returning {@link #NONE} if this type does not"
"ResolvableType.java:433"$0$"	 * implement or extend the specified class."
"ResolvableType.java:434"$0$"	 * @param type the required type (typically narrowed)"
"ResolvableType.java:435"$1$"	 * @return a {@link ResolvableType} representing this object as the specified"
"ResolvableType.java:436"$1$"	 * type, or {@link #NONE} if not resolvable as that type"
"ResolvableType.java:437"$0$"	 * @see #asCollection()"
"ResolvableType.java:438"$0$"	 * @see #asMap()"
"ResolvableType.java:439"$0$"	 * @see #getSuperType()"
"ResolvableType.java:440"$0$"	 * @see #getInterfaces()"
"ResolvableType.java:441"$0$"	 */"
"ResolvableType.java:442"$1$"	public ResolvableType as(Class<?> type) {"
"ResolvableType.java:443"$1$"		if (this == NONE) {"
"ResolvableType.java:444"$1$"			return NONE;"
"ResolvableType.java:445"$1$"		}"
"ResolvableType.java:446"$0$"		Class<?> resolved = resolve();"
"ResolvableType.java:447"$1$"		if (resolved == null || resolved == type) {"
"ResolvableType.java:448"$1$"			return this;"
"ResolvableType.java:449"$1$"		}"
"ResolvableType.java:450"$1$"		for (ResolvableType interfaceType : getInterfaces()) {"
"ResolvableType.java:451"$1$"			ResolvableType interfaceAsType = interfaceType.as(type);"
"ResolvableType.java:452"$1$"			if (interfaceAsType != NONE) {"
"ResolvableType.java:453"$1$"				return interfaceAsType;"
"ResolvableType.java:454"$1$"			}"
"ResolvableType.java:455"$0$"		}"
"ResolvableType.java:456"$0$"		return getSuperType().as(type);"
"ResolvableType.java:457"$0$"	}"
"ResolvableType.java:458"$0$""
"ResolvableType.java:459"$0$"	/**"
"ResolvableType.java:460"$1$"	 * Return a {@link ResolvableType} representing the direct supertype of this type."
"ResolvableType.java:461"$1$"	 * If no supertype is available this method returns {@link #NONE}."
"ResolvableType.java:462"$1$"	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}."
"ResolvableType.java:463"$0$"	 * @see #getInterfaces()"
"ResolvableType.java:464"$0$"	 */"
"ResolvableType.java:465"$1$"	public ResolvableType getSuperType() {"
"ResolvableType.java:466"$1$"		Class<?> resolved = resolve();"
"ResolvableType.java:467"$1$"		if (resolved == null || resolved.getGenericSuperclass() == null) {"
"ResolvableType.java:468"$1$"			return NONE;"
"ResolvableType.java:469"$1$"		}"
"ResolvableType.java:470"$0$"		ResolvableType superType = this.superType;"
"ResolvableType.java:471"$1$"		if (superType == null) {"
"ResolvableType.java:472"$1$"			superType = forType(resolved.getGenericSuperclass(), this);"
"ResolvableType.java:473"$1$"			this.superType = superType;"
"ResolvableType.java:474"$1$"		}"
"ResolvableType.java:475"$0$"		return superType;"
"ResolvableType.java:476"$0$"	}"
"ResolvableType.java:477"$0$""
"ResolvableType.java:478"$0$"	/**"
"ResolvableType.java:479"$1$"	 * Return a {@link ResolvableType} array representing the direct interfaces"
"ResolvableType.java:480"$0$"	 * implemented by this type. If this type does not implement any interfaces an"
"ResolvableType.java:481"$0$"	 * empty array is returned."
"ResolvableType.java:482"$1$"	 * <p>Note: The resulting {@link ResolvableType} instances may not be {@link Serializable}."
"ResolvableType.java:483"$0$"	 * @see #getSuperType()"
"ResolvableType.java:484"$0$"	 */"
"ResolvableType.java:485"$1$"	public ResolvableType[] getInterfaces() {"
"ResolvableType.java:486"$1$"		Class<?> resolved = resolve();"
"ResolvableType.java:487"$1$"		if (resolved == null) {"
"ResolvableType.java:488"$1$"			return EMPTY_TYPES_ARRAY;"
"ResolvableType.java:489"$1$"		}"
"ResolvableType.java:490"$0$"		ResolvableType[] interfaces = this.interfaces;"
"ResolvableType.java:491"$1$"		if (interfaces == null) {"
"ResolvableType.java:492"$1$"			Type[] genericIfcs = resolved.getGenericInterfaces();"
"ResolvableType.java:493"$1$"			interfaces = new ResolvableType[genericIfcs.length];"
"ResolvableType.java:494"$1$"			for (int i = 0; i < genericIfcs.length; i++) {"
"ResolvableType.java:495"$1$"				interfaces[i] = forType(genericIfcs[i], this);"
"ResolvableType.java:496"$1$"			}"
"ResolvableType.java:497"$0$"			this.interfaces = interfaces;"
"ResolvableType.java:498"$0$"		}"
"ResolvableType.java:499"$0$"		return interfaces;"
"ResolvableType.java:500"$0$"	}"
"ResolvableType.java:501"$0$""
"ResolvableType.java:502"$0$"	/**"
"ResolvableType.java:503"$1$"	 * Return {@code true} if this type contains generic parameters."
"ResolvableType.java:504"$0$"	 * @see #getGeneric(int...)"
"ResolvableType.java:505"$0$"	 * @see #getGenerics()"
"ResolvableType.java:506"$0$"	 */"
"ResolvableType.java:507"$1$"	public boolean hasGenerics() {"
"ResolvableType.java:508"$1$"		return (getGenerics().length > 0);"
"ResolvableType.java:509"$1$"	}"
"ResolvableType.java:510"$0$""
"ResolvableType.java:511"$0$"	/**"
"ResolvableType.java:512"$1$"	 * Return {@code true} if this type contains unresolvable generics only,"
"ResolvableType.java:513"$0$"	 * that is, no substitute for any of its declared type variables."
"ResolvableType.java:514"$0$"	 */"
"ResolvableType.java:515"$1$"	boolean isEntirelyUnresolvable() {"
"ResolvableType.java:516"$1$"		if (this == NONE) {"
"ResolvableType.java:517"$1$"			return false;"
"ResolvableType.java:518"$1$"		}"
"ResolvableType.java:519"$0$"		ResolvableType[] generics = getGenerics();"
"ResolvableType.java:520"$1$"		for (ResolvableType generic : generics) {"
"ResolvableType.java:521"$1$"			if (!generic.isUnresolvableTypeVariable() && !generic.isWildcardWithoutBounds()) {"
"ResolvableType.java:522"$1$"				return false;"
"ResolvableType.java:523"$1$"			}"
"ResolvableType.java:524"$0$"		}"
"ResolvableType.java:525"$0$"		return true;"
"ResolvableType.java:526"$0$"	}"
"ResolvableType.java:527"$0$""
"ResolvableType.java:528"$0$"	/**"
"ResolvableType.java:529"$0$"	 * Determine whether the underlying type has any unresolvable generics:"
"ResolvableType.java:530"$0$"	 * either through an unresolvable type variable on the type itself"
"ResolvableType.java:531"$0$"	 * or through implementing a generic interface in a raw fashion,"
"ResolvableType.java:532"$0$"	 * i.e. without substituting that interface's type variables."
"ResolvableType.java:533"$1$"	 * The result will be {@code true} only in those two scenarios."
"ResolvableType.java:534"$0$"	 */"
"ResolvableType.java:535"$1$"	public boolean hasUnresolvableGenerics() {"
"ResolvableType.java:536"$1$"		if (this == NONE) {"
"ResolvableType.java:537"$1$"			return false;"
"ResolvableType.java:538"$1$"		}"
"ResolvableType.java:539"$0$"		ResolvableType[] generics = getGenerics();"
"ResolvableType.java:540"$1$"		for (ResolvableType generic : generics) {"
"ResolvableType.java:541"$1$"			if (generic.isUnresolvableTypeVariable() || generic.isWildcardWithoutBounds()) {"
"ResolvableType.java:542"$1$"				return true;"
"ResolvableType.java:543"$1$"			}"
"ResolvableType.java:544"$0$"		}"
"ResolvableType.java:545"$0$"		Class<?> resolved = resolve();"
"ResolvableType.java:546"$1$"		if (resolved != null) {"
"ResolvableType.java:547"$1$"			for (Type genericInterface : resolved.getGenericInterfaces()) {"
"ResolvableType.java:548"$1$"				if (genericInterface instanceof Class) {"
"ResolvableType.java:549"$1$"					if (forClass((Class<?>) genericInterface).hasGenerics()) {"
"ResolvableType.java:550"$1$"						return true;"
"ResolvableType.java:551"$1$"					}"
"ResolvableType.java:552"$0$"				}"
"ResolvableType.java:553"$0$"			}"
"ResolvableType.java:554"$0$"			return getSuperType().hasUnresolvableGenerics();"
"ResolvableType.java:555"$0$"		}"
"ResolvableType.java:556"$0$"		return false;"
"ResolvableType.java:557"$0$"	}"
"ResolvableType.java:558"$0$""
"ResolvableType.java:559"$0$"	/**"
"ResolvableType.java:560"$0$"	 * Determine whether the underlying type is a type variable that"
"ResolvableType.java:561"$0$"	 * cannot be resolved through the associated variable resolver."
"ResolvableType.java:562"$0$"	 */"
"ResolvableType.java:563"$1$"	private boolean isUnresolvableTypeVariable() {"
"ResolvableType.java:564"$1$"		if (this.type instanceof TypeVariable) {"
"ResolvableType.java:565"$1$"			if (this.variableResolver == null) {"
"ResolvableType.java:566"$1$"				return true;"
"ResolvableType.java:567"$1$"			}"
"ResolvableType.java:568"$0$"			TypeVariable<?> variable = (TypeVariable<?>) this.type;"
"ResolvableType.java:569"$0$"			ResolvableType resolved = this.variableResolver.resolveVariable(variable);"
"ResolvableType.java:570"$1$"			if (resolved == null || resolved.isUnresolvableTypeVariable()) {"
"ResolvableType.java:571"$1$"				return true;"
"ResolvableType.java:572"$1$"			}"
"ResolvableType.java:573"$0$"		}"
"ResolvableType.java:574"$0$"		return false;"
"ResolvableType.java:575"$0$"	}"
"ResolvableType.java:576"$0$""
"ResolvableType.java:577"$0$"	/**"
"ResolvableType.java:578"$0$"	 * Determine whether the underlying type represents a wildcard"
"ResolvableType.java:579"$1$"	 * without specific bounds (i.e., equal to {@code ? extends Object})."
"ResolvableType.java:580"$0$"	 */"
"ResolvableType.java:581"$1$"	private boolean isWildcardWithoutBounds() {"
"ResolvableType.java:582"$1$"		if (this.type instanceof WildcardType) {"
"ResolvableType.java:583"$1$"			WildcardType wt = (WildcardType) this.type;"
"ResolvableType.java:584"$1$"			if (wt.getLowerBounds().length == 0) {"
"ResolvableType.java:585"$1$"				Type[] upperBounds = wt.getUpperBounds();"
"ResolvableType.java:586"$1$"				if (upperBounds.length == 0 || (upperBounds.length == 1 && Object.class == upperBounds[0])) {"
"ResolvableType.java:587"$1$"					return true;"
"ResolvableType.java:588"$1$"				}"
"ResolvableType.java:589"$0$"			}"
"ResolvableType.java:590"$0$"		}"
"ResolvableType.java:591"$0$"		return false;"
"ResolvableType.java:592"$0$"	}"
"ResolvableType.java:593"$0$""
"ResolvableType.java:594"$0$"	/**"
"ResolvableType.java:595"$1$"	 * Return a {@link ResolvableType} for the specified nesting level."
"ResolvableType.java:596"$1$"	 * See {@link #getNested(int, Map)} for details."
"ResolvableType.java:597"$0$"	 * @param nestingLevel the nesting level"
"ResolvableType.java:598"$1$"	 * @return the {@link ResolvableType} type, or {@code #NONE}"
"ResolvableType.java:599"$0$"	 */"
"ResolvableType.java:600"$1$"	public ResolvableType getNested(int nestingLevel) {"
"ResolvableType.java:601"$1$"		return getNested(nestingLevel, null);"
"ResolvableType.java:602"$1$"	}"
"ResolvableType.java:603"$0$""
"ResolvableType.java:604"$0$"	/**"
"ResolvableType.java:605"$1$"	 * Return a {@link ResolvableType} for the specified nesting level."
"ResolvableType.java:606"$0$"	 * <p>The nesting level refers to the specific generic parameter that should be returned."
"ResolvableType.java:607"$0$"	 * A nesting level of 1 indicates this type; 2 indicates the first nested generic;"
"ResolvableType.java:608"$1$"	 * 3 the second; and so on. For example, given {@code List<Set<Integer>>} level 1 refers"
"ResolvableType.java:609"$1$"	 * to the {@code List}, level 2 the {@code Set}, and level 3 the {@code Integer}."
"ResolvableType.java:610"$1$"	 * <p>The {@code typeIndexesPerLevel} map can be used to reference a specific generic"
"ResolvableType.java:611"$1$"	 * for the given level. For example, an index of 0 would refer to a {@code Map} key;"
"ResolvableType.java:612"$0$"	 * whereas, 1 would refer to the value. If the map does not contain a value for a"
"ResolvableType.java:613"$1$"	 * specific level the last generic will be used (e.g. a {@code Map} value)."
"ResolvableType.java:614"$0$"	 * <p>Nesting levels may also apply to array types; for example given"
"ResolvableType.java:615"$1$"	 * {@code String[]}, a nesting level of 2 refers to {@code String}."
"ResolvableType.java:616"$1$"	 * <p>If a type does not {@link #hasGenerics() contain} generics the"
"ResolvableType.java:617"$1$"	 * {@link #getSuperType() supertype} hierarchy will be considered."
"ResolvableType.java:618"$0$"	 * @param nestingLevel the required nesting level, indexed from 1 for the"
"ResolvableType.java:619"$0$"	 * current type, 2 for the first nested generic, 3 for the second and so on"
"ResolvableType.java:620"$0$"	 * @param typeIndexesPerLevel a map containing the generic index for a given"
"ResolvableType.java:621"$1$"	 * nesting level (may be {@code null})"
"ResolvableType.java:622"$1$"	 * @return a {@link ResolvableType} for the nested level, or {@link #NONE}"
"ResolvableType.java:623"$0$"	 */"
"ResolvableType.java:624"$1$"	public ResolvableType getNested(int nestingLevel, @Nullable Map<Integer, Integer> typeIndexesPerLevel) {"
"ResolvableType.java:625"$1$"		ResolvableType result = this;"
"ResolvableType.java:626"$1$"		for (int i = 2; i <= nestingLevel; i++) {"
"ResolvableType.java:627"$1$"			if (result.isArray()) {"
"ResolvableType.java:628"$1$"				result = result.getComponentType();"
"ResolvableType.java:629"$1$"			}"
"ResolvableType.java:630"$1$"			else {"
"ResolvableType.java:631"$0$"				// Handle derived types"
"ResolvableType.java:632"$1$"				while (result != ResolvableType.NONE && !result.hasGenerics()) {"
"ResolvableType.java:633"$1$"					result = result.getSuperType();"
"ResolvableType.java:634"$1$"				}"
"ResolvableType.java:635"$0$"				Integer index = (typeIndexesPerLevel != null ? typeIndexesPerLevel.get(i) : null);"
"ResolvableType.java:636"$0$"				index = (index == null ? result.getGenerics().length - 1 : index);"
"ResolvableType.java:637"$0$"				result = result.getGeneric(index);"
"ResolvableType.java:638"$0$"			}"
"ResolvableType.java:639"$0$"		}"
"ResolvableType.java:640"$0$"		return result;"
"ResolvableType.java:641"$0$"	}"
"ResolvableType.java:642"$0$""
"ResolvableType.java:643"$0$"	/**"
"ResolvableType.java:644"$1$"	 * Return a {@link ResolvableType} representing the generic parameter for the"
"ResolvableType.java:645"$0$"	 * given indexes. Indexes are zero based; for example given the type"
"ResolvableType.java:646"$1$"	 * {@code Map<Integer, List<String>>}, {@code getGeneric(0)} will access the"
"ResolvableType.java:647"$1$"	 * {@code Integer}. Nested generics can be accessed by specifying multiple indexes;"
"ResolvableType.java:648"$1$"	 * for example {@code getGeneric(1, 0)} will access the {@code String} from the"
"ResolvableType.java:649"$1$"	 * nested {@code List}. For convenience, if no indexes are specified the first"
"ResolvableType.java:650"$0$"	 * generic is returned."
"ResolvableType.java:651"$1$"	 * <p>If no generic is available at the specified indexes {@link #NONE} is returned."
"ResolvableType.java:652"$0$"	 * @param indexes the indexes that refer to the generic parameter"
"ResolvableType.java:653"$0$"	 * (may be omitted to return the first generic)"
"ResolvableType.java:654"$1$"	 * @return a {@link ResolvableType} for the specified generic, or {@link #NONE}"
"ResolvableType.java:655"$0$"	 * @see #hasGenerics()"
"ResolvableType.java:656"$0$"	 * @see #getGenerics()"
"ResolvableType.java:657"$0$"	 * @see #resolveGeneric(int...)"
"ResolvableType.java:658"$0$"	 * @see #resolveGenerics()"
"ResolvableType.java:659"$0$"	 */"
"ResolvableType.java:660"$1$"	public ResolvableType getGeneric(@Nullable int... indexes) {"
"ResolvableType.java:661"$1$"		ResolvableType[] generics = getGenerics();"
"ResolvableType.java:662"$1$"		if (indexes == null || indexes.length == 0) {"
"ResolvableType.java:663"$1$"			return (generics.length == 0 ? NONE : generics[0]);"
"ResolvableType.java:664"$1$"		}"
"ResolvableType.java:665"$0$"		ResolvableType generic = this;"
"ResolvableType.java:666"$1$"		for (int index : indexes) {"
"ResolvableType.java:667"$1$"			generics = generic.getGenerics();"
"ResolvableType.java:668"$1$"			if (index < 0 || index >= generics.length) {"
"ResolvableType.java:669"$1$"				return NONE;"
"ResolvableType.java:670"$1$"			}"
"ResolvableType.java:671"$0$"			generic = generics[index];"
"ResolvableType.java:672"$0$"		}"
"ResolvableType.java:673"$0$"		return generic;"
"ResolvableType.java:674"$0$"	}"
"ResolvableType.java:675"$0$""
"ResolvableType.java:676"$0$"	/**"
"ResolvableType.java:677"$1$"	 * Return an array of {@link ResolvableType ResolvableTypes} representing the generic parameters of"
"ResolvableType.java:678"$0$"	 * this type. If no generics are available an empty array is returned. If you need to"
"ResolvableType.java:679"$1$"	 * access a specific generic consider using the {@link #getGeneric(int...)} method as"
"ResolvableType.java:680"$0$"	 * it allows access to nested generics and protects against"
"ResolvableType.java:681"$1$"	 * {@code IndexOutOfBoundsExceptions}."
"ResolvableType.java:682"$1$"	 * @return an array of {@link ResolvableType ResolvableTypes} representing the generic parameters"
"ResolvableType.java:683"$1$"	 * (never {@code null})"
"ResolvableType.java:684"$0$"	 * @see #hasGenerics()"
"ResolvableType.java:685"$0$"	 * @see #getGeneric(int...)"
"ResolvableType.java:686"$0$"	 * @see #resolveGeneric(int...)"
"ResolvableType.java:687"$0$"	 * @see #resolveGenerics()"
"ResolvableType.java:688"$0$"	 */"
"ResolvableType.java:689"$1$"	public ResolvableType[] getGenerics() {"
"ResolvableType.java:690"$1$"		if (this == NONE) {"
"ResolvableType.java:691"$1$"			return EMPTY_TYPES_ARRAY;"
"ResolvableType.java:692"$1$"		}"
"ResolvableType.java:693"$0$"		ResolvableType[] generics = this.generics;"
"ResolvableType.java:694"$1$"		if (generics == null) {"
"ResolvableType.java:695"$1$"			if (this.type instanceof Class) {"
"ResolvableType.java:696"$1$"				Type[] typeParams = ((Class<?>) this.type).getTypeParameters();"
"ResolvableType.java:697"$1$"				generics = new ResolvableType[typeParams.length];"
"ResolvableType.java:698"$1$"				for (int i = 0; i < generics.length; i++) {"
"ResolvableType.java:699"$1$"					generics[i] = ResolvableType.forType(typeParams[i], this);"
"ResolvableType.java:700"$1$"				}"
"ResolvableType.java:701"$0$"			}"
"ResolvableType.java:702"$1$"			else if (this.type instanceof ParameterizedType) {"
"ResolvableType.java:703"$1$"				Type[] actualTypeArguments = ((ParameterizedType) this.type).getActualTypeArguments();"
"ResolvableType.java:704"$1$"				generics = new ResolvableType[actualTypeArguments.length];"
"ResolvableType.java:705"$1$"				for (int i = 0; i < actualTypeArguments.length; i++) {"
"ResolvableType.java:706"$1$"					generics[i] = forType(actualTypeArguments[i], this.variableResolver);"
"ResolvableType.java:707"$1$"				}"
"ResolvableType.java:708"$0$"			}"
"ResolvableType.java:709"$1$"			else {"
"ResolvableType.java:710"$1$"				generics = resolveType().getGenerics();"
"ResolvableType.java:711"$1$"			}"
"ResolvableType.java:712"$0$"			this.generics = generics;"
"ResolvableType.java:713"$0$"		}"
"ResolvableType.java:714"$0$"		return generics;"
"ResolvableType.java:715"$0$"	}"
"ResolvableType.java:716"$0$""
"ResolvableType.java:717"$0$"	/**"
"ResolvableType.java:718"$1$"	 * Convenience method that will {@link #getGenerics() get} and"
"ResolvableType.java:719"$1$"	 * {@link #resolve() resolve} generic parameters."
"ResolvableType.java:720"$0$"	 * @return an array of resolved generic parameters (the resulting array"
"ResolvableType.java:721"$1$"	 * will never be {@code null}, but it may contain {@code null} elements})"
"ResolvableType.java:722"$0$"	 * @see #getGenerics()"
"ResolvableType.java:723"$0$"	 * @see #resolve()"
"ResolvableType.java:724"$0$"	 */"
"ResolvableType.java:725"$1$"	public Class<?>[] resolveGenerics() {"
"ResolvableType.java:726"$1$"		ResolvableType[] generics = getGenerics();"
"ResolvableType.java:727"$1$"		Class<?>[] resolvedGenerics = new Class<?>[generics.length];"
"ResolvableType.java:728"$1$"		for (int i = 0; i < generics.length; i++) {"
"ResolvableType.java:729"$1$"			resolvedGenerics[i] = generics[i].resolve();"
"ResolvableType.java:730"$1$"		}"
"ResolvableType.java:731"$0$"		return resolvedGenerics;"
"ResolvableType.java:732"$0$"	}"
"ResolvableType.java:733"$0$""
"ResolvableType.java:734"$0$"	/**"
"ResolvableType.java:735"$1$"	 * Convenience method that will {@link #getGenerics() get} and {@link #resolve()"
"ResolvableType.java:736"$1$"	 * resolve} generic parameters, using the specified {@code fallback} if any type"
"ResolvableType.java:737"$0$"	 * cannot be resolved."
"ResolvableType.java:738"$0$"	 * @param fallback the fallback class to use if resolution fails"
"ResolvableType.java:739"$0$"	 * @return an array of resolved generic parameters"
"ResolvableType.java:740"$0$"	 * @see #getGenerics()"
"ResolvableType.java:741"$0$"	 * @see #resolve()"
"ResolvableType.java:742"$0$"	 */"
"ResolvableType.java:743"$1$"	public Class<?>[] resolveGenerics(Class<?> fallback) {"
"ResolvableType.java:744"$1$"		ResolvableType[] generics = getGenerics();"
"ResolvableType.java:745"$1$"		Class<?>[] resolvedGenerics = new Class<?>[generics.length];"
"ResolvableType.java:746"$1$"		for (int i = 0; i < generics.length; i++) {"
"ResolvableType.java:747"$1$"			resolvedGenerics[i] = generics[i].resolve(fallback);"
"ResolvableType.java:748"$1$"		}"
"ResolvableType.java:749"$0$"		return resolvedGenerics;"
"ResolvableType.java:750"$0$"	}"
"ResolvableType.java:751"$0$""
"ResolvableType.java:752"$0$"	/**"
"ResolvableType.java:753"$1$"	 * Convenience method that will {@link #getGeneric(int...) get} and"
"ResolvableType.java:754"$1$"	 * {@link #resolve() resolve} a specific generic parameters."
"ResolvableType.java:755"$0$"	 * @param indexes the indexes that refer to the generic parameter"
"ResolvableType.java:756"$0$"	 * (may be omitted to return the first generic)"
"ResolvableType.java:757"$1$"	 * @return a resolved {@link Class} or {@code null}"
"ResolvableType.java:758"$0$"	 * @see #getGeneric(int...)"
"ResolvableType.java:759"$0$"	 * @see #resolve()"
"ResolvableType.java:760"$0$"	 */"
"ResolvableType.java:761"$0$"	@Nullable"
"ResolvableType.java:762"$1$"	public Class<?> resolveGeneric(int... indexes) {"
"ResolvableType.java:763"$1$"		return getGeneric(indexes).resolve();"
"ResolvableType.java:764"$1$"	}"
"ResolvableType.java:765"$0$""
"ResolvableType.java:766"$0$"	/**"
"ResolvableType.java:767"$1$"	 * Resolve this type to a {@link java.lang.Class}, returning {@code null}"
"ResolvableType.java:768"$0$"	 * if the type cannot be resolved. This method will consider bounds of"
"ResolvableType.java:769"$1$"	 * {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if"
"ResolvableType.java:770"$1$"	 * direct resolution fails; however, bounds of {@code Object.class} will be ignored."
"ResolvableType.java:771"$1$"	 * <p>If this method returns a non-null {@code Class} and {@link #hasGenerics()}"
"ResolvableType.java:772"$1$"	 * returns {@code false}, the given type effectively wraps a plain {@code Class},"
"ResolvableType.java:773"$1$"	 * allowing for plain {@code Class} processing if desirable."
"ResolvableType.java:774"$1$"	 * @return the resolved {@link Class}, or {@code null} if not resolvable"
"ResolvableType.java:775"$0$"	 * @see #resolve(Class)"
"ResolvableType.java:776"$0$"	 * @see #resolveGeneric(int...)"
"ResolvableType.java:777"$0$"	 * @see #resolveGenerics()"
"ResolvableType.java:778"$0$"	 */"
"ResolvableType.java:779"$0$"	@Nullable"
"ResolvableType.java:780"$1$"	public Class<?> resolve() {"
"ResolvableType.java:781"$1$"		return this.resolved;"
"ResolvableType.java:782"$1$"	}"
"ResolvableType.java:783"$0$""
"ResolvableType.java:784"$0$"	/**"
"ResolvableType.java:785"$1$"	 * Resolve this type to a {@link java.lang.Class}, returning the specified"
"ResolvableType.java:786"$1$"	 * {@code fallback} if the type cannot be resolved. This method will consider bounds"
"ResolvableType.java:787"$1$"	 * of {@link TypeVariable TypeVariables} and {@link WildcardType WildcardTypes} if"
"ResolvableType.java:788"$1$"	 * direct resolution fails; however, bounds of {@code Object.class} will be ignored."
"ResolvableType.java:789"$0$"	 * @param fallback the fallback class to use if resolution fails"
"ResolvableType.java:790"$1$"	 * @return the resolved {@link Class} or the {@code fallback}"
"ResolvableType.java:791"$0$"	 * @see #resolve()"
"ResolvableType.java:792"$0$"	 * @see #resolveGeneric(int...)"
"ResolvableType.java:793"$0$"	 * @see #resolveGenerics()"
"ResolvableType.java:794"$0$"	 */"
"ResolvableType.java:795"$1$"	public Class<?> resolve(Class<?> fallback) {"
"ResolvableType.java:796"$1$"		return (this.resolved != null ? this.resolved : fallback);"
"ResolvableType.java:797"$1$"	}"
"ResolvableType.java:798"$0$""
"ResolvableType.java:799"$0$"	@Nullable"
"ResolvableType.java:800"$1$"	private Class<?> resolveClass() {"
"ResolvableType.java:801"$1$"		if (this.type == EmptyType.INSTANCE) {"
"ResolvableType.java:802"$1$"			return null;"
"ResolvableType.java:803"$1$"		}"
"ResolvableType.java:804"$1$"		if (this.type instanceof Class) {"
"ResolvableType.java:805"$1$"			return (Class<?>) this.type;"
"ResolvableType.java:806"$1$"		}"
"ResolvableType.java:807"$1$"		if (this.type instanceof GenericArrayType) {"
"ResolvableType.java:808"$1$"			Class<?> resolvedComponent = getComponentType().resolve();"
"ResolvableType.java:809"$1$"			return (resolvedComponent != null ? Array.newInstance(resolvedComponent, 0).getClass() : null);"
"ResolvableType.java:810"$1$"		}"
"ResolvableType.java:811"$0$"		return resolveType().resolve();"
"ResolvableType.java:812"$0$"	}"
"ResolvableType.java:813"$0$""
"ResolvableType.java:814"$0$"	/**"
"ResolvableType.java:815"$1$"	 * Resolve this type by a single level, returning the resolved value or {@link #NONE}."
"ResolvableType.java:816"$1$"	 * <p>Note: The returned {@link ResolvableType} should only be used as an intermediary"
"ResolvableType.java:817"$0$"	 * as it cannot be serialized."
"ResolvableType.java:818"$0$"	 */"
"ResolvableType.java:819"$1$"	ResolvableType resolveType() {"
"ResolvableType.java:820"$1$"		if (this.type instanceof ParameterizedType) {"
"ResolvableType.java:821"$1$"			return forType(((ParameterizedType) this.type).getRawType(), this.variableResolver);"
"ResolvableType.java:822"$1$"		}"
"ResolvableType.java:823"$1$"		if (this.type instanceof WildcardType) {"
"ResolvableType.java:824"$1$"			Type resolved = resolveBounds(((WildcardType) this.type).getUpperBounds());"
"ResolvableType.java:825"$1$"			if (resolved == null) {"
"ResolvableType.java:826"$1$"				resolved = resolveBounds(((WildcardType) this.type).getLowerBounds());"
"ResolvableType.java:827"$1$"			}"
"ResolvableType.java:828"$0$"			return forType(resolved, this.variableResolver);"
"ResolvableType.java:829"$0$"		}"
"ResolvableType.java:830"$1$"		if (this.type instanceof TypeVariable) {"
"ResolvableType.java:831"$1$"			TypeVariable<?> variable = (TypeVariable<?>) this.type;"
"ResolvableType.java:832"$0$"			// Try default variable resolution"
"ResolvableType.java:833"$1$"			if (this.variableResolver != null) {"
"ResolvableType.java:834"$1$"				ResolvableType resolved = this.variableResolver.resolveVariable(variable);"
"ResolvableType.java:835"$1$"				if (resolved != null) {"
"ResolvableType.java:836"$1$"					return resolved;"
"ResolvableType.java:837"$1$"				}"
"ResolvableType.java:838"$0$"			}"
"ResolvableType.java:839"$0$"			// Fallback to bounds"
"ResolvableType.java:840"$0$"			return forType(resolveBounds(variable.getBounds()), this.variableResolver);"
"ResolvableType.java:841"$0$"		}"
"ResolvableType.java:842"$0$"		return NONE;"
"ResolvableType.java:843"$0$"	}"
"ResolvableType.java:844"$0$""
"ResolvableType.java:845"$0$"	@Nullable"
"ResolvableType.java:846"$1$"	private Type resolveBounds(Type[] bounds) {"
"ResolvableType.java:847"$1$"		if (bounds.length == 0 || bounds[0] == Object.class) {"
"ResolvableType.java:848"$1$"			return null;"
"ResolvableType.java:849"$1$"		}"
"ResolvableType.java:850"$0$"		return bounds[0];"
"ResolvableType.java:851"$0$"	}"
"ResolvableType.java:852"$0$""
"ResolvableType.java:853"$0$"	@Nullable"
"ResolvableType.java:854"$1$"	private ResolvableType resolveVariable(TypeVariable<?> variable) {"
"ResolvableType.java:855"$1$"		if (this.type instanceof TypeVariable) {"
"ResolvableType.java:856"$1$"			return resolveType().resolveVariable(variable);"
"ResolvableType.java:857"$1$"		}"
"ResolvableType.java:858"$1$"		if (this.type instanceof ParameterizedType) {"
"ResolvableType.java:859"$1$"			ParameterizedType parameterizedType = (ParameterizedType) this.type;"
"ResolvableType.java:860"$1$"			Class<?> resolved = resolve();"
"ResolvableType.java:861"$1$"			if (resolved == null) {"
"ResolvableType.java:862"$1$"				return null;"
"ResolvableType.java:863"$1$"			}"
"ResolvableType.java:864"$0$"			TypeVariable<?>[] variables = resolved.getTypeParameters();"
"ResolvableType.java:865"$1$"			for (int i = 0; i < variables.length; i++) {"
"ResolvableType.java:866"$1$"				if (ObjectUtils.nullSafeEquals(variables[i].getName(), variable.getName())) {"
"ResolvableType.java:867"$1$"					Type actualType = parameterizedType.getActualTypeArguments()[i];"
"ResolvableType.java:868"$1$"					return forType(actualType, this.variableResolver);"
"ResolvableType.java:869"$1$"				}"
"ResolvableType.java:870"$0$"			}"
"ResolvableType.java:871"$0$"			Type ownerType = parameterizedType.getOwnerType();"
"ResolvableType.java:872"$1$"			if (ownerType != null) {"
"ResolvableType.java:873"$1$"				return forType(ownerType, this.variableResolver).resolveVariable(variable);"
"ResolvableType.java:874"$1$"			}"
"ResolvableType.java:875"$0$"		}"
"ResolvableType.java:876"$1$"		if (this.type instanceof WildcardType) {"
"ResolvableType.java:877"$1$"			ResolvableType resolved = resolveType().resolveVariable(variable);"
"ResolvableType.java:878"$1$"			if (resolved != null) {"
"ResolvableType.java:879"$1$"				return resolved;"
"ResolvableType.java:880"$1$"			}"
"ResolvableType.java:881"$0$"		}"
"ResolvableType.java:882"$1$"		if (this.variableResolver != null) {"
"ResolvableType.java:883"$1$"			return this.variableResolver.resolveVariable(variable);"
"ResolvableType.java:884"$1$"		}"
"ResolvableType.java:885"$0$"		return null;"
"ResolvableType.java:886"$0$"	}"
"ResolvableType.java:887"$0$""
"ResolvableType.java:888"$0$""
"ResolvableType.java:889"$0$"	@Override"
"ResolvableType.java:890"$1$"	public boolean equals(@Nullable Object other) {"
"ResolvableType.java:891"$1$"		if (this == other) {"
"ResolvableType.java:892"$1$"			return true;"
"ResolvableType.java:893"$1$"		}"
"ResolvableType.java:894"$1$"		if (!(other instanceof ResolvableType)) {"
"ResolvableType.java:895"$1$"			return false;"
"ResolvableType.java:896"$1$"		}"
"ResolvableType.java:897"$0$""
"ResolvableType.java:898"$0$"		ResolvableType otherType = (ResolvableType) other;"
"ResolvableType.java:899"$1$"		if (!ObjectUtils.nullSafeEquals(this.type, otherType.type)) {"
"ResolvableType.java:900"$1$"			return false;"
"ResolvableType.java:901"$1$"		}"
"ResolvableType.java:902"$0$"		if (this.typeProvider != otherType.typeProvider &&"
"ResolvableType.java:903"$0$"				(this.typeProvider == null || otherType.typeProvider == null ||"
"ResolvableType.java:904"$1$"				!ObjectUtils.nullSafeEquals(this.typeProvider.getType(), otherType.typeProvider.getType()))) {"
"ResolvableType.java:905"$1$"			return false;"
"ResolvableType.java:906"$1$"		}"
"ResolvableType.java:907"$0$"		if (this.variableResolver != otherType.variableResolver &&"
"ResolvableType.java:908"$0$"				(this.variableResolver == null || otherType.variableResolver == null ||"
"ResolvableType.java:909"$1$"				!ObjectUtils.nullSafeEquals(this.variableResolver.getSource(), otherType.variableResolver.getSource()))) {"
"ResolvableType.java:910"$1$"			return false;"
"ResolvableType.java:911"$1$"		}"
"ResolvableType.java:912"$1$"		if (!ObjectUtils.nullSafeEquals(this.componentType, otherType.componentType)) {"
"ResolvableType.java:913"$1$"			return false;"
"ResolvableType.java:914"$1$"		}"
"ResolvableType.java:915"$0$"		return true;"
"ResolvableType.java:916"$0$"	}"
"ResolvableType.java:917"$0$""
"ResolvableType.java:918"$0$"	@Override"
"ResolvableType.java:919"$1$"	public int hashCode() {"
"ResolvableType.java:920"$1$"		return (this.hash != null ? this.hash : calculateHashCode());"
"ResolvableType.java:921"$1$"	}"
"ResolvableType.java:922"$0$""
"ResolvableType.java:923"$1$"	private int calculateHashCode() {"
"ResolvableType.java:924"$1$"		int hashCode = ObjectUtils.nullSafeHashCode(this.type);"
"ResolvableType.java:925"$1$"		if (this.typeProvider != null) {"
"ResolvableType.java:926"$1$"			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.typeProvider.getType());"
"ResolvableType.java:927"$1$"		}"
"ResolvableType.java:928"$1$"		if (this.variableResolver != null) {"
"ResolvableType.java:929"$1$"			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.variableResolver.getSource());"
"ResolvableType.java:930"$1$"		}"
"ResolvableType.java:931"$1$"		if (this.componentType != null) {"
"ResolvableType.java:932"$1$"			hashCode = 31 * hashCode + ObjectUtils.nullSafeHashCode(this.componentType);"
"ResolvableType.java:933"$1$"		}"
"ResolvableType.java:934"$0$"		return hashCode;"
"ResolvableType.java:935"$0$"	}"
"ResolvableType.java:936"$0$""
"ResolvableType.java:937"$0$"	/**"
"ResolvableType.java:938"$1$"	 * Adapts this {@link ResolvableType} to a {@link VariableResolver}."
"ResolvableType.java:939"$0$"	 */"
"ResolvableType.java:940"$0$"	@Nullable"
"ResolvableType.java:941"$1$"	VariableResolver asVariableResolver() {"
"ResolvableType.java:942"$1$"		if (this == NONE) {"
"ResolvableType.java:943"$1$"			return null;"
"ResolvableType.java:944"$1$"		}"
"ResolvableType.java:945"$0$"		return new DefaultVariableResolver(this);"
"ResolvableType.java:946"$0$"	}"
"ResolvableType.java:947"$0$""
"ResolvableType.java:948"$0$"	/**"
"ResolvableType.java:949"$1$"	 * Custom serialization support for {@link #NONE}."
"ResolvableType.java:950"$0$"	 */"
"ResolvableType.java:951"$1$"	private Object readResolve() {"
"ResolvableType.java:952"$1$"		return (this.type == EmptyType.INSTANCE ? NONE : this);"
"ResolvableType.java:953"$1$"	}"
"ResolvableType.java:954"$0$""
"ResolvableType.java:955"$0$"	/**"
"ResolvableType.java:956"$0$"	 * Return a String representation of this type in its fully resolved form"
"ResolvableType.java:957"$0$"	 * (including any generic parameters)."
"ResolvableType.java:958"$0$"	 */"
"ResolvableType.java:959"$0$"	@Override"
"ResolvableType.java:960"$1$"	public String toString() {"
"ResolvableType.java:961"$1$"		if (isArray()) {"
"ResolvableType.java:962"$1$"			return getComponentType() + ""[]"";"
"ResolvableType.java:963"$1$"		}"
"ResolvableType.java:964"$1$"		if (this.resolved == null) {"
"ResolvableType.java:965"$1$"			return ""?"";"
"ResolvableType.java:966"$1$"		}"
"ResolvableType.java:967"$1$"		if (this.type instanceof TypeVariable) {"
"ResolvableType.java:968"$1$"			TypeVariable<?> variable = (TypeVariable<?>) this.type;"
"ResolvableType.java:969"$1$"			if (this.variableResolver == null || this.variableResolver.resolveVariable(variable) == null) {"
"ResolvableType.java:970"$0$"				// Don't bother with variable boundaries for toString()..."
"ResolvableType.java:971"$0$"				// Can cause infinite recursions in case of self-references"
"ResolvableType.java:972"$1$"				return ""?"";"
"ResolvableType.java:973"$1$"			}"
"ResolvableType.java:974"$0$"		}"
"ResolvableType.java:975"$1$"		if (hasGenerics()) {"
"ResolvableType.java:976"$1$"			return this.resolved.getName() + '<' + StringUtils.arrayToDelimitedString(getGenerics(), "", "") + '>';"
"ResolvableType.java:977"$1$"		}"
"ResolvableType.java:978"$0$"		return this.resolved.getName();"
"ResolvableType.java:979"$0$"	}"
"ResolvableType.java:980"$0$""
"ResolvableType.java:981"$0$""
"ResolvableType.java:982"$0$"	// Factory methods"
"ResolvableType.java:983"$0$""
"ResolvableType.java:984"$0$"	/**"
"ResolvableType.java:985"$1$"	 * Return a {@link ResolvableType} for the specified {@link Class},"
"ResolvableType.java:986"$0$"	 * using the full generic type information for assignability checks."
"ResolvableType.java:987"$1$"	 * For example: {@code ResolvableType.forClass(MyArrayList.class)}."
"ResolvableType.java:988"$1$"	 * @param clazz the class to introspect ({@code null} is semantically"
"ResolvableType.java:989"$1$"	 * equivalent to {@code Object.class} for typical use cases here)"
"ResolvableType.java:990"$1$"	 * @return a {@link ResolvableType} for the specified class"
"ResolvableType.java:991"$0$"	 * @see #forClass(Class, Class)"
"ResolvableType.java:992"$0$"	 * @see #forClassWithGenerics(Class, Class...)"
"ResolvableType.java:993"$0$"	 */"
"ResolvableType.java:994"$1$"	public static ResolvableType forClass(@Nullable Class<?> clazz) {"
"ResolvableType.java:995"$1$"		return new ResolvableType(clazz);"
"ResolvableType.java:996"$1$"	}"
"ResolvableType.java:997"$0$""
"ResolvableType.java:998"$0$"	/**"
"ResolvableType.java:999"$1$"	 * Return a {@link ResolvableType} for the specified {@link Class},"
"ResolvableType.java:1000"$0$"	 * doing assignability checks against the raw class only (analogous to"
"ResolvableType.java:1001"$1$"	 * {@link Class#isAssignableFrom}, which this serves as a wrapper for."
"ResolvableType.java:1002"$1$"	 * For example: {@code ResolvableType.forRawClass(List.class)}."
"ResolvableType.java:1003"$1$"	 * @param clazz the class to introspect ({@code null} is semantically"
"ResolvableType.java:1004"$1$"	 * equivalent to {@code Object.class} for typical use cases here)"
"ResolvableType.java:1005"$1$"	 * @return a {@link ResolvableType} for the specified class"
"ResolvableType.java:1006"$0$"	 * @since 4.2"
"ResolvableType.java:1007"$0$"	 * @see #forClass(Class)"
"ResolvableType.java:1008"$0$"	 * @see #getRawClass()"
"ResolvableType.java:1009"$0$"	 */"
"ResolvableType.java:1010"$1$"	public static ResolvableType forRawClass(@Nullable Class<?> clazz) {"
"ResolvableType.java:1011"$1$"		return new ResolvableType(clazz) {"
"ResolvableType.java:1012"$1$"			@Override"
"ResolvableType.java:1013"$1$"			public ResolvableType[] getGenerics() {"
"ResolvableType.java:1014"$1$"				return EMPTY_TYPES_ARRAY;"
"ResolvableType.java:1015"$1$"			}"
"ResolvableType.java:1016"$0$"			@Override"
"ResolvableType.java:1017"$1$"			public boolean isAssignableFrom(Class<?> other) {"
"ResolvableType.java:1018"$1$"				return (clazz == null || ClassUtils.isAssignable(clazz, other));"
"ResolvableType.java:1019"$1$"			}"
"ResolvableType.java:1020"$0$"			@Override"
"ResolvableType.java:1021"$1$"			public boolean isAssignableFrom(ResolvableType other) {"
"ResolvableType.java:1022"$1$"				Class<?> otherClass = other.resolve();"
"ResolvableType.java:1023"$1$"				return (otherClass != null && (clazz == null || ClassUtils.isAssignable(clazz, otherClass)));"
"ResolvableType.java:1024"$1$"			}"
"ResolvableType.java:1025"$0$"		};"
"ResolvableType.java:1026"$0$"	}"
"ResolvableType.java:1027"$0$""
"ResolvableType.java:1028"$0$"	/**"
"ResolvableType.java:1029"$1$"	 * Return a {@link ResolvableType} for the specified base type"
"ResolvableType.java:1030"$0$"	 * (interface or base class) with a given implementation class."
"ResolvableType.java:1031"$1$"	 * For example: {@code ResolvableType.forClass(List.class, MyArrayList.class)}."
"ResolvableType.java:1032"$1$"	 * @param baseType the base type (must not be {@code null})"
"ResolvableType.java:1033"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1034"$1$"	 * @return a {@link ResolvableType} for the specified base type backed by the"
"ResolvableType.java:1035"$0$"	 * given implementation class"
"ResolvableType.java:1036"$0$"	 * @see #forClass(Class)"
"ResolvableType.java:1037"$0$"	 * @see #forClassWithGenerics(Class, Class...)"
"ResolvableType.java:1038"$0$"	 */"
"ResolvableType.java:1039"$1$"	public static ResolvableType forClass(Class<?> baseType, Class<?> implementationClass) {"
"ResolvableType.java:1040"$1$"		Assert.notNull(baseType, ""Base type must not be null"");"
"ResolvableType.java:1041"$1$"		ResolvableType asType = forType(implementationClass).as(baseType);"
"ResolvableType.java:1042"$1$"		return (asType == NONE ? forType(baseType) : asType);"
"ResolvableType.java:1043"$1$"	}"
"ResolvableType.java:1044"$0$""
"ResolvableType.java:1045"$0$"	/**"
"ResolvableType.java:1046"$1$"	 * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics."
"ResolvableType.java:1047"$0$"	 * @param clazz the class (or interface) to introspect"
"ResolvableType.java:1048"$0$"	 * @param generics the generics of the class"
"ResolvableType.java:1049"$1$"	 * @return a {@link ResolvableType} for the specific class and generics"
"ResolvableType.java:1050"$0$"	 * @see #forClassWithGenerics(Class, ResolvableType...)"
"ResolvableType.java:1051"$0$"	 */"
"ResolvableType.java:1052"$1$"	public static ResolvableType forClassWithGenerics(Class<?> clazz, Class<?>... generics) {"
"ResolvableType.java:1053"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ResolvableType.java:1054"$1$"		Assert.notNull(generics, ""Generics array must not be null"");"
"ResolvableType.java:1055"$1$"		ResolvableType[] resolvableGenerics = new ResolvableType[generics.length];"
"ResolvableType.java:1056"$1$"		for (int i = 0; i < generics.length; i++) {"
"ResolvableType.java:1057"$1$"			resolvableGenerics[i] = forClass(generics[i]);"
"ResolvableType.java:1058"$1$"		}"
"ResolvableType.java:1059"$0$"		return forClassWithGenerics(clazz, resolvableGenerics);"
"ResolvableType.java:1060"$0$"	}"
"ResolvableType.java:1061"$0$""
"ResolvableType.java:1062"$0$"	/**"
"ResolvableType.java:1063"$1$"	 * Return a {@link ResolvableType} for the specified {@link Class} with pre-declared generics."
"ResolvableType.java:1064"$0$"	 * @param clazz the class (or interface) to introspect"
"ResolvableType.java:1065"$0$"	 * @param generics the generics of the class"
"ResolvableType.java:1066"$1$"	 * @return a {@link ResolvableType} for the specific class and generics"
"ResolvableType.java:1067"$0$"	 * @see #forClassWithGenerics(Class, Class...)"
"ResolvableType.java:1068"$0$"	 */"
"ResolvableType.java:1069"$1$"	public static ResolvableType forClassWithGenerics(Class<?> clazz, ResolvableType... generics) {"
"ResolvableType.java:1070"$1$"		Assert.notNull(clazz, ""Class must not be null"");"
"ResolvableType.java:1071"$1$"		Assert.notNull(generics, ""Generics array must not be null"");"
"ResolvableType.java:1072"$1$"		TypeVariable<?>[] variables = clazz.getTypeParameters();"
"ResolvableType.java:1073"$1$"		Assert.isTrue(variables.length == generics.length, ""Mismatched number of generics specified"");"
"ResolvableType.java:1074"$1$""
"ResolvableType.java:1075"$1$"		Type[] arguments = new Type[generics.length];"
"ResolvableType.java:1076"$1$"		for (int i = 0; i < generics.length; i++) {"
"ResolvableType.java:1077"$1$"			ResolvableType generic = generics[i];"
"ResolvableType.java:1078"$1$"			Type argument = (generic != null ? generic.getType() : null);"
"ResolvableType.java:1079"$1$"			arguments[i] = (argument != null && !(argument instanceof TypeVariable) ? argument : variables[i]);"
"ResolvableType.java:1080"$1$"		}"
"ResolvableType.java:1081"$0$""
"ResolvableType.java:1082"$0$"		ParameterizedType syntheticType = new SyntheticParameterizedType(clazz, arguments);"
"ResolvableType.java:1083"$0$"		return forType(syntheticType, new TypeVariablesVariableResolver(variables, generics));"
"ResolvableType.java:1084"$0$"	}"
"ResolvableType.java:1085"$0$""
"ResolvableType.java:1086"$0$"	/**"
"ResolvableType.java:1087"$1$"	 * Return a {@link ResolvableType} for the specified instance. The instance does not"
"ResolvableType.java:1088"$1$"	 * convey generic information but if it implements {@link ResolvableTypeProvider} a"
"ResolvableType.java:1089"$1$"	 * more precise {@link ResolvableType} can be used than the simple one based on"
"ResolvableType.java:1090"$1$"	 * the {@link #forClass(Class) Class instance}."
"ResolvableType.java:1091"$0$"	 * @param instance the instance"
"ResolvableType.java:1092"$1$"	 * @return a {@link ResolvableType} for the specified instance"
"ResolvableType.java:1093"$0$"	 * @since 4.2"
"ResolvableType.java:1094"$0$"	 * @see ResolvableTypeProvider"
"ResolvableType.java:1095"$0$"	 */"
"ResolvableType.java:1096"$1$"	public static ResolvableType forInstance(Object instance) {"
"ResolvableType.java:1097"$1$"		Assert.notNull(instance, ""Instance must not be null"");"
"ResolvableType.java:1098"$1$"		if (instance instanceof ResolvableTypeProvider) {"
"ResolvableType.java:1099"$1$"			ResolvableType type = ((ResolvableTypeProvider) instance).getResolvableType();"
"ResolvableType.java:1100"$1$"			if (type != null) {"
"ResolvableType.java:1101"$1$"				return type;"
"ResolvableType.java:1102"$1$"			}"
"ResolvableType.java:1103"$0$"		}"
"ResolvableType.java:1104"$0$"		return ResolvableType.forClass(instance.getClass());"
"ResolvableType.java:1105"$0$"	}"
"ResolvableType.java:1106"$0$""
"ResolvableType.java:1107"$0$"	/**"
"ResolvableType.java:1108"$1$"	 * Return a {@link ResolvableType} for the specified {@link Field}."
"ResolvableType.java:1109"$0$"	 * @param field the source field"
"ResolvableType.java:1110"$1$"	 * @return a {@link ResolvableType} for the specified field"
"ResolvableType.java:1111"$0$"	 * @see #forField(Field, Class)"
"ResolvableType.java:1112"$0$"	 */"
"ResolvableType.java:1113"$1$"	public static ResolvableType forField(Field field) {"
"ResolvableType.java:1114"$1$"		Assert.notNull(field, ""Field must not be null"");"
"ResolvableType.java:1115"$1$"		return forType(null, new FieldTypeProvider(field), null);"
"ResolvableType.java:1116"$1$"	}"
"ResolvableType.java:1117"$0$""
"ResolvableType.java:1118"$0$"	/**"
"ResolvableType.java:1119"$1$"	 * Return a {@link ResolvableType} for the specified {@link Field} with a given"
"ResolvableType.java:1120"$0$"	 * implementation."
"ResolvableType.java:1121"$0$"	 * <p>Use this variant when the class that declares the field includes generic"
"ResolvableType.java:1122"$0$"	 * parameter variables that are satisfied by the implementation class."
"ResolvableType.java:1123"$0$"	 * @param field the source field"
"ResolvableType.java:1124"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1125"$1$"	 * @return a {@link ResolvableType} for the specified field"
"ResolvableType.java:1126"$0$"	 * @see #forField(Field)"
"ResolvableType.java:1127"$0$"	 */"
"ResolvableType.java:1128"$1$"	public static ResolvableType forField(Field field, Class<?> implementationClass) {"
"ResolvableType.java:1129"$1$"		Assert.notNull(field, ""Field must not be null"");"
"ResolvableType.java:1130"$1$"		ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());"
"ResolvableType.java:1131"$1$"		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());"
"ResolvableType.java:1132"$1$"	}"
"ResolvableType.java:1133"$0$""
"ResolvableType.java:1134"$0$"	/**"
"ResolvableType.java:1135"$1$"	 * Return a {@link ResolvableType} for the specified {@link Field} with a given"
"ResolvableType.java:1136"$0$"	 * implementation."
"ResolvableType.java:1137"$0$"	 * <p>Use this variant when the class that declares the field includes generic"
"ResolvableType.java:1138"$0$"	 * parameter variables that are satisfied by the implementation type."
"ResolvableType.java:1139"$0$"	 * @param field the source field"
"ResolvableType.java:1140"$0$"	 * @param implementationType the implementation type"
"ResolvableType.java:1141"$1$"	 * @return a {@link ResolvableType} for the specified field"
"ResolvableType.java:1142"$0$"	 * @see #forField(Field)"
"ResolvableType.java:1143"$0$"	 */"
"ResolvableType.java:1144"$1$"	public static ResolvableType forField(Field field, @Nullable ResolvableType implementationType) {"
"ResolvableType.java:1145"$1$"		Assert.notNull(field, ""Field must not be null"");"
"ResolvableType.java:1146"$1$"		ResolvableType owner = (implementationType != null ? implementationType : NONE);"
"ResolvableType.java:1147"$1$"		owner = owner.as(field.getDeclaringClass());"
"ResolvableType.java:1148"$1$"		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver());"
"ResolvableType.java:1149"$1$"	}"
"ResolvableType.java:1150"$0$""
"ResolvableType.java:1151"$0$"	/**"
"ResolvableType.java:1152"$1$"	 * Return a {@link ResolvableType} for the specified {@link Field} with the"
"ResolvableType.java:1153"$0$"	 * given nesting level."
"ResolvableType.java:1154"$0$"	 * @param field the source field"
"ResolvableType.java:1155"$0$"	 * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested"
"ResolvableType.java:1156"$0$"	 * generic type; etc)"
"ResolvableType.java:1157"$0$"	 * @see #forField(Field)"
"ResolvableType.java:1158"$0$"	 */"
"ResolvableType.java:1159"$1$"	public static ResolvableType forField(Field field, int nestingLevel) {"
"ResolvableType.java:1160"$1$"		Assert.notNull(field, ""Field must not be null"");"
"ResolvableType.java:1161"$1$"		return forType(null, new FieldTypeProvider(field), null).getNested(nestingLevel);"
"ResolvableType.java:1162"$1$"	}"
"ResolvableType.java:1163"$0$""
"ResolvableType.java:1164"$0$"	/**"
"ResolvableType.java:1165"$1$"	 * Return a {@link ResolvableType} for the specified {@link Field} with a given"
"ResolvableType.java:1166"$0$"	 * implementation and the given nesting level."
"ResolvableType.java:1167"$0$"	 * <p>Use this variant when the class that declares the field includes generic"
"ResolvableType.java:1168"$0$"	 * parameter variables that are satisfied by the implementation class."
"ResolvableType.java:1169"$0$"	 * @param field the source field"
"ResolvableType.java:1170"$0$"	 * @param nestingLevel the nesting level (1 for the outer level; 2 for a nested"
"ResolvableType.java:1171"$0$"	 * generic type; etc)"
"ResolvableType.java:1172"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1173"$1$"	 * @return a {@link ResolvableType} for the specified field"
"ResolvableType.java:1174"$0$"	 * @see #forField(Field)"
"ResolvableType.java:1175"$0$"	 */"
"ResolvableType.java:1176"$1$"	public static ResolvableType forField(Field field, int nestingLevel, @Nullable Class<?> implementationClass) {"
"ResolvableType.java:1177"$1$"		Assert.notNull(field, ""Field must not be null"");"
"ResolvableType.java:1178"$1$"		ResolvableType owner = forType(implementationClass).as(field.getDeclaringClass());"
"ResolvableType.java:1179"$1$"		return forType(null, new FieldTypeProvider(field), owner.asVariableResolver()).getNested(nestingLevel);"
"ResolvableType.java:1180"$1$"	}"
"ResolvableType.java:1181"$0$""
"ResolvableType.java:1182"$0$"	/**"
"ResolvableType.java:1183"$1$"	 * Return a {@link ResolvableType} for the specified {@link Constructor} parameter."
"ResolvableType.java:1184"$1$"	 * @param constructor the source constructor (must not be {@code null})"
"ResolvableType.java:1185"$0$"	 * @param parameterIndex the parameter index"
"ResolvableType.java:1186"$1$"	 * @return a {@link ResolvableType} for the specified constructor parameter"
"ResolvableType.java:1187"$0$"	 * @see #forConstructorParameter(Constructor, int, Class)"
"ResolvableType.java:1188"$0$"	 */"
"ResolvableType.java:1189"$1$"	public static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex) {"
"ResolvableType.java:1190"$1$"		Assert.notNull(constructor, ""Constructor must not be null"");"
"ResolvableType.java:1191"$1$"		return forMethodParameter(new MethodParameter(constructor, parameterIndex));"
"ResolvableType.java:1192"$1$"	}"
"ResolvableType.java:1193"$0$""
"ResolvableType.java:1194"$0$"	/**"
"ResolvableType.java:1195"$1$"	 * Return a {@link ResolvableType} for the specified {@link Constructor} parameter"
"ResolvableType.java:1196"$0$"	 * with a given implementation. Use this variant when the class that declares the"
"ResolvableType.java:1197"$0$"	 * constructor includes generic parameter variables that are satisfied by the"
"ResolvableType.java:1198"$0$"	 * implementation class."
"ResolvableType.java:1199"$1$"	 * @param constructor the source constructor (must not be {@code null})"
"ResolvableType.java:1200"$0$"	 * @param parameterIndex the parameter index"
"ResolvableType.java:1201"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1202"$1$"	 * @return a {@link ResolvableType} for the specified constructor parameter"
"ResolvableType.java:1203"$0$"	 * @see #forConstructorParameter(Constructor, int)"
"ResolvableType.java:1204"$0$"	 */"
"ResolvableType.java:1205"$0$"	public static ResolvableType forConstructorParameter(Constructor<?> constructor, int parameterIndex,"
"ResolvableType.java:1206"$1$"			Class<?> implementationClass) {"
"ResolvableType.java:1207"$1$""
"ResolvableType.java:1208"$1$"		Assert.notNull(constructor, ""Constructor must not be null"");"
"ResolvableType.java:1209"$1$"		MethodParameter methodParameter = new MethodParameter(constructor, parameterIndex, implementationClass);"
"ResolvableType.java:1210"$1$"		return forMethodParameter(methodParameter);"
"ResolvableType.java:1211"$1$"	}"
"ResolvableType.java:1212"$0$""
"ResolvableType.java:1213"$0$"	/**"
"ResolvableType.java:1214"$1$"	 * Return a {@link ResolvableType} for the specified {@link Method} return type."
"ResolvableType.java:1215"$0$"	 * @param method the source for the method return type"
"ResolvableType.java:1216"$1$"	 * @return a {@link ResolvableType} for the specified method return"
"ResolvableType.java:1217"$0$"	 * @see #forMethodReturnType(Method, Class)"
"ResolvableType.java:1218"$0$"	 */"
"ResolvableType.java:1219"$1$"	public static ResolvableType forMethodReturnType(Method method) {"
"ResolvableType.java:1220"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ResolvableType.java:1221"$1$"		return forMethodParameter(new MethodParameter(method, -1));"
"ResolvableType.java:1222"$1$"	}"
"ResolvableType.java:1223"$0$""
"ResolvableType.java:1224"$0$"	/**"
"ResolvableType.java:1225"$1$"	 * Return a {@link ResolvableType} for the specified {@link Method} return type."
"ResolvableType.java:1226"$0$"	 * Use this variant when the class that declares the method includes generic"
"ResolvableType.java:1227"$0$"	 * parameter variables that are satisfied by the implementation class."
"ResolvableType.java:1228"$0$"	 * @param method the source for the method return type"
"ResolvableType.java:1229"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1230"$1$"	 * @return a {@link ResolvableType} for the specified method return"
"ResolvableType.java:1231"$0$"	 * @see #forMethodReturnType(Method)"
"ResolvableType.java:1232"$0$"	 */"
"ResolvableType.java:1233"$1$"	public static ResolvableType forMethodReturnType(Method method, Class<?> implementationClass) {"
"ResolvableType.java:1234"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ResolvableType.java:1235"$1$"		MethodParameter methodParameter = new MethodParameter(method, -1, implementationClass);"
"ResolvableType.java:1236"$1$"		return forMethodParameter(methodParameter);"
"ResolvableType.java:1237"$1$"	}"
"ResolvableType.java:1238"$0$""
"ResolvableType.java:1239"$0$"	/**"
"ResolvableType.java:1240"$1$"	 * Return a {@link ResolvableType} for the specified {@link Method} parameter."
"ResolvableType.java:1241"$1$"	 * @param method the source method (must not be {@code null})"
"ResolvableType.java:1242"$0$"	 * @param parameterIndex the parameter index"
"ResolvableType.java:1243"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1244"$0$"	 * @see #forMethodParameter(Method, int, Class)"
"ResolvableType.java:1245"$0$"	 * @see #forMethodParameter(MethodParameter)"
"ResolvableType.java:1246"$0$"	 */"
"ResolvableType.java:1247"$1$"	public static ResolvableType forMethodParameter(Method method, int parameterIndex) {"
"ResolvableType.java:1248"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ResolvableType.java:1249"$1$"		return forMethodParameter(new MethodParameter(method, parameterIndex));"
"ResolvableType.java:1250"$1$"	}"
"ResolvableType.java:1251"$0$""
"ResolvableType.java:1252"$0$"	/**"
"ResolvableType.java:1253"$1$"	 * Return a {@link ResolvableType} for the specified {@link Method} parameter with a"
"ResolvableType.java:1254"$0$"	 * given implementation. Use this variant when the class that declares the method"
"ResolvableType.java:1255"$0$"	 * includes generic parameter variables that are satisfied by the implementation class."
"ResolvableType.java:1256"$1$"	 * @param method the source method (must not be {@code null})"
"ResolvableType.java:1257"$0$"	 * @param parameterIndex the parameter index"
"ResolvableType.java:1258"$0$"	 * @param implementationClass the implementation class"
"ResolvableType.java:1259"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1260"$0$"	 * @see #forMethodParameter(Method, int, Class)"
"ResolvableType.java:1261"$0$"	 * @see #forMethodParameter(MethodParameter)"
"ResolvableType.java:1262"$0$"	 */"
"ResolvableType.java:1263"$1$"	public static ResolvableType forMethodParameter(Method method, int parameterIndex, Class<?> implementationClass) {"
"ResolvableType.java:1264"$1$"		Assert.notNull(method, ""Method must not be null"");"
"ResolvableType.java:1265"$1$"		MethodParameter methodParameter = new MethodParameter(method, parameterIndex, implementationClass);"
"ResolvableType.java:1266"$1$"		return forMethodParameter(methodParameter);"
"ResolvableType.java:1267"$1$"	}"
"ResolvableType.java:1268"$0$""
"ResolvableType.java:1269"$0$"	/**"
"ResolvableType.java:1270"$1$"	 * Return a {@link ResolvableType} for the specified {@link MethodParameter}."
"ResolvableType.java:1271"$1$"	 * @param methodParameter the source method parameter (must not be {@code null})"
"ResolvableType.java:1272"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1273"$0$"	 * @see #forMethodParameter(Method, int)"
"ResolvableType.java:1274"$0$"	 */"
"ResolvableType.java:1275"$1$"	public static ResolvableType forMethodParameter(MethodParameter methodParameter) {"
"ResolvableType.java:1276"$1$"		return forMethodParameter(methodParameter, (Type) null);"
"ResolvableType.java:1277"$1$"	}"
"ResolvableType.java:1278"$0$""
"ResolvableType.java:1279"$0$"	/**"
"ResolvableType.java:1280"$1$"	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a"
"ResolvableType.java:1281"$0$"	 * given implementation type. Use this variant when the class that declares the method"
"ResolvableType.java:1282"$0$"	 * includes generic parameter variables that are satisfied by the implementation type."
"ResolvableType.java:1283"$1$"	 * @param methodParameter the source method parameter (must not be {@code null})"
"ResolvableType.java:1284"$0$"	 * @param implementationType the implementation type"
"ResolvableType.java:1285"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1286"$0$"	 * @see #forMethodParameter(MethodParameter)"
"ResolvableType.java:1287"$0$"	 */"
"ResolvableType.java:1288"$0$"	public static ResolvableType forMethodParameter(MethodParameter methodParameter,"
"ResolvableType.java:1289"$1$"			@Nullable ResolvableType implementationType) {"
"ResolvableType.java:1290"$1$""
"ResolvableType.java:1291"$1$"		Assert.notNull(methodParameter, ""MethodParameter must not be null"");"
"ResolvableType.java:1292"$1$"		implementationType = (implementationType != null ? implementationType :"
"ResolvableType.java:1293"$1$"				forType(methodParameter.getContainingClass()));"
"ResolvableType.java:1294"$1$"		ResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());"
"ResolvableType.java:1295"$1$"		return forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver())."
"ResolvableType.java:1296"$1$"				getNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);"
"ResolvableType.java:1297"$1$"	}"
"ResolvableType.java:1298"$0$""
"ResolvableType.java:1299"$0$"	/**"
"ResolvableType.java:1300"$1$"	 * Return a {@link ResolvableType} for the specified {@link MethodParameter},"
"ResolvableType.java:1301"$0$"	 * overriding the target type to resolve with a specific given type."
"ResolvableType.java:1302"$1$"	 * @param methodParameter the source method parameter (must not be {@code null})"
"ResolvableType.java:1303"$0$"	 * @param targetType the type to resolve (a part of the method parameter's type)"
"ResolvableType.java:1304"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1305"$0$"	 * @see #forMethodParameter(Method, int)"
"ResolvableType.java:1306"$0$"	 */"
"ResolvableType.java:1307"$1$"	public static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {"
"ResolvableType.java:1308"$1$"		Assert.notNull(methodParameter, ""MethodParameter must not be null"");"
"ResolvableType.java:1309"$1$"		return forMethodParameter(methodParameter, targetType, methodParameter.getNestingLevel());"
"ResolvableType.java:1310"$1$"	}"
"ResolvableType.java:1311"$0$""
"ResolvableType.java:1312"$0$"	/**"
"ResolvableType.java:1313"$1$"	 * Return a {@link ResolvableType} for the specified {@link MethodParameter} at"
"ResolvableType.java:1314"$0$"	 * a specific nesting level, overriding the target type to resolve with a specific"
"ResolvableType.java:1315"$0$"	 * given type."
"ResolvableType.java:1316"$1$"	 * @param methodParameter the source method parameter (must not be {@code null})"
"ResolvableType.java:1317"$0$"	 * @param targetType the type to resolve (a part of the method parameter's type)"
"ResolvableType.java:1318"$0$"	 * @param nestingLevel the nesting level to use"
"ResolvableType.java:1319"$1$"	 * @return a {@link ResolvableType} for the specified method parameter"
"ResolvableType.java:1320"$0$"	 * @since 5.2"
"ResolvableType.java:1321"$0$"	 * @see #forMethodParameter(Method, int)"
"ResolvableType.java:1322"$0$"	 */"
"ResolvableType.java:1323"$0$"	static ResolvableType forMethodParameter("
"ResolvableType.java:1324"$1$"			MethodParameter methodParameter, @Nullable Type targetType, int nestingLevel) {"
"ResolvableType.java:1325"$1$""
"ResolvableType.java:1326"$1$"		ResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());"
"ResolvableType.java:1327"$1$"		return forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver())."
"ResolvableType.java:1328"$1$"				getNested(nestingLevel, methodParameter.typeIndexesPerLevel);"
"ResolvableType.java:1329"$1$"	}"
"ResolvableType.java:1330"$0$""
"ResolvableType.java:1331"$0$"	/**"
"ResolvableType.java:1332"$1$"	 * Return a {@link ResolvableType} as a array of the specified {@code componentType}."
"ResolvableType.java:1333"$0$"	 * @param componentType the component type"
"ResolvableType.java:1334"$1$"	 * @return a {@link ResolvableType} as an array of the specified component type"
"ResolvableType.java:1335"$0$"	 */"
"ResolvableType.java:1336"$1$"	public static ResolvableType forArrayComponent(ResolvableType componentType) {"
"ResolvableType.java:1337"$1$"		Assert.notNull(componentType, ""Component type must not be null"");"
"ResolvableType.java:1338"$1$"		Class<?> arrayClass = Array.newInstance(componentType.resolve(), 0).getClass();"
"ResolvableType.java:1339"$1$"		return new ResolvableType(arrayClass, null, null, componentType);"
"ResolvableType.java:1340"$1$"	}"
"ResolvableType.java:1341"$0$""
"ResolvableType.java:1342"$0$"	/**"
"ResolvableType.java:1343"$1$"	 * Return a {@link ResolvableType} for the specified {@link Type}."
"ResolvableType.java:1344"$1$"	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}."
"ResolvableType.java:1345"$1$"	 * @param type the source type (potentially {@code null})"
"ResolvableType.java:1346"$1$"	 * @return a {@link ResolvableType} for the specified {@link Type}"
"ResolvableType.java:1347"$0$"	 * @see #forType(Type, ResolvableType)"
"ResolvableType.java:1348"$0$"	 */"
"ResolvableType.java:1349"$1$"	public static ResolvableType forType(@Nullable Type type) {"
"ResolvableType.java:1350"$1$"		return forType(type, null, null);"
"ResolvableType.java:1351"$1$"	}"
"ResolvableType.java:1352"$0$""
"ResolvableType.java:1353"$0$"	/**"
"ResolvableType.java:1354"$1$"	 * Return a {@link ResolvableType} for the specified {@link Type} backed by the given"
"ResolvableType.java:1355"$0$"	 * owner type."
"ResolvableType.java:1356"$1$"	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}."
"ResolvableType.java:1357"$1$"	 * @param type the source type or {@code null}"
"ResolvableType.java:1358"$0$"	 * @param owner the owner type used to resolve variables"
"ResolvableType.java:1359"$1$"	 * @return a {@link ResolvableType} for the specified {@link Type} and owner"
"ResolvableType.java:1360"$0$"	 * @see #forType(Type)"
"ResolvableType.java:1361"$0$"	 */"
"ResolvableType.java:1362"$1$"	public static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {"
"ResolvableType.java:1363"$1$"		VariableResolver variableResolver = null;"
"ResolvableType.java:1364"$1$"		if (owner != null) {"
"ResolvableType.java:1365"$1$"			variableResolver = owner.asVariableResolver();"
"ResolvableType.java:1366"$1$"		}"
"ResolvableType.java:1367"$0$"		return forType(type, variableResolver);"
"ResolvableType.java:1368"$0$"	}"
"ResolvableType.java:1369"$0$""
"ResolvableType.java:1370"$0$""
"ResolvableType.java:1371"$0$"	/**"
"ResolvableType.java:1372"$1$"	 * Return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}."
"ResolvableType.java:1373"$1$"	 * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}."
"ResolvableType.java:1374"$0$"	 * @param typeReference the reference to obtain the source type from"
"ResolvableType.java:1375"$1$"	 * @return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}"
"ResolvableType.java:1376"$0$"	 * @since 4.3.12"
"ResolvableType.java:1377"$0$"	 * @see #forType(Type)"
"ResolvableType.java:1378"$0$"	 */"
"ResolvableType.java:1379"$1$"	public static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {"
"ResolvableType.java:1380"$1$"		return forType(typeReference.getType(), null, null);"
"ResolvableType.java:1381"$1$"	}"
"ResolvableType.java:1382"$0$""
"ResolvableType.java:1383"$0$"	/**"
"ResolvableType.java:1384"$1$"	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given"
"ResolvableType.java:1385"$1$"	 * {@link VariableResolver}."
"ResolvableType.java:1386"$1$"	 * @param type the source type or {@code null}"
"ResolvableType.java:1387"$1$"	 * @param variableResolver the variable resolver or {@code null}"
"ResolvableType.java:1388"$1$"	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}"
"ResolvableType.java:1389"$0$"	 */"
"ResolvableType.java:1390"$1$"	static ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {"
"ResolvableType.java:1391"$1$"		return forType(type, null, variableResolver);"
"ResolvableType.java:1392"$1$"	}"
"ResolvableType.java:1393"$0$""
"ResolvableType.java:1394"$0$"	/**"
"ResolvableType.java:1395"$1$"	 * Return a {@link ResolvableType} for the specified {@link Type} backed by a given"
"ResolvableType.java:1396"$1$"	 * {@link VariableResolver}."
"ResolvableType.java:1397"$1$"	 * @param type the source type or {@code null}"
"ResolvableType.java:1398"$1$"	 * @param typeProvider the type provider or {@code null}"
"ResolvableType.java:1399"$1$"	 * @param variableResolver the variable resolver or {@code null}"
"ResolvableType.java:1400"$1$"	 * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}"
"ResolvableType.java:1401"$0$"	 */"
"ResolvableType.java:1402"$0$"	static ResolvableType forType("
"ResolvableType.java:1403"$1$"			@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {"
"ResolvableType.java:1404"$1$""
"ResolvableType.java:1405"$1$"		if (type == null && typeProvider != null) {"
"ResolvableType.java:1406"$1$"			type = SerializableTypeWrapper.forTypeProvider(typeProvider);"
"ResolvableType.java:1407"$1$"		}"
"ResolvableType.java:1408"$1$"		if (type == null) {"
"ResolvableType.java:1409"$1$"			return NONE;"
"ResolvableType.java:1410"$1$"		}"
"ResolvableType.java:1411"$0$""
"ResolvableType.java:1412"$0$"		// For simple Class references, build the wrapper right away -"
"ResolvableType.java:1413"$0$"		// no expensive resolution necessary, so not worth caching..."
"ResolvableType.java:1414"$1$"		if (type instanceof Class) {"
"ResolvableType.java:1415"$1$"			return new ResolvableType(type, typeProvider, variableResolver, (ResolvableType) null);"
"ResolvableType.java:1416"$1$"		}"
"ResolvableType.java:1417"$0$""
"ResolvableType.java:1418"$0$"		// Purge empty entries on access since we don't have a clean-up thread or the like."
"ResolvableType.java:1419"$0$"		cache.purgeUnreferencedEntries();"
"ResolvableType.java:1420"$0$""
"ResolvableType.java:1421"$0$"		// Check the cache - we may have a ResolvableType which has been resolved before..."
"ResolvableType.java:1422"$0$"		ResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);"
"ResolvableType.java:1423"$0$"		ResolvableType cachedType = cache.get(resultType);"
"ResolvableType.java:1424"$1$"		if (cachedType == null) {"
"ResolvableType.java:1425"$1$"			cachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);"
"ResolvableType.java:1426"$1$"			cache.put(cachedType, cachedType);"
"ResolvableType.java:1427"$1$"		}"
"ResolvableType.java:1428"$0$"		resultType.resolved = cachedType.resolved;"
"ResolvableType.java:1429"$0$"		return resultType;"
"ResolvableType.java:1430"$0$"	}"
"ResolvableType.java:1431"$0$""
"ResolvableType.java:1432"$0$"	/**"
"ResolvableType.java:1433"$1$"	 * Clear the internal {@code ResolvableType}/{@code SerializableTypeWrapper} cache."
"ResolvableType.java:1434"$0$"	 * @since 4.2"
"ResolvableType.java:1435"$0$"	 */"
"ResolvableType.java:1436"$1$"	public static void clearCache() {"
"ResolvableType.java:1437"$1$"		cache.clear();"
"ResolvableType.java:1438"$1$"		SerializableTypeWrapper.cache.clear();"
"ResolvableType.java:1439"$1$"	}"
"ResolvableType.java:1440"$0$""
"ResolvableType.java:1441"$0$""
"ResolvableType.java:1442"$0$"	/**"
"ResolvableType.java:1443"$1$"	 * Strategy interface used to resolve {@link TypeVariable TypeVariables}."
"ResolvableType.java:1444"$0$"	 */"
"ResolvableType.java:1445"$1$"	interface VariableResolver extends Serializable {"
"ResolvableType.java:1446"$1$""
"ResolvableType.java:1447"$1$"		/**"
"ResolvableType.java:1448"$1$"		 * Return the source of the resolver (used for hashCode and equals)."
"ResolvableType.java:1449"$1$"		 */"
"ResolvableType.java:1450"$1$"		Object getSource();"
"ResolvableType.java:1451"$1$""
"ResolvableType.java:1452"$1$"		/**"
"ResolvableType.java:1453"$1$"		 * Resolve the specified variable."
"ResolvableType.java:1454"$1$"		 * @param variable the variable to resolve"
"ResolvableType.java:1455"$1$"		 * @return the resolved variable, or {@code null} if not found"
"ResolvableType.java:1456"$1$"		 */"
"ResolvableType.java:1457"$1$"		@Nullable"
"ResolvableType.java:1458"$1$"		ResolvableType resolveVariable(TypeVariable<?> variable);"
"ResolvableType.java:1459"$1$"	}"
"ResolvableType.java:1460"$0$""
"ResolvableType.java:1461"$0$""
"ResolvableType.java:1462"$0$"	@SuppressWarnings(""serial"")"
"ResolvableType.java:1463"$1$"	private static class DefaultVariableResolver implements VariableResolver {"
"ResolvableType.java:1464"$1$""
"ResolvableType.java:1465"$1$"		private final ResolvableType source;"
"ResolvableType.java:1466"$1$""
"ResolvableType.java:1467"$1$"		DefaultVariableResolver(ResolvableType resolvableType) {"
"ResolvableType.java:1468"$1$"			this.source = resolvableType;"
"ResolvableType.java:1469"$1$"		}"
"ResolvableType.java:1470"$0$""
"ResolvableType.java:1471"$0$"		@Override"
"ResolvableType.java:1472"$0$"		@Nullable"
"ResolvableType.java:1473"$1$"		public ResolvableType resolveVariable(TypeVariable<?> variable) {"
"ResolvableType.java:1474"$1$"			return this.source.resolveVariable(variable);"
"ResolvableType.java:1475"$1$"		}"
"ResolvableType.java:1476"$0$""
"ResolvableType.java:1477"$0$"		@Override"
"ResolvableType.java:1478"$1$"		public Object getSource() {"
"ResolvableType.java:1479"$1$"			return this.source;"
"ResolvableType.java:1480"$1$"		}"
"ResolvableType.java:1481"$0$"	}"
"ResolvableType.java:1482"$0$""
"ResolvableType.java:1483"$0$""
"ResolvableType.java:1484"$0$"	@SuppressWarnings(""serial"")"
"ResolvableType.java:1485"$1$"	private static class TypeVariablesVariableResolver implements VariableResolver {"
"ResolvableType.java:1486"$1$""
"ResolvableType.java:1487"$1$"		private final TypeVariable<?>[] variables;"
"ResolvableType.java:1488"$1$""
"ResolvableType.java:1489"$1$"		private final ResolvableType[] generics;"
"ResolvableType.java:1490"$1$""
"ResolvableType.java:1491"$1$"		public TypeVariablesVariableResolver(TypeVariable<?>[] variables, ResolvableType[] generics) {"
"ResolvableType.java:1492"$1$"			this.variables = variables;"
"ResolvableType.java:1493"$1$"			this.generics = generics;"
"ResolvableType.java:1494"$1$"		}"
"ResolvableType.java:1495"$0$""
"ResolvableType.java:1496"$0$"		@Override"
"ResolvableType.java:1497"$0$"		@Nullable"
"ResolvableType.java:1498"$1$"		public ResolvableType resolveVariable(TypeVariable<?> variable) {"
"ResolvableType.java:1499"$1$"			TypeVariable<?> variableToCompare = SerializableTypeWrapper.unwrap(variable);"
"ResolvableType.java:1500"$1$"			for (int i = 0; i < this.variables.length; i++) {"
"ResolvableType.java:1501"$1$"				TypeVariable<?> resolvedVariable = SerializableTypeWrapper.unwrap(this.variables[i]);"
"ResolvableType.java:1502"$1$"				if (ObjectUtils.nullSafeEquals(resolvedVariable, variableToCompare)) {"
"ResolvableType.java:1503"$1$"					return this.generics[i];"
"ResolvableType.java:1504"$1$"				}"
"ResolvableType.java:1505"$0$"			}"
"ResolvableType.java:1506"$0$"			return null;"
"ResolvableType.java:1507"$0$"		}"
"ResolvableType.java:1508"$0$""
"ResolvableType.java:1509"$0$"		@Override"
"ResolvableType.java:1510"$1$"		public Object getSource() {"
"ResolvableType.java:1511"$1$"			return this.generics;"
"ResolvableType.java:1512"$1$"		}"
"ResolvableType.java:1513"$0$"	}"
"ResolvableType.java:1514"$0$""
"ResolvableType.java:1515"$0$""
"ResolvableType.java:1516"$1$"	private static final class SyntheticParameterizedType implements ParameterizedType, Serializable {"
"ResolvableType.java:1517"$1$""
"ResolvableType.java:1518"$1$"		private final Type rawType;"
"ResolvableType.java:1519"$1$""
"ResolvableType.java:1520"$1$"		private final Type[] typeArguments;"
"ResolvableType.java:1521"$1$""
"ResolvableType.java:1522"$1$"		public SyntheticParameterizedType(Type rawType, Type[] typeArguments) {"
"ResolvableType.java:1523"$1$"			this.rawType = rawType;"
"ResolvableType.java:1524"$1$"			this.typeArguments = typeArguments;"
"ResolvableType.java:1525"$1$"		}"
"ResolvableType.java:1526"$0$""
"ResolvableType.java:1527"$0$"		@Override"
"ResolvableType.java:1528"$1$"		public String getTypeName() {"
"ResolvableType.java:1529"$1$"			String typeName = this.rawType.getTypeName();"
"ResolvableType.java:1530"$1$"			if (this.typeArguments.length > 0) {"
"ResolvableType.java:1531"$1$"				StringJoiner stringJoiner = new StringJoiner("", "", ""<"", "">"");"
"ResolvableType.java:1532"$1$"				for (Type argument : this.typeArguments) {"
"ResolvableType.java:1533"$1$"					stringJoiner.add(argument.getTypeName());"
"ResolvableType.java:1534"$1$"				}"
"ResolvableType.java:1535"$0$"				return typeName + stringJoiner;"
"ResolvableType.java:1536"$0$"			}"
"ResolvableType.java:1537"$0$"			return typeName;"
"ResolvableType.java:1538"$0$"		}"
"ResolvableType.java:1539"$0$""
"ResolvableType.java:1540"$0$"		@Override"
"ResolvableType.java:1541"$0$"		@Nullable"
"ResolvableType.java:1542"$1$"		public Type getOwnerType() {"
"ResolvableType.java:1543"$1$"			return null;"
"ResolvableType.java:1544"$1$"		}"
"ResolvableType.java:1545"$0$""
"ResolvableType.java:1546"$0$"		@Override"
"ResolvableType.java:1547"$1$"		public Type getRawType() {"
"ResolvableType.java:1548"$1$"			return this.rawType;"
"ResolvableType.java:1549"$1$"		}"
"ResolvableType.java:1550"$0$""
"ResolvableType.java:1551"$0$"		@Override"
"ResolvableType.java:1552"$1$"		public Type[] getActualTypeArguments() {"
"ResolvableType.java:1553"$1$"			return this.typeArguments;"
"ResolvableType.java:1554"$1$"		}"
"ResolvableType.java:1555"$0$""
"ResolvableType.java:1556"$0$"		@Override"
"ResolvableType.java:1557"$1$"		public boolean equals(@Nullable Object other) {"
"ResolvableType.java:1558"$1$"			if (this == other) {"
"ResolvableType.java:1559"$1$"				return true;"
"ResolvableType.java:1560"$1$"			}"
"ResolvableType.java:1561"$1$"			if (!(other instanceof ParameterizedType)) {"
"ResolvableType.java:1562"$1$"				return false;"
"ResolvableType.java:1563"$1$"			}"
"ResolvableType.java:1564"$0$"			ParameterizedType otherType = (ParameterizedType) other;"
"ResolvableType.java:1565"$0$"			return (otherType.getOwnerType() == null && this.rawType.equals(otherType.getRawType()) &&"
"ResolvableType.java:1566"$0$"					Arrays.equals(this.typeArguments, otherType.getActualTypeArguments()));"
"ResolvableType.java:1567"$0$"		}"
"ResolvableType.java:1568"$0$""
"ResolvableType.java:1569"$0$"		@Override"
"ResolvableType.java:1570"$1$"		public int hashCode() {"
"ResolvableType.java:1571"$1$"			return (this.rawType.hashCode() * 31 + Arrays.hashCode(this.typeArguments));"
"ResolvableType.java:1572"$1$"		}"
"ResolvableType.java:1573"$0$""
"ResolvableType.java:1574"$0$"		@Override"
"ResolvableType.java:1575"$1$"		public String toString() {"
"ResolvableType.java:1576"$1$"			return getTypeName();"
"ResolvableType.java:1577"$1$"		}"
"ResolvableType.java:1578"$0$"	}"
"ResolvableType.java:1579"$0$""
"ResolvableType.java:1580"$0$""
"ResolvableType.java:1581"$0$"	/**"
"ResolvableType.java:1582"$1$"	 * Internal helper to handle bounds from {@link WildcardType WildcardTypes}."
"ResolvableType.java:1583"$0$"	 */"
"ResolvableType.java:1584"$1$"	private static class WildcardBounds {"
"ResolvableType.java:1585"$1$""
"ResolvableType.java:1586"$1$"		private final Kind kind;"
"ResolvableType.java:1587"$1$""
"ResolvableType.java:1588"$1$"		private final ResolvableType[] bounds;"
"ResolvableType.java:1589"$1$""
"ResolvableType.java:1590"$1$"		/**"
"ResolvableType.java:1591"$1$"		 * Internal constructor to create a new {@link WildcardBounds} instance."
"ResolvableType.java:1592"$1$"		 * @param kind the kind of bounds"
"ResolvableType.java:1593"$1$"		 * @param bounds the bounds"
"ResolvableType.java:1594"$1$"		 * @see #get(ResolvableType)"
"ResolvableType.java:1595"$1$"		 */"
"ResolvableType.java:1596"$1$"		public WildcardBounds(Kind kind, ResolvableType[] bounds) {"
"ResolvableType.java:1597"$1$"			this.kind = kind;"
"ResolvableType.java:1598"$1$"			this.bounds = bounds;"
"ResolvableType.java:1599"$1$"		}"
"ResolvableType.java:1600"$0$""
"ResolvableType.java:1601"$0$"		/**"
"ResolvableType.java:1602"$1$"		 * Return {@code true} if this bounds is the same kind as the specified bounds."
"ResolvableType.java:1603"$0$"		 */"
"ResolvableType.java:1604"$1$"		public boolean isSameKind(WildcardBounds bounds) {"
"ResolvableType.java:1605"$1$"			return this.kind == bounds.kind;"
"ResolvableType.java:1606"$1$"		}"
"ResolvableType.java:1607"$0$""
"ResolvableType.java:1608"$0$"		/**"
"ResolvableType.java:1609"$1$"		 * Return {@code true} if this bounds is assignable to all the specified types."
"ResolvableType.java:1610"$0$"		 * @param types the types to test against"
"ResolvableType.java:1611"$1$"		 * @return {@code true} if this bounds is assignable to all types"
"ResolvableType.java:1612"$0$"		 */"
"ResolvableType.java:1613"$1$"		public boolean isAssignableFrom(ResolvableType... types) {"
"ResolvableType.java:1614"$1$"			for (ResolvableType bound : this.bounds) {"
"ResolvableType.java:1615"$1$"				for (ResolvableType type : types) {"
"ResolvableType.java:1616"$1$"					if (!isAssignable(bound, type)) {"
"ResolvableType.java:1617"$1$"						return false;"
"ResolvableType.java:1618"$1$"					}"
"ResolvableType.java:1619"$0$"				}"
"ResolvableType.java:1620"$0$"			}"
"ResolvableType.java:1621"$0$"			return true;"
"ResolvableType.java:1622"$0$"		}"
"ResolvableType.java:1623"$0$""
"ResolvableType.java:1624"$1$"		private boolean isAssignable(ResolvableType source, ResolvableType from) {"
"ResolvableType.java:1625"$1$"			return (this.kind == Kind.UPPER ? source.isAssignableFrom(from) : from.isAssignableFrom(source));"
"ResolvableType.java:1626"$1$"		}"
"ResolvableType.java:1627"$0$""
"ResolvableType.java:1628"$0$"		/**"
"ResolvableType.java:1629"$0$"		 * Return the underlying bounds."
"ResolvableType.java:1630"$0$"		 */"
"ResolvableType.java:1631"$1$"		public ResolvableType[] getBounds() {"
"ResolvableType.java:1632"$1$"			return this.bounds;"
"ResolvableType.java:1633"$1$"		}"
"ResolvableType.java:1634"$0$""
"ResolvableType.java:1635"$0$"		/**"
"ResolvableType.java:1636"$1$"		 * Get a {@link WildcardBounds} instance for the specified type, returning"
"ResolvableType.java:1637"$1$"		 * {@code null} if the specified type cannot be resolved to a {@link WildcardType}."
"ResolvableType.java:1638"$0$"		 * @param type the source type"
"ResolvableType.java:1639"$1$"		 * @return a {@link WildcardBounds} instance or {@code null}"
"ResolvableType.java:1640"$0$"		 */"
"ResolvableType.java:1641"$0$"		@Nullable"
"ResolvableType.java:1642"$1$"		public static WildcardBounds get(ResolvableType type) {"
"ResolvableType.java:1643"$1$"			ResolvableType resolveToWildcard = type;"
"ResolvableType.java:1644"$1$"			while (!(resolveToWildcard.getType() instanceof WildcardType)) {"
"ResolvableType.java:1645"$1$"				if (resolveToWildcard == NONE) {"
"ResolvableType.java:1646"$1$"					return null;"
"ResolvableType.java:1647"$1$"				}"
"ResolvableType.java:1648"$0$"				resolveToWildcard = resolveToWildcard.resolveType();"
"ResolvableType.java:1649"$0$"			}"
"ResolvableType.java:1650"$0$"			WildcardType wildcardType = (WildcardType) resolveToWildcard.type;"
"ResolvableType.java:1651"$0$"			Kind boundsType = (wildcardType.getLowerBounds().length > 0 ? Kind.LOWER : Kind.UPPER);"
"ResolvableType.java:1652"$0$"			Type[] bounds = (boundsType == Kind.UPPER ? wildcardType.getUpperBounds() : wildcardType.getLowerBounds());"
"ResolvableType.java:1653"$0$"			ResolvableType[] resolvableBounds = new ResolvableType[bounds.length];"
"ResolvableType.java:1654"$1$"			for (int i = 0; i < bounds.length; i++) {"
"ResolvableType.java:1655"$1$"				resolvableBounds[i] = ResolvableType.forType(bounds[i], type.variableResolver);"
"ResolvableType.java:1656"$1$"			}"
"ResolvableType.java:1657"$0$"			return new WildcardBounds(boundsType, resolvableBounds);"
"ResolvableType.java:1658"$0$"		}"
"ResolvableType.java:1659"$0$""
"ResolvableType.java:1660"$0$"		/**"
"ResolvableType.java:1661"$0$"		 * The various kinds of bounds."
"ResolvableType.java:1662"$0$"		 */"
"ResolvableType.java:1663"$1$"		enum Kind {UPPER, LOWER}"
"ResolvableType.java:1664"$0$"	}"
"ResolvableType.java:1665"$0$""
"ResolvableType.java:1666"$0$""
"ResolvableType.java:1667"$0$"	/**"
"ResolvableType.java:1668"$1$"	 * Internal {@link Type} used to represent an empty value."
"ResolvableType.java:1669"$0$"	 */"
"ResolvableType.java:1670"$0$"	@SuppressWarnings(""serial"")"
"ResolvableType.java:1671"$1$"	static class EmptyType implements Type, Serializable {"
"ResolvableType.java:1672"$1$""
"ResolvableType.java:1673"$1$"		static final Type INSTANCE = new EmptyType();"
"ResolvableType.java:1674"$1$""
"ResolvableType.java:1675"$1$"		Object readResolve() {"
"ResolvableType.java:1676"$1$"			return INSTANCE;"
"ResolvableType.java:1677"$1$"		}"
"ResolvableType.java:1678"$0$"	}"
"ResolvableType.java:1679"$0$""
"ResolvableType.java:1680"$0$"}"
"Profiles.java:1"$0$"/*"
"Profiles.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"Profiles.java:3"$0$" *"
"Profiles.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Profiles.java:5"$0$" * you may not use this file except in compliance with the License."
"Profiles.java:6"$0$" * You may obtain a copy of the License at"
"Profiles.java:7"$0$" *"
"Profiles.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Profiles.java:9"$0$" *"
"Profiles.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Profiles.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Profiles.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Profiles.java:13"$0$" * See the License for the specific language governing permissions and"
"Profiles.java:14"$0$" * limitations under the License."
"Profiles.java:15"$0$" */"
"Profiles.java:16"$0$""
"Profiles.java:17"$0$"package org.springframework.core.env;"
"Profiles.java:18"$0$""
"Profiles.java:19"$0$"import java.util.function.Predicate;"
"Profiles.java:20"$0$""
"Profiles.java:21"$0$"/**"
"Profiles.java:22"$1$" * Profile predicate that may be {@linkplain Environment#acceptsProfiles(Profiles)"
"Profiles.java:23"$1$" * accepted} by an {@link Environment}."
"Profiles.java:24"$1$" *"
"Profiles.java:25"$1$" * <p>May be implemented directly or, more usually, created using the"
"Profiles.java:26"$1$" * {@link #of(String...) of(...)} factory method."
"Profiles.java:27"$1$" *"
"Profiles.java:28"$1$" * @author Phillip Webb"
"Profiles.java:29"$1$" * @since 5.1"
"Profiles.java:30"$1$" */"
"Profiles.java:31"$1$"FunctionalInterface"
"Profiles.java:32"$1$"public interface Profiles {"
"Profiles.java:33"$1$""
"Profiles.java:34"$1$"	/**"
"Profiles.java:35"$1$"	 * Test if this {@code Profiles} instance <em>matches</em> against the given"
"Profiles.java:36"$1$"	 * active profiles predicate."
"Profiles.java:37"$1$"	 * @param activeProfiles predicate that tests whether a given profile is"
"Profiles.java:38"$1$"	 * currently active"
"Profiles.java:39"$1$"	 */"
"Profiles.java:40"$1$"	boolean matches(Predicate<String> activeProfiles);"
"Profiles.java:41"$1$""
"Profiles.java:42"$1$""
"Profiles.java:43"$1$"	/**"
"Profiles.java:44"$1$"	 * Create a new {@link Profiles} instance that checks for matches against"
"Profiles.java:45"$1$"	 * the given <em>profile strings</em>."
"Profiles.java:46"$1$"	 * <p>The returned instance will {@linkplain Profiles#matches(Predicate) match}"
"Profiles.java:47"$1$"	 * if any one of the given profile strings matches."
"Profiles.java:48"$1$"	 * <p>A profile string may contain a simple profile name (for example"
"Profiles.java:49"$1$"	 * {@code ""production""}) or a profile expression. A profile expression allows"
"Profiles.java:50"$1$"	 * for more complicated profile logic to be expressed, for example"
"Profiles.java:51"$1$"	 * {@code ""production & cloud""}."
"Profiles.java:52"$1$"	 * <p>The following operators are supported in profile expressions:"
"Profiles.java:53"$1$"	 * <ul>"
"Profiles.java:54"$1$"	 * <li>{@code !} - A logical <em>not</em> of the profile</li>"
"Profiles.java:55"$1$"	 * <li>{@code &} - A logical <em>and</em> of the profiles</li>"
"Profiles.java:56"$1$"	 * <li>{@code |} - A logical <em>or</em> of the profiles</li>"
"Profiles.java:57"$1$"	 * </ul>"
"Profiles.java:58"$1$"	 * <p>Please note that the {@code &} and {@code |} operators may not be mixed"
"Profiles.java:59"$1$"	 * without using parentheses. For example {@code ""a & b | c""} is not a valid"
"Profiles.java:60"$1$"	 * expression; it must be expressed as {@code ""(a & b) | c""} or"
"Profiles.java:61"$1$"	 * {@code ""a & (b | c)""}."
"Profiles.java:62"$1$"	 * @param profiles the <em>profile strings</em> to include"
"Profiles.java:63"$1$"	 * @return a new {@link Profiles} instance"
"Profiles.java:64"$1$"	 */"
"Profiles.java:65"$1$"	static Profiles of(String... profiles) {"
"Profiles.java:66"$1$"		return ProfilesParser.parse(profiles);"
"Profiles.java:67"$1$"	}"
"Profiles.java:68"$0$""
"Profiles.java:69"$0$"}"
"SpringFactoriesLoader.java:1"$0$"/*"
"SpringFactoriesLoader.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SpringFactoriesLoader.java:3"$0$" *"
"SpringFactoriesLoader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SpringFactoriesLoader.java:5"$0$" * you may not use this file except in compliance with the License."
"SpringFactoriesLoader.java:6"$0$" * You may obtain a copy of the License at"
"SpringFactoriesLoader.java:7"$0$" *"
"SpringFactoriesLoader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SpringFactoriesLoader.java:9"$0$" *"
"SpringFactoriesLoader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SpringFactoriesLoader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SpringFactoriesLoader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SpringFactoriesLoader.java:13"$0$" * See the License for the specific language governing permissions and"
"SpringFactoriesLoader.java:14"$0$" * limitations under the License."
"SpringFactoriesLoader.java:15"$0$" */"
"SpringFactoriesLoader.java:16"$0$""
"SpringFactoriesLoader.java:17"$0$"package org.springframework.core.io.support;"
"SpringFactoriesLoader.java:18"$0$""
"SpringFactoriesLoader.java:19"$0$"import java.io.IOException;"
"SpringFactoriesLoader.java:20"$0$"import java.net.URL;"
"SpringFactoriesLoader.java:21"$0$"import java.util.ArrayList;"
"SpringFactoriesLoader.java:22"$0$"import java.util.Collections;"
"SpringFactoriesLoader.java:23"$0$"import java.util.Enumeration;"
"SpringFactoriesLoader.java:24"$0$"import java.util.List;"
"SpringFactoriesLoader.java:25"$0$"import java.util.Map;"
"SpringFactoriesLoader.java:26"$0$"import java.util.Properties;"
"SpringFactoriesLoader.java:27"$0$""
"SpringFactoriesLoader.java:28"$0$"import org.apache.commons.logging.Log;"
"SpringFactoriesLoader.java:29"$0$"import org.apache.commons.logging.LogFactory;"
"SpringFactoriesLoader.java:30"$0$""
"SpringFactoriesLoader.java:31"$0$"import org.springframework.core.annotation.AnnotationAwareOrderComparator;"
"SpringFactoriesLoader.java:32"$0$"import org.springframework.core.io.UrlResource;"
"SpringFactoriesLoader.java:33"$0$"import org.springframework.lang.Nullable;"
"SpringFactoriesLoader.java:34"$0$"import org.springframework.util.Assert;"
"SpringFactoriesLoader.java:35"$0$"import org.springframework.util.ClassUtils;"
"SpringFactoriesLoader.java:36"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"SpringFactoriesLoader.java:37"$0$"import org.springframework.util.LinkedMultiValueMap;"
"SpringFactoriesLoader.java:38"$0$"import org.springframework.util.MultiValueMap;"
"SpringFactoriesLoader.java:39"$0$"import org.springframework.util.ReflectionUtils;"
"SpringFactoriesLoader.java:40"$0$"import org.springframework.util.StringUtils;"
"SpringFactoriesLoader.java:41"$0$""
"SpringFactoriesLoader.java:42"$0$"/**"
"SpringFactoriesLoader.java:43"$0$" * General purpose factory loading mechanism for internal use within the framework."
"SpringFactoriesLoader.java:44"$0$" *"
"SpringFactoriesLoader.java:45"$1$" * <p>{@code SpringFactoriesLoader} {@linkplain #loadFactories loads} and instantiates"
"SpringFactoriesLoader.java:46"$1$" * factories of a given type from {@value #FACTORIES_RESOURCE_LOCATION} files which"
"SpringFactoriesLoader.java:47"$1$" * may be present in multiple JAR files in the classpath. The {@code spring.factories}"
"SpringFactoriesLoader.java:48"$1$" * file must be in {@link Properties} format, where the key is the fully qualified"
"SpringFactoriesLoader.java:49"$0$" * name of the interface or abstract class, and the value is a comma-separated list of"
"SpringFactoriesLoader.java:50"$0$" * implementation class names. For example:"
"SpringFactoriesLoader.java:51"$0$" *"
"SpringFactoriesLoader.java:52"$0$" * <pre class=""code"">example.MyService=example.MyServiceImpl1,example.MyServiceImpl2</pre>"
"SpringFactoriesLoader.java:53"$0$" *"
"SpringFactoriesLoader.java:54"$1$" * where {@code example.MyService} is the name of the interface, and {@code MyServiceImpl1}"
"SpringFactoriesLoader.java:55"$1$" * and {@code MyServiceImpl2} are two implementations."
"SpringFactoriesLoader.java:56"$0$" *"
"SpringFactoriesLoader.java:57"$0$" * @author Arjen Poutsma"
"SpringFactoriesLoader.java:58"$0$" * @author Juergen Hoeller"
"SpringFactoriesLoader.java:59"$0$" * @author Sam Brannen"
"SpringFactoriesLoader.java:60"$0$" * @since 3.2"
"SpringFactoriesLoader.java:61"$0$" */"
"SpringFactoriesLoader.java:62"$1$"public final class SpringFactoriesLoader {"
"SpringFactoriesLoader.java:63"$1$""
"SpringFactoriesLoader.java:64"$1$"	/**"
"SpringFactoriesLoader.java:65"$1$"	 * The location to look for factories."
"SpringFactoriesLoader.java:66"$1$"	 * <p>Can be present in multiple JAR files."
"SpringFactoriesLoader.java:67"$1$"	 */"
"SpringFactoriesLoader.java:68"$1$"	public static final String FACTORIES_RESOURCE_LOCATION = ""META-INF/spring.factories"";"
"SpringFactoriesLoader.java:69"$1$""
"SpringFactoriesLoader.java:70"$1$""
"SpringFactoriesLoader.java:71"$1$"	private static final Log logger = LogFactory.getLog(SpringFactoriesLoader.class);"
"SpringFactoriesLoader.java:72"$1$""
"SpringFactoriesLoader.java:73"$1$"	private static final Map<ClassLoader, MultiValueMap<String, String>> cache = new ConcurrentReferenceHashMap<>();"
"SpringFactoriesLoader.java:74"$1$""
"SpringFactoriesLoader.java:75"$1$""
"SpringFactoriesLoader.java:76"$1$"	private SpringFactoriesLoader() {"
"SpringFactoriesLoader.java:77"$1$"	}"
"SpringFactoriesLoader.java:78"$0$""
"SpringFactoriesLoader.java:79"$0$""
"SpringFactoriesLoader.java:80"$0$"	/**"
"SpringFactoriesLoader.java:81"$0$"	 * Load and instantiate the factory implementations of the given type from"
"SpringFactoriesLoader.java:82"$1$"	 * {@value #FACTORIES_RESOURCE_LOCATION}, using the given class loader."
"SpringFactoriesLoader.java:83"$1$"	 * <p>The returned factories are sorted through {@link AnnotationAwareOrderComparator}."
"SpringFactoriesLoader.java:84"$1$"	 * <p>If a custom instantiation strategy is required, use {@link #loadFactoryNames}"
"SpringFactoriesLoader.java:85"$0$"	 * to obtain all registered factory names."
"SpringFactoriesLoader.java:86"$0$"	 * @param factoryType the interface or abstract class representing the factory"
"SpringFactoriesLoader.java:87"$1$"	 * @param classLoader the ClassLoader to use for loading (can be {@code null} to use the default)"
"SpringFactoriesLoader.java:88"$0$"	 * @throws IllegalArgumentException if any factory implementation class cannot"
"SpringFactoriesLoader.java:89"$0$"	 * be loaded or if an error occurs while instantiating any factory"
"SpringFactoriesLoader.java:90"$0$"	 * @see #loadFactoryNames"
"SpringFactoriesLoader.java:91"$0$"	 */"
"SpringFactoriesLoader.java:92"$1$"	public static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {"
"SpringFactoriesLoader.java:93"$1$"		Assert.notNull(factoryType, ""'factoryType' must not be null"");"
"SpringFactoriesLoader.java:94"$1$"		ClassLoader classLoaderToUse = classLoader;"
"SpringFactoriesLoader.java:95"$1$"		if (classLoaderToUse == null) {"
"SpringFactoriesLoader.java:96"$1$"			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();"
"SpringFactoriesLoader.java:97"$1$"		}"
"SpringFactoriesLoader.java:98"$0$"		List<String> factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);"
"SpringFactoriesLoader.java:99"$1$"		if (logger.isTraceEnabled()) {"
"SpringFactoriesLoader.java:100"$1$"			logger.trace(""Loaded ["" + factoryType.getName() + ""] names: "" + factoryImplementationNames);"
"SpringFactoriesLoader.java:101"$1$"		}"
"SpringFactoriesLoader.java:102"$0$"		List<T> result = new ArrayList<>(factoryImplementationNames.size());"
"SpringFactoriesLoader.java:103"$1$"		for (String factoryImplementationName : factoryImplementationNames) {"
"SpringFactoriesLoader.java:104"$1$"			result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));"
"SpringFactoriesLoader.java:105"$1$"		}"
"SpringFactoriesLoader.java:106"$0$"		AnnotationAwareOrderComparator.sort(result);"
"SpringFactoriesLoader.java:107"$0$"		return result;"
"SpringFactoriesLoader.java:108"$0$"	}"
"SpringFactoriesLoader.java:109"$0$""
"SpringFactoriesLoader.java:110"$0$"	/**"
"SpringFactoriesLoader.java:111"$0$"	 * Load the fully qualified class names of factory implementations of the"
"SpringFactoriesLoader.java:112"$1$"	 * given type from {@value #FACTORIES_RESOURCE_LOCATION}, using the given"
"SpringFactoriesLoader.java:113"$0$"	 * class loader."
"SpringFactoriesLoader.java:114"$0$"	 * @param factoryType the interface or abstract class representing the factory"
"SpringFactoriesLoader.java:115"$0$"	 * @param classLoader the ClassLoader to use for loading resources; can be"
"SpringFactoriesLoader.java:116"$1$"	 * {@code null} to use the default"
"SpringFactoriesLoader.java:117"$0$"	 * @throws IllegalArgumentException if an error occurs while loading factory names"
"SpringFactoriesLoader.java:118"$0$"	 * @see #loadFactories"
"SpringFactoriesLoader.java:119"$0$"	 */"
"SpringFactoriesLoader.java:120"$1$"	public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {"
"SpringFactoriesLoader.java:121"$1$"		String factoryTypeName = factoryType.getName();"
"SpringFactoriesLoader.java:122"$1$"		return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());"
"SpringFactoriesLoader.java:123"$1$"	}"
"SpringFactoriesLoader.java:124"$0$""
"SpringFactoriesLoader.java:125"$1$"	private static Map<String, List<String>> loadSpringFactories(@Nullable ClassLoader classLoader) {"
"SpringFactoriesLoader.java:126"$1$"		MultiValueMap<String, String> result = cache.get(classLoader);"
"SpringFactoriesLoader.java:127"$1$"		if (result != null) {"
"SpringFactoriesLoader.java:128"$1$"			return result;"
"SpringFactoriesLoader.java:129"$1$"		}"
"SpringFactoriesLoader.java:130"$0$""
"SpringFactoriesLoader.java:131"$1$"		try {"
"SpringFactoriesLoader.java:132"$1$"			Enumeration<URL> urls = (classLoader != null ?"
"SpringFactoriesLoader.java:133"$1$"					classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :"
"SpringFactoriesLoader.java:134"$1$"					ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));"
"SpringFactoriesLoader.java:135"$1$"			result = new LinkedMultiValueMap<>();"
"SpringFactoriesLoader.java:136"$1$"			while (urls.hasMoreElements()) {"
"SpringFactoriesLoader.java:137"$1$"				URL url = urls.nextElement();"
"SpringFactoriesLoader.java:138"$1$"				UrlResource resource = new UrlResource(url);"
"SpringFactoriesLoader.java:139"$1$"				Properties properties = PropertiesLoaderUtils.loadProperties(resource);"
"SpringFactoriesLoader.java:140"$1$"				for (Map.Entry<?, ?> entry : properties.entrySet()) {"
"SpringFactoriesLoader.java:141"$1$"					String factoryTypeName = ((String) entry.getKey()).trim();"
"SpringFactoriesLoader.java:142"$1$"					for (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) {"
"SpringFactoriesLoader.java:143"$1$"						result.add(factoryTypeName, factoryImplementationName.trim());"
"SpringFactoriesLoader.java:144"$1$"					}"
"SpringFactoriesLoader.java:145"$0$"				}"
"SpringFactoriesLoader.java:146"$0$"			}"
"SpringFactoriesLoader.java:147"$0$"			cache.put(classLoader, result);"
"SpringFactoriesLoader.java:148"$0$"			return result;"
"SpringFactoriesLoader.java:149"$0$"		}"
"SpringFactoriesLoader.java:150"$1$"		catch (IOException ex) {"
"SpringFactoriesLoader.java:151"$1$"			throw new IllegalArgumentException(""Unable to load factories from location ["" +"
"SpringFactoriesLoader.java:152"$1$"					FACTORIES_RESOURCE_LOCATION + ""]"", ex);"
"SpringFactoriesLoader.java:153"$1$"		}"
"SpringFactoriesLoader.java:154"$0$"	}"
"SpringFactoriesLoader.java:155"$0$""
"SpringFactoriesLoader.java:156"$0$"	@SuppressWarnings(""unchecked"")"
"SpringFactoriesLoader.java:157"$1$"	private static <T> T instantiateFactory(String factoryImplementationName, Class<T> factoryType, ClassLoader classLoader) {"
"SpringFactoriesLoader.java:158"$1$"		try {"
"SpringFactoriesLoader.java:159"$1$"			Class<?> factoryImplementationClass = ClassUtils.forName(factoryImplementationName, classLoader);"
"SpringFactoriesLoader.java:160"$1$"			if (!factoryType.isAssignableFrom(factoryImplementationClass)) {"
"SpringFactoriesLoader.java:161"$1$"				throw new IllegalArgumentException("
"SpringFactoriesLoader.java:162"$1$"						""Class ["" + factoryImplementationName + ""] is not assignable to factory type ["" + factoryType.getName() + ""]"");"
"SpringFactoriesLoader.java:163"$1$"			}"
"SpringFactoriesLoader.java:164"$0$"			return (T) ReflectionUtils.accessibleConstructor(factoryImplementationClass).newInstance();"
"SpringFactoriesLoader.java:165"$0$"		}"
"SpringFactoriesLoader.java:166"$1$"		catch (Throwable ex) {"
"SpringFactoriesLoader.java:167"$1$"			throw new IllegalArgumentException("
"SpringFactoriesLoader.java:168"$1$"				""Unable to instantiate factory class ["" + factoryImplementationName + ""] for factory type ["" + factoryType.getName() + ""]"","
"SpringFactoriesLoader.java:169"$1$"				ex);"
"SpringFactoriesLoader.java:170"$1$"		}"
"SpringFactoriesLoader.java:171"$0$"	}"
"SpringFactoriesLoader.java:172"$0$""
"SpringFactoriesLoader.java:173"$0$"}"
"ClassPathResource.java:1"$0$"/*"
"ClassPathResource.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ClassPathResource.java:3"$0$" *"
"ClassPathResource.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ClassPathResource.java:5"$0$" * you may not use this file except in compliance with the License."
"ClassPathResource.java:6"$0$" * You may obtain a copy of the License at"
"ClassPathResource.java:7"$0$" *"
"ClassPathResource.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ClassPathResource.java:9"$0$" *"
"ClassPathResource.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ClassPathResource.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ClassPathResource.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ClassPathResource.java:13"$0$" * See the License for the specific language governing permissions and"
"ClassPathResource.java:14"$0$" * limitations under the License."
"ClassPathResource.java:15"$0$" */"
"ClassPathResource.java:16"$0$""
"ClassPathResource.java:17"$0$"package org.springframework.core.io;"
"ClassPathResource.java:18"$0$""
"ClassPathResource.java:19"$0$"import java.io.FileNotFoundException;"
"ClassPathResource.java:20"$0$"import java.io.IOException;"
"ClassPathResource.java:21"$0$"import java.io.InputStream;"
"ClassPathResource.java:22"$0$"import java.net.URL;"
"ClassPathResource.java:23"$0$""
"ClassPathResource.java:24"$0$"import org.springframework.lang.Nullable;"
"ClassPathResource.java:25"$0$"import org.springframework.util.Assert;"
"ClassPathResource.java:26"$0$"import org.springframework.util.ClassUtils;"
"ClassPathResource.java:27"$0$"import org.springframework.util.ObjectUtils;"
"ClassPathResource.java:28"$0$"import org.springframework.util.StringUtils;"
"ClassPathResource.java:29"$0$""
"ClassPathResource.java:30"$0$"/**"
"ClassPathResource.java:31"$1$" * {@link Resource} implementation for class path resources. Uses either a"
"ClassPathResource.java:32"$1$" * given {@link ClassLoader} or a given {@link Class} for loading resources."
"ClassPathResource.java:33"$0$" *"
"ClassPathResource.java:34"$1$" * <p>Supports resolution as {@code java.io.File} if the class path"
"ClassPathResource.java:35"$0$" * resource resides in the file system, but not for resources in a JAR."
"ClassPathResource.java:36"$0$" * Always supports resolution as URL."
"ClassPathResource.java:37"$0$" *"
"ClassPathResource.java:38"$0$" * @author Juergen Hoeller"
"ClassPathResource.java:39"$0$" * @author Sam Brannen"
"ClassPathResource.java:40"$0$" * @since 28.12.2003"
"ClassPathResource.java:41"$0$" * @see ClassLoader#getResourceAsStream(String)"
"ClassPathResource.java:42"$0$" * @see Class#getResourceAsStream(String)"
"ClassPathResource.java:43"$0$" */"
"ClassPathResource.java:44"$1$"public class ClassPathResource extends AbstractFileResolvingResource {"
"ClassPathResource.java:45"$1$""
"ClassPathResource.java:46"$1$"	private final String path;"
"ClassPathResource.java:47"$1$""
"ClassPathResource.java:48"$1$"	@Nullable"
"ClassPathResource.java:49"$1$"	private ClassLoader classLoader;"
"ClassPathResource.java:50"$1$""
"ClassPathResource.java:51"$1$"	@Nullable"
"ClassPathResource.java:52"$1$"	private Class<?> clazz;"
"ClassPathResource.java:53"$1$""
"ClassPathResource.java:54"$1$""
"ClassPathResource.java:55"$1$"	/**"
"ClassPathResource.java:56"$1$"	 * Create a new {@code ClassPathResource} for {@code ClassLoader} usage."
"ClassPathResource.java:57"$1$"	 * A leading slash will be removed, as the ClassLoader resource access"
"ClassPathResource.java:58"$1$"	 * methods will not accept it."
"ClassPathResource.java:59"$1$"	 * <p>The thread context class loader will be used for"
"ClassPathResource.java:60"$1$"	 * loading the resource."
"ClassPathResource.java:61"$1$"	 * @param path the absolute path within the class path"
"ClassPathResource.java:62"$1$"	 * @see java.lang.ClassLoader#getResourceAsStream(String)"
"ClassPathResource.java:63"$1$"	 * @see org.springframework.util.ClassUtils#getDefaultClassLoader()"
"ClassPathResource.java:64"$1$"	 */"
"ClassPathResource.java:65"$1$"	public ClassPathResource(String path) {"
"ClassPathResource.java:66"$1$"		this(path, (ClassLoader) null);"
"ClassPathResource.java:67"$1$"	}"
"ClassPathResource.java:68"$0$""
"ClassPathResource.java:69"$0$"	/**"
"ClassPathResource.java:70"$1$"	 * Create a new {@code ClassPathResource} for {@code ClassLoader} usage."
"ClassPathResource.java:71"$0$"	 * A leading slash will be removed, as the ClassLoader resource access"
"ClassPathResource.java:72"$0$"	 * methods will not accept it."
"ClassPathResource.java:73"$0$"	 * @param path the absolute path within the classpath"
"ClassPathResource.java:74"$0$"	 * @param classLoader the class loader to load the resource with,"
"ClassPathResource.java:75"$1$"	 * or {@code null} for the thread context class loader"
"ClassPathResource.java:76"$0$"	 * @see ClassLoader#getResourceAsStream(String)"
"ClassPathResource.java:77"$0$"	 */"
"ClassPathResource.java:78"$1$"	public ClassPathResource(String path, @Nullable ClassLoader classLoader) {"
"ClassPathResource.java:79"$1$"		Assert.notNull(path, ""Path must not be null"");"
"ClassPathResource.java:80"$1$"		String pathToUse = StringUtils.cleanPath(path);"
"ClassPathResource.java:81"$1$"		if (pathToUse.startsWith(""/"")) {"
"ClassPathResource.java:82"$1$"			pathToUse = pathToUse.substring(1);"
"ClassPathResource.java:83"$1$"		}"
"ClassPathResource.java:84"$0$"		this.path = pathToUse;"
"ClassPathResource.java:85"$0$"		this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());"
"ClassPathResource.java:86"$0$"	}"
"ClassPathResource.java:87"$0$""
"ClassPathResource.java:88"$0$"	/**"
"ClassPathResource.java:89"$1$"	 * Create a new {@code ClassPathResource} for {@code Class} usage."
"ClassPathResource.java:90"$0$"	 * The path can be relative to the given class, or absolute within"
"ClassPathResource.java:91"$0$"	 * the classpath via a leading slash."
"ClassPathResource.java:92"$0$"	 * @param path relative or absolute path within the class path"
"ClassPathResource.java:93"$0$"	 * @param clazz the class to load resources with"
"ClassPathResource.java:94"$0$"	 * @see java.lang.Class#getResourceAsStream"
"ClassPathResource.java:95"$0$"	 */"
"ClassPathResource.java:96"$1$"	public ClassPathResource(String path, @Nullable Class<?> clazz) {"
"ClassPathResource.java:97"$1$"		Assert.notNull(path, ""Path must not be null"");"
"ClassPathResource.java:98"$1$"		this.path = StringUtils.cleanPath(path);"
"ClassPathResource.java:99"$1$"		this.clazz = clazz;"
"ClassPathResource.java:100"$1$"	}"
"ClassPathResource.java:101"$0$""
"ClassPathResource.java:102"$0$"	/**"
"ClassPathResource.java:103"$1$"	 * Create a new {@code ClassPathResource} with optional {@code ClassLoader}"
"ClassPathResource.java:104"$1$"	 * and {@code Class}. Only for internal usage."
"ClassPathResource.java:105"$0$"	 * @param path relative or absolute path within the classpath"
"ClassPathResource.java:106"$0$"	 * @param classLoader the class loader to load the resource with, if any"
"ClassPathResource.java:107"$0$"	 * @param clazz the class to load resources with, if any"
"ClassPathResource.java:108"$0$"	 * @deprecated as of 4.3.13, in favor of selective use of"
"ClassPathResource.java:109"$1$"	 * {@link #ClassPathResource(String, ClassLoader)} vs {@link #ClassPathResource(String, Class)}"
"ClassPathResource.java:110"$0$"	 */"
"ClassPathResource.java:111"$0$"	@Deprecated"
"ClassPathResource.java:112"$1$"	protected ClassPathResource(String path, @Nullable ClassLoader classLoader, @Nullable Class<?> clazz) {"
"ClassPathResource.java:113"$1$"		this.path = StringUtils.cleanPath(path);"
"ClassPathResource.java:114"$1$"		this.classLoader = classLoader;"
"ClassPathResource.java:115"$1$"		this.clazz = clazz;"
"ClassPathResource.java:116"$1$"	}"
"ClassPathResource.java:117"$0$""
"ClassPathResource.java:118"$0$""
"ClassPathResource.java:119"$0$"	/**"
"ClassPathResource.java:120"$0$"	 * Return the path for this resource (as resource path within the class path)."
"ClassPathResource.java:121"$0$"	 */"
"ClassPathResource.java:122"$1$"	public final String getPath() {"
"ClassPathResource.java:123"$1$"		return this.path;"
"ClassPathResource.java:124"$1$"	}"
"ClassPathResource.java:125"$0$""
"ClassPathResource.java:126"$0$"	/**"
"ClassPathResource.java:127"$0$"	 * Return the ClassLoader that this resource will be obtained from."
"ClassPathResource.java:128"$0$"	 */"
"ClassPathResource.java:129"$0$"	@Nullable"
"ClassPathResource.java:130"$1$"	public final ClassLoader getClassLoader() {"
"ClassPathResource.java:131"$1$"		return (this.clazz != null ? this.clazz.getClassLoader() : this.classLoader);"
"ClassPathResource.java:132"$1$"	}"
"ClassPathResource.java:133"$0$""
"ClassPathResource.java:134"$0$""
"ClassPathResource.java:135"$0$"	/**"
"ClassPathResource.java:136"$0$"	 * This implementation checks for the resolution of a resource URL."
"ClassPathResource.java:137"$0$"	 * @see java.lang.ClassLoader#getResource(String)"
"ClassPathResource.java:138"$0$"	 * @see java.lang.Class#getResource(String)"
"ClassPathResource.java:139"$0$"	 */"
"ClassPathResource.java:140"$0$"	@Override"
"ClassPathResource.java:141"$1$"	public boolean exists() {"
"ClassPathResource.java:142"$1$"		return (resolveURL() != null);"
"ClassPathResource.java:143"$1$"	}"
"ClassPathResource.java:144"$0$""
"ClassPathResource.java:145"$0$"	/**"
"ClassPathResource.java:146"$0$"	 * Resolves a URL for the underlying class path resource."
"ClassPathResource.java:147"$1$"	 * @return the resolved URL, or {@code null} if not resolvable"
"ClassPathResource.java:148"$0$"	 */"
"ClassPathResource.java:149"$0$"	@Nullable"
"ClassPathResource.java:150"$1$"	protected URL resolveURL() {"
"ClassPathResource.java:151"$1$"		if (this.clazz != null) {"
"ClassPathResource.java:152"$1$"			return this.clazz.getResource(this.path);"
"ClassPathResource.java:153"$1$"		}"
"ClassPathResource.java:154"$1$"		else if (this.classLoader != null) {"
"ClassPathResource.java:155"$1$"			return this.classLoader.getResource(this.path);"
"ClassPathResource.java:156"$1$"		}"
"ClassPathResource.java:157"$1$"		else {"
"ClassPathResource.java:158"$1$"			return ClassLoader.getSystemResource(this.path);"
"ClassPathResource.java:159"$1$"		}"
"ClassPathResource.java:160"$0$"	}"
"ClassPathResource.java:161"$0$""
"ClassPathResource.java:162"$0$"	/**"
"ClassPathResource.java:163"$0$"	 * This implementation opens an InputStream for the given class path resource."
"ClassPathResource.java:164"$0$"	 * @see java.lang.ClassLoader#getResourceAsStream(String)"
"ClassPathResource.java:165"$0$"	 * @see java.lang.Class#getResourceAsStream(String)"
"ClassPathResource.java:166"$0$"	 */"
"ClassPathResource.java:167"$0$"	@Override"
"ClassPathResource.java:168"$1$"	public InputStream getInputStream() throws IOException {"
"ClassPathResource.java:169"$1$"		InputStream is;"
"ClassPathResource.java:170"$1$"		if (this.clazz != null) {"
"ClassPathResource.java:171"$1$"			is = this.clazz.getResourceAsStream(this.path);"
"ClassPathResource.java:172"$1$"		}"
"ClassPathResource.java:173"$1$"		else if (this.classLoader != null) {"
"ClassPathResource.java:174"$1$"			is = this.classLoader.getResourceAsStream(this.path);"
"ClassPathResource.java:175"$1$"		}"
"ClassPathResource.java:176"$1$"		else {"
"ClassPathResource.java:177"$1$"			is = ClassLoader.getSystemResourceAsStream(this.path);"
"ClassPathResource.java:178"$1$"		}"
"ClassPathResource.java:179"$1$"		if (is == null) {"
"ClassPathResource.java:180"$1$"			throw new FileNotFoundException(getDescription() + "" cannot be opened because it does not exist"");"
"ClassPathResource.java:181"$1$"		}"
"ClassPathResource.java:182"$0$"		return is;"
"ClassPathResource.java:183"$0$"	}"
"ClassPathResource.java:184"$0$""
"ClassPathResource.java:185"$0$"	/**"
"ClassPathResource.java:186"$0$"	 * This implementation returns a URL for the underlying class path resource,"
"ClassPathResource.java:187"$0$"	 * if available."
"ClassPathResource.java:188"$0$"	 * @see java.lang.ClassLoader#getResource(String)"
"ClassPathResource.java:189"$0$"	 * @see java.lang.Class#getResource(String)"
"ClassPathResource.java:190"$0$"	 */"
"ClassPathResource.java:191"$0$"	@Override"
"ClassPathResource.java:192"$1$"	public URL getURL() throws IOException {"
"ClassPathResource.java:193"$1$"		URL url = resolveURL();"
"ClassPathResource.java:194"$1$"		if (url == null) {"
"ClassPathResource.java:195"$1$"			throw new FileNotFoundException(getDescription() + "" cannot be resolved to URL because it does not exist"");"
"ClassPathResource.java:196"$1$"		}"
"ClassPathResource.java:197"$0$"		return url;"
"ClassPathResource.java:198"$0$"	}"
"ClassPathResource.java:199"$0$""
"ClassPathResource.java:200"$0$"	/**"
"ClassPathResource.java:201"$0$"	 * This implementation creates a ClassPathResource, applying the given path"
"ClassPathResource.java:202"$0$"	 * relative to the path of the underlying resource of this descriptor."
"ClassPathResource.java:203"$0$"	 * @see org.springframework.util.StringUtils#applyRelativePath(String, String)"
"ClassPathResource.java:204"$0$"	 */"
"ClassPathResource.java:205"$0$"	@Override"
"ClassPathResource.java:206"$1$"	public Resource createRelative(String relativePath) {"
"ClassPathResource.java:207"$1$"		String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);"
"ClassPathResource.java:208"$1$"		return (this.clazz != null ? new ClassPathResource(pathToUse, this.clazz) :"
"ClassPathResource.java:209"$1$"				new ClassPathResource(pathToUse, this.classLoader));"
"ClassPathResource.java:210"$1$"	}"
"ClassPathResource.java:211"$0$""
"ClassPathResource.java:212"$0$"	/**"
"ClassPathResource.java:213"$0$"	 * This implementation returns the name of the file that this class path"
"ClassPathResource.java:214"$0$"	 * resource refers to."
"ClassPathResource.java:215"$0$"	 * @see org.springframework.util.StringUtils#getFilename(String)"
"ClassPathResource.java:216"$0$"	 */"
"ClassPathResource.java:217"$0$"	@Override"
"ClassPathResource.java:218"$0$"	@Nullable"
"ClassPathResource.java:219"$1$"	public String getFilename() {"
"ClassPathResource.java:220"$1$"		return StringUtils.getFilename(this.path);"
"ClassPathResource.java:221"$1$"	}"
"ClassPathResource.java:222"$0$""
"ClassPathResource.java:223"$0$"	/**"
"ClassPathResource.java:224"$0$"	 * This implementation returns a description that includes the class path location."
"ClassPathResource.java:225"$0$"	 */"
"ClassPathResource.java:226"$0$"	@Override"
"ClassPathResource.java:227"$1$"	public String getDescription() {"
"ClassPathResource.java:228"$1$"		StringBuilder builder = new StringBuilder(""class path resource ["");"
"ClassPathResource.java:229"$1$"		String pathToUse = this.path;"
"ClassPathResource.java:230"$1$"		if (this.clazz != null && !pathToUse.startsWith(""/"")) {"
"ClassPathResource.java:231"$1$"			builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));"
"ClassPathResource.java:232"$1$"			builder.append('/');"
"ClassPathResource.java:233"$1$"		}"
"ClassPathResource.java:234"$1$"		if (pathToUse.startsWith(""/"")) {"
"ClassPathResource.java:235"$1$"			pathToUse = pathToUse.substring(1);"
"ClassPathResource.java:236"$1$"		}"
"ClassPathResource.java:237"$0$"		builder.append(pathToUse);"
"ClassPathResource.java:238"$0$"		builder.append(']');"
"ClassPathResource.java:239"$0$"		return builder.toString();"
"ClassPathResource.java:240"$0$"	}"
"ClassPathResource.java:241"$0$""
"ClassPathResource.java:242"$0$""
"ClassPathResource.java:243"$0$"	/**"
"ClassPathResource.java:244"$0$"	 * This implementation compares the underlying class path locations."
"ClassPathResource.java:245"$0$"	 */"
"ClassPathResource.java:246"$0$"	@Override"
"ClassPathResource.java:247"$1$"	public boolean equals(@Nullable Object other) {"
"ClassPathResource.java:248"$1$"		if (this == other) {"
"ClassPathResource.java:249"$1$"			return true;"
"ClassPathResource.java:250"$1$"		}"
"ClassPathResource.java:251"$1$"		if (!(other instanceof ClassPathResource)) {"
"ClassPathResource.java:252"$1$"			return false;"
"ClassPathResource.java:253"$1$"		}"
"ClassPathResource.java:254"$0$"		ClassPathResource otherRes = (ClassPathResource) other;"
"ClassPathResource.java:255"$0$"		return (this.path.equals(otherRes.path) &&"
"ClassPathResource.java:256"$0$"				ObjectUtils.nullSafeEquals(this.classLoader, otherRes.classLoader) &&"
"ClassPathResource.java:257"$0$"				ObjectUtils.nullSafeEquals(this.clazz, otherRes.clazz));"
"ClassPathResource.java:258"$0$"	}"
"ClassPathResource.java:259"$0$""
"ClassPathResource.java:260"$0$"	/**"
"ClassPathResource.java:261"$0$"	 * This implementation returns the hash code of the underlying"
"ClassPathResource.java:262"$0$"	 * class path location."
"ClassPathResource.java:263"$0$"	 */"
"ClassPathResource.java:264"$0$"	@Override"
"ClassPathResource.java:265"$1$"	public int hashCode() {"
"ClassPathResource.java:266"$1$"		return this.path.hashCode();"
"ClassPathResource.java:267"$1$"	}"
"ClassPathResource.java:268"$0$""
"ClassPathResource.java:269"$0$"}"
"MethodParameter.java:1"$0$"/*"
"MethodParameter.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"MethodParameter.java:3"$0$" *"
"MethodParameter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MethodParameter.java:5"$0$" * you may not use this file except in compliance with the License."
"MethodParameter.java:6"$0$" * You may obtain a copy of the License at"
"MethodParameter.java:7"$0$" *"
"MethodParameter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MethodParameter.java:9"$0$" *"
"MethodParameter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MethodParameter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MethodParameter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MethodParameter.java:13"$0$" * See the License for the specific language governing permissions and"
"MethodParameter.java:14"$0$" * limitations under the License."
"MethodParameter.java:15"$0$" */"
"MethodParameter.java:16"$0$""
"MethodParameter.java:17"$0$"package org.springframework.core;"
"MethodParameter.java:18"$0$""
"MethodParameter.java:19"$0$"import java.lang.annotation.Annotation;"
"MethodParameter.java:20"$0$"import java.lang.reflect.AnnotatedElement;"
"MethodParameter.java:21"$0$"import java.lang.reflect.Constructor;"
"MethodParameter.java:22"$0$"import java.lang.reflect.Executable;"
"MethodParameter.java:23"$0$"import java.lang.reflect.Member;"
"MethodParameter.java:24"$0$"import java.lang.reflect.Method;"
"MethodParameter.java:25"$0$"import java.lang.reflect.Parameter;"
"MethodParameter.java:26"$0$"import java.lang.reflect.ParameterizedType;"
"MethodParameter.java:27"$0$"import java.lang.reflect.Type;"
"MethodParameter.java:28"$0$"import java.util.HashMap;"
"MethodParameter.java:29"$0$"import java.util.Map;"
"MethodParameter.java:30"$0$"import java.util.Optional;"
"MethodParameter.java:31"$0$"import java.util.function.Predicate;"
"MethodParameter.java:32"$0$""
"MethodParameter.java:33"$0$"import kotlin.Unit;"
"MethodParameter.java:34"$0$"import kotlin.reflect.KFunction;"
"MethodParameter.java:35"$0$"import kotlin.reflect.KParameter;"
"MethodParameter.java:36"$0$"import kotlin.reflect.jvm.ReflectJvmMapping;"
"MethodParameter.java:37"$0$""
"MethodParameter.java:38"$0$"import org.springframework.lang.Nullable;"
"MethodParameter.java:39"$0$"import org.springframework.util.Assert;"
"MethodParameter.java:40"$0$"import org.springframework.util.ClassUtils;"
"MethodParameter.java:41"$0$"import org.springframework.util.ObjectUtils;"
"MethodParameter.java:42"$0$""
"MethodParameter.java:43"$0$"/**"
"MethodParameter.java:44"$1$" * Helper class that encapsulates the specification of a method parameter, i.e. a {@link Method}"
"MethodParameter.java:45"$1$" * or {@link Constructor} plus a parameter index and a nested type index for a declared generic"
"MethodParameter.java:46"$0$" * type. Useful as a specification object to pass along."
"MethodParameter.java:47"$0$" *"
"MethodParameter.java:48"$1$" * <p>As of 4.2, there is a {@link org.springframework.core.annotation.SynthesizingMethodParameter}"
"MethodParameter.java:49"$0$" * subclass available which synthesizes annotations with attribute aliases. That subclass is used"
"MethodParameter.java:50"$0$" * for web and message endpoint processing, in particular."
"MethodParameter.java:51"$0$" *"
"MethodParameter.java:52"$0$" * @author Juergen Hoeller"
"MethodParameter.java:53"$0$" * @author Rob Harrop"
"MethodParameter.java:54"$0$" * @author Andy Clement"
"MethodParameter.java:55"$0$" * @author Sam Brannen"
"MethodParameter.java:56"$0$" * @author Sebastien Deleuze"
"MethodParameter.java:57"$0$" * @author Phillip Webb"
"MethodParameter.java:58"$0$" * @since 2.0"
"MethodParameter.java:59"$0$" * @see org.springframework.core.annotation.SynthesizingMethodParameter"
"MethodParameter.java:60"$0$" */"
"MethodParameter.java:61"$1$"public class MethodParameter {"
"MethodParameter.java:62"$1$""
"MethodParameter.java:63"$1$"	private static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0];"
"MethodParameter.java:64"$1$""
"MethodParameter.java:65"$1$""
"MethodParameter.java:66"$1$"	private final Executable executable;"
"MethodParameter.java:67"$1$""
"MethodParameter.java:68"$1$"	private final int parameterIndex;"
"MethodParameter.java:69"$1$""
"MethodParameter.java:70"$1$"	@Nullable"
"MethodParameter.java:71"$1$"	private volatile Parameter parameter;"
"MethodParameter.java:72"$1$""
"MethodParameter.java:73"$1$"	private int nestingLevel;"
"MethodParameter.java:74"$1$""
"MethodParameter.java:75"$1$"	/** Map from Integer level to Integer type index. */"
"MethodParameter.java:76"$1$"	@Nullable"
"MethodParameter.java:77"$1$"	Map<Integer, Integer> typeIndexesPerLevel;"
"MethodParameter.java:78"$1$""
"MethodParameter.java:79"$1$"	/** The containing class. Could also be supplied by overriding {@link #getContainingClass()} */"
"MethodParameter.java:80"$1$"	@Nullable"
"MethodParameter.java:81"$1$"	private volatile Class<?> containingClass;"
"MethodParameter.java:82"$1$""
"MethodParameter.java:83"$1$"	@Nullable"
"MethodParameter.java:84"$1$"	private volatile Class<?> parameterType;"
"MethodParameter.java:85"$1$""
"MethodParameter.java:86"$1$"	@Nullable"
"MethodParameter.java:87"$1$"	private volatile Type genericParameterType;"
"MethodParameter.java:88"$1$""
"MethodParameter.java:89"$1$"	@Nullable"
"MethodParameter.java:90"$1$"	private volatile Annotation[] parameterAnnotations;"
"MethodParameter.java:91"$1$""
"MethodParameter.java:92"$1$"	@Nullable"
"MethodParameter.java:93"$1$"	private volatile ParameterNameDiscoverer parameterNameDiscoverer;"
"MethodParameter.java:94"$1$""
"MethodParameter.java:95"$1$"	@Nullable"
"MethodParameter.java:96"$1$"	private volatile String parameterName;"
"MethodParameter.java:97"$1$""
"MethodParameter.java:98"$1$"	@Nullable"
"MethodParameter.java:99"$1$"	private volatile MethodParameter nestedMethodParameter;"
"MethodParameter.java:100"$1$""
"MethodParameter.java:101"$1$""
"MethodParameter.java:102"$1$"	/**"
"MethodParameter.java:103"$1$"	 * Create a new {@code MethodParameter} for the given method, with nesting level 1."
"MethodParameter.java:104"$1$"	 * @param method the Method to specify a parameter for"
"MethodParameter.java:105"$1$"	 * @param parameterIndex the index of the parameter: -1 for the method"
"MethodParameter.java:106"$1$"	 * return type; 0 for the first method parameter; 1 for the second method"
"MethodParameter.java:107"$1$"	 * parameter, etc."
"MethodParameter.java:108"$1$"	 */"
"MethodParameter.java:109"$1$"	public MethodParameter(Method method, int parameterIndex) {"
"MethodParameter.java:110"$1$"		this(method, parameterIndex, 1);"
"MethodParameter.java:111"$1$"	}"
"MethodParameter.java:112"$0$""
"MethodParameter.java:113"$0$"	/**"
"MethodParameter.java:114"$1$"	 * Create a new {@code MethodParameter} for the given method."
"MethodParameter.java:115"$0$"	 * @param method the Method to specify a parameter for"
"MethodParameter.java:116"$0$"	 * @param parameterIndex the index of the parameter: -1 for the method"
"MethodParameter.java:117"$0$"	 * return type; 0 for the first method parameter; 1 for the second method"
"MethodParameter.java:118"$0$"	 * parameter, etc."
"MethodParameter.java:119"$0$"	 * @param nestingLevel the nesting level of the target type"
"MethodParameter.java:120"$0$"	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the"
"MethodParameter.java:121"$0$"	 * nested List, whereas 2 would indicate the element of the nested List)"
"MethodParameter.java:122"$0$"	 */"
"MethodParameter.java:123"$1$"	public MethodParameter(Method method, int parameterIndex, int nestingLevel) {"
"MethodParameter.java:124"$1$"		Assert.notNull(method, ""Method must not be null"");"
"MethodParameter.java:125"$1$"		this.executable = method;"
"MethodParameter.java:126"$1$"		this.parameterIndex = validateIndex(method, parameterIndex);"
"MethodParameter.java:127"$1$"		this.nestingLevel = nestingLevel;"
"MethodParameter.java:128"$1$"	}"
"MethodParameter.java:129"$0$""
"MethodParameter.java:130"$0$"	/**"
"MethodParameter.java:131"$0$"	 * Create a new MethodParameter for the given constructor, with nesting level 1."
"MethodParameter.java:132"$0$"	 * @param constructor the Constructor to specify a parameter for"
"MethodParameter.java:133"$0$"	 * @param parameterIndex the index of the parameter"
"MethodParameter.java:134"$0$"	 */"
"MethodParameter.java:135"$1$"	public MethodParameter(Constructor<?> constructor, int parameterIndex) {"
"MethodParameter.java:136"$1$"		this(constructor, parameterIndex, 1);"
"MethodParameter.java:137"$1$"	}"
"MethodParameter.java:138"$0$""
"MethodParameter.java:139"$0$"	/**"
"MethodParameter.java:140"$0$"	 * Create a new MethodParameter for the given constructor."
"MethodParameter.java:141"$0$"	 * @param constructor the Constructor to specify a parameter for"
"MethodParameter.java:142"$0$"	 * @param parameterIndex the index of the parameter"
"MethodParameter.java:143"$0$"	 * @param nestingLevel the nesting level of the target type"
"MethodParameter.java:144"$0$"	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the"
"MethodParameter.java:145"$0$"	 * nested List, whereas 2 would indicate the element of the nested List)"
"MethodParameter.java:146"$0$"	 */"
"MethodParameter.java:147"$1$"	public MethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {"
"MethodParameter.java:148"$1$"		Assert.notNull(constructor, ""Constructor must not be null"");"
"MethodParameter.java:149"$1$"		this.executable = constructor;"
"MethodParameter.java:150"$1$"		this.parameterIndex = validateIndex(constructor, parameterIndex);"
"MethodParameter.java:151"$1$"		this.nestingLevel = nestingLevel;"
"MethodParameter.java:152"$1$"	}"
"MethodParameter.java:153"$0$""
"MethodParameter.java:154"$0$"	/**"
"MethodParameter.java:155"$1$"	 * Internal constructor used to create a {@link MethodParameter} with a"
"MethodParameter.java:156"$0$"	 * containing class already set."
"MethodParameter.java:157"$0$"	 * @param executable the Executable to specify a parameter for"
"MethodParameter.java:158"$0$"	 * @param parameterIndex the index of the parameter"
"MethodParameter.java:159"$0$"	 * @param containingClass the containing class"
"MethodParameter.java:160"$0$"	 * @since 5.2"
"MethodParameter.java:161"$0$"	 */"
"MethodParameter.java:162"$1$"	MethodParameter(Executable executable, int parameterIndex, @Nullable Class<?> containingClass) {"
"MethodParameter.java:163"$1$"		Assert.notNull(executable, ""Executable must not be null"");"
"MethodParameter.java:164"$1$"		this.executable = executable;"
"MethodParameter.java:165"$1$"		this.parameterIndex = validateIndex(executable, parameterIndex);"
"MethodParameter.java:166"$1$"		this.nestingLevel = 1;"
"MethodParameter.java:167"$1$"		this.containingClass = containingClass;"
"MethodParameter.java:168"$1$"	}"
"MethodParameter.java:169"$0$""
"MethodParameter.java:170"$0$"	/**"
"MethodParameter.java:171"$0$"	 * Copy constructor, resulting in an independent MethodParameter object"
"MethodParameter.java:172"$0$"	 * based on the same metadata and cache state that the original object was in."
"MethodParameter.java:173"$0$"	 * @param original the original MethodParameter object to copy from"
"MethodParameter.java:174"$0$"	 */"
"MethodParameter.java:175"$1$"	public MethodParameter(MethodParameter original) {"
"MethodParameter.java:176"$1$"		Assert.notNull(original, ""Original must not be null"");"
"MethodParameter.java:177"$1$"		this.executable = original.executable;"
"MethodParameter.java:178"$1$"		this.parameterIndex = original.parameterIndex;"
"MethodParameter.java:179"$1$"		this.parameter = original.parameter;"
"MethodParameter.java:180"$1$"		this.nestingLevel = original.nestingLevel;"
"MethodParameter.java:181"$1$"		this.typeIndexesPerLevel = original.typeIndexesPerLevel;"
"MethodParameter.java:182"$1$"		this.containingClass = original.containingClass;"
"MethodParameter.java:183"$1$"		this.parameterType = original.parameterType;"
"MethodParameter.java:184"$1$"		this.genericParameterType = original.genericParameterType;"
"MethodParameter.java:185"$1$"		this.parameterAnnotations = original.parameterAnnotations;"
"MethodParameter.java:186"$1$"		this.parameterNameDiscoverer = original.parameterNameDiscoverer;"
"MethodParameter.java:187"$1$"		this.parameterName = original.parameterName;"
"MethodParameter.java:188"$1$"	}"
"MethodParameter.java:189"$0$""
"MethodParameter.java:190"$0$""
"MethodParameter.java:191"$0$"	/**"
"MethodParameter.java:192"$0$"	 * Return the wrapped Method, if any."
"MethodParameter.java:193"$0$"	 * <p>Note: Either Method or Constructor is available."
"MethodParameter.java:194"$1$"	 * @return the Method, or {@code null} if none"
"MethodParameter.java:195"$0$"	 */"
"MethodParameter.java:196"$0$"	@Nullable"
"MethodParameter.java:197"$1$"	public Method getMethod() {"
"MethodParameter.java:198"$1$"		return (this.executable instanceof Method ? (Method) this.executable : null);"
"MethodParameter.java:199"$1$"	}"
"MethodParameter.java:200"$0$""
"MethodParameter.java:201"$0$"	/**"
"MethodParameter.java:202"$0$"	 * Return the wrapped Constructor, if any."
"MethodParameter.java:203"$0$"	 * <p>Note: Either Method or Constructor is available."
"MethodParameter.java:204"$1$"	 * @return the Constructor, or {@code null} if none"
"MethodParameter.java:205"$0$"	 */"
"MethodParameter.java:206"$0$"	@Nullable"
"MethodParameter.java:207"$1$"	public Constructor<?> getConstructor() {"
"MethodParameter.java:208"$1$"		return (this.executable instanceof Constructor ? (Constructor<?>) this.executable : null);"
"MethodParameter.java:209"$1$"	}"
"MethodParameter.java:210"$0$""
"MethodParameter.java:211"$0$"	/**"
"MethodParameter.java:212"$0$"	 * Return the class that declares the underlying Method or Constructor."
"MethodParameter.java:213"$0$"	 */"
"MethodParameter.java:214"$1$"	public Class<?> getDeclaringClass() {"
"MethodParameter.java:215"$1$"		return this.executable.getDeclaringClass();"
"MethodParameter.java:216"$1$"	}"
"MethodParameter.java:217"$0$""
"MethodParameter.java:218"$0$"	/**"
"MethodParameter.java:219"$0$"	 * Return the wrapped member."
"MethodParameter.java:220"$0$"	 * @return the Method or Constructor as Member"
"MethodParameter.java:221"$0$"	 */"
"MethodParameter.java:222"$1$"	public Member getMember() {"
"MethodParameter.java:223"$1$"		return this.executable;"
"MethodParameter.java:224"$1$"	}"
"MethodParameter.java:225"$0$""
"MethodParameter.java:226"$0$"	/**"
"MethodParameter.java:227"$0$"	 * Return the wrapped annotated element."
"MethodParameter.java:228"$0$"	 * <p>Note: This method exposes the annotations declared on the method/constructor"
"MethodParameter.java:229"$0$"	 * itself (i.e. at the method/constructor level, not at the parameter level)."
"MethodParameter.java:230"$0$"	 * @return the Method or Constructor as AnnotatedElement"
"MethodParameter.java:231"$0$"	 */"
"MethodParameter.java:232"$1$"	public AnnotatedElement getAnnotatedElement() {"
"MethodParameter.java:233"$1$"		return this.executable;"
"MethodParameter.java:234"$1$"	}"
"MethodParameter.java:235"$0$""
"MethodParameter.java:236"$0$"	/**"
"MethodParameter.java:237"$0$"	 * Return the wrapped executable."
"MethodParameter.java:238"$0$"	 * @return the Method or Constructor as Executable"
"MethodParameter.java:239"$0$"	 * @since 5.0"
"MethodParameter.java:240"$0$"	 */"
"MethodParameter.java:241"$1$"	public Executable getExecutable() {"
"MethodParameter.java:242"$1$"		return this.executable;"
"MethodParameter.java:243"$1$"	}"
"MethodParameter.java:244"$0$""
"MethodParameter.java:245"$0$"	/**"
"MethodParameter.java:246"$1$"	 * Return the {@link Parameter} descriptor for method/constructor parameter."
"MethodParameter.java:247"$0$"	 * @since 5.0"
"MethodParameter.java:248"$0$"	 */"
"MethodParameter.java:249"$1$"	public Parameter getParameter() {"
"MethodParameter.java:250"$1$"		if (this.parameterIndex < 0) {"
"MethodParameter.java:251"$1$"			throw new IllegalStateException(""Cannot retrieve Parameter descriptor for method return type"");"
"MethodParameter.java:252"$1$"		}"
"MethodParameter.java:253"$0$"		Parameter parameter = this.parameter;"
"MethodParameter.java:254"$1$"		if (parameter == null) {"
"MethodParameter.java:255"$1$"			parameter = getExecutable().getParameters()[this.parameterIndex];"
"MethodParameter.java:256"$1$"			this.parameter = parameter;"
"MethodParameter.java:257"$1$"		}"
"MethodParameter.java:258"$0$"		return parameter;"
"MethodParameter.java:259"$0$"	}"
"MethodParameter.java:260"$0$""
"MethodParameter.java:261"$0$"	/**"
"MethodParameter.java:262"$0$"	 * Return the index of the method/constructor parameter."
"MethodParameter.java:263"$0$"	 * @return the parameter index (-1 in case of the return type)"
"MethodParameter.java:264"$0$"	 */"
"MethodParameter.java:265"$1$"	public int getParameterIndex() {"
"MethodParameter.java:266"$1$"		return this.parameterIndex;"
"MethodParameter.java:267"$1$"	}"
"MethodParameter.java:268"$0$""
"MethodParameter.java:269"$0$"	/**"
"MethodParameter.java:270"$0$"	 * Increase this parameter's nesting level."
"MethodParameter.java:271"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:272"$1$"	 * @deprecated since 5.2 in favor of {@link #nested(Integer)}"
"MethodParameter.java:273"$0$"	 */"
"MethodParameter.java:274"$0$"	@Deprecated"
"MethodParameter.java:275"$1$"	public void increaseNestingLevel() {"
"MethodParameter.java:276"$1$"		this.nestingLevel++;"
"MethodParameter.java:277"$1$"	}"
"MethodParameter.java:278"$0$""
"MethodParameter.java:279"$0$"	/**"
"MethodParameter.java:280"$0$"	 * Decrease this parameter's nesting level."
"MethodParameter.java:281"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:282"$0$"	 * @deprecated since 5.2 in favor of retaining the original MethodParameter and"
"MethodParameter.java:283"$1$"	 * using {@link #nested(Integer)} if nesting is required"
"MethodParameter.java:284"$0$"	 */"
"MethodParameter.java:285"$0$"	@Deprecated"
"MethodParameter.java:286"$1$"	public void decreaseNestingLevel() {"
"MethodParameter.java:287"$1$"		getTypeIndexesPerLevel().remove(this.nestingLevel);"
"MethodParameter.java:288"$1$"		this.nestingLevel--;"
"MethodParameter.java:289"$1$"	}"
"MethodParameter.java:290"$0$""
"MethodParameter.java:291"$0$"	/**"
"MethodParameter.java:292"$0$"	 * Return the nesting level of the target type"
"MethodParameter.java:293"$0$"	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the"
"MethodParameter.java:294"$0$"	 * nested List, whereas 2 would indicate the element of the nested List)."
"MethodParameter.java:295"$0$"	 */"
"MethodParameter.java:296"$1$"	public int getNestingLevel() {"
"MethodParameter.java:297"$1$"		return this.nestingLevel;"
"MethodParameter.java:298"$1$"	}"
"MethodParameter.java:299"$0$""
"MethodParameter.java:300"$0$"	/**"
"MethodParameter.java:301"$1$"	 * Return a variant of this {@code MethodParameter} with the type"
"MethodParameter.java:302"$0$"	 * for the current level set to the specified value."
"MethodParameter.java:303"$0$"	 * @param typeIndex the new type index"
"MethodParameter.java:304"$0$"	 * @since 5.2"
"MethodParameter.java:305"$0$"	 */"
"MethodParameter.java:306"$1$"	public MethodParameter withTypeIndex(int typeIndex) {"
"MethodParameter.java:307"$1$"		return nested(this.nestingLevel, typeIndex);"
"MethodParameter.java:308"$1$"	}"
"MethodParameter.java:309"$0$""
"MethodParameter.java:310"$0$"	/**"
"MethodParameter.java:311"$0$"	 * Set the type index for the current nesting level."
"MethodParameter.java:312"$0$"	 * @param typeIndex the corresponding type index"
"MethodParameter.java:313"$1$"	 * (or {@code null} for the default type index)"
"MethodParameter.java:314"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:315"$1$"	 * @deprecated since 5.2 in favor of {@link #withTypeIndex}"
"MethodParameter.java:316"$0$"	 */"
"MethodParameter.java:317"$0$"	@Deprecated"
"MethodParameter.java:318"$1$"	public void setTypeIndexForCurrentLevel(int typeIndex) {"
"MethodParameter.java:319"$1$"		getTypeIndexesPerLevel().put(this.nestingLevel, typeIndex);"
"MethodParameter.java:320"$1$"	}"
"MethodParameter.java:321"$0$""
"MethodParameter.java:322"$0$"	/**"
"MethodParameter.java:323"$0$"	 * Return the type index for the current nesting level."
"MethodParameter.java:324"$1$"	 * @return the corresponding type index, or {@code null}"
"MethodParameter.java:325"$0$"	 * if none specified (indicating the default type index)"
"MethodParameter.java:326"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:327"$0$"	 */"
"MethodParameter.java:328"$0$"	@Nullable"
"MethodParameter.java:329"$1$"	public Integer getTypeIndexForCurrentLevel() {"
"MethodParameter.java:330"$1$"		return getTypeIndexForLevel(this.nestingLevel);"
"MethodParameter.java:331"$1$"	}"
"MethodParameter.java:332"$0$""
"MethodParameter.java:333"$0$"	/**"
"MethodParameter.java:334"$0$"	 * Return the type index for the specified nesting level."
"MethodParameter.java:335"$0$"	 * @param nestingLevel the nesting level to check"
"MethodParameter.java:336"$1$"	 * @return the corresponding type index, or {@code null}"
"MethodParameter.java:337"$0$"	 * if none specified (indicating the default type index)"
"MethodParameter.java:338"$0$"	 */"
"MethodParameter.java:339"$0$"	@Nullable"
"MethodParameter.java:340"$1$"	public Integer getTypeIndexForLevel(int nestingLevel) {"
"MethodParameter.java:341"$1$"		return getTypeIndexesPerLevel().get(nestingLevel);"
"MethodParameter.java:342"$1$"	}"
"MethodParameter.java:343"$0$""
"MethodParameter.java:344"$0$"	/**"
"MethodParameter.java:345"$0$"	 * Obtain the (lazily constructed) type-indexes-per-level Map."
"MethodParameter.java:346"$0$"	 */"
"MethodParameter.java:347"$1$"	private Map<Integer, Integer> getTypeIndexesPerLevel() {"
"MethodParameter.java:348"$1$"		if (this.typeIndexesPerLevel == null) {"
"MethodParameter.java:349"$1$"			this.typeIndexesPerLevel = new HashMap<>(4);"
"MethodParameter.java:350"$1$"		}"
"MethodParameter.java:351"$0$"		return this.typeIndexesPerLevel;"
"MethodParameter.java:352"$0$"	}"
"MethodParameter.java:353"$0$""
"MethodParameter.java:354"$0$"	/**"
"MethodParameter.java:355"$1$"	 * Return a variant of this {@code MethodParameter} which points to the"
"MethodParameter.java:356"$0$"	 * same parameter but one nesting level deeper."
"MethodParameter.java:357"$0$"	 * @since 4.3"
"MethodParameter.java:358"$0$"	 */"
"MethodParameter.java:359"$1$"	public MethodParameter nested() {"
"MethodParameter.java:360"$1$"		return nested(null);"
"MethodParameter.java:361"$1$"	}"
"MethodParameter.java:362"$0$""
"MethodParameter.java:363"$0$"	/**"
"MethodParameter.java:364"$1$"	 * Return a variant of this {@code MethodParameter} which points to the"
"MethodParameter.java:365"$0$"	 * same parameter but one nesting level deeper."
"MethodParameter.java:366"$0$"	 * @param typeIndex the type index for the new nesting level"
"MethodParameter.java:367"$0$"	 * @since 5.2"
"MethodParameter.java:368"$0$"	 */"
"MethodParameter.java:369"$1$"	public MethodParameter nested(@Nullable Integer typeIndex) {"
"MethodParameter.java:370"$1$"		MethodParameter nestedParam = this.nestedMethodParameter;"
"MethodParameter.java:371"$1$"		if (nestedParam != null && typeIndex == null) {"
"MethodParameter.java:372"$1$"			return nestedParam;"
"MethodParameter.java:373"$1$"		}"
"MethodParameter.java:374"$0$"		nestedParam = nested(this.nestingLevel + 1, typeIndex);"
"MethodParameter.java:375"$1$"		if (typeIndex == null) {"
"MethodParameter.java:376"$1$"			this.nestedMethodParameter = nestedParam;"
"MethodParameter.java:377"$1$"		}"
"MethodParameter.java:378"$0$"		return nestedParam;"
"MethodParameter.java:379"$0$"	}"
"MethodParameter.java:380"$0$""
"MethodParameter.java:381"$1$"	private MethodParameter nested(int nestingLevel, @Nullable Integer typeIndex) {"
"MethodParameter.java:382"$1$"		MethodParameter copy = clone();"
"MethodParameter.java:383"$1$"		copy.nestingLevel = nestingLevel;"
"MethodParameter.java:384"$1$"		if (this.typeIndexesPerLevel != null) {"
"MethodParameter.java:385"$1$"			copy.typeIndexesPerLevel = new HashMap<>(this.typeIndexesPerLevel);"
"MethodParameter.java:386"$1$"		}"
"MethodParameter.java:387"$1$"		if (typeIndex != null) {"
"MethodParameter.java:388"$1$"			copy.getTypeIndexesPerLevel().put(copy.nestingLevel, typeIndex);"
"MethodParameter.java:389"$1$"		}"
"MethodParameter.java:390"$0$"		copy.parameterType = null;"
"MethodParameter.java:391"$0$"		copy.genericParameterType = null;"
"MethodParameter.java:392"$0$"		return copy;"
"MethodParameter.java:393"$0$"	}"
"MethodParameter.java:394"$0$""
"MethodParameter.java:395"$0$"	/**"
"MethodParameter.java:396"$0$"	 * Return whether this method indicates a parameter which is not required:"
"MethodParameter.java:397"$1$"	 * either in the form of Java 8's {@link java.util.Optional}, any variant"
"MethodParameter.java:398"$1$"	 * of a parameter-level {@code Nullable} annotation (such as from JSR-305"
"MethodParameter.java:399"$0$"	 * or the FindBugs set of annotations), or a language-level nullable type"
"MethodParameter.java:400"$1$"	 * declaration or {@code Continuation} parameter in Kotlin."
"MethodParameter.java:401"$0$"	 * @since 4.3"
"MethodParameter.java:402"$0$"	 */"
"MethodParameter.java:403"$1$"	public boolean isOptional() {"
"MethodParameter.java:404"$1$"		return (getParameterType() == Optional.class || hasNullableAnnotation() ||"
"MethodParameter.java:405"$1$"				(KotlinDetector.isKotlinReflectPresent() &&"
"MethodParameter.java:406"$1$"						KotlinDetector.isKotlinType(getContainingClass()) &&"
"MethodParameter.java:407"$1$"						KotlinDelegate.isOptional(this)));"
"MethodParameter.java:408"$1$"	}"
"MethodParameter.java:409"$0$""
"MethodParameter.java:410"$0$"	/**"
"MethodParameter.java:411"$0$"	 * Check whether this method parameter is annotated with any variant of a"
"MethodParameter.java:412"$1$"	 * {@code Nullable} annotation, e.g. {@code javax.annotation.Nullable} or"
"MethodParameter.java:413"$1$"	 * {@code edu.umd.cs.findbugs.annotations.Nullable}."
"MethodParameter.java:414"$0$"	 */"
"MethodParameter.java:415"$1$"	private boolean hasNullableAnnotation() {"
"MethodParameter.java:416"$1$"		for (Annotation ann : getParameterAnnotations()) {"
"MethodParameter.java:417"$1$"			if (""Nullable"".equals(ann.annotationType().getSimpleName())) {"
"MethodParameter.java:418"$1$"				return true;"
"MethodParameter.java:419"$1$"			}"
"MethodParameter.java:420"$0$"		}"
"MethodParameter.java:421"$0$"		return false;"
"MethodParameter.java:422"$0$"	}"
"MethodParameter.java:423"$0$""
"MethodParameter.java:424"$0$"	/**"
"MethodParameter.java:425"$1$"	 * Return a variant of this {@code MethodParameter} which points to"
"MethodParameter.java:426"$0$"	 * the same parameter but one nesting level deeper in case of a"
"MethodParameter.java:427"$1$"	 * {@link java.util.Optional} declaration."
"MethodParameter.java:428"$0$"	 * @since 4.3"
"MethodParameter.java:429"$0$"	 * @see #isOptional()"
"MethodParameter.java:430"$0$"	 * @see #nested()"
"MethodParameter.java:431"$0$"	 */"
"MethodParameter.java:432"$1$"	public MethodParameter nestedIfOptional() {"
"MethodParameter.java:433"$1$"		return (getParameterType() == Optional.class ? nested() : this);"
"MethodParameter.java:434"$1$"	}"
"MethodParameter.java:435"$0$""
"MethodParameter.java:436"$0$"	/**"
"MethodParameter.java:437"$1$"	 * Return a variant of this {@code MethodParameter} which refers to the"
"MethodParameter.java:438"$0$"	 * given containing class."
"MethodParameter.java:439"$0$"	 * @param containingClass a specific containing class (potentially a"
"MethodParameter.java:440"$0$"	 * subclass of the declaring class, e.g. substituting a type variable)"
"MethodParameter.java:441"$0$"	 * @since 5.2"
"MethodParameter.java:442"$0$"	 * @see #getParameterType()"
"MethodParameter.java:443"$0$"	 */"
"MethodParameter.java:444"$1$"	public MethodParameter withContainingClass(@Nullable Class<?> containingClass) {"
"MethodParameter.java:445"$1$"		MethodParameter result = clone();"
"MethodParameter.java:446"$1$"		result.containingClass = containingClass;"
"MethodParameter.java:447"$1$"		result.parameterType = null;"
"MethodParameter.java:448"$1$"		return result;"
"MethodParameter.java:449"$1$"	}"
"MethodParameter.java:450"$0$""
"MethodParameter.java:451"$0$"	/**"
"MethodParameter.java:452"$0$"	 * Set a containing class to resolve the parameter type against."
"MethodParameter.java:453"$0$"	 */"
"MethodParameter.java:454"$0$"	@Deprecated"
"MethodParameter.java:455"$1$"	void setContainingClass(Class<?> containingClass) {"
"MethodParameter.java:456"$1$"		this.containingClass = containingClass;"
"MethodParameter.java:457"$1$"		this.parameterType = null;"
"MethodParameter.java:458"$1$"	}"
"MethodParameter.java:459"$0$""
"MethodParameter.java:460"$0$"	/**"
"MethodParameter.java:461"$0$"	 * Return the containing class for this method parameter."
"MethodParameter.java:462"$0$"	 * @return a specific containing class (potentially a subclass of the"
"MethodParameter.java:463"$0$"	 * declaring class), or otherwise simply the declaring class itself"
"MethodParameter.java:464"$0$"	 * @see #getDeclaringClass()"
"MethodParameter.java:465"$0$"	 */"
"MethodParameter.java:466"$1$"	public Class<?> getContainingClass() {"
"MethodParameter.java:467"$1$"		Class<?> containingClass = this.containingClass;"
"MethodParameter.java:468"$1$"		return (containingClass != null ? containingClass : getDeclaringClass());"
"MethodParameter.java:469"$1$"	}"
"MethodParameter.java:470"$0$""
"MethodParameter.java:471"$0$"	/**"
"MethodParameter.java:472"$0$"	 * Set a resolved (generic) parameter type."
"MethodParameter.java:473"$0$"	 */"
"MethodParameter.java:474"$0$"	@Deprecated"
"MethodParameter.java:475"$1$"	void setParameterType(@Nullable Class<?> parameterType) {"
"MethodParameter.java:476"$1$"		this.parameterType = parameterType;"
"MethodParameter.java:477"$1$"	}"
"MethodParameter.java:478"$0$""
"MethodParameter.java:479"$0$"	/**"
"MethodParameter.java:480"$0$"	 * Return the type of the method/constructor parameter."
"MethodParameter.java:481"$1$"	 * @return the parameter type (never {@code null})"
"MethodParameter.java:482"$0$"	 */"
"MethodParameter.java:483"$1$"	public Class<?> getParameterType() {"
"MethodParameter.java:484"$1$"		Class<?> paramType = this.parameterType;"
"MethodParameter.java:485"$1$"		if (paramType != null) {"
"MethodParameter.java:486"$1$"			return paramType;"
"MethodParameter.java:487"$1$"		}"
"MethodParameter.java:488"$1$"		if (getContainingClass() != getDeclaringClass()) {"
"MethodParameter.java:489"$1$"			paramType = ResolvableType.forMethodParameter(this, null, 1).resolve();"
"MethodParameter.java:490"$1$"		}"
"MethodParameter.java:491"$1$"		if (paramType == null) {"
"MethodParameter.java:492"$1$"			paramType = computeParameterType();"
"MethodParameter.java:493"$1$"		}"
"MethodParameter.java:494"$0$"		this.parameterType = paramType;"
"MethodParameter.java:495"$0$"		return paramType;"
"MethodParameter.java:496"$0$"	}"
"MethodParameter.java:497"$0$""
"MethodParameter.java:498"$0$"	/**"
"MethodParameter.java:499"$0$"	 * Return the generic type of the method/constructor parameter."
"MethodParameter.java:500"$1$"	 * @return the parameter type (never {@code null})"
"MethodParameter.java:501"$0$"	 * @since 3.0"
"MethodParameter.java:502"$0$"	 */"
"MethodParameter.java:503"$1$"	public Type getGenericParameterType() {"
"MethodParameter.java:504"$1$"		Type paramType = this.genericParameterType;"
"MethodParameter.java:505"$1$"		if (paramType == null) {"
"MethodParameter.java:506"$1$"			if (this.parameterIndex < 0) {"
"MethodParameter.java:507"$1$"				Method method = getMethod();"
"MethodParameter.java:508"$1$"				paramType = (method != null ?"
"MethodParameter.java:509"$1$"						(KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(getContainingClass()) ?"
"MethodParameter.java:510"$1$"						KotlinDelegate.getGenericReturnType(method) : method.getGenericReturnType()) : void.class);"
"MethodParameter.java:511"$1$"			}"
"MethodParameter.java:512"$1$"			else {"
"MethodParameter.java:513"$1$"				Type[] genericParameterTypes = this.executable.getGenericParameterTypes();"
"MethodParameter.java:514"$1$"				int index = this.parameterIndex;"
"MethodParameter.java:515"$1$"				if (this.executable instanceof Constructor &&"
"MethodParameter.java:516"$1$"						ClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&"
"MethodParameter.java:517"$1$"						genericParameterTypes.length == this.executable.getParameterCount() - 1) {"
"MethodParameter.java:518"$0$"					// Bug in javac: type array excludes enclosing instance parameter"
"MethodParameter.java:519"$0$"					// for inner classes with at least one generic constructor parameter,"
"MethodParameter.java:520"$0$"					// so access it with the actual parameter index lowered by 1"
"MethodParameter.java:521"$1$"					index = this.parameterIndex - 1;"
"MethodParameter.java:522"$1$"				}"
"MethodParameter.java:523"$0$"				paramType = (index >= 0 && index < genericParameterTypes.length ?"
"MethodParameter.java:524"$0$"						genericParameterTypes[index] : computeParameterType());"
"MethodParameter.java:525"$0$"			}"
"MethodParameter.java:526"$0$"			this.genericParameterType = paramType;"
"MethodParameter.java:527"$0$"		}"
"MethodParameter.java:528"$0$"		return paramType;"
"MethodParameter.java:529"$0$"	}"
"MethodParameter.java:530"$0$""
"MethodParameter.java:531"$1$"	private Class<?> computeParameterType() {"
"MethodParameter.java:532"$1$"		if (this.parameterIndex < 0) {"
"MethodParameter.java:533"$1$"			Method method = getMethod();"
"MethodParameter.java:534"$1$"			if (method == null) {"
"MethodParameter.java:535"$1$"				return void.class;"
"MethodParameter.java:536"$1$"			}"
"MethodParameter.java:537"$1$"			if (KotlinDetector.isKotlinReflectPresent() && KotlinDetector.isKotlinType(getContainingClass())) {"
"MethodParameter.java:538"$1$"				return KotlinDelegate.getReturnType(method);"
"MethodParameter.java:539"$1$"			}"
"MethodParameter.java:540"$0$"			return method.getReturnType();"
"MethodParameter.java:541"$0$"		}"
"MethodParameter.java:542"$0$"		return this.executable.getParameterTypes()[this.parameterIndex];"
"MethodParameter.java:543"$0$"	}"
"MethodParameter.java:544"$0$""
"MethodParameter.java:545"$0$"	/**"
"MethodParameter.java:546"$0$"	 * Return the nested type of the method/constructor parameter."
"MethodParameter.java:547"$1$"	 * @return the parameter type (never {@code null})"
"MethodParameter.java:548"$0$"	 * @since 3.1"
"MethodParameter.java:549"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:550"$0$"	 */"
"MethodParameter.java:551"$1$"	public Class<?> getNestedParameterType() {"
"MethodParameter.java:552"$1$"		if (this.nestingLevel > 1) {"
"MethodParameter.java:553"$1$"			Type type = getGenericParameterType();"
"MethodParameter.java:554"$1$"			for (int i = 2; i <= this.nestingLevel; i++) {"
"MethodParameter.java:555"$1$"				if (type instanceof ParameterizedType) {"
"MethodParameter.java:556"$1$"					Type[] args = ((ParameterizedType) type).getActualTypeArguments();"
"MethodParameter.java:557"$1$"					Integer index = getTypeIndexForLevel(i);"
"MethodParameter.java:558"$1$"					type = args[index != null ? index : args.length - 1];"
"MethodParameter.java:559"$1$"				}"
"MethodParameter.java:560"$0$"				// TODO: Object.class if unresolvable"
"MethodParameter.java:561"$0$"			}"
"MethodParameter.java:562"$1$"			if (type instanceof Class) {"
"MethodParameter.java:563"$1$"				return (Class<?>) type;"
"MethodParameter.java:564"$1$"			}"
"MethodParameter.java:565"$1$"			else if (type instanceof ParameterizedType) {"
"MethodParameter.java:566"$1$"				Type arg = ((ParameterizedType) type).getRawType();"
"MethodParameter.java:567"$1$"				if (arg instanceof Class) {"
"MethodParameter.java:568"$1$"					return (Class<?>) arg;"
"MethodParameter.java:569"$1$"				}"
"MethodParameter.java:570"$0$"			}"
"MethodParameter.java:571"$0$"			return Object.class;"
"MethodParameter.java:572"$0$"		}"
"MethodParameter.java:573"$1$"		else {"
"MethodParameter.java:574"$1$"			return getParameterType();"
"MethodParameter.java:575"$1$"		}"
"MethodParameter.java:576"$0$"	}"
"MethodParameter.java:577"$0$""
"MethodParameter.java:578"$0$"	/**"
"MethodParameter.java:579"$0$"	 * Return the nested generic type of the method/constructor parameter."
"MethodParameter.java:580"$1$"	 * @return the parameter type (never {@code null})"
"MethodParameter.java:581"$0$"	 * @since 4.2"
"MethodParameter.java:582"$0$"	 * @see #getNestingLevel()"
"MethodParameter.java:583"$0$"	 */"
"MethodParameter.java:584"$1$"	public Type getNestedGenericParameterType() {"
"MethodParameter.java:585"$1$"		if (this.nestingLevel > 1) {"
"MethodParameter.java:586"$1$"			Type type = getGenericParameterType();"
"MethodParameter.java:587"$1$"			for (int i = 2; i <= this.nestingLevel; i++) {"
"MethodParameter.java:588"$1$"				if (type instanceof ParameterizedType) {"
"MethodParameter.java:589"$1$"					Type[] args = ((ParameterizedType) type).getActualTypeArguments();"
"MethodParameter.java:590"$1$"					Integer index = getTypeIndexForLevel(i);"
"MethodParameter.java:591"$1$"					type = args[index != null ? index : args.length - 1];"
"MethodParameter.java:592"$1$"				}"
"MethodParameter.java:593"$0$"			}"
"MethodParameter.java:594"$0$"			return type;"
"MethodParameter.java:595"$0$"		}"
"MethodParameter.java:596"$1$"		else {"
"MethodParameter.java:597"$1$"			return getGenericParameterType();"
"MethodParameter.java:598"$1$"		}"
"MethodParameter.java:599"$0$"	}"
"MethodParameter.java:600"$0$""
"MethodParameter.java:601"$0$"	/**"
"MethodParameter.java:602"$0$"	 * Return the annotations associated with the target method/constructor itself."
"MethodParameter.java:603"$0$"	 */"
"MethodParameter.java:604"$1$"	public Annotation[] getMethodAnnotations() {"
"MethodParameter.java:605"$1$"		return adaptAnnotationArray(getAnnotatedElement().getAnnotations());"
"MethodParameter.java:606"$1$"	}"
"MethodParameter.java:607"$0$""
"MethodParameter.java:608"$0$"	/**"
"MethodParameter.java:609"$0$"	 * Return the method/constructor annotation of the given type, if available."
"MethodParameter.java:610"$0$"	 * @param annotationType the annotation type to look for"
"MethodParameter.java:611"$1$"	 * @return the annotation object, or {@code null} if not found"
"MethodParameter.java:612"$0$"	 */"
"MethodParameter.java:613"$0$"	@Nullable"
"MethodParameter.java:614"$1$"	public <A extends Annotation> A getMethodAnnotation(Class<A> annotationType) {"
"MethodParameter.java:615"$1$"		A annotation = getAnnotatedElement().getAnnotation(annotationType);"
"MethodParameter.java:616"$1$"		return (annotation != null ? adaptAnnotation(annotation) : null);"
"MethodParameter.java:617"$1$"	}"
"MethodParameter.java:618"$0$""
"MethodParameter.java:619"$0$"	/**"
"MethodParameter.java:620"$0$"	 * Return whether the method/constructor is annotated with the given type."
"MethodParameter.java:621"$0$"	 * @param annotationType the annotation type to look for"
"MethodParameter.java:622"$0$"	 * @since 4.3"
"MethodParameter.java:623"$0$"	 * @see #getMethodAnnotation(Class)"
"MethodParameter.java:624"$0$"	 */"
"MethodParameter.java:625"$1$"	public <A extends Annotation> boolean hasMethodAnnotation(Class<A> annotationType) {"
"MethodParameter.java:626"$1$"		return getAnnotatedElement().isAnnotationPresent(annotationType);"
"MethodParameter.java:627"$1$"	}"
"MethodParameter.java:628"$0$""
"MethodParameter.java:629"$0$"	/**"
"MethodParameter.java:630"$0$"	 * Return the annotations associated with the specific method/constructor parameter."
"MethodParameter.java:631"$0$"	 */"
"MethodParameter.java:632"$1$"	public Annotation[] getParameterAnnotations() {"
"MethodParameter.java:633"$1$"		Annotation[] paramAnns = this.parameterAnnotations;"
"MethodParameter.java:634"$1$"		if (paramAnns == null) {"
"MethodParameter.java:635"$1$"			Annotation[][] annotationArray = this.executable.getParameterAnnotations();"
"MethodParameter.java:636"$1$"			int index = this.parameterIndex;"
"MethodParameter.java:637"$1$"			if (this.executable instanceof Constructor &&"
"MethodParameter.java:638"$1$"					ClassUtils.isInnerClass(this.executable.getDeclaringClass()) &&"
"MethodParameter.java:639"$1$"					annotationArray.length == this.executable.getParameterCount() - 1) {"
"MethodParameter.java:640"$0$"				// Bug in javac in JDK <9: annotation array excludes enclosing instance parameter"
"MethodParameter.java:641"$0$"				// for inner classes, so access it with the actual parameter index lowered by 1"
"MethodParameter.java:642"$1$"				index = this.parameterIndex - 1;"
"MethodParameter.java:643"$1$"			}"
"MethodParameter.java:644"$0$"			paramAnns = (index >= 0 && index < annotationArray.length ?"
"MethodParameter.java:645"$0$"					adaptAnnotationArray(annotationArray[index]) : EMPTY_ANNOTATION_ARRAY);"
"MethodParameter.java:646"$0$"			this.parameterAnnotations = paramAnns;"
"MethodParameter.java:647"$0$"		}"
"MethodParameter.java:648"$0$"		return paramAnns;"
"MethodParameter.java:649"$0$"	}"
"MethodParameter.java:650"$0$""
"MethodParameter.java:651"$0$"	/**"
"MethodParameter.java:652"$1$"	 * Return {@code true} if the parameter has at least one annotation,"
"MethodParameter.java:653"$1$"	 * {@code false} if it has none."
"MethodParameter.java:654"$0$"	 * @see #getParameterAnnotations()"
"MethodParameter.java:655"$0$"	 */"
"MethodParameter.java:656"$1$"	public boolean hasParameterAnnotations() {"
"MethodParameter.java:657"$1$"		return (getParameterAnnotations().length != 0);"
"MethodParameter.java:658"$1$"	}"
"MethodParameter.java:659"$0$""
"MethodParameter.java:660"$0$"	/**"
"MethodParameter.java:661"$0$"	 * Return the parameter annotation of the given type, if available."
"MethodParameter.java:662"$0$"	 * @param annotationType the annotation type to look for"
"MethodParameter.java:663"$1$"	 * @return the annotation object, or {@code null} if not found"
"MethodParameter.java:664"$0$"	 */"
"MethodParameter.java:665"$0$"	@SuppressWarnings(""unchecked"")"
"MethodParameter.java:666"$0$"	@Nullable"
"MethodParameter.java:667"$1$"	public <A extends Annotation> A getParameterAnnotation(Class<A> annotationType) {"
"MethodParameter.java:668"$1$"		Annotation[] anns = getParameterAnnotations();"
"MethodParameter.java:669"$1$"		for (Annotation ann : anns) {"
"MethodParameter.java:670"$1$"			if (annotationType.isInstance(ann)) {"
"MethodParameter.java:671"$1$"				return (A) ann;"
"MethodParameter.java:672"$1$"			}"
"MethodParameter.java:673"$0$"		}"
"MethodParameter.java:674"$0$"		return null;"
"MethodParameter.java:675"$0$"	}"
"MethodParameter.java:676"$0$""
"MethodParameter.java:677"$0$"	/**"
"MethodParameter.java:678"$0$"	 * Return whether the parameter is declared with the given annotation type."
"MethodParameter.java:679"$0$"	 * @param annotationType the annotation type to look for"
"MethodParameter.java:680"$0$"	 * @see #getParameterAnnotation(Class)"
"MethodParameter.java:681"$0$"	 */"
"MethodParameter.java:682"$1$"	public <A extends Annotation> boolean hasParameterAnnotation(Class<A> annotationType) {"
"MethodParameter.java:683"$1$"		return (getParameterAnnotation(annotationType) != null);"
"MethodParameter.java:684"$1$"	}"
"MethodParameter.java:685"$0$""
"MethodParameter.java:686"$0$"	/**"
"MethodParameter.java:687"$0$"	 * Initialize parameter name discovery for this method parameter."
"MethodParameter.java:688"$0$"	 * <p>This method does not actually try to retrieve the parameter name at"
"MethodParameter.java:689"$0$"	 * this point; it just allows discovery to happen when the application calls"
"MethodParameter.java:690"$1$"	 * {@link #getParameterName()} (if ever)."
"MethodParameter.java:691"$0$"	 */"
"MethodParameter.java:692"$1$"	public void initParameterNameDiscovery(@Nullable ParameterNameDiscoverer parameterNameDiscoverer) {"
"MethodParameter.java:693"$1$"		this.parameterNameDiscoverer = parameterNameDiscoverer;"
"MethodParameter.java:694"$1$"	}"
"MethodParameter.java:695"$0$""
"MethodParameter.java:696"$0$"	/**"
"MethodParameter.java:697"$0$"	 * Return the name of the method/constructor parameter."
"MethodParameter.java:698"$1$"	 * @return the parameter name (may be {@code null} if no"
"MethodParameter.java:699"$0$"	 * parameter name metadata is contained in the class file or no"
"MethodParameter.java:700"$1$"	 * {@link #initParameterNameDiscovery ParameterNameDiscoverer}"
"MethodParameter.java:701"$0$"	 * has been set to begin with)"
"MethodParameter.java:702"$0$"	 */"
"MethodParameter.java:703"$0$"	@Nullable"
"MethodParameter.java:704"$1$"	public String getParameterName() {"
"MethodParameter.java:705"$1$"		if (this.parameterIndex < 0) {"
"MethodParameter.java:706"$1$"			return null;"
"MethodParameter.java:707"$1$"		}"
"MethodParameter.java:708"$0$"		ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer;"
"MethodParameter.java:709"$1$"		if (discoverer != null) {"
"MethodParameter.java:710"$1$"			String[] parameterNames = null;"
"MethodParameter.java:711"$1$"			if (this.executable instanceof Method) {"
"MethodParameter.java:712"$1$"				parameterNames = discoverer.getParameterNames((Method) this.executable);"
"MethodParameter.java:713"$1$"			}"
"MethodParameter.java:714"$1$"			else if (this.executable instanceof Constructor) {"
"MethodParameter.java:715"$1$"				parameterNames = discoverer.getParameterNames((Constructor<?>) this.executable);"
"MethodParameter.java:716"$1$"			}"
"MethodParameter.java:717"$1$"			if (parameterNames != null) {"
"MethodParameter.java:718"$1$"				this.parameterName = parameterNames[this.parameterIndex];"
"MethodParameter.java:719"$1$"			}"
"MethodParameter.java:720"$0$"			this.parameterNameDiscoverer = null;"
"MethodParameter.java:721"$0$"		}"
"MethodParameter.java:722"$0$"		return this.parameterName;"
"MethodParameter.java:723"$0$"	}"
"MethodParameter.java:724"$0$""
"MethodParameter.java:725"$0$""
"MethodParameter.java:726"$0$"	/**"
"MethodParameter.java:727"$0$"	 * A template method to post-process a given annotation instance before"
"MethodParameter.java:728"$0$"	 * returning it to the caller."
"MethodParameter.java:729"$0$"	 * <p>The default implementation simply returns the given annotation as-is."
"MethodParameter.java:730"$0$"	 * @param annotation the annotation about to be returned"
"MethodParameter.java:731"$0$"	 * @return the post-processed annotation (or simply the original one)"
"MethodParameter.java:732"$0$"	 * @since 4.2"
"MethodParameter.java:733"$0$"	 */"
"MethodParameter.java:734"$1$"	protected <A extends Annotation> A adaptAnnotation(A annotation) {"
"MethodParameter.java:735"$1$"		return annotation;"
"MethodParameter.java:736"$1$"	}"
"MethodParameter.java:737"$0$""
"MethodParameter.java:738"$0$"	/**"
"MethodParameter.java:739"$0$"	 * A template method to post-process a given annotation array before"
"MethodParameter.java:740"$0$"	 * returning it to the caller."
"MethodParameter.java:741"$0$"	 * <p>The default implementation simply returns the given annotation array as-is."
"MethodParameter.java:742"$0$"	 * @param annotations the annotation array about to be returned"
"MethodParameter.java:743"$0$"	 * @return the post-processed annotation array (or simply the original one)"
"MethodParameter.java:744"$0$"	 * @since 4.2"
"MethodParameter.java:745"$0$"	 */"
"MethodParameter.java:746"$1$"	protected Annotation[] adaptAnnotationArray(Annotation[] annotations) {"
"MethodParameter.java:747"$1$"		return annotations;"
"MethodParameter.java:748"$1$"	}"
"MethodParameter.java:749"$0$""
"MethodParameter.java:750"$0$""
"MethodParameter.java:751"$0$"	@Override"
"MethodParameter.java:752"$1$"	public boolean equals(@Nullable Object other) {"
"MethodParameter.java:753"$1$"		if (this == other) {"
"MethodParameter.java:754"$1$"			return true;"
"MethodParameter.java:755"$1$"		}"
"MethodParameter.java:756"$1$"		if (!(other instanceof MethodParameter)) {"
"MethodParameter.java:757"$1$"			return false;"
"MethodParameter.java:758"$1$"		}"
"MethodParameter.java:759"$0$"		MethodParameter otherParam = (MethodParameter) other;"
"MethodParameter.java:760"$0$"		return (getContainingClass() == otherParam.getContainingClass() &&"
"MethodParameter.java:761"$0$"				ObjectUtils.nullSafeEquals(this.typeIndexesPerLevel, otherParam.typeIndexesPerLevel) &&"
"MethodParameter.java:762"$0$"				this.nestingLevel == otherParam.nestingLevel &&"
"MethodParameter.java:763"$0$"				this.parameterIndex == otherParam.parameterIndex &&"
"MethodParameter.java:764"$0$"				this.executable.equals(otherParam.executable));"
"MethodParameter.java:765"$0$"	}"
"MethodParameter.java:766"$0$""
"MethodParameter.java:767"$0$"	@Override"
"MethodParameter.java:768"$1$"	public int hashCode() {"
"MethodParameter.java:769"$1$"		return (31 * this.executable.hashCode() + this.parameterIndex);"
"MethodParameter.java:770"$1$"	}"
"MethodParameter.java:771"$0$""
"MethodParameter.java:772"$0$"	@Override"
"MethodParameter.java:773"$1$"	public String toString() {"
"MethodParameter.java:774"$1$"		Method method = getMethod();"
"MethodParameter.java:775"$1$"		return (method != null ? ""method '"" + method.getName() + ""'"" : ""constructor"") +"
"MethodParameter.java:776"$1$"				"" parameter "" + this.parameterIndex;"
"MethodParameter.java:777"$1$"	}"
"MethodParameter.java:778"$0$""
"MethodParameter.java:779"$0$"	@Override"
"MethodParameter.java:780"$1$"	public MethodParameter clone() {"
"MethodParameter.java:781"$1$"		return new MethodParameter(this);"
"MethodParameter.java:782"$1$"	}"
"MethodParameter.java:783"$0$""
"MethodParameter.java:784"$0$"	/**"
"MethodParameter.java:785"$0$"	 * Create a new MethodParameter for the given method or constructor."
"MethodParameter.java:786"$0$"	 * <p>This is a convenience factory method for scenarios where a"
"MethodParameter.java:787"$0$"	 * Method or Constructor reference is treated in a generic fashion."
"MethodParameter.java:788"$0$"	 * @param methodOrConstructor the Method or Constructor to specify a parameter for"
"MethodParameter.java:789"$0$"	 * @param parameterIndex the index of the parameter"
"MethodParameter.java:790"$0$"	 * @return the corresponding MethodParameter instance"
"MethodParameter.java:791"$1$"	 * @deprecated as of 5.0, in favor of {@link #forExecutable}"
"MethodParameter.java:792"$0$"	 */"
"MethodParameter.java:793"$0$"	@Deprecated"
"MethodParameter.java:794"$1$"	public static MethodParameter forMethodOrConstructor(Object methodOrConstructor, int parameterIndex) {"
"MethodParameter.java:795"$1$"		if (!(methodOrConstructor instanceof Executable)) {"
"MethodParameter.java:796"$1$"			throw new IllegalArgumentException("
"MethodParameter.java:797"$1$"					""Given object ["" + methodOrConstructor + ""] is neither a Method nor a Constructor"");"
"MethodParameter.java:798"$1$"		}"
"MethodParameter.java:799"$0$"		return forExecutable((Executable) methodOrConstructor, parameterIndex);"
"MethodParameter.java:800"$0$"	}"
"MethodParameter.java:801"$0$""
"MethodParameter.java:802"$0$"	/**"
"MethodParameter.java:803"$0$"	 * Create a new MethodParameter for the given method or constructor."
"MethodParameter.java:804"$0$"	 * <p>This is a convenience factory method for scenarios where a"
"MethodParameter.java:805"$0$"	 * Method or Constructor reference is treated in a generic fashion."
"MethodParameter.java:806"$0$"	 * @param executable the Method or Constructor to specify a parameter for"
"MethodParameter.java:807"$0$"	 * @param parameterIndex the index of the parameter"
"MethodParameter.java:808"$0$"	 * @return the corresponding MethodParameter instance"
"MethodParameter.java:809"$0$"	 * @since 5.0"
"MethodParameter.java:810"$0$"	 */"
"MethodParameter.java:811"$1$"	public static MethodParameter forExecutable(Executable executable, int parameterIndex) {"
"MethodParameter.java:812"$1$"		if (executable instanceof Method) {"
"MethodParameter.java:813"$1$"			return new MethodParameter((Method) executable, parameterIndex);"
"MethodParameter.java:814"$1$"		}"
"MethodParameter.java:815"$1$"		else if (executable instanceof Constructor) {"
"MethodParameter.java:816"$1$"			return new MethodParameter((Constructor<?>) executable, parameterIndex);"
"MethodParameter.java:817"$1$"		}"
"MethodParameter.java:818"$1$"		else {"
"MethodParameter.java:819"$1$"			throw new IllegalArgumentException(""Not a Method/Constructor: "" + executable);"
"MethodParameter.java:820"$1$"		}"
"MethodParameter.java:821"$0$"	}"
"MethodParameter.java:822"$0$""
"MethodParameter.java:823"$0$"	/**"
"MethodParameter.java:824"$0$"	 * Create a new MethodParameter for the given parameter descriptor."
"MethodParameter.java:825"$0$"	 * <p>This is a convenience factory method for scenarios where a"
"MethodParameter.java:826"$1$"	 * Java 8 {@link Parameter} descriptor is already available."
"MethodParameter.java:827"$0$"	 * @param parameter the parameter descriptor"
"MethodParameter.java:828"$0$"	 * @return the corresponding MethodParameter instance"
"MethodParameter.java:829"$0$"	 * @since 5.0"
"MethodParameter.java:830"$0$"	 */"
"MethodParameter.java:831"$1$"	public static MethodParameter forParameter(Parameter parameter) {"
"MethodParameter.java:832"$1$"		return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));"
"MethodParameter.java:833"$1$"	}"
"MethodParameter.java:834"$0$""
"MethodParameter.java:835"$1$"	protected static int findParameterIndex(Parameter parameter) {"
"MethodParameter.java:836"$1$"		Executable executable = parameter.getDeclaringExecutable();"
"MethodParameter.java:837"$1$"		Parameter[] allParams = executable.getParameters();"
"MethodParameter.java:838"$0$"		// Try first with identity checks for greater performance."
"MethodParameter.java:839"$1$"		for (int i = 0; i < allParams.length; i++) {"
"MethodParameter.java:840"$1$"			if (parameter == allParams[i]) {"
"MethodParameter.java:841"$1$"				return i;"
"MethodParameter.java:842"$1$"			}"
"MethodParameter.java:843"$0$"		}"
"MethodParameter.java:844"$0$"		// Potentially try again with object equality checks in order to avoid race"
"MethodParameter.java:845"$0$"		// conditions while invoking java.lang.reflect.Executable.getParameters()."
"MethodParameter.java:846"$1$"		for (int i = 0; i < allParams.length; i++) {"
"MethodParameter.java:847"$1$"			if (parameter.equals(allParams[i])) {"
"MethodParameter.java:848"$1$"				return i;"
"MethodParameter.java:849"$1$"			}"
"MethodParameter.java:850"$0$"		}"
"MethodParameter.java:851"$0$"		throw new IllegalArgumentException(""Given parameter ["" + parameter +"
"MethodParameter.java:852"$0$"				""] does not match any parameter in the declaring executable"");"
"MethodParameter.java:853"$0$"	}"
"MethodParameter.java:854"$0$""
"MethodParameter.java:855"$1$"	private static int validateIndex(Executable executable, int parameterIndex) {"
"MethodParameter.java:856"$1$"		int count = executable.getParameterCount();"
"MethodParameter.java:857"$1$"		Assert.isTrue(parameterIndex >= -1 && parameterIndex < count,"
"MethodParameter.java:858"$1$"				() -> ""Parameter index needs to be between -1 and "" + (count - 1));"
"MethodParameter.java:859"$1$"		return parameterIndex;"
"MethodParameter.java:860"$1$"	}"
"MethodParameter.java:861"$0$""
"MethodParameter.java:862"$0$""
"MethodParameter.java:863"$0$"	/**"
"MethodParameter.java:864"$0$"	 * Inner class to avoid a hard dependency on Kotlin at runtime."
"MethodParameter.java:865"$0$"	 */"
"MethodParameter.java:866"$1$"	private static class KotlinDelegate {"
"MethodParameter.java:867"$1$""
"MethodParameter.java:868"$1$"		/**"
"MethodParameter.java:869"$1$"		 * Check whether the specified {@link MethodParameter} represents a nullable Kotlin type,"
"MethodParameter.java:870"$1$"		 * an optional parameter (with a default value in the Kotlin declaration) or a"
"MethodParameter.java:871"$1$"		 * {@code Continuation} parameter used in suspending functions."
"MethodParameter.java:872"$1$"		 */"
"MethodParameter.java:873"$1$"		public static boolean isOptional(MethodParameter param) {"
"MethodParameter.java:874"$1$"			Method method = param.getMethod();"
"MethodParameter.java:875"$1$"			int index = param.getParameterIndex();"
"MethodParameter.java:876"$1$"			if (method != null && index == -1) {"
"MethodParameter.java:877"$1$"				KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);"
"MethodParameter.java:878"$1$"				return (function != null && function.getReturnType().isMarkedNullable());"
"MethodParameter.java:879"$1$"			}"
"MethodParameter.java:880"$0$"			KFunction<?> function;"
"MethodParameter.java:881"$0$"			Predicate<KParameter> predicate;"
"MethodParameter.java:882"$1$"			if (method != null) {"
"MethodParameter.java:883"$1$"				if (param.getParameterType().getName().equals(""kotlin.coroutines.Continuation"")) {"
"MethodParameter.java:884"$1$"					return true;"
"MethodParameter.java:885"$1$"				}"
"MethodParameter.java:886"$0$"				function = ReflectJvmMapping.getKotlinFunction(method);"
"MethodParameter.java:887"$0$"				predicate = p -> KParameter.Kind.VALUE.equals(p.getKind());"
"MethodParameter.java:888"$0$"			}"
"MethodParameter.java:889"$1$"			else {"
"MethodParameter.java:890"$1$"				Constructor<?> ctor = param.getConstructor();"
"MethodParameter.java:891"$1$"				Assert.state(ctor != null, ""Neither method nor constructor found"");"
"MethodParameter.java:892"$1$"				function = ReflectJvmMapping.getKotlinFunction(ctor);"
"MethodParameter.java:893"$1$"				predicate = p -> (KParameter.Kind.VALUE.equals(p.getKind()) ||"
"MethodParameter.java:894"$1$"						KParameter.Kind.INSTANCE.equals(p.getKind()));"
"MethodParameter.java:895"$1$"			}"
"MethodParameter.java:896"$1$"			if (function != null) {"
"MethodParameter.java:897"$1$"				int i = 0;"
"MethodParameter.java:898"$1$"				for (KParameter kParameter : function.getParameters()) {"
"MethodParameter.java:899"$1$"					if (predicate.test(kParameter)) {"
"MethodParameter.java:900"$1$"						if (index == i++) {"
"MethodParameter.java:901"$1$"							return (kParameter.getType().isMarkedNullable() || kParameter.isOptional());"
"MethodParameter.java:902"$1$"						}"
"MethodParameter.java:903"$0$"					}"
"MethodParameter.java:904"$0$"				}"
"MethodParameter.java:905"$0$"			}"
"MethodParameter.java:906"$0$"			return false;"
"MethodParameter.java:907"$0$"		}"
"MethodParameter.java:908"$0$""
"MethodParameter.java:909"$0$"		/**"
"MethodParameter.java:910"$0$"		 * Return the generic return type of the method, with support of suspending"
"MethodParameter.java:911"$0$"		 * functions via Kotlin reflection."
"MethodParameter.java:912"$0$"		 */"
"MethodParameter.java:913"$1$"		static private Type getGenericReturnType(Method method) {"
"MethodParameter.java:914"$1$"			try {"
"MethodParameter.java:915"$1$"				KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);"
"MethodParameter.java:916"$1$"				if (function != null && function.isSuspend()) {"
"MethodParameter.java:917"$1$"					return ReflectJvmMapping.getJavaType(function.getReturnType());"
"MethodParameter.java:918"$1$"				}"
"MethodParameter.java:919"$0$"			}"
"MethodParameter.java:920"$1$"			catch (UnsupportedOperationException ex) {"
"MethodParameter.java:921"$0$"				// probably a synthetic class - let's use java reflection instead"
"MethodParameter.java:922"$1$"			}"
"MethodParameter.java:923"$0$"			return method.getGenericReturnType();"
"MethodParameter.java:924"$0$"		}"
"MethodParameter.java:925"$0$""
"MethodParameter.java:926"$0$"		/**"
"MethodParameter.java:927"$0$"		 * Return the return type of the method, with support of suspending"
"MethodParameter.java:928"$0$"		 * functions via Kotlin reflection."
"MethodParameter.java:929"$0$"		 */"
"MethodParameter.java:930"$1$"		static private Class<?> getReturnType(Method method) {"
"MethodParameter.java:931"$1$"			try {"
"MethodParameter.java:932"$1$"				KFunction<?> function = ReflectJvmMapping.getKotlinFunction(method);"
"MethodParameter.java:933"$1$"				if (function != null && function.isSuspend()) {"
"MethodParameter.java:934"$1$"					Type paramType = ReflectJvmMapping.getJavaType(function.getReturnType());"
"MethodParameter.java:935"$1$"					if (paramType == Unit.class) {"
"MethodParameter.java:936"$1$"						paramType = void.class;"
"MethodParameter.java:937"$1$"					}"
"MethodParameter.java:938"$0$"					return ResolvableType.forType(paramType).resolve(method.getReturnType());"
"MethodParameter.java:939"$0$"				}"
"MethodParameter.java:940"$0$"			}"
"MethodParameter.java:941"$1$"			catch (UnsupportedOperationException ex) {"
"MethodParameter.java:942"$0$"				// probably a synthetic class - let's use java reflection instead"
"MethodParameter.java:943"$1$"			}"
"MethodParameter.java:944"$0$"			return method.getReturnType();"
"MethodParameter.java:945"$0$"		}"
"MethodParameter.java:946"$0$"	}"
"MethodParameter.java:947"$0$""
"MethodParameter.java:948"$0$"}"
"ListBasedXMLEventReader.java:1"$0$"/*"
"ListBasedXMLEventReader.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ListBasedXMLEventReader.java:3"$0$" *"
"ListBasedXMLEventReader.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ListBasedXMLEventReader.java:5"$0$" * you may not use this file except in compliance with the License."
"ListBasedXMLEventReader.java:6"$0$" * You may obtain a copy of the License at"
"ListBasedXMLEventReader.java:7"$0$" *"
"ListBasedXMLEventReader.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ListBasedXMLEventReader.java:9"$0$" *"
"ListBasedXMLEventReader.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ListBasedXMLEventReader.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ListBasedXMLEventReader.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ListBasedXMLEventReader.java:13"$0$" * See the License for the specific language governing permissions and"
"ListBasedXMLEventReader.java:14"$0$" * limitations under the License."
"ListBasedXMLEventReader.java:15"$0$" */"
"ListBasedXMLEventReader.java:16"$0$""
"ListBasedXMLEventReader.java:17"$0$"package org.springframework.util.xml;"
"ListBasedXMLEventReader.java:18"$0$""
"ListBasedXMLEventReader.java:19"$0$"import java.util.ArrayList;"
"ListBasedXMLEventReader.java:20"$0$"import java.util.List;"
"ListBasedXMLEventReader.java:21"$0$"import java.util.NoSuchElementException;"
"ListBasedXMLEventReader.java:22"$0$""
"ListBasedXMLEventReader.java:23"$0$"import javax.xml.stream.XMLStreamConstants;"
"ListBasedXMLEventReader.java:24"$0$"import javax.xml.stream.XMLStreamException;"
"ListBasedXMLEventReader.java:25"$0$"import javax.xml.stream.events.Characters;"
"ListBasedXMLEventReader.java:26"$0$"import javax.xml.stream.events.XMLEvent;"
"ListBasedXMLEventReader.java:27"$0$""
"ListBasedXMLEventReader.java:28"$0$"import org.springframework.lang.Nullable;"
"ListBasedXMLEventReader.java:29"$0$"import org.springframework.util.Assert;"
"ListBasedXMLEventReader.java:30"$0$""
"ListBasedXMLEventReader.java:31"$0$"/**"
"ListBasedXMLEventReader.java:32"$1$" * Implementation of {@code XMLEventReader} based on a {@link List}"
"ListBasedXMLEventReader.java:33"$1$" * of {@link XMLEvent} elements."
"ListBasedXMLEventReader.java:34"$0$" *"
"ListBasedXMLEventReader.java:35"$0$" * @author Arjen Poutsma"
"ListBasedXMLEventReader.java:36"$0$" * @author Juergen Hoeller"
"ListBasedXMLEventReader.java:37"$0$" * @since 5.0"
"ListBasedXMLEventReader.java:38"$0$" */"
"ListBasedXMLEventReader.java:39"$1$"class ListBasedXMLEventReader extends AbstractXMLEventReader {"
"ListBasedXMLEventReader.java:40"$1$""
"ListBasedXMLEventReader.java:41"$1$"	private final List<XMLEvent> events;"
"ListBasedXMLEventReader.java:42"$1$""
"ListBasedXMLEventReader.java:43"$1$"	@Nullable"
"ListBasedXMLEventReader.java:44"$1$"	private XMLEvent currentEvent;"
"ListBasedXMLEventReader.java:45"$1$""
"ListBasedXMLEventReader.java:46"$1$"	private int cursor = 0;"
"ListBasedXMLEventReader.java:47"$1$""
"ListBasedXMLEventReader.java:48"$1$""
"ListBasedXMLEventReader.java:49"$1$"	public ListBasedXMLEventReader(List<XMLEvent> events) {"
"ListBasedXMLEventReader.java:50"$1$"		Assert.notNull(events, ""XMLEvent List must not be null"");"
"ListBasedXMLEventReader.java:51"$1$"		this.events = new ArrayList<>(events);"
"ListBasedXMLEventReader.java:52"$1$"	}"
"ListBasedXMLEventReader.java:53"$0$""
"ListBasedXMLEventReader.java:54"$0$""
"ListBasedXMLEventReader.java:55"$0$"	@Override"
"ListBasedXMLEventReader.java:56"$1$"	public boolean hasNext() {"
"ListBasedXMLEventReader.java:57"$1$"		return (this.cursor < this.events.size());"
"ListBasedXMLEventReader.java:58"$1$"	}"
"ListBasedXMLEventReader.java:59"$0$""
"ListBasedXMLEventReader.java:60"$0$"	@Override"
"ListBasedXMLEventReader.java:61"$1$"	public XMLEvent nextEvent() {"
"ListBasedXMLEventReader.java:62"$1$"		if (hasNext()) {"
"ListBasedXMLEventReader.java:63"$1$"			this.currentEvent = this.events.get(this.cursor);"
"ListBasedXMLEventReader.java:64"$1$"			this.cursor++;"
"ListBasedXMLEventReader.java:65"$1$"			return this.currentEvent;"
"ListBasedXMLEventReader.java:66"$1$"		}"
"ListBasedXMLEventReader.java:67"$1$"		else {"
"ListBasedXMLEventReader.java:68"$1$"			throw new NoSuchElementException();"
"ListBasedXMLEventReader.java:69"$1$"		}"
"ListBasedXMLEventReader.java:70"$0$"	}"
"ListBasedXMLEventReader.java:71"$0$""
"ListBasedXMLEventReader.java:72"$0$"	@Override"
"ListBasedXMLEventReader.java:73"$0$"	@Nullable"
"ListBasedXMLEventReader.java:74"$1$"	public XMLEvent peek() {"
"ListBasedXMLEventReader.java:75"$1$"		if (hasNext()) {"
"ListBasedXMLEventReader.java:76"$1$"			return this.events.get(this.cursor);"
"ListBasedXMLEventReader.java:77"$1$"		}"
"ListBasedXMLEventReader.java:78"$1$"		else {"
"ListBasedXMLEventReader.java:79"$1$"			return null;"
"ListBasedXMLEventReader.java:80"$1$"		}"
"ListBasedXMLEventReader.java:81"$0$"	}"
"ListBasedXMLEventReader.java:82"$0$""
"ListBasedXMLEventReader.java:83"$0$"	@Override"
"ListBasedXMLEventReader.java:84"$1$"	public String getElementText() throws XMLStreamException {"
"ListBasedXMLEventReader.java:85"$1$"		checkIfClosed();"
"ListBasedXMLEventReader.java:86"$1$"		if (this.currentEvent == null || !this.currentEvent.isStartElement()) {"
"ListBasedXMLEventReader.java:87"$1$"			throw new XMLStreamException(""Not at START_ELEMENT: "" + this.currentEvent);"
"ListBasedXMLEventReader.java:88"$1$"		}"
"ListBasedXMLEventReader.java:89"$0$""
"ListBasedXMLEventReader.java:90"$0$"		StringBuilder builder = new StringBuilder();"
"ListBasedXMLEventReader.java:91"$1$"		while (true) {"
"ListBasedXMLEventReader.java:92"$1$"			XMLEvent event = nextEvent();"
"ListBasedXMLEventReader.java:93"$1$"			if (event.isEndElement()) {"
"ListBasedXMLEventReader.java:94"$1$"				break;"
"ListBasedXMLEventReader.java:95"$1$"			}"
"ListBasedXMLEventReader.java:96"$1$"			else if (!event.isCharacters()) {"
"ListBasedXMLEventReader.java:97"$1$"				throw new XMLStreamException(""Unexpected non-text event: "" + event);"
"ListBasedXMLEventReader.java:98"$1$"			}"
"ListBasedXMLEventReader.java:99"$0$"			Characters characters = event.asCharacters();"
"ListBasedXMLEventReader.java:100"$1$"			if (!characters.isIgnorableWhiteSpace()) {"
"ListBasedXMLEventReader.java:101"$1$"				builder.append(event.asCharacters().getData());"
"ListBasedXMLEventReader.java:102"$1$"			}"
"ListBasedXMLEventReader.java:103"$0$"		}"
"ListBasedXMLEventReader.java:104"$0$"		return builder.toString();"
"ListBasedXMLEventReader.java:105"$0$"	}"
"ListBasedXMLEventReader.java:106"$0$""
"ListBasedXMLEventReader.java:107"$0$"	@Override"
"ListBasedXMLEventReader.java:108"$0$"	@Nullable"
"ListBasedXMLEventReader.java:109"$1$"	public XMLEvent nextTag() throws XMLStreamException {"
"ListBasedXMLEventReader.java:110"$1$"		checkIfClosed();"
"ListBasedXMLEventReader.java:111"$1$""
"ListBasedXMLEventReader.java:112"$1$"		while (true) {"
"ListBasedXMLEventReader.java:113"$1$"			XMLEvent event = nextEvent();"
"ListBasedXMLEventReader.java:114"$1$"			switch (event.getEventType()) {"
"ListBasedXMLEventReader.java:115"$1$"				case XMLStreamConstants.START_ELEMENT:"
"ListBasedXMLEventReader.java:116"$1$"				case XMLStreamConstants.END_ELEMENT:"
"ListBasedXMLEventReader.java:117"$1$"					return event;"
"ListBasedXMLEventReader.java:118"$1$"				case XMLStreamConstants.END_DOCUMENT:"
"ListBasedXMLEventReader.java:119"$1$"					return null;"
"ListBasedXMLEventReader.java:120"$1$"				case XMLStreamConstants.SPACE:"
"ListBasedXMLEventReader.java:121"$1$"				case XMLStreamConstants.COMMENT:"
"ListBasedXMLEventReader.java:122"$1$"				case XMLStreamConstants.PROCESSING_INSTRUCTION:"
"ListBasedXMLEventReader.java:123"$1$"					continue;"
"ListBasedXMLEventReader.java:124"$1$"				case XMLStreamConstants.CDATA:"
"ListBasedXMLEventReader.java:125"$1$"				case XMLStreamConstants.CHARACTERS:"
"ListBasedXMLEventReader.java:126"$1$"					if (!event.asCharacters().isWhiteSpace()) {"
"ListBasedXMLEventReader.java:127"$1$"						throw new XMLStreamException("
"ListBasedXMLEventReader.java:128"$1$"								""Non-ignorable whitespace CDATA or CHARACTERS event: "" + event);"
"ListBasedXMLEventReader.java:129"$1$"					}"
"ListBasedXMLEventReader.java:130"$0$"					break;"
"ListBasedXMLEventReader.java:131"$0$"				default:"
"ListBasedXMLEventReader.java:132"$0$"					throw new XMLStreamException(""Expected START_ELEMENT or END_ELEMENT: "" + event);"
"ListBasedXMLEventReader.java:133"$0$"			}"
"ListBasedXMLEventReader.java:134"$0$"		}"
"ListBasedXMLEventReader.java:135"$0$"	}"
"ListBasedXMLEventReader.java:136"$0$""
"ListBasedXMLEventReader.java:137"$0$"	@Override"
"ListBasedXMLEventReader.java:138"$1$"	public void close() {"
"ListBasedXMLEventReader.java:139"$1$"		super.close();"
"ListBasedXMLEventReader.java:140"$1$"		this.events.clear();"
"ListBasedXMLEventReader.java:141"$1$"	}"
"ListBasedXMLEventReader.java:142"$0$""
"ListBasedXMLEventReader.java:143"$0$"}"
"AnnotationMetadataReadingVisitor.java:1"$0$"/*"
"AnnotationMetadataReadingVisitor.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"AnnotationMetadataReadingVisitor.java:3"$0$" *"
"AnnotationMetadataReadingVisitor.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"AnnotationMetadataReadingVisitor.java:5"$0$" * you may not use this file except in compliance with the License."
"AnnotationMetadataReadingVisitor.java:6"$0$" * You may obtain a copy of the License at"
"AnnotationMetadataReadingVisitor.java:7"$0$" *"
"AnnotationMetadataReadingVisitor.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"AnnotationMetadataReadingVisitor.java:9"$0$" *"
"AnnotationMetadataReadingVisitor.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"AnnotationMetadataReadingVisitor.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"AnnotationMetadataReadingVisitor.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"AnnotationMetadataReadingVisitor.java:13"$0$" * See the License for the specific language governing permissions and"
"AnnotationMetadataReadingVisitor.java:14"$0$" * limitations under the License."
"AnnotationMetadataReadingVisitor.java:15"$0$" */"
"AnnotationMetadataReadingVisitor.java:16"$0$""
"AnnotationMetadataReadingVisitor.java:17"$0$"package org.springframework.core.type.classreading;"
"AnnotationMetadataReadingVisitor.java:18"$0$""
"AnnotationMetadataReadingVisitor.java:19"$0$"import java.util.Collection;"
"AnnotationMetadataReadingVisitor.java:20"$0$"import java.util.Collections;"
"AnnotationMetadataReadingVisitor.java:21"$0$"import java.util.LinkedHashMap;"
"AnnotationMetadataReadingVisitor.java:22"$0$"import java.util.LinkedHashSet;"
"AnnotationMetadataReadingVisitor.java:23"$0$"import java.util.List;"
"AnnotationMetadataReadingVisitor.java:24"$0$"import java.util.Map;"
"AnnotationMetadataReadingVisitor.java:25"$0$"import java.util.Set;"
"AnnotationMetadataReadingVisitor.java:26"$0$""
"AnnotationMetadataReadingVisitor.java:27"$0$"import org.springframework.asm.AnnotationVisitor;"
"AnnotationMetadataReadingVisitor.java:28"$0$"import org.springframework.asm.MethodVisitor;"
"AnnotationMetadataReadingVisitor.java:29"$0$"import org.springframework.asm.Opcodes;"
"AnnotationMetadataReadingVisitor.java:30"$0$"import org.springframework.asm.Type;"
"AnnotationMetadataReadingVisitor.java:31"$0$"import org.springframework.core.annotation.AnnotationAttributes;"
"AnnotationMetadataReadingVisitor.java:32"$0$"import org.springframework.core.annotation.AnnotationUtils;"
"AnnotationMetadataReadingVisitor.java:33"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"AnnotationMetadataReadingVisitor.java:34"$0$"import org.springframework.core.type.AnnotationMetadata;"
"AnnotationMetadataReadingVisitor.java:35"$0$"import org.springframework.core.type.MethodMetadata;"
"AnnotationMetadataReadingVisitor.java:36"$0$"import org.springframework.lang.Nullable;"
"AnnotationMetadataReadingVisitor.java:37"$0$"import org.springframework.util.LinkedMultiValueMap;"
"AnnotationMetadataReadingVisitor.java:38"$0$"import org.springframework.util.MultiValueMap;"
"AnnotationMetadataReadingVisitor.java:39"$0$""
"AnnotationMetadataReadingVisitor.java:40"$0$"/**"
"AnnotationMetadataReadingVisitor.java:41"$0$" * ASM class visitor which looks for the class name and implemented types as"
"AnnotationMetadataReadingVisitor.java:42"$0$" * well as for the annotations defined on the class, exposing them through"
"AnnotationMetadataReadingVisitor.java:43"$1$" * the {@link org.springframework.core.type.AnnotationMetadata} interface."
"AnnotationMetadataReadingVisitor.java:44"$0$" *"
"AnnotationMetadataReadingVisitor.java:45"$0$" * @author Juergen Hoeller"
"AnnotationMetadataReadingVisitor.java:46"$0$" * @author Mark Fisher"
"AnnotationMetadataReadingVisitor.java:47"$0$" * @author Costin Leau"
"AnnotationMetadataReadingVisitor.java:48"$0$" * @author Phillip Webb"
"AnnotationMetadataReadingVisitor.java:49"$0$" * @author Sam Brannen"
"AnnotationMetadataReadingVisitor.java:50"$0$" * @since 2.5"
"AnnotationMetadataReadingVisitor.java:51"$0$" * @deprecated As of Spring Framework 5.2, this class has been replaced by"
"AnnotationMetadataReadingVisitor.java:52"$1$" * {@link SimpleAnnotationMetadataReadingVisitor} for internal use within the"
"AnnotationMetadataReadingVisitor.java:53"$0$" * framework, but there is no public replacement for"
"AnnotationMetadataReadingVisitor.java:54"$1$" * {@code AnnotationMetadataReadingVisitor}."
"AnnotationMetadataReadingVisitor.java:55"$0$" */"
"AnnotationMetadataReadingVisitor.java:56"$0$"Deprecated"
"AnnotationMetadataReadingVisitor.java:57"$1$"public class AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor implements AnnotationMetadata {"
"AnnotationMetadataReadingVisitor.java:58"$1$""
"AnnotationMetadataReadingVisitor.java:59"$1$"	@Nullable"
"AnnotationMetadataReadingVisitor.java:60"$1$"	protected final ClassLoader classLoader;"
"AnnotationMetadataReadingVisitor.java:61"$1$""
"AnnotationMetadataReadingVisitor.java:62"$1$"	protected final Set<String> annotationSet = new LinkedHashSet<>(4);"
"AnnotationMetadataReadingVisitor.java:63"$1$""
"AnnotationMetadataReadingVisitor.java:64"$1$"	protected final Map<String, Set<String>> metaAnnotationMap = new LinkedHashMap<>(4);"
"AnnotationMetadataReadingVisitor.java:65"$1$""
"AnnotationMetadataReadingVisitor.java:66"$1$"	/**"
"AnnotationMetadataReadingVisitor.java:67"$1$"	 * Declared as a {@link LinkedMultiValueMap} instead of a {@link MultiValueMap}"
"AnnotationMetadataReadingVisitor.java:68"$1$"	 * to ensure that the hierarchical ordering of the entries is preserved."
"AnnotationMetadataReadingVisitor.java:69"$1$"	 * @see AnnotationReadingVisitorUtils#getMergedAnnotationAttributes"
"AnnotationMetadataReadingVisitor.java:70"$1$"	 */"
"AnnotationMetadataReadingVisitor.java:71"$1$"	protected final LinkedMultiValueMap<String, AnnotationAttributes> attributesMap = new LinkedMultiValueMap<>(4);"
"AnnotationMetadataReadingVisitor.java:72"$1$""
"AnnotationMetadataReadingVisitor.java:73"$1$"	protected final Set<MethodMetadata> methodMetadataSet = new LinkedHashSet<>(4);"
"AnnotationMetadataReadingVisitor.java:74"$1$""
"AnnotationMetadataReadingVisitor.java:75"$1$""
"AnnotationMetadataReadingVisitor.java:76"$1$"	public AnnotationMetadataReadingVisitor(@Nullable ClassLoader classLoader) {"
"AnnotationMetadataReadingVisitor.java:77"$1$"		this.classLoader = classLoader;"
"AnnotationMetadataReadingVisitor.java:78"$1$"	}"
"AnnotationMetadataReadingVisitor.java:79"$0$""
"AnnotationMetadataReadingVisitor.java:80"$0$""
"AnnotationMetadataReadingVisitor.java:81"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:82"$1$"	public MergedAnnotations getAnnotations() {"
"AnnotationMetadataReadingVisitor.java:83"$1$"		throw new UnsupportedOperationException();"
"AnnotationMetadataReadingVisitor.java:84"$1$"	}"
"AnnotationMetadataReadingVisitor.java:85"$0$""
"AnnotationMetadataReadingVisitor.java:86"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:87"$1$"	public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {"
"AnnotationMetadataReadingVisitor.java:88"$0$"		// Skip bridge methods - we're only interested in original annotation-defining user methods."
"AnnotationMetadataReadingVisitor.java:89"$0$"		// On JDK 8, we'd otherwise run into double detection of the same annotated method..."
"AnnotationMetadataReadingVisitor.java:90"$1$"		if ((access & Opcodes.ACC_BRIDGE) != 0) {"
"AnnotationMetadataReadingVisitor.java:91"$1$"			return super.visitMethod(access, name, desc, signature, exceptions);"
"AnnotationMetadataReadingVisitor.java:92"$1$"		}"
"AnnotationMetadataReadingVisitor.java:93"$0$"		return new MethodMetadataReadingVisitor(name, access, getClassName(),"
"AnnotationMetadataReadingVisitor.java:94"$0$"				Type.getReturnType(desc).getClassName(), this.classLoader, this.methodMetadataSet);"
"AnnotationMetadataReadingVisitor.java:95"$0$"	}"
"AnnotationMetadataReadingVisitor.java:96"$0$""
"AnnotationMetadataReadingVisitor.java:97"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:98"$0$"	@Nullable"
"AnnotationMetadataReadingVisitor.java:99"$1$"	public AnnotationVisitor visitAnnotation(String desc, boolean visible) {"
"AnnotationMetadataReadingVisitor.java:100"$1$"		if (!visible) {"
"AnnotationMetadataReadingVisitor.java:101"$1$"			return null;"
"AnnotationMetadataReadingVisitor.java:102"$1$"		}"
"AnnotationMetadataReadingVisitor.java:103"$0$"		String className = Type.getType(desc).getClassName();"
"AnnotationMetadataReadingVisitor.java:104"$1$"		if (AnnotationUtils.isInJavaLangAnnotationPackage(className)) {"
"AnnotationMetadataReadingVisitor.java:105"$1$"			return null;"
"AnnotationMetadataReadingVisitor.java:106"$1$"		}"
"AnnotationMetadataReadingVisitor.java:107"$0$"		this.annotationSet.add(className);"
"AnnotationMetadataReadingVisitor.java:108"$0$"		return new AnnotationAttributesReadingVisitor("
"AnnotationMetadataReadingVisitor.java:109"$0$"				className, this.attributesMap, this.metaAnnotationMap, this.classLoader);"
"AnnotationMetadataReadingVisitor.java:110"$0$"	}"
"AnnotationMetadataReadingVisitor.java:111"$0$""
"AnnotationMetadataReadingVisitor.java:112"$0$""
"AnnotationMetadataReadingVisitor.java:113"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:114"$1$"	public Set<String> getAnnotationTypes() {"
"AnnotationMetadataReadingVisitor.java:115"$1$"		return this.annotationSet;"
"AnnotationMetadataReadingVisitor.java:116"$1$"	}"
"AnnotationMetadataReadingVisitor.java:117"$0$""
"AnnotationMetadataReadingVisitor.java:118"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:119"$1$"	public Set<String> getMetaAnnotationTypes(String annotationName) {"
"AnnotationMetadataReadingVisitor.java:120"$1$"		Set<String> metaAnnotationTypes = this.metaAnnotationMap.get(annotationName);"
"AnnotationMetadataReadingVisitor.java:121"$1$"		return (metaAnnotationTypes != null ? metaAnnotationTypes : Collections.emptySet());"
"AnnotationMetadataReadingVisitor.java:122"$1$"	}"
"AnnotationMetadataReadingVisitor.java:123"$0$""
"AnnotationMetadataReadingVisitor.java:124"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:125"$1$"	public boolean hasMetaAnnotation(String metaAnnotationType) {"
"AnnotationMetadataReadingVisitor.java:126"$1$"		if (AnnotationUtils.isInJavaLangAnnotationPackage(metaAnnotationType)) {"
"AnnotationMetadataReadingVisitor.java:127"$1$"			return false;"
"AnnotationMetadataReadingVisitor.java:128"$1$"		}"
"AnnotationMetadataReadingVisitor.java:129"$0$"		Collection<Set<String>> allMetaTypes = this.metaAnnotationMap.values();"
"AnnotationMetadataReadingVisitor.java:130"$1$"		for (Set<String> metaTypes : allMetaTypes) {"
"AnnotationMetadataReadingVisitor.java:131"$1$"			if (metaTypes.contains(metaAnnotationType)) {"
"AnnotationMetadataReadingVisitor.java:132"$1$"				return true;"
"AnnotationMetadataReadingVisitor.java:133"$1$"			}"
"AnnotationMetadataReadingVisitor.java:134"$0$"		}"
"AnnotationMetadataReadingVisitor.java:135"$0$"		return false;"
"AnnotationMetadataReadingVisitor.java:136"$0$"	}"
"AnnotationMetadataReadingVisitor.java:137"$0$""
"AnnotationMetadataReadingVisitor.java:138"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:139"$1$"	public boolean isAnnotated(String annotationName) {"
"AnnotationMetadataReadingVisitor.java:140"$1$"		return (!AnnotationUtils.isInJavaLangAnnotationPackage(annotationName) &&"
"AnnotationMetadataReadingVisitor.java:141"$1$"				this.attributesMap.containsKey(annotationName));"
"AnnotationMetadataReadingVisitor.java:142"$1$"	}"
"AnnotationMetadataReadingVisitor.java:143"$0$""
"AnnotationMetadataReadingVisitor.java:144"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:145"$1$"	public boolean hasAnnotation(String annotationName) {"
"AnnotationMetadataReadingVisitor.java:146"$1$"		return getAnnotationTypes().contains(annotationName);"
"AnnotationMetadataReadingVisitor.java:147"$1$"	}"
"AnnotationMetadataReadingVisitor.java:148"$0$""
"AnnotationMetadataReadingVisitor.java:149"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:150"$0$"	@Nullable"
"AnnotationMetadataReadingVisitor.java:151"$1$"	public AnnotationAttributes getAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"AnnotationMetadataReadingVisitor.java:152"$1$"		AnnotationAttributes raw = AnnotationReadingVisitorUtils.getMergedAnnotationAttributes("
"AnnotationMetadataReadingVisitor.java:153"$1$"				this.attributesMap, this.metaAnnotationMap, annotationName);"
"AnnotationMetadataReadingVisitor.java:154"$1$"		if (raw == null) {"
"AnnotationMetadataReadingVisitor.java:155"$1$"			return null;"
"AnnotationMetadataReadingVisitor.java:156"$1$"		}"
"AnnotationMetadataReadingVisitor.java:157"$0$"		return AnnotationReadingVisitorUtils.convertClassValues("
"AnnotationMetadataReadingVisitor.java:158"$0$"				""class '"" + getClassName() + ""'"", this.classLoader, raw, classValuesAsString);"
"AnnotationMetadataReadingVisitor.java:159"$0$"	}"
"AnnotationMetadataReadingVisitor.java:160"$0$""
"AnnotationMetadataReadingVisitor.java:161"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:162"$0$"	@Nullable"
"AnnotationMetadataReadingVisitor.java:163"$1$"	public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"AnnotationMetadataReadingVisitor.java:164"$1$"		MultiValueMap<String, Object> allAttributes = new LinkedMultiValueMap<>();"
"AnnotationMetadataReadingVisitor.java:165"$1$"		List<AnnotationAttributes> attributes = this.attributesMap.get(annotationName);"
"AnnotationMetadataReadingVisitor.java:166"$1$"		if (attributes == null) {"
"AnnotationMetadataReadingVisitor.java:167"$1$"			return null;"
"AnnotationMetadataReadingVisitor.java:168"$1$"		}"
"AnnotationMetadataReadingVisitor.java:169"$0$"		String annotatedElement = ""class '"" + getClassName() + ""'"";"
"AnnotationMetadataReadingVisitor.java:170"$1$"		for (AnnotationAttributes raw : attributes) {"
"AnnotationMetadataReadingVisitor.java:171"$1$"			for (Map.Entry<String, Object> entry : AnnotationReadingVisitorUtils.convertClassValues("
"AnnotationMetadataReadingVisitor.java:172"$1$"					annotatedElement, this.classLoader, raw, classValuesAsString).entrySet()) {"
"AnnotationMetadataReadingVisitor.java:173"$1$"				allAttributes.add(entry.getKey(), entry.getValue());"
"AnnotationMetadataReadingVisitor.java:174"$1$"			}"
"AnnotationMetadataReadingVisitor.java:175"$0$"		}"
"AnnotationMetadataReadingVisitor.java:176"$0$"		return allAttributes;"
"AnnotationMetadataReadingVisitor.java:177"$0$"	}"
"AnnotationMetadataReadingVisitor.java:178"$0$""
"AnnotationMetadataReadingVisitor.java:179"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:180"$1$"	public boolean hasAnnotatedMethods(String annotationName) {"
"AnnotationMetadataReadingVisitor.java:181"$1$"		for (MethodMetadata methodMetadata : this.methodMetadataSet) {"
"AnnotationMetadataReadingVisitor.java:182"$1$"			if (methodMetadata.isAnnotated(annotationName)) {"
"AnnotationMetadataReadingVisitor.java:183"$1$"				return true;"
"AnnotationMetadataReadingVisitor.java:184"$1$"			}"
"AnnotationMetadataReadingVisitor.java:185"$0$"		}"
"AnnotationMetadataReadingVisitor.java:186"$0$"		return false;"
"AnnotationMetadataReadingVisitor.java:187"$0$"	}"
"AnnotationMetadataReadingVisitor.java:188"$0$""
"AnnotationMetadataReadingVisitor.java:189"$0$"	@Override"
"AnnotationMetadataReadingVisitor.java:190"$1$"	public Set<MethodMetadata> getAnnotatedMethods(String annotationName) {"
"AnnotationMetadataReadingVisitor.java:191"$1$"		Set<MethodMetadata> annotatedMethods = new LinkedHashSet<>(4);"
"AnnotationMetadataReadingVisitor.java:192"$1$"		for (MethodMetadata methodMetadata : this.methodMetadataSet) {"
"AnnotationMetadataReadingVisitor.java:193"$1$"			if (methodMetadata.isAnnotated(annotationName)) {"
"AnnotationMetadataReadingVisitor.java:194"$1$"				annotatedMethods.add(methodMetadata);"
"AnnotationMetadataReadingVisitor.java:195"$1$"			}"
"AnnotationMetadataReadingVisitor.java:196"$0$"		}"
"AnnotationMetadataReadingVisitor.java:197"$0$"		return annotatedMethods;"
"AnnotationMetadataReadingVisitor.java:198"$0$"	}"
"AnnotationMetadataReadingVisitor.java:199"$0$""
"AnnotationMetadataReadingVisitor.java:200"$0$"}"
"ComparableComparator.java:1"$0$"/*"
"ComparableComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ComparableComparator.java:3"$0$" *"
"ComparableComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ComparableComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"ComparableComparator.java:6"$0$" * You may obtain a copy of the License at"
"ComparableComparator.java:7"$0$" *"
"ComparableComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ComparableComparator.java:9"$0$" *"
"ComparableComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ComparableComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ComparableComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ComparableComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"ComparableComparator.java:14"$0$" * limitations under the License."
"ComparableComparator.java:15"$0$" */"
"ComparableComparator.java:16"$0$""
"ComparableComparator.java:17"$0$"package org.springframework.util.comparator;"
"ComparableComparator.java:18"$0$""
"ComparableComparator.java:19"$0$"import java.util.Comparator;"
"ComparableComparator.java:20"$0$""
"ComparableComparator.java:21"$0$"/**"
"ComparableComparator.java:22"$0$" * Comparator that adapts Comparables to the Comparator interface."
"ComparableComparator.java:23"$0$" * Mainly for internal use in other Comparators, when supposed"
"ComparableComparator.java:24"$0$" * to work on Comparables."
"ComparableComparator.java:25"$0$" *"
"ComparableComparator.java:26"$0$" * @author Keith Donald"
"ComparableComparator.java:27"$0$" * @since 1.2.2"
"ComparableComparator.java:28"$0$" * @param <T> the type of comparable objects that may be compared by this comparator"
"ComparableComparator.java:29"$0$" * @see Comparable"
"ComparableComparator.java:30"$0$" */"
"ComparableComparator.java:31"$1$"public class ComparableComparator<T extends Comparable<T>> implements Comparator<T> {"
"ComparableComparator.java:32"$1$""
"ComparableComparator.java:33"$1$"	/**"
"ComparableComparator.java:34"$1$"	 * A shared instance of this default comparator."
"ComparableComparator.java:35"$1$"	 * @see Comparators#comparable()"
"ComparableComparator.java:36"$1$"	 */"
"ComparableComparator.java:37"$1$"	@SuppressWarnings(""rawtypes"")"
"ComparableComparator.java:38"$1$"	public static final ComparableComparator INSTANCE = new ComparableComparator();"
"ComparableComparator.java:39"$1$""
"ComparableComparator.java:40"$1$""
"ComparableComparator.java:41"$1$"	@Override"
"ComparableComparator.java:42"$1$"	public int compare(T o1, T o2) {"
"ComparableComparator.java:43"$1$"		return o1.compareTo(o2);"
"ComparableComparator.java:44"$1$"	}"
"ComparableComparator.java:45"$0$""
"ComparableComparator.java:46"$0$"}"
"XMLEventStreamWriter.java:1"$0$"/*"
"XMLEventStreamWriter.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"XMLEventStreamWriter.java:3"$0$" *"
"XMLEventStreamWriter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"XMLEventStreamWriter.java:5"$0$" * you may not use this file except in compliance with the License."
"XMLEventStreamWriter.java:6"$0$" * You may obtain a copy of the License at"
"XMLEventStreamWriter.java:7"$0$" *"
"XMLEventStreamWriter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"XMLEventStreamWriter.java:9"$0$" *"
"XMLEventStreamWriter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"XMLEventStreamWriter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"XMLEventStreamWriter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"XMLEventStreamWriter.java:13"$0$" * See the License for the specific language governing permissions and"
"XMLEventStreamWriter.java:14"$0$" * limitations under the License."
"XMLEventStreamWriter.java:15"$0$" */"
"XMLEventStreamWriter.java:16"$0$""
"XMLEventStreamWriter.java:17"$0$"package org.springframework.util.xml;"
"XMLEventStreamWriter.java:18"$0$""
"XMLEventStreamWriter.java:19"$0$"import java.util.ArrayList;"
"XMLEventStreamWriter.java:20"$0$"import java.util.Iterator;"
"XMLEventStreamWriter.java:21"$0$"import java.util.List;"
"XMLEventStreamWriter.java:22"$0$""
"XMLEventStreamWriter.java:23"$0$"import javax.xml.namespace.NamespaceContext;"
"XMLEventStreamWriter.java:24"$0$"import javax.xml.namespace.QName;"
"XMLEventStreamWriter.java:25"$0$"import javax.xml.stream.XMLEventFactory;"
"XMLEventStreamWriter.java:26"$0$"import javax.xml.stream.XMLEventWriter;"
"XMLEventStreamWriter.java:27"$0$"import javax.xml.stream.XMLStreamException;"
"XMLEventStreamWriter.java:28"$0$"import javax.xml.stream.XMLStreamWriter;"
"XMLEventStreamWriter.java:29"$0$"import javax.xml.stream.events.EndElement;"
"XMLEventStreamWriter.java:30"$0$"import javax.xml.stream.events.Namespace;"
"XMLEventStreamWriter.java:31"$0$"import javax.xml.stream.events.StartElement;"
"XMLEventStreamWriter.java:32"$0$""
"XMLEventStreamWriter.java:33"$0$"/**"
"XMLEventStreamWriter.java:34"$1$" * Implementation of the {@link javax.xml.stream.XMLStreamWriter} interface"
"XMLEventStreamWriter.java:35"$1$" * that wraps an {@link XMLEventWriter}."
"XMLEventStreamWriter.java:36"$0$" *"
"XMLEventStreamWriter.java:37"$0$" * @author Arjen Poutsma"
"XMLEventStreamWriter.java:38"$0$" * @since 3.0.5"
"XMLEventStreamWriter.java:39"$0$" * @see StaxUtils#createEventStreamWriter(javax.xml.stream.XMLEventWriter, javax.xml.stream.XMLEventFactory)"
"XMLEventStreamWriter.java:40"$0$" */"
"XMLEventStreamWriter.java:41"$1$"class XMLEventStreamWriter implements XMLStreamWriter {"
"XMLEventStreamWriter.java:42"$1$""
"XMLEventStreamWriter.java:43"$1$"	private static final String DEFAULT_ENCODING = ""UTF-8"";"
"XMLEventStreamWriter.java:44"$1$""
"XMLEventStreamWriter.java:45"$1$"	private final XMLEventWriter eventWriter;"
"XMLEventStreamWriter.java:46"$1$""
"XMLEventStreamWriter.java:47"$1$"	private final XMLEventFactory eventFactory;"
"XMLEventStreamWriter.java:48"$1$""
"XMLEventStreamWriter.java:49"$1$"	private final List<EndElement> endElements = new ArrayList<>();"
"XMLEventStreamWriter.java:50"$1$""
"XMLEventStreamWriter.java:51"$1$"	private boolean emptyElement = false;"
"XMLEventStreamWriter.java:52"$1$""
"XMLEventStreamWriter.java:53"$1$""
"XMLEventStreamWriter.java:54"$1$"	public XMLEventStreamWriter(XMLEventWriter eventWriter, XMLEventFactory eventFactory) {"
"XMLEventStreamWriter.java:55"$1$"		this.eventWriter = eventWriter;"
"XMLEventStreamWriter.java:56"$1$"		this.eventFactory = eventFactory;"
"XMLEventStreamWriter.java:57"$1$"	}"
"XMLEventStreamWriter.java:58"$0$""
"XMLEventStreamWriter.java:59"$0$""
"XMLEventStreamWriter.java:60"$0$"	@Override"
"XMLEventStreamWriter.java:61"$1$"	public void setNamespaceContext(NamespaceContext context) throws XMLStreamException {"
"XMLEventStreamWriter.java:62"$1$"		this.eventWriter.setNamespaceContext(context);"
"XMLEventStreamWriter.java:63"$1$"	}"
"XMLEventStreamWriter.java:64"$0$""
"XMLEventStreamWriter.java:65"$0$"	@Override"
"XMLEventStreamWriter.java:66"$1$"	public NamespaceContext getNamespaceContext() {"
"XMLEventStreamWriter.java:67"$1$"		return this.eventWriter.getNamespaceContext();"
"XMLEventStreamWriter.java:68"$1$"	}"
"XMLEventStreamWriter.java:69"$0$""
"XMLEventStreamWriter.java:70"$0$"	@Override"
"XMLEventStreamWriter.java:71"$1$"	public void setPrefix(String prefix, String uri) throws XMLStreamException {"
"XMLEventStreamWriter.java:72"$1$"		this.eventWriter.setPrefix(prefix, uri);"
"XMLEventStreamWriter.java:73"$1$"	}"
"XMLEventStreamWriter.java:74"$0$""
"XMLEventStreamWriter.java:75"$0$"	@Override"
"XMLEventStreamWriter.java:76"$1$"	public String getPrefix(String uri) throws XMLStreamException {"
"XMLEventStreamWriter.java:77"$1$"		return this.eventWriter.getPrefix(uri);"
"XMLEventStreamWriter.java:78"$1$"	}"
"XMLEventStreamWriter.java:79"$0$""
"XMLEventStreamWriter.java:80"$0$"	@Override"
"XMLEventStreamWriter.java:81"$1$"	public void setDefaultNamespace(String uri) throws XMLStreamException {"
"XMLEventStreamWriter.java:82"$1$"		this.eventWriter.setDefaultNamespace(uri);"
"XMLEventStreamWriter.java:83"$1$"	}"
"XMLEventStreamWriter.java:84"$0$""
"XMLEventStreamWriter.java:85"$0$"	@Override"
"XMLEventStreamWriter.java:86"$1$"	public Object getProperty(String name) throws IllegalArgumentException {"
"XMLEventStreamWriter.java:87"$1$"		throw new IllegalArgumentException();"
"XMLEventStreamWriter.java:88"$1$"	}"
"XMLEventStreamWriter.java:89"$0$""
"XMLEventStreamWriter.java:90"$0$""
"XMLEventStreamWriter.java:91"$0$"	@Override"
"XMLEventStreamWriter.java:92"$1$"	public void writeStartDocument() throws XMLStreamException {"
"XMLEventStreamWriter.java:93"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:94"$1$"		this.eventWriter.add(this.eventFactory.createStartDocument());"
"XMLEventStreamWriter.java:95"$1$"	}"
"XMLEventStreamWriter.java:96"$0$""
"XMLEventStreamWriter.java:97"$0$"	@Override"
"XMLEventStreamWriter.java:98"$1$"	public void writeStartDocument(String version) throws XMLStreamException {"
"XMLEventStreamWriter.java:99"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:100"$1$"		this.eventWriter.add(this.eventFactory.createStartDocument(DEFAULT_ENCODING, version));"
"XMLEventStreamWriter.java:101"$1$"	}"
"XMLEventStreamWriter.java:102"$0$""
"XMLEventStreamWriter.java:103"$0$"	@Override"
"XMLEventStreamWriter.java:104"$1$"	public void writeStartDocument(String encoding, String version) throws XMLStreamException {"
"XMLEventStreamWriter.java:105"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:106"$1$"		this.eventWriter.add(this.eventFactory.createStartDocument(encoding, version));"
"XMLEventStreamWriter.java:107"$1$"	}"
"XMLEventStreamWriter.java:108"$0$""
"XMLEventStreamWriter.java:109"$0$"	@Override"
"XMLEventStreamWriter.java:110"$1$"	public void writeStartElement(String localName) throws XMLStreamException {"
"XMLEventStreamWriter.java:111"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:112"$1$"		doWriteStartElement(this.eventFactory.createStartElement(new QName(localName), null, null));"
"XMLEventStreamWriter.java:113"$1$"	}"
"XMLEventStreamWriter.java:114"$0$""
"XMLEventStreamWriter.java:115"$0$"	@Override"
"XMLEventStreamWriter.java:116"$1$"	public void writeStartElement(String namespaceURI, String localName) throws XMLStreamException {"
"XMLEventStreamWriter.java:117"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:118"$1$"		doWriteStartElement(this.eventFactory.createStartElement(new QName(namespaceURI, localName), null, null));"
"XMLEventStreamWriter.java:119"$1$"	}"
"XMLEventStreamWriter.java:120"$0$""
"XMLEventStreamWriter.java:121"$0$"	@Override"
"XMLEventStreamWriter.java:122"$1$"	public void writeStartElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {"
"XMLEventStreamWriter.java:123"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:124"$1$"		doWriteStartElement(this.eventFactory.createStartElement(new QName(namespaceURI, localName, prefix), null, null));"
"XMLEventStreamWriter.java:125"$1$"	}"
"XMLEventStreamWriter.java:126"$0$""
"XMLEventStreamWriter.java:127"$1$"	private void doWriteStartElement(StartElement startElement) throws XMLStreamException {"
"XMLEventStreamWriter.java:128"$1$"		this.eventWriter.add(startElement);"
"XMLEventStreamWriter.java:129"$1$"		this.endElements.add(this.eventFactory.createEndElement(startElement.getName(), startElement.getNamespaces()));"
"XMLEventStreamWriter.java:130"$1$"	}"
"XMLEventStreamWriter.java:131"$0$""
"XMLEventStreamWriter.java:132"$0$"	@Override"
"XMLEventStreamWriter.java:133"$1$"	public void writeEmptyElement(String localName) throws XMLStreamException {"
"XMLEventStreamWriter.java:134"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:135"$1$"		writeStartElement(localName);"
"XMLEventStreamWriter.java:136"$1$"		this.emptyElement = true;"
"XMLEventStreamWriter.java:137"$1$"	}"
"XMLEventStreamWriter.java:138"$0$""
"XMLEventStreamWriter.java:139"$0$"	@Override"
"XMLEventStreamWriter.java:140"$1$"	public void writeEmptyElement(String namespaceURI, String localName) throws XMLStreamException {"
"XMLEventStreamWriter.java:141"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:142"$1$"		writeStartElement(namespaceURI, localName);"
"XMLEventStreamWriter.java:143"$1$"		this.emptyElement = true;"
"XMLEventStreamWriter.java:144"$1$"	}"
"XMLEventStreamWriter.java:145"$0$""
"XMLEventStreamWriter.java:146"$0$"	@Override"
"XMLEventStreamWriter.java:147"$1$"	public void writeEmptyElement(String prefix, String localName, String namespaceURI) throws XMLStreamException {"
"XMLEventStreamWriter.java:148"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:149"$1$"		writeStartElement(prefix, localName, namespaceURI);"
"XMLEventStreamWriter.java:150"$1$"		this.emptyElement = true;"
"XMLEventStreamWriter.java:151"$1$"	}"
"XMLEventStreamWriter.java:152"$0$""
"XMLEventStreamWriter.java:153"$1$"	private void closeEmptyElementIfNecessary() throws XMLStreamException {"
"XMLEventStreamWriter.java:154"$1$"		if (this.emptyElement) {"
"XMLEventStreamWriter.java:155"$1$"			this.emptyElement = false;"
"XMLEventStreamWriter.java:156"$1$"			writeEndElement();"
"XMLEventStreamWriter.java:157"$1$"		}"
"XMLEventStreamWriter.java:158"$0$"	}"
"XMLEventStreamWriter.java:159"$0$""
"XMLEventStreamWriter.java:160"$0$"	@Override"
"XMLEventStreamWriter.java:161"$1$"	public void writeEndElement() throws XMLStreamException {"
"XMLEventStreamWriter.java:162"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:163"$1$"		int last = this.endElements.size() - 1;"
"XMLEventStreamWriter.java:164"$1$"		EndElement lastEndElement = this.endElements.get(last);"
"XMLEventStreamWriter.java:165"$1$"		this.eventWriter.add(lastEndElement);"
"XMLEventStreamWriter.java:166"$1$"		this.endElements.remove(last);"
"XMLEventStreamWriter.java:167"$1$"	}"
"XMLEventStreamWriter.java:168"$0$""
"XMLEventStreamWriter.java:169"$0$"	@Override"
"XMLEventStreamWriter.java:170"$1$"	public void writeAttribute(String localName, String value) throws XMLStreamException {"
"XMLEventStreamWriter.java:171"$1$"		this.eventWriter.add(this.eventFactory.createAttribute(localName, value));"
"XMLEventStreamWriter.java:172"$1$"	}"
"XMLEventStreamWriter.java:173"$0$""
"XMLEventStreamWriter.java:174"$0$"	@Override"
"XMLEventStreamWriter.java:175"$1$"	public void writeAttribute(String namespaceURI, String localName, String value) throws XMLStreamException {"
"XMLEventStreamWriter.java:176"$1$"		this.eventWriter.add(this.eventFactory.createAttribute(new QName(namespaceURI, localName), value));"
"XMLEventStreamWriter.java:177"$1$"	}"
"XMLEventStreamWriter.java:178"$0$""
"XMLEventStreamWriter.java:179"$0$"	@Override"
"XMLEventStreamWriter.java:180"$0$"	public void writeAttribute(String prefix, String namespaceURI, String localName, String value)"
"XMLEventStreamWriter.java:181"$1$"			throws XMLStreamException {"
"XMLEventStreamWriter.java:182"$1$""
"XMLEventStreamWriter.java:183"$1$"		this.eventWriter.add(this.eventFactory.createAttribute(prefix, namespaceURI, localName, value));"
"XMLEventStreamWriter.java:184"$1$"	}"
"XMLEventStreamWriter.java:185"$0$""
"XMLEventStreamWriter.java:186"$0$"	@Override"
"XMLEventStreamWriter.java:187"$1$"	public void writeNamespace(String prefix, String namespaceURI) throws XMLStreamException {"
"XMLEventStreamWriter.java:188"$1$"		doWriteNamespace(this.eventFactory.createNamespace(prefix, namespaceURI));"
"XMLEventStreamWriter.java:189"$1$"	}"
"XMLEventStreamWriter.java:190"$0$""
"XMLEventStreamWriter.java:191"$0$"	@Override"
"XMLEventStreamWriter.java:192"$1$"	public void writeDefaultNamespace(String namespaceURI) throws XMLStreamException {"
"XMLEventStreamWriter.java:193"$1$"		doWriteNamespace(this.eventFactory.createNamespace(namespaceURI));"
"XMLEventStreamWriter.java:194"$1$"	}"
"XMLEventStreamWriter.java:195"$0$""
"XMLEventStreamWriter.java:196"$0$"	@SuppressWarnings(""rawtypes"")"
"XMLEventStreamWriter.java:197"$1$"	private void doWriteNamespace(Namespace namespace) throws XMLStreamException {"
"XMLEventStreamWriter.java:198"$1$"		int last = this.endElements.size() - 1;"
"XMLEventStreamWriter.java:199"$1$"		EndElement oldEndElement = this.endElements.get(last);"
"XMLEventStreamWriter.java:200"$1$"		Iterator oldNamespaces = oldEndElement.getNamespaces();"
"XMLEventStreamWriter.java:201"$1$"		List<Namespace> newNamespaces = new ArrayList<>();"
"XMLEventStreamWriter.java:202"$1$"		while (oldNamespaces.hasNext()) {"
"XMLEventStreamWriter.java:203"$1$"			Namespace oldNamespace = (Namespace) oldNamespaces.next();"
"XMLEventStreamWriter.java:204"$1$"			newNamespaces.add(oldNamespace);"
"XMLEventStreamWriter.java:205"$1$"		}"
"XMLEventStreamWriter.java:206"$0$"		newNamespaces.add(namespace);"
"XMLEventStreamWriter.java:207"$0$"		EndElement newEndElement = this.eventFactory.createEndElement(oldEndElement.getName(), newNamespaces.iterator());"
"XMLEventStreamWriter.java:208"$0$"		this.eventWriter.add(namespace);"
"XMLEventStreamWriter.java:209"$0$"		this.endElements.set(last, newEndElement);"
"XMLEventStreamWriter.java:210"$0$"	}"
"XMLEventStreamWriter.java:211"$0$""
"XMLEventStreamWriter.java:212"$0$"	@Override"
"XMLEventStreamWriter.java:213"$1$"	public void writeCharacters(String text) throws XMLStreamException {"
"XMLEventStreamWriter.java:214"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:215"$1$"		this.eventWriter.add(this.eventFactory.createCharacters(text));"
"XMLEventStreamWriter.java:216"$1$"	}"
"XMLEventStreamWriter.java:217"$0$""
"XMLEventStreamWriter.java:218"$0$"	@Override"
"XMLEventStreamWriter.java:219"$1$"	public void writeCharacters(char[] text, int start, int len) throws XMLStreamException {"
"XMLEventStreamWriter.java:220"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:221"$1$"		this.eventWriter.add(this.eventFactory.createCharacters(new String(text, start, len)));"
"XMLEventStreamWriter.java:222"$1$"	}"
"XMLEventStreamWriter.java:223"$0$""
"XMLEventStreamWriter.java:224"$0$"	@Override"
"XMLEventStreamWriter.java:225"$1$"	public void writeCData(String data) throws XMLStreamException {"
"XMLEventStreamWriter.java:226"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:227"$1$"		this.eventWriter.add(this.eventFactory.createCData(data));"
"XMLEventStreamWriter.java:228"$1$"	}"
"XMLEventStreamWriter.java:229"$0$""
"XMLEventStreamWriter.java:230"$0$"	@Override"
"XMLEventStreamWriter.java:231"$1$"	public void writeComment(String data) throws XMLStreamException {"
"XMLEventStreamWriter.java:232"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:233"$1$"		this.eventWriter.add(this.eventFactory.createComment(data));"
"XMLEventStreamWriter.java:234"$1$"	}"
"XMLEventStreamWriter.java:235"$0$""
"XMLEventStreamWriter.java:236"$0$"	@Override"
"XMLEventStreamWriter.java:237"$1$"	public void writeProcessingInstruction(String target) throws XMLStreamException {"
"XMLEventStreamWriter.java:238"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:239"$1$"		this.eventWriter.add(this.eventFactory.createProcessingInstruction(target, """"));"
"XMLEventStreamWriter.java:240"$1$"	}"
"XMLEventStreamWriter.java:241"$0$""
"XMLEventStreamWriter.java:242"$0$"	@Override"
"XMLEventStreamWriter.java:243"$1$"	public void writeProcessingInstruction(String target, String data) throws XMLStreamException {"
"XMLEventStreamWriter.java:244"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:245"$1$"		this.eventWriter.add(this.eventFactory.createProcessingInstruction(target, data));"
"XMLEventStreamWriter.java:246"$1$"	}"
"XMLEventStreamWriter.java:247"$0$""
"XMLEventStreamWriter.java:248"$0$"	@Override"
"XMLEventStreamWriter.java:249"$1$"	public void writeDTD(String dtd) throws XMLStreamException {"
"XMLEventStreamWriter.java:250"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:251"$1$"		this.eventWriter.add(this.eventFactory.createDTD(dtd));"
"XMLEventStreamWriter.java:252"$1$"	}"
"XMLEventStreamWriter.java:253"$0$""
"XMLEventStreamWriter.java:254"$0$"	@Override"
"XMLEventStreamWriter.java:255"$1$"	public void writeEntityRef(String name) throws XMLStreamException {"
"XMLEventStreamWriter.java:256"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:257"$1$"		this.eventWriter.add(this.eventFactory.createEntityReference(name, null));"
"XMLEventStreamWriter.java:258"$1$"	}"
"XMLEventStreamWriter.java:259"$0$""
"XMLEventStreamWriter.java:260"$0$"	@Override"
"XMLEventStreamWriter.java:261"$1$"	public void writeEndDocument() throws XMLStreamException {"
"XMLEventStreamWriter.java:262"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:263"$1$"		this.eventWriter.add(this.eventFactory.createEndDocument());"
"XMLEventStreamWriter.java:264"$1$"	}"
"XMLEventStreamWriter.java:265"$0$""
"XMLEventStreamWriter.java:266"$0$"	@Override"
"XMLEventStreamWriter.java:267"$1$"	public void flush() throws XMLStreamException {"
"XMLEventStreamWriter.java:268"$1$"		this.eventWriter.flush();"
"XMLEventStreamWriter.java:269"$1$"	}"
"XMLEventStreamWriter.java:270"$0$""
"XMLEventStreamWriter.java:271"$0$"	@Override"
"XMLEventStreamWriter.java:272"$1$"	public void close() throws XMLStreamException {"
"XMLEventStreamWriter.java:273"$1$"		closeEmptyElementIfNecessary();"
"XMLEventStreamWriter.java:274"$1$"		this.eventWriter.close();"
"XMLEventStreamWriter.java:275"$1$"	}"
"XMLEventStreamWriter.java:276"$0$""
"XMLEventStreamWriter.java:277"$0$"}"
"MonoToListenableFutureAdapter.java:1"$0$"/*"
"MonoToListenableFutureAdapter.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"MonoToListenableFutureAdapter.java:3"$0$" *"
"MonoToListenableFutureAdapter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MonoToListenableFutureAdapter.java:5"$0$" * you may not use this file except in compliance with the License."
"MonoToListenableFutureAdapter.java:6"$0$" * You may obtain a copy of the License at"
"MonoToListenableFutureAdapter.java:7"$0$" *"
"MonoToListenableFutureAdapter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MonoToListenableFutureAdapter.java:9"$0$" *"
"MonoToListenableFutureAdapter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MonoToListenableFutureAdapter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MonoToListenableFutureAdapter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MonoToListenableFutureAdapter.java:13"$0$" * See the License for the specific language governing permissions and"
"MonoToListenableFutureAdapter.java:14"$0$" * limitations under the License."
"MonoToListenableFutureAdapter.java:15"$0$" */"
"MonoToListenableFutureAdapter.java:16"$0$""
"MonoToListenableFutureAdapter.java:17"$0$"package org.springframework.util.concurrent;"
"MonoToListenableFutureAdapter.java:18"$0$""
"MonoToListenableFutureAdapter.java:19"$0$"import java.time.Duration;"
"MonoToListenableFutureAdapter.java:20"$0$"import java.util.concurrent.TimeUnit;"
"MonoToListenableFutureAdapter.java:21"$0$""
"MonoToListenableFutureAdapter.java:22"$0$"import reactor.core.publisher.Mono;"
"MonoToListenableFutureAdapter.java:23"$0$"import reactor.core.publisher.MonoProcessor;"
"MonoToListenableFutureAdapter.java:24"$0$""
"MonoToListenableFutureAdapter.java:25"$0$"import org.springframework.lang.Nullable;"
"MonoToListenableFutureAdapter.java:26"$0$"import org.springframework.util.Assert;"
"MonoToListenableFutureAdapter.java:27"$0$""
"MonoToListenableFutureAdapter.java:28"$0$"/**"
"MonoToListenableFutureAdapter.java:29"$1$" * Adapts a {@link Mono} into a {@link ListenableFuture}."
"MonoToListenableFutureAdapter.java:30"$0$" *"
"MonoToListenableFutureAdapter.java:31"$0$" * @author Rossen Stoyanchev"
"MonoToListenableFutureAdapter.java:32"$0$" * @author Stephane Maldini"
"MonoToListenableFutureAdapter.java:33"$0$" * @since 5.1"
"MonoToListenableFutureAdapter.java:34"$0$" * @param <T> the object type"
"MonoToListenableFutureAdapter.java:35"$0$" */"
"MonoToListenableFutureAdapter.java:36"$1$"public class MonoToListenableFutureAdapter<T> implements ListenableFuture<T> {"
"MonoToListenableFutureAdapter.java:37"$1$""
"MonoToListenableFutureAdapter.java:38"$1$"	private final MonoProcessor<T> processor;"
"MonoToListenableFutureAdapter.java:39"$1$""
"MonoToListenableFutureAdapter.java:40"$1$"	private final ListenableFutureCallbackRegistry<T> registry = new ListenableFutureCallbackRegistry<>();"
"MonoToListenableFutureAdapter.java:41"$1$""
"MonoToListenableFutureAdapter.java:42"$1$""
"MonoToListenableFutureAdapter.java:43"$1$"	public MonoToListenableFutureAdapter(Mono<T> mono) {"
"MonoToListenableFutureAdapter.java:44"$1$"		Assert.notNull(mono, ""Mono must not be null"");"
"MonoToListenableFutureAdapter.java:45"$1$"		this.processor = mono"
"MonoToListenableFutureAdapter.java:46"$1$"				.doOnSuccess(this.registry::success)"
"MonoToListenableFutureAdapter.java:47"$1$"				.doOnError(this.registry::failure)"
"MonoToListenableFutureAdapter.java:48"$1$"				.toProcessor();"
"MonoToListenableFutureAdapter.java:49"$1$"	}"
"MonoToListenableFutureAdapter.java:50"$0$""
"MonoToListenableFutureAdapter.java:51"$0$""
"MonoToListenableFutureAdapter.java:52"$0$"	@Override"
"MonoToListenableFutureAdapter.java:53"$0$"	@Nullable"
"MonoToListenableFutureAdapter.java:54"$1$"	public T get() {"
"MonoToListenableFutureAdapter.java:55"$1$"		return this.processor.block();"
"MonoToListenableFutureAdapter.java:56"$1$"	}"
"MonoToListenableFutureAdapter.java:57"$0$""
"MonoToListenableFutureAdapter.java:58"$0$"	@Override"
"MonoToListenableFutureAdapter.java:59"$0$"	@Nullable"
"MonoToListenableFutureAdapter.java:60"$1$"	public T get(long timeout, TimeUnit unit) {"
"MonoToListenableFutureAdapter.java:61"$1$"		Assert.notNull(unit, ""TimeUnit must not be null"");"
"MonoToListenableFutureAdapter.java:62"$1$"		Duration duration = Duration.ofMillis(TimeUnit.MILLISECONDS.convert(timeout, unit));"
"MonoToListenableFutureAdapter.java:63"$1$"		return this.processor.block(duration);"
"MonoToListenableFutureAdapter.java:64"$1$"	}"
"MonoToListenableFutureAdapter.java:65"$0$""
"MonoToListenableFutureAdapter.java:66"$0$"	@Override"
"MonoToListenableFutureAdapter.java:67"$1$"	public boolean cancel(boolean mayInterruptIfRunning) {"
"MonoToListenableFutureAdapter.java:68"$1$"		if (isCancelled()) {"
"MonoToListenableFutureAdapter.java:69"$1$"			return false;"
"MonoToListenableFutureAdapter.java:70"$1$"		}"
"MonoToListenableFutureAdapter.java:71"$0$"		this.processor.cancel();"
"MonoToListenableFutureAdapter.java:72"$0$"		// isCancelled may still return false, if mono completed before the cancel"
"MonoToListenableFutureAdapter.java:73"$0$"		return this.processor.isCancelled();"
"MonoToListenableFutureAdapter.java:74"$0$"	}"
"MonoToListenableFutureAdapter.java:75"$0$""
"MonoToListenableFutureAdapter.java:76"$0$"	@Override"
"MonoToListenableFutureAdapter.java:77"$1$"	public boolean isCancelled() {"
"MonoToListenableFutureAdapter.java:78"$1$"		return this.processor.isCancelled();"
"MonoToListenableFutureAdapter.java:79"$1$"	}"
"MonoToListenableFutureAdapter.java:80"$0$""
"MonoToListenableFutureAdapter.java:81"$0$"	@Override"
"MonoToListenableFutureAdapter.java:82"$1$"	public boolean isDone() {"
"MonoToListenableFutureAdapter.java:83"$1$"		return this.processor.isTerminated();"
"MonoToListenableFutureAdapter.java:84"$1$"	}"
"MonoToListenableFutureAdapter.java:85"$0$""
"MonoToListenableFutureAdapter.java:86"$0$"	@Override"
"MonoToListenableFutureAdapter.java:87"$1$"	public void addCallback(ListenableFutureCallback<? super T> callback) {"
"MonoToListenableFutureAdapter.java:88"$1$"		this.registry.addCallback(callback);"
"MonoToListenableFutureAdapter.java:89"$1$"	}"
"MonoToListenableFutureAdapter.java:90"$0$""
"MonoToListenableFutureAdapter.java:91"$0$"	@Override"
"MonoToListenableFutureAdapter.java:92"$1$"	public void addCallback(SuccessCallback<? super T> success, FailureCallback failure) {"
"MonoToListenableFutureAdapter.java:93"$1$"		this.registry.addSuccessCallback(success);"
"MonoToListenableFutureAdapter.java:94"$1$"		this.registry.addFailureCallback(failure);"
"MonoToListenableFutureAdapter.java:95"$1$"	}"
"MonoToListenableFutureAdapter.java:96"$0$""
"MonoToListenableFutureAdapter.java:97"$0$"}"
"MethodInvoker.java:1"$0$"/*"
"MethodInvoker.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MethodInvoker.java:3"$0$" *"
"MethodInvoker.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MethodInvoker.java:5"$0$" * you may not use this file except in compliance with the License."
"MethodInvoker.java:6"$0$" * You may obtain a copy of the License at"
"MethodInvoker.java:7"$0$" *"
"MethodInvoker.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MethodInvoker.java:9"$0$" *"
"MethodInvoker.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MethodInvoker.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MethodInvoker.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MethodInvoker.java:13"$0$" * See the License for the specific language governing permissions and"
"MethodInvoker.java:14"$0$" * limitations under the License."
"MethodInvoker.java:15"$0$" */"
"MethodInvoker.java:16"$0$""
"MethodInvoker.java:17"$0$"package org.springframework.util;"
"MethodInvoker.java:18"$0$""
"MethodInvoker.java:19"$0$"import java.lang.reflect.InvocationTargetException;"
"MethodInvoker.java:20"$0$"import java.lang.reflect.Method;"
"MethodInvoker.java:21"$0$"import java.lang.reflect.Modifier;"
"MethodInvoker.java:22"$0$""
"MethodInvoker.java:23"$0$"import org.springframework.lang.Nullable;"
"MethodInvoker.java:24"$0$""
"MethodInvoker.java:25"$0$"/**"
"MethodInvoker.java:26"$0$" * Helper class that allows for specifying a method to invoke in a declarative"
"MethodInvoker.java:27"$0$" * fashion, be it static or non-static."
"MethodInvoker.java:28"$0$" *"
"MethodInvoker.java:29"$0$" * <p>Usage: Specify ""targetClass""/""targetMethod"" or ""targetObject""/""targetMethod"","
"MethodInvoker.java:30"$0$" * optionally specify arguments, prepare the invoker. Afterwards, you may"
"MethodInvoker.java:31"$0$" * invoke the method any number of times, obtaining the invocation result."
"MethodInvoker.java:32"$0$" *"
"MethodInvoker.java:33"$0$" * @author Colin Sampaleanu"
"MethodInvoker.java:34"$0$" * @author Juergen Hoeller"
"MethodInvoker.java:35"$0$" * @since 19.02.2004"
"MethodInvoker.java:36"$0$" * @see #prepare"
"MethodInvoker.java:37"$0$" * @see #invoke"
"MethodInvoker.java:38"$0$" */"
"MethodInvoker.java:39"$1$"public class MethodInvoker {"
"MethodInvoker.java:40"$1$""
"MethodInvoker.java:41"$1$"	private static final Object[] EMPTY_ARGUMENTS = new Object[0];"
"MethodInvoker.java:42"$1$""
"MethodInvoker.java:43"$1$""
"MethodInvoker.java:44"$1$"	@Nullable"
"MethodInvoker.java:45"$1$"	protected Class<?> targetClass;"
"MethodInvoker.java:46"$1$""
"MethodInvoker.java:47"$1$"	@Nullable"
"MethodInvoker.java:48"$1$"	private Object targetObject;"
"MethodInvoker.java:49"$1$""
"MethodInvoker.java:50"$1$"	@Nullable"
"MethodInvoker.java:51"$1$"	private String targetMethod;"
"MethodInvoker.java:52"$1$""
"MethodInvoker.java:53"$1$"	@Nullable"
"MethodInvoker.java:54"$1$"	private String staticMethod;"
"MethodInvoker.java:55"$1$""
"MethodInvoker.java:56"$1$"	@Nullable"
"MethodInvoker.java:57"$1$"	private Object[] arguments;"
"MethodInvoker.java:58"$1$""
"MethodInvoker.java:59"$1$"	/** The method we will call. */"
"MethodInvoker.java:60"$1$"	@Nullable"
"MethodInvoker.java:61"$1$"	private Method methodObject;"
"MethodInvoker.java:62"$1$""
"MethodInvoker.java:63"$1$""
"MethodInvoker.java:64"$1$"	/**"
"MethodInvoker.java:65"$1$"	 * Set the target class on which to call the target method."
"MethodInvoker.java:66"$1$"	 * Only necessary when the target method is static; else,"
"MethodInvoker.java:67"$1$"	 * a target object needs to be specified anyway."
"MethodInvoker.java:68"$1$"	 * @see #setTargetObject"
"MethodInvoker.java:69"$1$"	 * @see #setTargetMethod"
"MethodInvoker.java:70"$1$"	 */"
"MethodInvoker.java:71"$1$"	public void setTargetClass(@Nullable Class<?> targetClass) {"
"MethodInvoker.java:72"$1$"		this.targetClass = targetClass;"
"MethodInvoker.java:73"$1$"	}"
"MethodInvoker.java:74"$0$""
"MethodInvoker.java:75"$0$"	/**"
"MethodInvoker.java:76"$0$"	 * Return the target class on which to call the target method."
"MethodInvoker.java:77"$0$"	 */"
"MethodInvoker.java:78"$0$"	@Nullable"
"MethodInvoker.java:79"$1$"	public Class<?> getTargetClass() {"
"MethodInvoker.java:80"$1$"		return this.targetClass;"
"MethodInvoker.java:81"$1$"	}"
"MethodInvoker.java:82"$0$""
"MethodInvoker.java:83"$0$"	/**"
"MethodInvoker.java:84"$0$"	 * Set the target object on which to call the target method."
"MethodInvoker.java:85"$0$"	 * Only necessary when the target method is not static;"
"MethodInvoker.java:86"$0$"	 * else, a target class is sufficient."
"MethodInvoker.java:87"$0$"	 * @see #setTargetClass"
"MethodInvoker.java:88"$0$"	 * @see #setTargetMethod"
"MethodInvoker.java:89"$0$"	 */"
"MethodInvoker.java:90"$1$"	public void setTargetObject(@Nullable Object targetObject) {"
"MethodInvoker.java:91"$1$"		this.targetObject = targetObject;"
"MethodInvoker.java:92"$1$"		if (targetObject != null) {"
"MethodInvoker.java:93"$1$"			this.targetClass = targetObject.getClass();"
"MethodInvoker.java:94"$1$"		}"
"MethodInvoker.java:95"$0$"	}"
"MethodInvoker.java:96"$0$""
"MethodInvoker.java:97"$0$"	/**"
"MethodInvoker.java:98"$0$"	 * Return the target object on which to call the target method."
"MethodInvoker.java:99"$0$"	 */"
"MethodInvoker.java:100"$0$"	@Nullable"
"MethodInvoker.java:101"$1$"	public Object getTargetObject() {"
"MethodInvoker.java:102"$1$"		return this.targetObject;"
"MethodInvoker.java:103"$1$"	}"
"MethodInvoker.java:104"$0$""
"MethodInvoker.java:105"$0$"	/**"
"MethodInvoker.java:106"$0$"	 * Set the name of the method to be invoked."
"MethodInvoker.java:107"$0$"	 * Refers to either a static method or a non-static method,"
"MethodInvoker.java:108"$0$"	 * depending on a target object being set."
"MethodInvoker.java:109"$0$"	 * @see #setTargetClass"
"MethodInvoker.java:110"$0$"	 * @see #setTargetObject"
"MethodInvoker.java:111"$0$"	 */"
"MethodInvoker.java:112"$1$"	public void setTargetMethod(@Nullable String targetMethod) {"
"MethodInvoker.java:113"$1$"		this.targetMethod = targetMethod;"
"MethodInvoker.java:114"$1$"	}"
"MethodInvoker.java:115"$0$""
"MethodInvoker.java:116"$0$"	/**"
"MethodInvoker.java:117"$0$"	 * Return the name of the method to be invoked."
"MethodInvoker.java:118"$0$"	 */"
"MethodInvoker.java:119"$0$"	@Nullable"
"MethodInvoker.java:120"$1$"	public String getTargetMethod() {"
"MethodInvoker.java:121"$1$"		return this.targetMethod;"
"MethodInvoker.java:122"$1$"	}"
"MethodInvoker.java:123"$0$""
"MethodInvoker.java:124"$0$"	/**"
"MethodInvoker.java:125"$0$"	 * Set a fully qualified static method name to invoke,"
"MethodInvoker.java:126"$0$"	 * e.g. ""example.MyExampleClass.myExampleMethod""."
"MethodInvoker.java:127"$0$"	 * Convenient alternative to specifying targetClass and targetMethod."
"MethodInvoker.java:128"$0$"	 * @see #setTargetClass"
"MethodInvoker.java:129"$0$"	 * @see #setTargetMethod"
"MethodInvoker.java:130"$0$"	 */"
"MethodInvoker.java:131"$1$"	public void setStaticMethod(String staticMethod) {"
"MethodInvoker.java:132"$1$"		this.staticMethod = staticMethod;"
"MethodInvoker.java:133"$1$"	}"
"MethodInvoker.java:134"$0$""
"MethodInvoker.java:135"$0$"	/**"
"MethodInvoker.java:136"$0$"	 * Set arguments for the method invocation. If this property is not set,"
"MethodInvoker.java:137"$0$"	 * or the Object array is of length 0, a method with no arguments is assumed."
"MethodInvoker.java:138"$0$"	 */"
"MethodInvoker.java:139"$1$"	public void setArguments(Object... arguments) {"
"MethodInvoker.java:140"$1$"		this.arguments = arguments;"
"MethodInvoker.java:141"$1$"	}"
"MethodInvoker.java:142"$0$""
"MethodInvoker.java:143"$0$"	/**"
"MethodInvoker.java:144"$0$"	 * Return the arguments for the method invocation."
"MethodInvoker.java:145"$0$"	 */"
"MethodInvoker.java:146"$1$"	public Object[] getArguments() {"
"MethodInvoker.java:147"$1$"		return (this.arguments != null ? this.arguments : EMPTY_ARGUMENTS);"
"MethodInvoker.java:148"$1$"	}"
"MethodInvoker.java:149"$0$""
"MethodInvoker.java:150"$0$""
"MethodInvoker.java:151"$0$"	/**"
"MethodInvoker.java:152"$0$"	 * Prepare the specified method."
"MethodInvoker.java:153"$0$"	 * The method can be invoked any number of times afterwards."
"MethodInvoker.java:154"$0$"	 * @see #getPreparedMethod"
"MethodInvoker.java:155"$0$"	 * @see #invoke"
"MethodInvoker.java:156"$0$"	 */"
"MethodInvoker.java:157"$1$"	public void prepare() throws ClassNotFoundException, NoSuchMethodException {"
"MethodInvoker.java:158"$1$"		if (this.staticMethod != null) {"
"MethodInvoker.java:159"$1$"			int lastDotIndex = this.staticMethod.lastIndexOf('.');"
"MethodInvoker.java:160"$1$"			if (lastDotIndex == -1 || lastDotIndex == this.staticMethod.length()) {"
"MethodInvoker.java:161"$1$"				throw new IllegalArgumentException("
"MethodInvoker.java:162"$1$"						""staticMethod must be a fully qualified class plus method name: "" +"
"MethodInvoker.java:163"$1$"						""e.g. 'example.MyExampleClass.myExampleMethod'"");"
"MethodInvoker.java:164"$1$"			}"
"MethodInvoker.java:165"$0$"			String className = this.staticMethod.substring(0, lastDotIndex);"
"MethodInvoker.java:166"$0$"			String methodName = this.staticMethod.substring(lastDotIndex + 1);"
"MethodInvoker.java:167"$0$"			this.targetClass = resolveClassName(className);"
"MethodInvoker.java:168"$0$"			this.targetMethod = methodName;"
"MethodInvoker.java:169"$0$"		}"
"MethodInvoker.java:170"$0$""
"MethodInvoker.java:171"$0$"		Class<?> targetClass = getTargetClass();"
"MethodInvoker.java:172"$0$"		String targetMethod = getTargetMethod();"
"MethodInvoker.java:173"$0$"		Assert.notNull(targetClass, ""Either 'targetClass' or 'targetObject' is required"");"
"MethodInvoker.java:174"$0$"		Assert.notNull(targetMethod, ""Property 'targetMethod' is required"");"
"MethodInvoker.java:175"$0$""
"MethodInvoker.java:176"$0$"		Object[] arguments = getArguments();"
"MethodInvoker.java:177"$0$"		Class<?>[] argTypes = new Class<?>[arguments.length];"
"MethodInvoker.java:178"$1$"		for (int i = 0; i < arguments.length; ++i) {"
"MethodInvoker.java:179"$1$"			argTypes[i] = (arguments[i] != null ? arguments[i].getClass() : Object.class);"
"MethodInvoker.java:180"$1$"		}"
"MethodInvoker.java:181"$0$""
"MethodInvoker.java:182"$0$"		// Try to get the exact method first."
"MethodInvoker.java:183"$1$"		try {"
"MethodInvoker.java:184"$1$"			this.methodObject = targetClass.getMethod(targetMethod, argTypes);"
"MethodInvoker.java:185"$1$"		}"
"MethodInvoker.java:186"$1$"		catch (NoSuchMethodException ex) {"
"MethodInvoker.java:187"$0$"			// Just rethrow exception if we can't get any match."
"MethodInvoker.java:188"$1$"			this.methodObject = findMatchingMethod();"
"MethodInvoker.java:189"$1$"			if (this.methodObject == null) {"
"MethodInvoker.java:190"$1$"				throw ex;"
"MethodInvoker.java:191"$1$"			}"
"MethodInvoker.java:192"$0$"		}"
"MethodInvoker.java:193"$0$"	}"
"MethodInvoker.java:194"$0$""
"MethodInvoker.java:195"$0$"	/**"
"MethodInvoker.java:196"$0$"	 * Resolve the given class name into a Class."
"MethodInvoker.java:197"$1$"	 * <p>The default implementations uses {@code ClassUtils.forName},"
"MethodInvoker.java:198"$0$"	 * using the thread context class loader."
"MethodInvoker.java:199"$0$"	 * @param className the class name to resolve"
"MethodInvoker.java:200"$0$"	 * @return the resolved Class"
"MethodInvoker.java:201"$0$"	 * @throws ClassNotFoundException if the class name was invalid"
"MethodInvoker.java:202"$0$"	 */"
"MethodInvoker.java:203"$1$"	protected Class<?> resolveClassName(String className) throws ClassNotFoundException {"
"MethodInvoker.java:204"$1$"		return ClassUtils.forName(className, ClassUtils.getDefaultClassLoader());"
"MethodInvoker.java:205"$1$"	}"
"MethodInvoker.java:206"$0$""
"MethodInvoker.java:207"$0$"	/**"
"MethodInvoker.java:208"$0$"	 * Find a matching method with the specified name for the specified arguments."
"MethodInvoker.java:209"$1$"	 * @return a matching method, or {@code null} if none"
"MethodInvoker.java:210"$0$"	 * @see #getTargetClass()"
"MethodInvoker.java:211"$0$"	 * @see #getTargetMethod()"
"MethodInvoker.java:212"$0$"	 * @see #getArguments()"
"MethodInvoker.java:213"$0$"	 */"
"MethodInvoker.java:214"$0$"	@Nullable"
"MethodInvoker.java:215"$1$"	protected Method findMatchingMethod() {"
"MethodInvoker.java:216"$1$"		String targetMethod = getTargetMethod();"
"MethodInvoker.java:217"$1$"		Object[] arguments = getArguments();"
"MethodInvoker.java:218"$1$"		int argCount = arguments.length;"
"MethodInvoker.java:219"$1$""
"MethodInvoker.java:220"$1$"		Class<?> targetClass = getTargetClass();"
"MethodInvoker.java:221"$1$"		Assert.state(targetClass != null, ""No target class set"");"
"MethodInvoker.java:222"$1$"		Method[] candidates = ReflectionUtils.getAllDeclaredMethods(targetClass);"
"MethodInvoker.java:223"$1$"		int minTypeDiffWeight = Integer.MAX_VALUE;"
"MethodInvoker.java:224"$1$"		Method matchingMethod = null;"
"MethodInvoker.java:225"$1$""
"MethodInvoker.java:226"$1$"		for (Method candidate : candidates) {"
"MethodInvoker.java:227"$1$"			if (candidate.getName().equals(targetMethod)) {"
"MethodInvoker.java:228"$1$"				if (candidate.getParameterCount() == argCount) {"
"MethodInvoker.java:229"$1$"					Class<?>[] paramTypes = candidate.getParameterTypes();"
"MethodInvoker.java:230"$1$"					int typeDiffWeight = getTypeDifferenceWeight(paramTypes, arguments);"
"MethodInvoker.java:231"$1$"					if (typeDiffWeight < minTypeDiffWeight) {"
"MethodInvoker.java:232"$1$"						minTypeDiffWeight = typeDiffWeight;"
"MethodInvoker.java:233"$1$"						matchingMethod = candidate;"
"MethodInvoker.java:234"$1$"					}"
"MethodInvoker.java:235"$0$"				}"
"MethodInvoker.java:236"$0$"			}"
"MethodInvoker.java:237"$0$"		}"
"MethodInvoker.java:238"$0$""
"MethodInvoker.java:239"$0$"		return matchingMethod;"
"MethodInvoker.java:240"$0$"	}"
"MethodInvoker.java:241"$0$""
"MethodInvoker.java:242"$0$"	/**"
"MethodInvoker.java:243"$0$"	 * Return the prepared Method object that will be invoked."
"MethodInvoker.java:244"$0$"	 * <p>Can for example be used to determine the return type."
"MethodInvoker.java:245"$1$"	 * @return the prepared Method object (never {@code null})"
"MethodInvoker.java:246"$0$"	 * @throws IllegalStateException if the invoker hasn't been prepared yet"
"MethodInvoker.java:247"$0$"	 * @see #prepare"
"MethodInvoker.java:248"$0$"	 * @see #invoke"
"MethodInvoker.java:249"$0$"	 */"
"MethodInvoker.java:250"$1$"	public Method getPreparedMethod() throws IllegalStateException {"
"MethodInvoker.java:251"$1$"		if (this.methodObject == null) {"
"MethodInvoker.java:252"$1$"			throw new IllegalStateException(""prepare() must be called prior to invoke() on MethodInvoker"");"
"MethodInvoker.java:253"$1$"		}"
"MethodInvoker.java:254"$0$"		return this.methodObject;"
"MethodInvoker.java:255"$0$"	}"
"MethodInvoker.java:256"$0$""
"MethodInvoker.java:257"$0$"	/**"
"MethodInvoker.java:258"$0$"	 * Return whether this invoker has been prepared already,"
"MethodInvoker.java:259"$1$"	 * i.e. whether it allows access to {@link #getPreparedMethod()} already."
"MethodInvoker.java:260"$0$"	 */"
"MethodInvoker.java:261"$1$"	public boolean isPrepared() {"
"MethodInvoker.java:262"$1$"		return (this.methodObject != null);"
"MethodInvoker.java:263"$1$"	}"
"MethodInvoker.java:264"$0$""
"MethodInvoker.java:265"$0$"	/**"
"MethodInvoker.java:266"$0$"	 * Invoke the specified method."
"MethodInvoker.java:267"$0$"	 * <p>The invoker needs to have been prepared before."
"MethodInvoker.java:268"$0$"	 * @return the object (possibly null) returned by the method invocation,"
"MethodInvoker.java:269"$1$"	 * or {@code null} if the method has a void return type"
"MethodInvoker.java:270"$0$"	 * @throws InvocationTargetException if the target method threw an exception"
"MethodInvoker.java:271"$0$"	 * @throws IllegalAccessException if the target method couldn't be accessed"
"MethodInvoker.java:272"$0$"	 * @see #prepare"
"MethodInvoker.java:273"$0$"	 */"
"MethodInvoker.java:274"$0$"	@Nullable"
"MethodInvoker.java:275"$1$"	public Object invoke() throws InvocationTargetException, IllegalAccessException {"
"MethodInvoker.java:276"$0$"		// In the static case, target will simply be {@code null}."
"MethodInvoker.java:277"$1$"		Object targetObject = getTargetObject();"
"MethodInvoker.java:278"$1$"		Method preparedMethod = getPreparedMethod();"
"MethodInvoker.java:279"$1$"		if (targetObject == null && !Modifier.isStatic(preparedMethod.getModifiers())) {"
"MethodInvoker.java:280"$1$"			throw new IllegalArgumentException(""Target method must not be non-static without a target"");"
"MethodInvoker.java:281"$1$"		}"
"MethodInvoker.java:282"$0$"		ReflectionUtils.makeAccessible(preparedMethod);"
"MethodInvoker.java:283"$0$"		return preparedMethod.invoke(targetObject, getArguments());"
"MethodInvoker.java:284"$0$"	}"
"MethodInvoker.java:285"$0$""
"MethodInvoker.java:286"$0$""
"MethodInvoker.java:287"$0$"	/**"
"MethodInvoker.java:288"$0$"	 * Algorithm that judges the match between the declared parameter types of a candidate method"
"MethodInvoker.java:289"$0$"	 * and a specific list of arguments that this method is supposed to be invoked with."
"MethodInvoker.java:290"$0$"	 * <p>Determines a weight that represents the class hierarchy difference between types and"
"MethodInvoker.java:291"$0$"	 * arguments. A direct match, i.e. type Integer -> arg of class Integer, does not increase"
"MethodInvoker.java:292"$0$"	 * the result - all direct matches means weight 0. A match between type Object and arg of"
"MethodInvoker.java:293"$0$"	 * class Integer would increase the weight by 2, due to the superclass 2 steps up in the"
"MethodInvoker.java:294"$0$"	 * hierarchy (i.e. Object) being the last one that still matches the required type Object."
"MethodInvoker.java:295"$0$"	 * Type Number and class Integer would increase the weight by 1 accordingly, due to the"
"MethodInvoker.java:296"$0$"	 * superclass 1 step up the hierarchy (i.e. Number) still matching the required type Number."
"MethodInvoker.java:297"$0$"	 * Therefore, with an arg of type Integer, a constructor (Integer) would be preferred to a"
"MethodInvoker.java:298"$0$"	 * constructor (Number) which would in turn be preferred to a constructor (Object)."
"MethodInvoker.java:299"$0$"	 * All argument weights get accumulated."
"MethodInvoker.java:300"$0$"	 * <p>Note: This is the algorithm used by MethodInvoker itself and also the algorithm"
"MethodInvoker.java:301"$0$"	 * used for constructor and factory method selection in Spring's bean container (in case"
"MethodInvoker.java:302"$0$"	 * of lenient constructor resolution which is the default for regular bean definitions)."
"MethodInvoker.java:303"$0$"	 * @param paramTypes the parameter types to match"
"MethodInvoker.java:304"$0$"	 * @param args the arguments to match"
"MethodInvoker.java:305"$0$"	 * @return the accumulated weight for all arguments"
"MethodInvoker.java:306"$0$"	 */"
"MethodInvoker.java:307"$1$"	public static int getTypeDifferenceWeight(Class<?>[] paramTypes, Object[] args) {"
"MethodInvoker.java:308"$1$"		int result = 0;"
"MethodInvoker.java:309"$1$"		for (int i = 0; i < paramTypes.length; i++) {"
"MethodInvoker.java:310"$1$"			if (!ClassUtils.isAssignableValue(paramTypes[i], args[i])) {"
"MethodInvoker.java:311"$1$"				return Integer.MAX_VALUE;"
"MethodInvoker.java:312"$1$"			}"
"MethodInvoker.java:313"$1$"			if (args[i] != null) {"
"MethodInvoker.java:314"$1$"				Class<?> paramType = paramTypes[i];"
"MethodInvoker.java:315"$1$"				Class<?> superClass = args[i].getClass().getSuperclass();"
"MethodInvoker.java:316"$1$"				while (superClass != null) {"
"MethodInvoker.java:317"$1$"					if (paramType.equals(superClass)) {"
"MethodInvoker.java:318"$1$"						result = result + 2;"
"MethodInvoker.java:319"$1$"						superClass = null;"
"MethodInvoker.java:320"$1$"					}"
"MethodInvoker.java:321"$1$"					else if (ClassUtils.isAssignable(paramType, superClass)) {"
"MethodInvoker.java:322"$1$"						result = result + 2;"
"MethodInvoker.java:323"$1$"						superClass = superClass.getSuperclass();"
"MethodInvoker.java:324"$1$"					}"
"MethodInvoker.java:325"$1$"					else {"
"MethodInvoker.java:326"$1$"						superClass = null;"
"MethodInvoker.java:327"$1$"					}"
"MethodInvoker.java:328"$0$"				}"
"MethodInvoker.java:329"$1$"				if (paramType.isInterface()) {"
"MethodInvoker.java:330"$1$"					result = result + 1;"
"MethodInvoker.java:331"$1$"				}"
"MethodInvoker.java:332"$0$"			}"
"MethodInvoker.java:333"$0$"		}"
"MethodInvoker.java:334"$0$"		return result;"
"MethodInvoker.java:335"$0$"	}"
"MethodInvoker.java:336"$0$""
"MethodInvoker.java:337"$0$"}"
"Conventions.java:1"$0$"/*"
"Conventions.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"Conventions.java:3"$0$" *"
"Conventions.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"Conventions.java:5"$0$" * you may not use this file except in compliance with the License."
"Conventions.java:6"$0$" * You may obtain a copy of the License at"
"Conventions.java:7"$0$" *"
"Conventions.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"Conventions.java:9"$0$" *"
"Conventions.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"Conventions.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"Conventions.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"Conventions.java:13"$0$" * See the License for the specific language governing permissions and"
"Conventions.java:14"$0$" * limitations under the License."
"Conventions.java:15"$0$" */"
"Conventions.java:16"$0$""
"Conventions.java:17"$0$"package org.springframework.core;"
"Conventions.java:18"$0$""
"Conventions.java:19"$0$"import java.lang.reflect.Method;"
"Conventions.java:20"$0$"import java.lang.reflect.Proxy;"
"Conventions.java:21"$0$"import java.util.Collection;"
"Conventions.java:22"$0$"import java.util.Iterator;"
"Conventions.java:23"$0$""
"Conventions.java:24"$0$"import org.springframework.lang.Nullable;"
"Conventions.java:25"$0$"import org.springframework.util.Assert;"
"Conventions.java:26"$0$"import org.springframework.util.ClassUtils;"
"Conventions.java:27"$0$""
"Conventions.java:28"$0$"/**"
"Conventions.java:29"$0$" * Provides methods to support various naming and other conventions used"
"Conventions.java:30"$0$" * throughout the framework. Mainly for internal use within the framework."
"Conventions.java:31"$0$" *"
"Conventions.java:32"$0$" * @author Rob Harrop"
"Conventions.java:33"$0$" * @author Juergen Hoeller"
"Conventions.java:34"$0$" * @author Rossen Stoyanchev"
"Conventions.java:35"$0$" * @since 2.0"
"Conventions.java:36"$0$" */"
"Conventions.java:37"$1$"public final class Conventions {"
"Conventions.java:38"$1$""
"Conventions.java:39"$1$"	/**"
"Conventions.java:40"$1$"	 * Suffix added to names when using arrays."
"Conventions.java:41"$1$"	 */"
"Conventions.java:42"$1$"	private static final String PLURAL_SUFFIX = ""List"";"
"Conventions.java:43"$1$""
"Conventions.java:44"$1$""
"Conventions.java:45"$1$"	private Conventions() {"
"Conventions.java:46"$1$"	}"
"Conventions.java:47"$0$""
"Conventions.java:48"$0$""
"Conventions.java:49"$0$"	/**"
"Conventions.java:50"$1$"	 * Determine the conventional variable name for the supplied {@code Object}"
"Conventions.java:51"$0$"	 * based on its concrete type. The convention used is to return the"
"Conventions.java:52"$1$"	 * un-capitalized short name of the {@code Class}, according to JavaBeans"
"Conventions.java:53"$0$"	 * property naming rules."
"Conventions.java:54"$0$"	 * <p>For example:<br>"
"Conventions.java:55"$1$"	 * {@code com.myapp.Product} becomes {@code ""product""}<br>"
"Conventions.java:56"$1$"	 * {@code com.myapp.MyProduct} becomes {@code ""myProduct""}<br>"
"Conventions.java:57"$1$"	 * {@code com.myapp.UKProduct} becomes {@code ""UKProduct""}<br>"
"Conventions.java:58"$0$"	 * <p>For arrays the pluralized version of the array component type is used."
"Conventions.java:59"$1$"	 * For {@code Collection}s an attempt is made to 'peek ahead' to determine"
"Conventions.java:60"$0$"	 * the component type and return its pluralized version."
"Conventions.java:61"$0$"	 * @param value the value to generate a variable name for"
"Conventions.java:62"$0$"	 * @return the generated variable name"
"Conventions.java:63"$0$"	 */"
"Conventions.java:64"$1$"	public static String getVariableName(Object value) {"
"Conventions.java:65"$1$"		Assert.notNull(value, ""Value must not be null"");"
"Conventions.java:66"$1$"		Class<?> valueClass;"
"Conventions.java:67"$1$"		boolean pluralize = false;"
"Conventions.java:68"$1$""
"Conventions.java:69"$1$"		if (value.getClass().isArray()) {"
"Conventions.java:70"$1$"			valueClass = value.getClass().getComponentType();"
"Conventions.java:71"$1$"			pluralize = true;"
"Conventions.java:72"$1$"		}"
"Conventions.java:73"$1$"		else if (value instanceof Collection) {"
"Conventions.java:74"$1$"			Collection<?> collection = (Collection<?>) value;"
"Conventions.java:75"$1$"			if (collection.isEmpty()) {"
"Conventions.java:76"$1$"				throw new IllegalArgumentException("
"Conventions.java:77"$1$"						""Cannot generate variable name for an empty Collection"");"
"Conventions.java:78"$1$"			}"
"Conventions.java:79"$0$"			Object valueToCheck = peekAhead(collection);"
"Conventions.java:80"$0$"			valueClass = getClassForValue(valueToCheck);"
"Conventions.java:81"$0$"			pluralize = true;"
"Conventions.java:82"$0$"		}"
"Conventions.java:83"$1$"		else {"
"Conventions.java:84"$1$"			valueClass = getClassForValue(value);"
"Conventions.java:85"$1$"		}"
"Conventions.java:86"$0$""
"Conventions.java:87"$0$"		String name = ClassUtils.getShortNameAsProperty(valueClass);"
"Conventions.java:88"$0$"		return (pluralize ? pluralize(name) : name);"
"Conventions.java:89"$0$"	}"
"Conventions.java:90"$0$""
"Conventions.java:91"$0$"	/**"
"Conventions.java:92"$0$"	 * Determine the conventional variable name for the given parameter taking"
"Conventions.java:93"$0$"	 * the generic collection type, if any, into account."
"Conventions.java:94"$0$"	 * <p>As of 5.0 this method supports reactive types:<br>"
"Conventions.java:95"$1$"	 * {@code Mono<com.myapp.Product>} becomes {@code ""productMono""}<br>"
"Conventions.java:96"$1$"	 * {@code Flux<com.myapp.MyProduct>} becomes {@code ""myProductFlux""}<br>"
"Conventions.java:97"$1$"	 * {@code Observable<com.myapp.MyProduct>} becomes {@code ""myProductObservable""}<br>"
"Conventions.java:98"$0$"	 * @param parameter the method or constructor parameter"
"Conventions.java:99"$0$"	 * @return the generated variable name"
"Conventions.java:100"$0$"	 */"
"Conventions.java:101"$1$"	public static String getVariableNameForParameter(MethodParameter parameter) {"
"Conventions.java:102"$1$"		Assert.notNull(parameter, ""MethodParameter must not be null"");"
"Conventions.java:103"$1$"		Class<?> valueClass;"
"Conventions.java:104"$1$"		boolean pluralize = false;"
"Conventions.java:105"$1$"		String reactiveSuffix = """";"
"Conventions.java:106"$1$""
"Conventions.java:107"$1$"		if (parameter.getParameterType().isArray()) {"
"Conventions.java:108"$1$"			valueClass = parameter.getParameterType().getComponentType();"
"Conventions.java:109"$1$"			pluralize = true;"
"Conventions.java:110"$1$"		}"
"Conventions.java:111"$1$"		else if (Collection.class.isAssignableFrom(parameter.getParameterType())) {"
"Conventions.java:112"$1$"			valueClass = ResolvableType.forMethodParameter(parameter).asCollection().resolveGeneric();"
"Conventions.java:113"$1$"			if (valueClass == null) {"
"Conventions.java:114"$1$"				throw new IllegalArgumentException("
"Conventions.java:115"$1$"						""Cannot generate variable name for non-typed Collection parameter type"");"
"Conventions.java:116"$1$"			}"
"Conventions.java:117"$0$"			pluralize = true;"
"Conventions.java:118"$0$"		}"
"Conventions.java:119"$1$"		else {"
"Conventions.java:120"$1$"			valueClass = parameter.getParameterType();"
"Conventions.java:121"$1$"			ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);"
"Conventions.java:122"$1$"			if (adapter != null && !adapter.getDescriptor().isNoValue()) {"
"Conventions.java:123"$1$"				reactiveSuffix = ClassUtils.getShortName(valueClass);"
"Conventions.java:124"$1$"				valueClass = parameter.nested().getNestedParameterType();"
"Conventions.java:125"$1$"			}"
"Conventions.java:126"$0$"		}"
"Conventions.java:127"$0$""
"Conventions.java:128"$0$"		String name = ClassUtils.getShortNameAsProperty(valueClass);"
"Conventions.java:129"$0$"		return (pluralize ? pluralize(name) : name + reactiveSuffix);"
"Conventions.java:130"$0$"	}"
"Conventions.java:131"$0$""
"Conventions.java:132"$0$"	/**"
"Conventions.java:133"$0$"	 * Determine the conventional variable name for the return type of the"
"Conventions.java:134"$0$"	 * given method, taking the generic collection type, if any, into account."
"Conventions.java:135"$0$"	 * @param method the method to generate a variable name for"
"Conventions.java:136"$0$"	 * @return the generated variable name"
"Conventions.java:137"$0$"	 */"
"Conventions.java:138"$1$"	public static String getVariableNameForReturnType(Method method) {"
"Conventions.java:139"$1$"		return getVariableNameForReturnType(method, method.getReturnType(), null);"
"Conventions.java:140"$1$"	}"
"Conventions.java:141"$0$""
"Conventions.java:142"$0$"	/**"
"Conventions.java:143"$0$"	 * Determine the conventional variable name for the return type of the given"
"Conventions.java:144"$0$"	 * method, taking the generic collection type, if any, into account, falling"
"Conventions.java:145"$0$"	 * back on the given actual return value if the method declaration is not"
"Conventions.java:146"$1$"	 * specific enough, e.g. {@code Object} return type or untyped collection."
"Conventions.java:147"$0$"	 * @param method the method to generate a variable name for"
"Conventions.java:148"$1$"	 * @param value the return value (may be {@code null} if not available)"
"Conventions.java:149"$0$"	 * @return the generated variable name"
"Conventions.java:150"$0$"	 */"
"Conventions.java:151"$1$"	public static String getVariableNameForReturnType(Method method, @Nullable Object value) {"
"Conventions.java:152"$1$"		return getVariableNameForReturnType(method, method.getReturnType(), value);"
"Conventions.java:153"$1$"	}"
"Conventions.java:154"$0$""
"Conventions.java:155"$0$"	/**"
"Conventions.java:156"$0$"	 * Determine the conventional variable name for the return type of the given"
"Conventions.java:157"$0$"	 * method, taking the generic collection type, if any, into account, falling"
"Conventions.java:158"$0$"	 * back on the given return value if the method declaration is not specific"
"Conventions.java:159"$1$"	 * enough, e.g. {@code Object} return type or untyped collection."
"Conventions.java:160"$0$"	 * <p>As of 5.0 this method supports reactive types:<br>"
"Conventions.java:161"$1$"	 * {@code Mono<com.myapp.Product>} becomes {@code ""productMono""}<br>"
"Conventions.java:162"$1$"	 * {@code Flux<com.myapp.MyProduct>} becomes {@code ""myProductFlux""}<br>"
"Conventions.java:163"$1$"	 * {@code Observable<com.myapp.MyProduct>} becomes {@code ""myProductObservable""}<br>"
"Conventions.java:164"$0$"	 * @param method the method to generate a variable name for"
"Conventions.java:165"$0$"	 * @param resolvedType the resolved return type of the method"
"Conventions.java:166"$1$"	 * @param value the return value (may be {@code null} if not available)"
"Conventions.java:167"$0$"	 * @return the generated variable name"
"Conventions.java:168"$0$"	 */"
"Conventions.java:169"$1$"	public static String getVariableNameForReturnType(Method method, Class<?> resolvedType, @Nullable Object value) {"
"Conventions.java:170"$1$"		Assert.notNull(method, ""Method must not be null"");"
"Conventions.java:171"$1$""
"Conventions.java:172"$1$"		if (Object.class == resolvedType) {"
"Conventions.java:173"$1$"			if (value == null) {"
"Conventions.java:174"$1$"				throw new IllegalArgumentException("
"Conventions.java:175"$1$"						""Cannot generate variable name for an Object return type with null value"");"
"Conventions.java:176"$1$"			}"
"Conventions.java:177"$0$"			return getVariableName(value);"
"Conventions.java:178"$0$"		}"
"Conventions.java:179"$0$""
"Conventions.java:180"$0$"		Class<?> valueClass;"
"Conventions.java:181"$0$"		boolean pluralize = false;"
"Conventions.java:182"$0$"		String reactiveSuffix = """";"
"Conventions.java:183"$0$""
"Conventions.java:184"$1$"		if (resolvedType.isArray()) {"
"Conventions.java:185"$1$"			valueClass = resolvedType.getComponentType();"
"Conventions.java:186"$1$"			pluralize = true;"
"Conventions.java:187"$1$"		}"
"Conventions.java:188"$1$"		else if (Collection.class.isAssignableFrom(resolvedType)) {"
"Conventions.java:189"$1$"			valueClass = ResolvableType.forMethodReturnType(method).asCollection().resolveGeneric();"
"Conventions.java:190"$1$"			if (valueClass == null) {"
"Conventions.java:191"$1$"				if (!(value instanceof Collection)) {"
"Conventions.java:192"$1$"					throw new IllegalArgumentException(""Cannot generate variable name "" +"
"Conventions.java:193"$1$"							""for non-typed Collection return type and a non-Collection value"");"
"Conventions.java:194"$1$"				}"
"Conventions.java:195"$0$"				Collection<?> collection = (Collection<?>) value;"
"Conventions.java:196"$1$"				if (collection.isEmpty()) {"
"Conventions.java:197"$1$"					throw new IllegalArgumentException(""Cannot generate variable name "" +"
"Conventions.java:198"$1$"							""for non-typed Collection return type and an empty Collection value"");"
"Conventions.java:199"$1$"				}"
"Conventions.java:200"$0$"				Object valueToCheck = peekAhead(collection);"
"Conventions.java:201"$0$"				valueClass = getClassForValue(valueToCheck);"
"Conventions.java:202"$0$"			}"
"Conventions.java:203"$0$"			pluralize = true;"
"Conventions.java:204"$0$"		}"
"Conventions.java:205"$1$"		else {"
"Conventions.java:206"$1$"			valueClass = resolvedType;"
"Conventions.java:207"$1$"			ReactiveAdapter adapter = ReactiveAdapterRegistry.getSharedInstance().getAdapter(valueClass);"
"Conventions.java:208"$1$"			if (adapter != null && !adapter.getDescriptor().isNoValue()) {"
"Conventions.java:209"$1$"				reactiveSuffix = ClassUtils.getShortName(valueClass);"
"Conventions.java:210"$1$"				valueClass = ResolvableType.forMethodReturnType(method).getGeneric().toClass();"
"Conventions.java:211"$1$"			}"
"Conventions.java:212"$0$"		}"
"Conventions.java:213"$0$""
"Conventions.java:214"$0$"		String name = ClassUtils.getShortNameAsProperty(valueClass);"
"Conventions.java:215"$0$"		return (pluralize ? pluralize(name) : name + reactiveSuffix);"
"Conventions.java:216"$0$"	}"
"Conventions.java:217"$0$""
"Conventions.java:218"$0$"	/**"
"Conventions.java:219"$1$"	 * Convert {@code String}s in attribute name format (e.g. lowercase, hyphens"
"Conventions.java:220"$0$"	 * separating words) into property name format (camel-case). For example"
"Conventions.java:221"$1$"	 * {@code transaction-manager} becomes {@code ""transactionManager""}."
"Conventions.java:222"$0$"	 */"
"Conventions.java:223"$1$"	public static String attributeNameToPropertyName(String attributeName) {"
"Conventions.java:224"$1$"		Assert.notNull(attributeName, ""'attributeName' must not be null"");"
"Conventions.java:225"$1$"		if (!attributeName.contains(""-"")) {"
"Conventions.java:226"$1$"			return attributeName;"
"Conventions.java:227"$1$"		}"
"Conventions.java:228"$0$"		char[] chars = attributeName.toCharArray();"
"Conventions.java:229"$0$"		char[] result = new char[chars.length -1]; // not completely accurate but good guess"
"Conventions.java:230"$0$"		int currPos = 0;"
"Conventions.java:231"$0$"		boolean upperCaseNext = false;"
"Conventions.java:232"$1$"		for (char c : chars) {"
"Conventions.java:233"$1$"			if (c == '-') {"
"Conventions.java:234"$1$"				upperCaseNext = true;"
"Conventions.java:235"$1$"			}"
"Conventions.java:236"$1$"			else if (upperCaseNext) {"
"Conventions.java:237"$1$"				result[currPos++] = Character.toUpperCase(c);"
"Conventions.java:238"$1$"				upperCaseNext = false;"
"Conventions.java:239"$1$"			}"
"Conventions.java:240"$1$"			else {"
"Conventions.java:241"$1$"				result[currPos++] = c;"
"Conventions.java:242"$1$"			}"
"Conventions.java:243"$0$"		}"
"Conventions.java:244"$0$"		return new String(result, 0, currPos);"
"Conventions.java:245"$0$"	}"
"Conventions.java:246"$0$""
"Conventions.java:247"$0$"	/**"
"Conventions.java:248"$1$"	 * Return an attribute name qualified by the given enclosing {@link Class}."
"Conventions.java:249"$1$"	 * For example the attribute name '{@code foo}' qualified by {@link Class}"
"Conventions.java:250"$1$"	 * '{@code com.myapp.SomeClass}' would be '{@code com.myapp.SomeClass.foo}'"
"Conventions.java:251"$0$"	 */"
"Conventions.java:252"$1$"	public static String getQualifiedAttributeName(Class<?> enclosingClass, String attributeName) {"
"Conventions.java:253"$1$"		Assert.notNull(enclosingClass, ""'enclosingClass' must not be null"");"
"Conventions.java:254"$1$"		Assert.notNull(attributeName, ""'attributeName' must not be null"");"
"Conventions.java:255"$1$"		return enclosingClass.getName() + '.' + attributeName;"
"Conventions.java:256"$1$"	}"
"Conventions.java:257"$0$""
"Conventions.java:258"$0$""
"Conventions.java:259"$0$"	/**"
"Conventions.java:260"$0$"	 * Determine the class to use for naming a variable containing the given value."
"Conventions.java:261"$0$"	 * <p>Will return the class of the given value, except when encountering a"
"Conventions.java:262"$0$"	 * JDK proxy, in which case it will determine the 'primary' interface"
"Conventions.java:263"$0$"	 * implemented by that proxy."
"Conventions.java:264"$0$"	 * @param value the value to check"
"Conventions.java:265"$0$"	 * @return the class to use for naming a variable"
"Conventions.java:266"$0$"	 */"
"Conventions.java:267"$1$"	private static Class<?> getClassForValue(Object value) {"
"Conventions.java:268"$1$"		Class<?> valueClass = value.getClass();"
"Conventions.java:269"$1$"		if (Proxy.isProxyClass(valueClass)) {"
"Conventions.java:270"$1$"			Class<?>[] ifcs = valueClass.getInterfaces();"
"Conventions.java:271"$1$"			for (Class<?> ifc : ifcs) {"
"Conventions.java:272"$1$"				if (!ClassUtils.isJavaLanguageInterface(ifc)) {"
"Conventions.java:273"$1$"					return ifc;"
"Conventions.java:274"$1$"				}"
"Conventions.java:275"$0$"			}"
"Conventions.java:276"$0$"		}"
"Conventions.java:277"$1$"		else if (valueClass.getName().lastIndexOf('$') != -1 && valueClass.getDeclaringClass() == null) {"
"Conventions.java:278"$0$"			// '$' in the class name but no inner class -"
"Conventions.java:279"$0$"			// assuming it's a special subclass (e.g. by OpenJPA)"
"Conventions.java:280"$1$"			valueClass = valueClass.getSuperclass();"
"Conventions.java:281"$1$"		}"
"Conventions.java:282"$0$"		return valueClass;"
"Conventions.java:283"$0$"	}"
"Conventions.java:284"$0$""
"Conventions.java:285"$0$"	/**"
"Conventions.java:286"$0$"	 * Pluralize the given name."
"Conventions.java:287"$0$"	 */"
"Conventions.java:288"$1$"	private static String pluralize(String name) {"
"Conventions.java:289"$1$"		return name + PLURAL_SUFFIX;"
"Conventions.java:290"$1$"	}"
"Conventions.java:291"$0$""
"Conventions.java:292"$0$"	/**"
"Conventions.java:293"$1$"	 * Retrieve the {@code Class} of an element in the {@code Collection}."
"Conventions.java:294"$1$"	 * The exact element for which the {@code Class} is retrieved will depend"
"Conventions.java:295"$1$"	 * on the concrete {@code Collection} implementation."
"Conventions.java:296"$0$"	 */"
"Conventions.java:297"$1$"	private static <E> E peekAhead(Collection<E> collection) {"
"Conventions.java:298"$1$"		Iterator<E> it = collection.iterator();"
"Conventions.java:299"$1$"		if (!it.hasNext()) {"
"Conventions.java:300"$1$"			throw new IllegalStateException("
"Conventions.java:301"$1$"					""Unable to peek ahead in non-empty collection - no element found"");"
"Conventions.java:302"$1$"		}"
"Conventions.java:303"$0$"		E value = it.next();"
"Conventions.java:304"$1$"		if (value == null) {"
"Conventions.java:305"$1$"			throw new IllegalStateException("
"Conventions.java:306"$1$"					""Unable to peek ahead in non-empty collection - only null element found"");"
"Conventions.java:307"$1$"		}"
"Conventions.java:308"$0$"		return value;"
"Conventions.java:309"$0$"	}"
"Conventions.java:310"$0$""
"Conventions.java:311"$0$"}"
"PathMatchingResourcePatternResolver.java:1"$0$"/*"
"PathMatchingResourcePatternResolver.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"PathMatchingResourcePatternResolver.java:3"$0$" *"
"PathMatchingResourcePatternResolver.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PathMatchingResourcePatternResolver.java:5"$0$" * you may not use this file except in compliance with the License."
"PathMatchingResourcePatternResolver.java:6"$0$" * You may obtain a copy of the License at"
"PathMatchingResourcePatternResolver.java:7"$0$" *"
"PathMatchingResourcePatternResolver.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PathMatchingResourcePatternResolver.java:9"$0$" *"
"PathMatchingResourcePatternResolver.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PathMatchingResourcePatternResolver.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PathMatchingResourcePatternResolver.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PathMatchingResourcePatternResolver.java:13"$0$" * See the License for the specific language governing permissions and"
"PathMatchingResourcePatternResolver.java:14"$0$" * limitations under the License."
"PathMatchingResourcePatternResolver.java:15"$0$" */"
"PathMatchingResourcePatternResolver.java:16"$0$""
"PathMatchingResourcePatternResolver.java:17"$0$"package org.springframework.core.io.support;"
"PathMatchingResourcePatternResolver.java:18"$0$""
"PathMatchingResourcePatternResolver.java:19"$0$"import java.io.File;"
"PathMatchingResourcePatternResolver.java:20"$0$"import java.io.FileNotFoundException;"
"PathMatchingResourcePatternResolver.java:21"$0$"import java.io.IOException;"
"PathMatchingResourcePatternResolver.java:22"$0$"import java.lang.reflect.InvocationHandler;"
"PathMatchingResourcePatternResolver.java:23"$0$"import java.lang.reflect.Method;"
"PathMatchingResourcePatternResolver.java:24"$0$"import java.net.JarURLConnection;"
"PathMatchingResourcePatternResolver.java:25"$0$"import java.net.MalformedURLException;"
"PathMatchingResourcePatternResolver.java:26"$0$"import java.net.URISyntaxException;"
"PathMatchingResourcePatternResolver.java:27"$0$"import java.net.URL;"
"PathMatchingResourcePatternResolver.java:28"$0$"import java.net.URLClassLoader;"
"PathMatchingResourcePatternResolver.java:29"$0$"import java.net.URLConnection;"
"PathMatchingResourcePatternResolver.java:30"$0$"import java.util.Arrays;"
"PathMatchingResourcePatternResolver.java:31"$0$"import java.util.Collections;"
"PathMatchingResourcePatternResolver.java:32"$0$"import java.util.Comparator;"
"PathMatchingResourcePatternResolver.java:33"$0$"import java.util.Enumeration;"
"PathMatchingResourcePatternResolver.java:34"$0$"import java.util.LinkedHashSet;"
"PathMatchingResourcePatternResolver.java:35"$0$"import java.util.Set;"
"PathMatchingResourcePatternResolver.java:36"$0$"import java.util.jar.JarEntry;"
"PathMatchingResourcePatternResolver.java:37"$0$"import java.util.jar.JarFile;"
"PathMatchingResourcePatternResolver.java:38"$0$"import java.util.zip.ZipException;"
"PathMatchingResourcePatternResolver.java:39"$0$""
"PathMatchingResourcePatternResolver.java:40"$0$"import org.apache.commons.logging.Log;"
"PathMatchingResourcePatternResolver.java:41"$0$"import org.apache.commons.logging.LogFactory;"
"PathMatchingResourcePatternResolver.java:42"$0$""
"PathMatchingResourcePatternResolver.java:43"$0$"import org.springframework.core.io.DefaultResourceLoader;"
"PathMatchingResourcePatternResolver.java:44"$0$"import org.springframework.core.io.FileSystemResource;"
"PathMatchingResourcePatternResolver.java:45"$0$"import org.springframework.core.io.Resource;"
"PathMatchingResourcePatternResolver.java:46"$0$"import org.springframework.core.io.ResourceLoader;"
"PathMatchingResourcePatternResolver.java:47"$0$"import org.springframework.core.io.UrlResource;"
"PathMatchingResourcePatternResolver.java:48"$0$"import org.springframework.core.io.VfsResource;"
"PathMatchingResourcePatternResolver.java:49"$0$"import org.springframework.lang.Nullable;"
"PathMatchingResourcePatternResolver.java:50"$0$"import org.springframework.util.AntPathMatcher;"
"PathMatchingResourcePatternResolver.java:51"$0$"import org.springframework.util.Assert;"
"PathMatchingResourcePatternResolver.java:52"$0$"import org.springframework.util.ClassUtils;"
"PathMatchingResourcePatternResolver.java:53"$0$"import org.springframework.util.PathMatcher;"
"PathMatchingResourcePatternResolver.java:54"$0$"import org.springframework.util.ReflectionUtils;"
"PathMatchingResourcePatternResolver.java:55"$0$"import org.springframework.util.ResourceUtils;"
"PathMatchingResourcePatternResolver.java:56"$0$"import org.springframework.util.StringUtils;"
"PathMatchingResourcePatternResolver.java:57"$0$""
"PathMatchingResourcePatternResolver.java:58"$0$"/**"
"PathMatchingResourcePatternResolver.java:59"$1$" * A {@link ResourcePatternResolver} implementation that is able to resolve a"
"PathMatchingResourcePatternResolver.java:60"$0$" * specified resource location path into one or more matching Resources."
"PathMatchingResourcePatternResolver.java:61"$0$" * The source path may be a simple path which has a one-to-one mapping to a"
"PathMatchingResourcePatternResolver.java:62"$1$" * target {@link org.springframework.core.io.Resource}, or alternatively"
"PathMatchingResourcePatternResolver.java:63"$1$" * may contain the special ""{@code classpath*:}"" prefix and/or"
"PathMatchingResourcePatternResolver.java:64"$0$" * internal Ant-style regular expressions (matched using Spring's"
"PathMatchingResourcePatternResolver.java:65"$1$" * {@link org.springframework.util.AntPathMatcher} utility)."
"PathMatchingResourcePatternResolver.java:66"$0$" * Both of the latter are effectively wildcards."
"PathMatchingResourcePatternResolver.java:67"$0$" *"
"PathMatchingResourcePatternResolver.java:68"$0$" * <p><b>No Wildcards:</b>"
"PathMatchingResourcePatternResolver.java:69"$0$" *"
"PathMatchingResourcePatternResolver.java:70"$0$" * <p>In the simple case, if the specified location path does not start with the"
"PathMatchingResourcePatternResolver.java:71"$1$" * {@code ""classpath*:}"" prefix, and does not contain a PathMatcher pattern,"
"PathMatchingResourcePatternResolver.java:72"$0$" * this resolver will simply return a single resource via a"
"PathMatchingResourcePatternResolver.java:73"$1$" * {@code getResource()} call on the underlying {@code ResourceLoader}."
"PathMatchingResourcePatternResolver.java:74"$1$" * Examples are real URLs such as ""{@code file:C:/context.xml}"", pseudo-URLs"
"PathMatchingResourcePatternResolver.java:75"$1$" * such as ""{@code classpath:/context.xml}"", and simple unprefixed paths"
"PathMatchingResourcePatternResolver.java:76"$1$" * such as ""{@code /WEB-INF/context.xml}"". The latter will resolve in a"
"PathMatchingResourcePatternResolver.java:77"$1$" * fashion specific to the underlying {@code ResourceLoader} (e.g."
"PathMatchingResourcePatternResolver.java:78"$1$" * {@code ServletContextResource} for a {@code WebApplicationContext})."
"PathMatchingResourcePatternResolver.java:79"$0$" *"
"PathMatchingResourcePatternResolver.java:80"$0$" * <p><b>Ant-style Patterns:</b>"
"PathMatchingResourcePatternResolver.java:81"$0$" *"
"PathMatchingResourcePatternResolver.java:82"$0$" * <p>When the path location contains an Ant-style pattern, e.g.:"
"PathMatchingResourcePatternResolver.java:83"$0$" * <pre class=""code"">"
"PathMatchingResourcePatternResolver.java:84"$0$" * /WEB-INF/*-context.xml"
"PathMatchingResourcePatternResolver.java:85"$0$" * com/mycompany/**&#47;applicationContext.xml"
"PathMatchingResourcePatternResolver.java:86"$0$" * file:C:/some/path/*-context.xml"
"PathMatchingResourcePatternResolver.java:87"$0$" * classpath:com/mycompany/**&#47;applicationContext.xml</pre>"
"PathMatchingResourcePatternResolver.java:88"$0$" * the resolver follows a more complex but defined procedure to try to resolve"
"PathMatchingResourcePatternResolver.java:89"$1$" * the wildcard. It produces a {@code Resource} for the path up to the last"
"PathMatchingResourcePatternResolver.java:90"$1$" * non-wildcard segment and obtains a {@code URL} from it. If this URL is"
"PathMatchingResourcePatternResolver.java:91"$1$" * not a ""{@code jar:}"" URL or container-specific variant (e.g."
"PathMatchingResourcePatternResolver.java:92"$1$" * ""{@code zip:}"" in WebLogic, ""{@code wsjar}"" in WebSphere"", etc.),"
"PathMatchingResourcePatternResolver.java:93"$1$" * then a {@code java.io.File} is obtained from it, and used to resolve the"
"PathMatchingResourcePatternResolver.java:94"$0$" * wildcard by walking the filesystem. In the case of a jar URL, the resolver"
"PathMatchingResourcePatternResolver.java:95"$1$" * either gets a {@code java.net.JarURLConnection} from it, or manually parses"
"PathMatchingResourcePatternResolver.java:96"$0$" * the jar URL, and then traverses the contents of the jar file, to resolve the"
"PathMatchingResourcePatternResolver.java:97"$0$" * wildcards."
"PathMatchingResourcePatternResolver.java:98"$0$" *"
"PathMatchingResourcePatternResolver.java:99"$0$" * <p><b>Implications on portability:</b>"
"PathMatchingResourcePatternResolver.java:100"$0$" *"
"PathMatchingResourcePatternResolver.java:101"$0$" * <p>If the specified path is already a file URL (either explicitly, or"
"PathMatchingResourcePatternResolver.java:102"$1$" * implicitly because the base {@code ResourceLoader} is a filesystem one,"
"PathMatchingResourcePatternResolver.java:103"$0$" * then wildcarding is guaranteed to work in a completely portable fashion."
"PathMatchingResourcePatternResolver.java:104"$0$" *"
"PathMatchingResourcePatternResolver.java:105"$0$" * <p>If the specified path is a classpath location, then the resolver must"
"PathMatchingResourcePatternResolver.java:106"$0$" * obtain the last non-wildcard path segment URL via a"
"PathMatchingResourcePatternResolver.java:107"$1$" * {@code Classloader.getResource()} call. Since this is just a"
"PathMatchingResourcePatternResolver.java:108"$0$" * node of the path (not the file at the end) it is actually undefined"
"PathMatchingResourcePatternResolver.java:109"$0$" * (in the ClassLoader Javadocs) exactly what sort of a URL is returned in"
"PathMatchingResourcePatternResolver.java:110"$1$" * this case. In practice, it is usually a {@code java.io.File} representing"
"PathMatchingResourcePatternResolver.java:111"$0$" * the directory, where the classpath resource resolves to a filesystem"
"PathMatchingResourcePatternResolver.java:112"$0$" * location, or a jar URL of some sort, where the classpath resource resolves"
"PathMatchingResourcePatternResolver.java:113"$0$" * to a jar location. Still, there is a portability concern on this operation."
"PathMatchingResourcePatternResolver.java:114"$0$" *"
"PathMatchingResourcePatternResolver.java:115"$0$" * <p>If a jar URL is obtained for the last non-wildcard segment, the resolver"
"PathMatchingResourcePatternResolver.java:116"$1$" * must be able to get a {@code java.net.JarURLConnection} from it, or"
"PathMatchingResourcePatternResolver.java:117"$0$" * manually parse the jar URL, to be able to walk the contents of the jar,"
"PathMatchingResourcePatternResolver.java:118"$0$" * and resolve the wildcard. This will work in most environments, but will"
"PathMatchingResourcePatternResolver.java:119"$0$" * fail in others, and it is strongly recommended that the wildcard"
"PathMatchingResourcePatternResolver.java:120"$0$" * resolution of resources coming from jars be thoroughly tested in your"
"PathMatchingResourcePatternResolver.java:121"$0$" * specific environment before you rely on it."
"PathMatchingResourcePatternResolver.java:122"$0$" *"
"PathMatchingResourcePatternResolver.java:123"$1$" * <p><b>{@code classpath*:} Prefix:</b>"
"PathMatchingResourcePatternResolver.java:124"$0$" *"
"PathMatchingResourcePatternResolver.java:125"$0$" * <p>There is special support for retrieving multiple class path resources with"
"PathMatchingResourcePatternResolver.java:126"$1$" * the same name, via the ""{@code classpath*:}"" prefix. For example,"
"PathMatchingResourcePatternResolver.java:127"$1$" * ""{@code classpath*:META-INF/beans.xml}"" will find all ""beans.xml"""
"PathMatchingResourcePatternResolver.java:128"$0$" * files in the class path, be it in ""classes"" directories or in JAR files."
"PathMatchingResourcePatternResolver.java:129"$0$" * This is particularly useful for autodetecting config files of the same name"
"PathMatchingResourcePatternResolver.java:130"$0$" * at the same location within each jar file. Internally, this happens via a"
"PathMatchingResourcePatternResolver.java:131"$1$" * {@code ClassLoader.getResources()} call, and is completely portable."
"PathMatchingResourcePatternResolver.java:132"$0$" *"
"PathMatchingResourcePatternResolver.java:133"$0$" * <p>The ""classpath*:"" prefix can also be combined with a PathMatcher pattern in"
"PathMatchingResourcePatternResolver.java:134"$0$" * the rest of the location path, for example ""classpath*:META-INF/*-beans.xml""."
"PathMatchingResourcePatternResolver.java:135"$0$" * In this case, the resolution strategy is fairly simple: a"
"PathMatchingResourcePatternResolver.java:136"$1$" * {@code ClassLoader.getResources()} call is used on the last non-wildcard"
"PathMatchingResourcePatternResolver.java:137"$0$" * path segment to get all the matching resources in the class loader hierarchy,"
"PathMatchingResourcePatternResolver.java:138"$0$" * and then off each resource the same PathMatcher resolution strategy described"
"PathMatchingResourcePatternResolver.java:139"$0$" * above is used for the wildcard subpath."
"PathMatchingResourcePatternResolver.java:140"$0$" *"
"PathMatchingResourcePatternResolver.java:141"$0$" * <p><b>Other notes:</b>"
"PathMatchingResourcePatternResolver.java:142"$0$" *"
"PathMatchingResourcePatternResolver.java:143"$1$" * <p><b>WARNING:</b> Note that ""{@code classpath*:}"" when combined with"
"PathMatchingResourcePatternResolver.java:144"$0$" * Ant-style patterns will only work reliably with at least one root directory"
"PathMatchingResourcePatternResolver.java:145"$0$" * before the pattern starts, unless the actual target files reside in the file"
"PathMatchingResourcePatternResolver.java:146"$1$" * system. This means that a pattern like ""{@code classpath*:*.xml}"" will"
"PathMatchingResourcePatternResolver.java:147"$0$" * <i>not</i> retrieve files from the root of jar files but rather only from the"
"PathMatchingResourcePatternResolver.java:148"$0$" * root of expanded directories. This originates from a limitation in the JDK's"
"PathMatchingResourcePatternResolver.java:149"$1$" * {@code ClassLoader.getResources()} method which only returns file system"
"PathMatchingResourcePatternResolver.java:150"$0$" * locations for a passed-in empty String (indicating potential roots to search)."
"PathMatchingResourcePatternResolver.java:151"$1$" * This {@code ResourcePatternResolver} implementation is trying to mitigate the"
"PathMatchingResourcePatternResolver.java:152"$1$" * jar root lookup limitation through {@link URLClassLoader} introspection and"
"PathMatchingResourcePatternResolver.java:153"$0$" * ""java.class.path"" manifest evaluation; however, without portability guarantees."
"PathMatchingResourcePatternResolver.java:154"$0$" *"
"PathMatchingResourcePatternResolver.java:155"$0$" * <p><b>WARNING:</b> Ant-style patterns with ""classpath:"" resources are not"
"PathMatchingResourcePatternResolver.java:156"$0$" * guaranteed to find matching resources if the root package to search is available"
"PathMatchingResourcePatternResolver.java:157"$0$" * in multiple class path locations. This is because a resource such as"
"PathMatchingResourcePatternResolver.java:158"$0$" * <pre class=""code"">"
"PathMatchingResourcePatternResolver.java:159"$0$" *     com/mycompany/package1/service-context.xml"
"PathMatchingResourcePatternResolver.java:160"$0$" * </pre>"
"PathMatchingResourcePatternResolver.java:161"$0$" * may be in only one location, but when a path such as"
"PathMatchingResourcePatternResolver.java:162"$0$" * <pre class=""code"">"
"PathMatchingResourcePatternResolver.java:163"$0$" *     classpath:com/mycompany/**&#47;service-context.xml"
"PathMatchingResourcePatternResolver.java:164"$0$" * </pre>"
"PathMatchingResourcePatternResolver.java:165"$0$" * is used to try to resolve it, the resolver will work off the (first) URL"
"PathMatchingResourcePatternResolver.java:166"$1$" * returned by {@code getResource(""com/mycompany"");}. If this base package node"
"PathMatchingResourcePatternResolver.java:167"$0$" * exists in multiple classloader locations, the actual end resource may not be"
"PathMatchingResourcePatternResolver.java:168"$1$" * underneath. Therefore, preferably, use ""{@code classpath*:}"" with the same"
"PathMatchingResourcePatternResolver.java:169"$0$" * Ant-style pattern in such a case, which will search <i>all</i> class path"
"PathMatchingResourcePatternResolver.java:170"$0$" * locations that contain the root package."
"PathMatchingResourcePatternResolver.java:171"$0$" *"
"PathMatchingResourcePatternResolver.java:172"$0$" * @author Juergen Hoeller"
"PathMatchingResourcePatternResolver.java:173"$0$" * @author Colin Sampaleanu"
"PathMatchingResourcePatternResolver.java:174"$0$" * @author Marius Bogoevici"
"PathMatchingResourcePatternResolver.java:175"$0$" * @author Costin Leau"
"PathMatchingResourcePatternResolver.java:176"$0$" * @author Phillip Webb"
"PathMatchingResourcePatternResolver.java:177"$0$" * @since 1.0.2"
"PathMatchingResourcePatternResolver.java:178"$0$" * @see #CLASSPATH_ALL_URL_PREFIX"
"PathMatchingResourcePatternResolver.java:179"$0$" * @see org.springframework.util.AntPathMatcher"
"PathMatchingResourcePatternResolver.java:180"$0$" * @see org.springframework.core.io.ResourceLoader#getResource(String)"
"PathMatchingResourcePatternResolver.java:181"$0$" * @see ClassLoader#getResources(String)"
"PathMatchingResourcePatternResolver.java:182"$0$" */"
"PathMatchingResourcePatternResolver.java:183"$1$"public class PathMatchingResourcePatternResolver implements ResourcePatternResolver {"
"PathMatchingResourcePatternResolver.java:184"$1$""
"PathMatchingResourcePatternResolver.java:185"$1$"	private static final Log logger = LogFactory.getLog(PathMatchingResourcePatternResolver.class);"
"PathMatchingResourcePatternResolver.java:186"$1$""
"PathMatchingResourcePatternResolver.java:187"$1$"	@Nullable"
"PathMatchingResourcePatternResolver.java:188"$1$"	private static Method equinoxResolveMethod;"
"PathMatchingResourcePatternResolver.java:189"$1$""
"PathMatchingResourcePatternResolver.java:190"$1$"	static {"
"PathMatchingResourcePatternResolver.java:191"$1$"		try {"
"PathMatchingResourcePatternResolver.java:192"$0$"			// Detect Equinox OSGi (e.g. on WebSphere 6.1)"
"PathMatchingResourcePatternResolver.java:193"$1$"			Class<?> fileLocatorClass = ClassUtils.forName(""org.eclipse.core.runtime.FileLocator"","
"PathMatchingResourcePatternResolver.java:194"$1$"					PathMatchingResourcePatternResolver.class.getClassLoader());"
"PathMatchingResourcePatternResolver.java:195"$1$"			equinoxResolveMethod = fileLocatorClass.getMethod(""resolve"", URL.class);"
"PathMatchingResourcePatternResolver.java:196"$1$"			logger.trace(""Found Equinox FileLocator for OSGi bundle URL resolution"");"
"PathMatchingResourcePatternResolver.java:197"$1$"		}"
"PathMatchingResourcePatternResolver.java:198"$1$"		catch (Throwable ex) {"
"PathMatchingResourcePatternResolver.java:199"$1$"			equinoxResolveMethod = null;"
"PathMatchingResourcePatternResolver.java:200"$1$"		}"
"PathMatchingResourcePatternResolver.java:201"$0$"	}"
"PathMatchingResourcePatternResolver.java:202"$0$""
"PathMatchingResourcePatternResolver.java:203"$0$""
"PathMatchingResourcePatternResolver.java:204"$0$"	private final ResourceLoader resourceLoader;"
"PathMatchingResourcePatternResolver.java:205"$0$""
"PathMatchingResourcePatternResolver.java:206"$0$"	private PathMatcher pathMatcher = new AntPathMatcher();"
"PathMatchingResourcePatternResolver.java:207"$0$""
"PathMatchingResourcePatternResolver.java:208"$0$""
"PathMatchingResourcePatternResolver.java:209"$0$"	/**"
"PathMatchingResourcePatternResolver.java:210"$0$"	 * Create a new PathMatchingResourcePatternResolver with a DefaultResourceLoader."
"PathMatchingResourcePatternResolver.java:211"$0$"	 * <p>ClassLoader access will happen via the thread context class loader."
"PathMatchingResourcePatternResolver.java:212"$0$"	 * @see org.springframework.core.io.DefaultResourceLoader"
"PathMatchingResourcePatternResolver.java:213"$0$"	 */"
"PathMatchingResourcePatternResolver.java:214"$1$"	public PathMatchingResourcePatternResolver() {"
"PathMatchingResourcePatternResolver.java:215"$1$"		this.resourceLoader = new DefaultResourceLoader();"
"PathMatchingResourcePatternResolver.java:216"$1$"	}"
"PathMatchingResourcePatternResolver.java:217"$0$""
"PathMatchingResourcePatternResolver.java:218"$0$"	/**"
"PathMatchingResourcePatternResolver.java:219"$0$"	 * Create a new PathMatchingResourcePatternResolver."
"PathMatchingResourcePatternResolver.java:220"$0$"	 * <p>ClassLoader access will happen via the thread context class loader."
"PathMatchingResourcePatternResolver.java:221"$0$"	 * @param resourceLoader the ResourceLoader to load root directories and"
"PathMatchingResourcePatternResolver.java:222"$0$"	 * actual resources with"
"PathMatchingResourcePatternResolver.java:223"$0$"	 */"
"PathMatchingResourcePatternResolver.java:224"$1$"	public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {"
"PathMatchingResourcePatternResolver.java:225"$1$"		Assert.notNull(resourceLoader, ""ResourceLoader must not be null"");"
"PathMatchingResourcePatternResolver.java:226"$1$"		this.resourceLoader = resourceLoader;"
"PathMatchingResourcePatternResolver.java:227"$1$"	}"
"PathMatchingResourcePatternResolver.java:228"$0$""
"PathMatchingResourcePatternResolver.java:229"$0$"	/**"
"PathMatchingResourcePatternResolver.java:230"$0$"	 * Create a new PathMatchingResourcePatternResolver with a DefaultResourceLoader."
"PathMatchingResourcePatternResolver.java:231"$0$"	 * @param classLoader the ClassLoader to load classpath resources with,"
"PathMatchingResourcePatternResolver.java:232"$1$"	 * or {@code null} for using the thread context class loader"
"PathMatchingResourcePatternResolver.java:233"$0$"	 * at the time of actual resource access"
"PathMatchingResourcePatternResolver.java:234"$0$"	 * @see org.springframework.core.io.DefaultResourceLoader"
"PathMatchingResourcePatternResolver.java:235"$0$"	 */"
"PathMatchingResourcePatternResolver.java:236"$1$"	public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {"
"PathMatchingResourcePatternResolver.java:237"$1$"		this.resourceLoader = new DefaultResourceLoader(classLoader);"
"PathMatchingResourcePatternResolver.java:238"$1$"	}"
"PathMatchingResourcePatternResolver.java:239"$0$""
"PathMatchingResourcePatternResolver.java:240"$0$""
"PathMatchingResourcePatternResolver.java:241"$0$"	/**"
"PathMatchingResourcePatternResolver.java:242"$0$"	 * Return the ResourceLoader that this pattern resolver works with."
"PathMatchingResourcePatternResolver.java:243"$0$"	 */"
"PathMatchingResourcePatternResolver.java:244"$1$"	public ResourceLoader getResourceLoader() {"
"PathMatchingResourcePatternResolver.java:245"$1$"		return this.resourceLoader;"
"PathMatchingResourcePatternResolver.java:246"$1$"	}"
"PathMatchingResourcePatternResolver.java:247"$0$""
"PathMatchingResourcePatternResolver.java:248"$0$"	@Override"
"PathMatchingResourcePatternResolver.java:249"$0$"	@Nullable"
"PathMatchingResourcePatternResolver.java:250"$1$"	public ClassLoader getClassLoader() {"
"PathMatchingResourcePatternResolver.java:251"$1$"		return getResourceLoader().getClassLoader();"
"PathMatchingResourcePatternResolver.java:252"$1$"	}"
"PathMatchingResourcePatternResolver.java:253"$0$""
"PathMatchingResourcePatternResolver.java:254"$0$"	/**"
"PathMatchingResourcePatternResolver.java:255"$0$"	 * Set the PathMatcher implementation to use for this"
"PathMatchingResourcePatternResolver.java:256"$0$"	 * resource pattern resolver. Default is AntPathMatcher."
"PathMatchingResourcePatternResolver.java:257"$0$"	 * @see org.springframework.util.AntPathMatcher"
"PathMatchingResourcePatternResolver.java:258"$0$"	 */"
"PathMatchingResourcePatternResolver.java:259"$1$"	public void setPathMatcher(PathMatcher pathMatcher) {"
"PathMatchingResourcePatternResolver.java:260"$1$"		Assert.notNull(pathMatcher, ""PathMatcher must not be null"");"
"PathMatchingResourcePatternResolver.java:261"$1$"		this.pathMatcher = pathMatcher;"
"PathMatchingResourcePatternResolver.java:262"$1$"	}"
"PathMatchingResourcePatternResolver.java:263"$0$""
"PathMatchingResourcePatternResolver.java:264"$0$"	/**"
"PathMatchingResourcePatternResolver.java:265"$0$"	 * Return the PathMatcher that this resource pattern resolver uses."
"PathMatchingResourcePatternResolver.java:266"$0$"	 */"
"PathMatchingResourcePatternResolver.java:267"$1$"	public PathMatcher getPathMatcher() {"
"PathMatchingResourcePatternResolver.java:268"$1$"		return this.pathMatcher;"
"PathMatchingResourcePatternResolver.java:269"$1$"	}"
"PathMatchingResourcePatternResolver.java:270"$0$""
"PathMatchingResourcePatternResolver.java:271"$0$""
"PathMatchingResourcePatternResolver.java:272"$0$"	@Override"
"PathMatchingResourcePatternResolver.java:273"$1$"	public Resource getResource(String location) {"
"PathMatchingResourcePatternResolver.java:274"$1$"		return getResourceLoader().getResource(location);"
"PathMatchingResourcePatternResolver.java:275"$1$"	}"
"PathMatchingResourcePatternResolver.java:276"$0$""
"PathMatchingResourcePatternResolver.java:277"$0$"	@Override"
"PathMatchingResourcePatternResolver.java:278"$1$"	public Resource[] getResources(String locationPattern) throws IOException {"
"PathMatchingResourcePatternResolver.java:279"$1$"		Assert.notNull(locationPattern, ""Location pattern must not be null"");"
"PathMatchingResourcePatternResolver.java:280"$1$"		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {"
"PathMatchingResourcePatternResolver.java:281"$0$"			// a class path resource (multiple resources for same name possible)"
"PathMatchingResourcePatternResolver.java:282"$1$"			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {"
"PathMatchingResourcePatternResolver.java:283"$0$"				// a class path resource pattern"
"PathMatchingResourcePatternResolver.java:284"$1$"				return findPathMatchingResources(locationPattern);"
"PathMatchingResourcePatternResolver.java:285"$1$"			}"
"PathMatchingResourcePatternResolver.java:286"$1$"			else {"
"PathMatchingResourcePatternResolver.java:287"$0$"				// all class path resources with the given name"
"PathMatchingResourcePatternResolver.java:288"$1$"				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));"
"PathMatchingResourcePatternResolver.java:289"$1$"			}"
"PathMatchingResourcePatternResolver.java:290"$0$"		}"
"PathMatchingResourcePatternResolver.java:291"$1$"		else {"
"PathMatchingResourcePatternResolver.java:292"$0$"			// Generally only look for a pattern after a prefix here,"
"PathMatchingResourcePatternResolver.java:293"$0$"			// and on Tomcat only after the ""*/"" separator for its ""war:"" protocol."
"PathMatchingResourcePatternResolver.java:294"$1$"			int prefixEnd = (locationPattern.startsWith(""war:"") ? locationPattern.indexOf(""*/"") + 1 :"
"PathMatchingResourcePatternResolver.java:295"$1$"					locationPattern.indexOf(':') + 1);"
"PathMatchingResourcePatternResolver.java:296"$1$"			if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {"
"PathMatchingResourcePatternResolver.java:297"$0$"				// a file pattern"
"PathMatchingResourcePatternResolver.java:298"$1$"				return findPathMatchingResources(locationPattern);"
"PathMatchingResourcePatternResolver.java:299"$1$"			}"
"PathMatchingResourcePatternResolver.java:300"$1$"			else {"
"PathMatchingResourcePatternResolver.java:301"$0$"				// a single resource with the given name"
"PathMatchingResourcePatternResolver.java:302"$1$"				return new Resource[] {getResourceLoader().getResource(locationPattern)};"
"PathMatchingResourcePatternResolver.java:303"$1$"			}"
"PathMatchingResourcePatternResolver.java:304"$0$"		}"
"PathMatchingResourcePatternResolver.java:305"$0$"	}"
"PathMatchingResourcePatternResolver.java:306"$0$""
"PathMatchingResourcePatternResolver.java:307"$0$"	/**"
"PathMatchingResourcePatternResolver.java:308"$0$"	 * Find all class location resources with the given location via the ClassLoader."
"PathMatchingResourcePatternResolver.java:309"$1$"	 * Delegates to {@link #doFindAllClassPathResources(String)}."
"PathMatchingResourcePatternResolver.java:310"$0$"	 * @param location the absolute path within the classpath"
"PathMatchingResourcePatternResolver.java:311"$0$"	 * @return the result as Resource array"
"PathMatchingResourcePatternResolver.java:312"$0$"	 * @throws IOException in case of I/O errors"
"PathMatchingResourcePatternResolver.java:313"$0$"	 * @see java.lang.ClassLoader#getResources"
"PathMatchingResourcePatternResolver.java:314"$0$"	 * @see #convertClassLoaderURL"
"PathMatchingResourcePatternResolver.java:315"$0$"	 */"
"PathMatchingResourcePatternResolver.java:316"$1$"	protected Resource[] findAllClassPathResources(String location) throws IOException {"
"PathMatchingResourcePatternResolver.java:317"$1$"		String path = location;"
"PathMatchingResourcePatternResolver.java:318"$1$"		if (path.startsWith(""/"")) {"
"PathMatchingResourcePatternResolver.java:319"$1$"			path = path.substring(1);"
"PathMatchingResourcePatternResolver.java:320"$1$"		}"
"PathMatchingResourcePatternResolver.java:321"$0$"		Set<Resource> result = doFindAllClassPathResources(path);"
"PathMatchingResourcePatternResolver.java:322"$1$"		if (logger.isTraceEnabled()) {"
"PathMatchingResourcePatternResolver.java:323"$1$"			logger.trace(""Resolved classpath location ["" + location + ""] to resources "" + result);"
"PathMatchingResourcePatternResolver.java:324"$1$"		}"
"PathMatchingResourcePatternResolver.java:325"$0$"		return result.toArray(new Resource[0]);"
"PathMatchingResourcePatternResolver.java:326"$0$"	}"
"PathMatchingResourcePatternResolver.java:327"$0$""
"PathMatchingResourcePatternResolver.java:328"$0$"	/**"
"PathMatchingResourcePatternResolver.java:329"$0$"	 * Find all class location resources with the given path via the ClassLoader."
"PathMatchingResourcePatternResolver.java:330"$1$"	 * Called by {@link #findAllClassPathResources(String)}."
"PathMatchingResourcePatternResolver.java:331"$0$"	 * @param path the absolute path within the classpath (never a leading slash)"
"PathMatchingResourcePatternResolver.java:332"$0$"	 * @return a mutable Set of matching Resource instances"
"PathMatchingResourcePatternResolver.java:333"$0$"	 * @since 4.1.1"
"PathMatchingResourcePatternResolver.java:334"$0$"	 */"
"PathMatchingResourcePatternResolver.java:335"$1$"	protected Set<Resource> doFindAllClassPathResources(String path) throws IOException {"
"PathMatchingResourcePatternResolver.java:336"$1$"		Set<Resource> result = new LinkedHashSet<>(16);"
"PathMatchingResourcePatternResolver.java:337"$1$"		ClassLoader cl = getClassLoader();"
"PathMatchingResourcePatternResolver.java:338"$1$"		Enumeration<URL> resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));"
"PathMatchingResourcePatternResolver.java:339"$1$"		while (resourceUrls.hasMoreElements()) {"
"PathMatchingResourcePatternResolver.java:340"$1$"			URL url = resourceUrls.nextElement();"
"PathMatchingResourcePatternResolver.java:341"$1$"			result.add(convertClassLoaderURL(url));"
"PathMatchingResourcePatternResolver.java:342"$1$"		}"
"PathMatchingResourcePatternResolver.java:343"$1$"		if ("""".equals(path)) {"
"PathMatchingResourcePatternResolver.java:344"$0$"			// The above result is likely to be incomplete, i.e. only containing file system references."
"PathMatchingResourcePatternResolver.java:345"$0$"			// We need to have pointers to each of the jar files on the classpath as well..."
"PathMatchingResourcePatternResolver.java:346"$1$"			addAllClassLoaderJarRoots(cl, result);"
"PathMatchingResourcePatternResolver.java:347"$1$"		}"
"PathMatchingResourcePatternResolver.java:348"$0$"		return result;"
"PathMatchingResourcePatternResolver.java:349"$0$"	}"
"PathMatchingResourcePatternResolver.java:350"$0$""
"PathMatchingResourcePatternResolver.java:351"$0$"	/**"
"PathMatchingResourcePatternResolver.java:352"$1$"	 * Convert the given URL as returned from the ClassLoader into a {@link Resource}."
"PathMatchingResourcePatternResolver.java:353"$1$"	 * <p>The default implementation simply creates a {@link UrlResource} instance."
"PathMatchingResourcePatternResolver.java:354"$0$"	 * @param url a URL as returned from the ClassLoader"
"PathMatchingResourcePatternResolver.java:355"$0$"	 * @return the corresponding Resource object"
"PathMatchingResourcePatternResolver.java:356"$0$"	 * @see java.lang.ClassLoader#getResources"
"PathMatchingResourcePatternResolver.java:357"$0$"	 * @see org.springframework.core.io.Resource"
"PathMatchingResourcePatternResolver.java:358"$0$"	 */"
"PathMatchingResourcePatternResolver.java:359"$1$"	protected Resource convertClassLoaderURL(URL url) {"
"PathMatchingResourcePatternResolver.java:360"$1$"		return new UrlResource(url);"
"PathMatchingResourcePatternResolver.java:361"$1$"	}"
"PathMatchingResourcePatternResolver.java:362"$0$""
"PathMatchingResourcePatternResolver.java:363"$0$"	/**"
"PathMatchingResourcePatternResolver.java:364"$1$"	 * Search all {@link URLClassLoader} URLs for jar file references and add them to the"
"PathMatchingResourcePatternResolver.java:365"$0$"	 * given set of resources in the form of pointers to the root of the jar file content."
"PathMatchingResourcePatternResolver.java:366"$0$"	 * @param classLoader the ClassLoader to search (including its ancestors)"
"PathMatchingResourcePatternResolver.java:367"$0$"	 * @param result the set of resources to add jar roots to"
"PathMatchingResourcePatternResolver.java:368"$0$"	 * @since 4.1.1"
"PathMatchingResourcePatternResolver.java:369"$0$"	 */"
"PathMatchingResourcePatternResolver.java:370"$1$"	protected void addAllClassLoaderJarRoots(@Nullable ClassLoader classLoader, Set<Resource> result) {"
"PathMatchingResourcePatternResolver.java:371"$1$"		if (classLoader instanceof URLClassLoader) {"
"PathMatchingResourcePatternResolver.java:372"$1$"			try {"
"PathMatchingResourcePatternResolver.java:373"$1$"				for (URL url : ((URLClassLoader) classLoader).getURLs()) {"
"PathMatchingResourcePatternResolver.java:374"$1$"					try {"
"PathMatchingResourcePatternResolver.java:375"$1$"						UrlResource jarResource = (ResourceUtils.URL_PROTOCOL_JAR.equals(url.getProtocol()) ?"
"PathMatchingResourcePatternResolver.java:376"$1$"								new UrlResource(url) :"
"PathMatchingResourcePatternResolver.java:377"$1$"								new UrlResource(ResourceUtils.JAR_URL_PREFIX + url + ResourceUtils.JAR_URL_SEPARATOR));"
"PathMatchingResourcePatternResolver.java:378"$1$"						if (jarResource.exists()) {"
"PathMatchingResourcePatternResolver.java:379"$1$"							result.add(jarResource);"
"PathMatchingResourcePatternResolver.java:380"$1$"						}"
"PathMatchingResourcePatternResolver.java:381"$0$"					}"
"PathMatchingResourcePatternResolver.java:382"$1$"					catch (MalformedURLException ex) {"
"PathMatchingResourcePatternResolver.java:383"$1$"						if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:384"$1$"							logger.debug(""Cannot search for matching files underneath ["" + url +"
"PathMatchingResourcePatternResolver.java:385"$1$"									""] because it cannot be converted to a valid 'jar:' URL: "" + ex.getMessage());"
"PathMatchingResourcePatternResolver.java:386"$1$"						}"
"PathMatchingResourcePatternResolver.java:387"$0$"					}"
"PathMatchingResourcePatternResolver.java:388"$0$"				}"
"PathMatchingResourcePatternResolver.java:389"$0$"			}"
"PathMatchingResourcePatternResolver.java:390"$1$"			catch (Exception ex) {"
"PathMatchingResourcePatternResolver.java:391"$1$"				if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:392"$1$"					logger.debug(""Cannot introspect jar files since ClassLoader ["" + classLoader +"
"PathMatchingResourcePatternResolver.java:393"$1$"							""] does not support 'getURLs()': "" + ex);"
"PathMatchingResourcePatternResolver.java:394"$1$"				}"
"PathMatchingResourcePatternResolver.java:395"$0$"			}"
"PathMatchingResourcePatternResolver.java:396"$0$"		}"
"PathMatchingResourcePatternResolver.java:397"$0$""
"PathMatchingResourcePatternResolver.java:398"$1$"		if (classLoader == ClassLoader.getSystemClassLoader()) {"
"PathMatchingResourcePatternResolver.java:399"$0$"			// ""java.class.path"" manifest evaluation..."
"PathMatchingResourcePatternResolver.java:400"$1$"			addClassPathManifestEntries(result);"
"PathMatchingResourcePatternResolver.java:401"$1$"		}"
"PathMatchingResourcePatternResolver.java:402"$0$""
"PathMatchingResourcePatternResolver.java:403"$1$"		if (classLoader != null) {"
"PathMatchingResourcePatternResolver.java:404"$1$"			try {"
"PathMatchingResourcePatternResolver.java:405"$0$"				// Hierarchy traversal..."
"PathMatchingResourcePatternResolver.java:406"$1$"				addAllClassLoaderJarRoots(classLoader.getParent(), result);"
"PathMatchingResourcePatternResolver.java:407"$1$"			}"
"PathMatchingResourcePatternResolver.java:408"$1$"			catch (Exception ex) {"
"PathMatchingResourcePatternResolver.java:409"$1$"				if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:410"$1$"					logger.debug(""Cannot introspect jar files in parent ClassLoader since ["" + classLoader +"
"PathMatchingResourcePatternResolver.java:411"$1$"							""] does not support 'getParent()': "" + ex);"
"PathMatchingResourcePatternResolver.java:412"$1$"				}"
"PathMatchingResourcePatternResolver.java:413"$0$"			}"
"PathMatchingResourcePatternResolver.java:414"$0$"		}"
"PathMatchingResourcePatternResolver.java:415"$0$"	}"
"PathMatchingResourcePatternResolver.java:416"$0$""
"PathMatchingResourcePatternResolver.java:417"$0$"	/**"
"PathMatchingResourcePatternResolver.java:418"$0$"	 * Determine jar file references from the ""java.class.path."" manifest property and add them"
"PathMatchingResourcePatternResolver.java:419"$0$"	 * to the given set of resources in the form of pointers to the root of the jar file content."
"PathMatchingResourcePatternResolver.java:420"$0$"	 * @param result the set of resources to add jar roots to"
"PathMatchingResourcePatternResolver.java:421"$0$"	 * @since 4.3"
"PathMatchingResourcePatternResolver.java:422"$0$"	 */"
"PathMatchingResourcePatternResolver.java:423"$1$"	protected void addClassPathManifestEntries(Set<Resource> result) {"
"PathMatchingResourcePatternResolver.java:424"$1$"		try {"
"PathMatchingResourcePatternResolver.java:425"$1$"			String javaClassPathProperty = System.getProperty(""java.class.path"");"
"PathMatchingResourcePatternResolver.java:426"$1$"			for (String path : StringUtils.delimitedListToStringArray("
"PathMatchingResourcePatternResolver.java:427"$1$"					javaClassPathProperty, System.getProperty(""path.separator""))) {"
"PathMatchingResourcePatternResolver.java:428"$1$"				try {"
"PathMatchingResourcePatternResolver.java:429"$1$"					String filePath = new File(path).getAbsolutePath();"
"PathMatchingResourcePatternResolver.java:430"$1$"					int prefixIndex = filePath.indexOf(':');"
"PathMatchingResourcePatternResolver.java:431"$1$"					if (prefixIndex == 1) {"
"PathMatchingResourcePatternResolver.java:432"$0$"						// Possibly ""c:"" drive prefix on Windows, to be upper-cased for proper duplicate detection"
"PathMatchingResourcePatternResolver.java:433"$1$"						filePath = StringUtils.capitalize(filePath);"
"PathMatchingResourcePatternResolver.java:434"$1$"					}"
"PathMatchingResourcePatternResolver.java:435"$0$"					UrlResource jarResource = new UrlResource(ResourceUtils.JAR_URL_PREFIX +"
"PathMatchingResourcePatternResolver.java:436"$0$"							ResourceUtils.FILE_URL_PREFIX + filePath + ResourceUtils.JAR_URL_SEPARATOR);"
"PathMatchingResourcePatternResolver.java:437"$0$"					// Potentially overlapping with URLClassLoader.getURLs() result above!"
"PathMatchingResourcePatternResolver.java:438"$1$"					if (!result.contains(jarResource) && !hasDuplicate(filePath, result) && jarResource.exists()) {"
"PathMatchingResourcePatternResolver.java:439"$1$"						result.add(jarResource);"
"PathMatchingResourcePatternResolver.java:440"$1$"					}"
"PathMatchingResourcePatternResolver.java:441"$0$"				}"
"PathMatchingResourcePatternResolver.java:442"$1$"				catch (MalformedURLException ex) {"
"PathMatchingResourcePatternResolver.java:443"$1$"					if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:444"$1$"						logger.debug(""Cannot search for matching files underneath ["" + path +"
"PathMatchingResourcePatternResolver.java:445"$1$"								""] because it cannot be converted to a valid 'jar:' URL: "" + ex.getMessage());"
"PathMatchingResourcePatternResolver.java:446"$1$"					}"
"PathMatchingResourcePatternResolver.java:447"$0$"				}"
"PathMatchingResourcePatternResolver.java:448"$0$"			}"
"PathMatchingResourcePatternResolver.java:449"$0$"		}"
"PathMatchingResourcePatternResolver.java:450"$1$"		catch (Exception ex) {"
"PathMatchingResourcePatternResolver.java:451"$1$"			if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:452"$1$"				logger.debug(""Failed to evaluate 'java.class.path' manifest entries: "" + ex);"
"PathMatchingResourcePatternResolver.java:453"$1$"			}"
"PathMatchingResourcePatternResolver.java:454"$0$"		}"
"PathMatchingResourcePatternResolver.java:455"$0$"	}"
"PathMatchingResourcePatternResolver.java:456"$0$""
"PathMatchingResourcePatternResolver.java:457"$0$"	/**"
"PathMatchingResourcePatternResolver.java:458"$0$"	 * Check whether the given file path has a duplicate but differently structured entry"
"PathMatchingResourcePatternResolver.java:459"$0$"	 * in the existing result, i.e. with or without a leading slash."
"PathMatchingResourcePatternResolver.java:460"$0$"	 * @param filePath the file path (with or without a leading slash)"
"PathMatchingResourcePatternResolver.java:461"$0$"	 * @param result the current result"
"PathMatchingResourcePatternResolver.java:462"$1$"	 * @return {@code true} if there is a duplicate (i.e. to ignore the given file path),"
"PathMatchingResourcePatternResolver.java:463"$1$"	 * {@code false} to proceed with adding a corresponding resource to the current result"
"PathMatchingResourcePatternResolver.java:464"$0$"	 */"
"PathMatchingResourcePatternResolver.java:465"$1$"	private boolean hasDuplicate(String filePath, Set<Resource> result) {"
"PathMatchingResourcePatternResolver.java:466"$1$"		if (result.isEmpty()) {"
"PathMatchingResourcePatternResolver.java:467"$1$"			return false;"
"PathMatchingResourcePatternResolver.java:468"$1$"		}"
"PathMatchingResourcePatternResolver.java:469"$0$"		String duplicatePath = (filePath.startsWith(""/"") ? filePath.substring(1) : ""/"" + filePath);"
"PathMatchingResourcePatternResolver.java:470"$1$"		try {"
"PathMatchingResourcePatternResolver.java:471"$1$"			return result.contains(new UrlResource(ResourceUtils.JAR_URL_PREFIX + ResourceUtils.FILE_URL_PREFIX +"
"PathMatchingResourcePatternResolver.java:472"$1$"					duplicatePath + ResourceUtils.JAR_URL_SEPARATOR));"
"PathMatchingResourcePatternResolver.java:473"$1$"		}"
"PathMatchingResourcePatternResolver.java:474"$1$"		catch (MalformedURLException ex) {"
"PathMatchingResourcePatternResolver.java:475"$0$"			// Ignore: just for testing against duplicate."
"PathMatchingResourcePatternResolver.java:476"$1$"			return false;"
"PathMatchingResourcePatternResolver.java:477"$1$"		}"
"PathMatchingResourcePatternResolver.java:478"$0$"	}"
"PathMatchingResourcePatternResolver.java:479"$0$""
"PathMatchingResourcePatternResolver.java:480"$0$"	/**"
"PathMatchingResourcePatternResolver.java:481"$0$"	 * Find all resources that match the given location pattern via the"
"PathMatchingResourcePatternResolver.java:482"$0$"	 * Ant-style PathMatcher. Supports resources in jar files and zip files"
"PathMatchingResourcePatternResolver.java:483"$0$"	 * and in the file system."
"PathMatchingResourcePatternResolver.java:484"$0$"	 * @param locationPattern the location pattern to match"
"PathMatchingResourcePatternResolver.java:485"$0$"	 * @return the result as Resource array"
"PathMatchingResourcePatternResolver.java:486"$0$"	 * @throws IOException in case of I/O errors"
"PathMatchingResourcePatternResolver.java:487"$0$"	 * @see #doFindPathMatchingJarResources"
"PathMatchingResourcePatternResolver.java:488"$0$"	 * @see #doFindPathMatchingFileResources"
"PathMatchingResourcePatternResolver.java:489"$0$"	 * @see org.springframework.util.PathMatcher"
"PathMatchingResourcePatternResolver.java:490"$0$"	 */"
"PathMatchingResourcePatternResolver.java:491"$1$"	protected Resource[] findPathMatchingResources(String locationPattern) throws IOException {"
"PathMatchingResourcePatternResolver.java:492"$1$"		String rootDirPath = determineRootDir(locationPattern);"
"PathMatchingResourcePatternResolver.java:493"$1$"		String subPattern = locationPattern.substring(rootDirPath.length());"
"PathMatchingResourcePatternResolver.java:494"$1$"		Resource[] rootDirResources = getResources(rootDirPath);"
"PathMatchingResourcePatternResolver.java:495"$1$"		Set<Resource> result = new LinkedHashSet<>(16);"
"PathMatchingResourcePatternResolver.java:496"$1$"		for (Resource rootDirResource : rootDirResources) {"
"PathMatchingResourcePatternResolver.java:497"$1$"			rootDirResource = resolveRootDirResource(rootDirResource);"
"PathMatchingResourcePatternResolver.java:498"$1$"			URL rootDirUrl = rootDirResource.getURL();"
"PathMatchingResourcePatternResolver.java:499"$1$"			if (equinoxResolveMethod != null && rootDirUrl.getProtocol().startsWith(""bundle"")) {"
"PathMatchingResourcePatternResolver.java:500"$1$"				URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl);"
"PathMatchingResourcePatternResolver.java:501"$1$"				if (resolvedUrl != null) {"
"PathMatchingResourcePatternResolver.java:502"$1$"					rootDirUrl = resolvedUrl;"
"PathMatchingResourcePatternResolver.java:503"$1$"				}"
"PathMatchingResourcePatternResolver.java:504"$0$"				rootDirResource = new UrlResource(rootDirUrl);"
"PathMatchingResourcePatternResolver.java:505"$0$"			}"
"PathMatchingResourcePatternResolver.java:506"$1$"			if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) {"
"PathMatchingResourcePatternResolver.java:507"$1$"				result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));"
"PathMatchingResourcePatternResolver.java:508"$1$"			}"
"PathMatchingResourcePatternResolver.java:509"$1$"			else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) {"
"PathMatchingResourcePatternResolver.java:510"$1$"				result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));"
"PathMatchingResourcePatternResolver.java:511"$1$"			}"
"PathMatchingResourcePatternResolver.java:512"$1$"			else {"
"PathMatchingResourcePatternResolver.java:513"$1$"				result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));"
"PathMatchingResourcePatternResolver.java:514"$1$"			}"
"PathMatchingResourcePatternResolver.java:515"$0$"		}"
"PathMatchingResourcePatternResolver.java:516"$1$"		if (logger.isTraceEnabled()) {"
"PathMatchingResourcePatternResolver.java:517"$1$"			logger.trace(""Resolved location pattern ["" + locationPattern + ""] to resources "" + result);"
"PathMatchingResourcePatternResolver.java:518"$1$"		}"
"PathMatchingResourcePatternResolver.java:519"$0$"		return result.toArray(new Resource[0]);"
"PathMatchingResourcePatternResolver.java:520"$0$"	}"
"PathMatchingResourcePatternResolver.java:521"$0$""
"PathMatchingResourcePatternResolver.java:522"$0$"	/**"
"PathMatchingResourcePatternResolver.java:523"$0$"	 * Determine the root directory for the given location."
"PathMatchingResourcePatternResolver.java:524"$0$"	 * <p>Used for determining the starting point for file matching,"
"PathMatchingResourcePatternResolver.java:525"$1$"	 * resolving the root directory location to a {@code java.io.File}"
"PathMatchingResourcePatternResolver.java:526"$1$"	 * and passing it into {@code retrieveMatchingFiles}, with the"
"PathMatchingResourcePatternResolver.java:527"$0$"	 * remainder of the location as pattern."
"PathMatchingResourcePatternResolver.java:528"$0$"	 * <p>Will return ""/WEB-INF/"" for the pattern ""/WEB-INF/*.xml"","
"PathMatchingResourcePatternResolver.java:529"$0$"	 * for example."
"PathMatchingResourcePatternResolver.java:530"$0$"	 * @param location the location to check"
"PathMatchingResourcePatternResolver.java:531"$0$"	 * @return the part of the location that denotes the root directory"
"PathMatchingResourcePatternResolver.java:532"$0$"	 * @see #retrieveMatchingFiles"
"PathMatchingResourcePatternResolver.java:533"$0$"	 */"
"PathMatchingResourcePatternResolver.java:534"$1$"	protected String determineRootDir(String location) {"
"PathMatchingResourcePatternResolver.java:535"$1$"		int prefixEnd = location.indexOf(':') + 1;"
"PathMatchingResourcePatternResolver.java:536"$1$"		int rootDirEnd = location.length();"
"PathMatchingResourcePatternResolver.java:537"$1$"		while (rootDirEnd > prefixEnd && getPathMatcher().isPattern(location.substring(prefixEnd, rootDirEnd))) {"
"PathMatchingResourcePatternResolver.java:538"$1$"			rootDirEnd = location.lastIndexOf('/', rootDirEnd - 2) + 1;"
"PathMatchingResourcePatternResolver.java:539"$1$"		}"
"PathMatchingResourcePatternResolver.java:540"$1$"		if (rootDirEnd == 0) {"
"PathMatchingResourcePatternResolver.java:541"$1$"			rootDirEnd = prefixEnd;"
"PathMatchingResourcePatternResolver.java:542"$1$"		}"
"PathMatchingResourcePatternResolver.java:543"$0$"		return location.substring(0, rootDirEnd);"
"PathMatchingResourcePatternResolver.java:544"$0$"	}"
"PathMatchingResourcePatternResolver.java:545"$0$""
"PathMatchingResourcePatternResolver.java:546"$0$"	/**"
"PathMatchingResourcePatternResolver.java:547"$0$"	 * Resolve the specified resource for path matching."
"PathMatchingResourcePatternResolver.java:548"$0$"	 * <p>By default, Equinox OSGi ""bundleresource:"" / ""bundleentry:"" URL will be"
"PathMatchingResourcePatternResolver.java:549"$0$"	 * resolved into a standard jar file URL that be traversed using Spring's"
"PathMatchingResourcePatternResolver.java:550"$0$"	 * standard jar file traversal algorithm. For any preceding custom resolution,"
"PathMatchingResourcePatternResolver.java:551"$0$"	 * override this method and replace the resource handle accordingly."
"PathMatchingResourcePatternResolver.java:552"$0$"	 * @param original the resource to resolve"
"PathMatchingResourcePatternResolver.java:553"$0$"	 * @return the resolved resource (may be identical to the passed-in resource)"
"PathMatchingResourcePatternResolver.java:554"$0$"	 * @throws IOException in case of resolution failure"
"PathMatchingResourcePatternResolver.java:555"$0$"	 */"
"PathMatchingResourcePatternResolver.java:556"$1$"	protected Resource resolveRootDirResource(Resource original) throws IOException {"
"PathMatchingResourcePatternResolver.java:557"$1$"		return original;"
"PathMatchingResourcePatternResolver.java:558"$1$"	}"
"PathMatchingResourcePatternResolver.java:559"$0$""
"PathMatchingResourcePatternResolver.java:560"$0$"	/**"
"PathMatchingResourcePatternResolver.java:561"$0$"	 * Return whether the given resource handle indicates a jar resource"
"PathMatchingResourcePatternResolver.java:562"$1$"	 * that the {@code doFindPathMatchingJarResources} method can handle."
"PathMatchingResourcePatternResolver.java:563"$0$"	 * <p>By default, the URL protocols ""jar"", ""zip"", ""vfszip and ""wsjar"""
"PathMatchingResourcePatternResolver.java:564"$0$"	 * will be treated as jar resources. This template method allows for"
"PathMatchingResourcePatternResolver.java:565"$0$"	 * detecting further kinds of jar-like resources, e.g. through"
"PathMatchingResourcePatternResolver.java:566"$1$"	 * {@code instanceof} checks on the resource handle type."
"PathMatchingResourcePatternResolver.java:567"$0$"	 * @param resource the resource handle to check"
"PathMatchingResourcePatternResolver.java:568"$0$"	 * (usually the root directory to start path matching from)"
"PathMatchingResourcePatternResolver.java:569"$0$"	 * @see #doFindPathMatchingJarResources"
"PathMatchingResourcePatternResolver.java:570"$0$"	 * @see org.springframework.util.ResourceUtils#isJarURL"
"PathMatchingResourcePatternResolver.java:571"$0$"	 */"
"PathMatchingResourcePatternResolver.java:572"$1$"	protected boolean isJarResource(Resource resource) throws IOException {"
"PathMatchingResourcePatternResolver.java:573"$1$"		return false;"
"PathMatchingResourcePatternResolver.java:574"$1$"	}"
"PathMatchingResourcePatternResolver.java:575"$0$""
"PathMatchingResourcePatternResolver.java:576"$0$"	/**"
"PathMatchingResourcePatternResolver.java:577"$0$"	 * Find all resources in jar files that match the given location pattern"
"PathMatchingResourcePatternResolver.java:578"$0$"	 * via the Ant-style PathMatcher."
"PathMatchingResourcePatternResolver.java:579"$0$"	 * @param rootDirResource the root directory as Resource"
"PathMatchingResourcePatternResolver.java:580"$0$"	 * @param rootDirURL the pre-resolved root directory URL"
"PathMatchingResourcePatternResolver.java:581"$0$"	 * @param subPattern the sub pattern to match (below the root directory)"
"PathMatchingResourcePatternResolver.java:582"$0$"	 * @return a mutable Set of matching Resource instances"
"PathMatchingResourcePatternResolver.java:583"$0$"	 * @throws IOException in case of I/O errors"
"PathMatchingResourcePatternResolver.java:584"$0$"	 * @since 4.3"
"PathMatchingResourcePatternResolver.java:585"$0$"	 * @see java.net.JarURLConnection"
"PathMatchingResourcePatternResolver.java:586"$0$"	 * @see org.springframework.util.PathMatcher"
"PathMatchingResourcePatternResolver.java:587"$0$"	 */"
"PathMatchingResourcePatternResolver.java:588"$0$"	protected Set<Resource> doFindPathMatchingJarResources(Resource rootDirResource, URL rootDirURL, String subPattern)"
"PathMatchingResourcePatternResolver.java:589"$1$"			throws IOException {"
"PathMatchingResourcePatternResolver.java:590"$1$""
"PathMatchingResourcePatternResolver.java:591"$1$"		URLConnection con = rootDirURL.openConnection();"
"PathMatchingResourcePatternResolver.java:592"$1$"		JarFile jarFile;"
"PathMatchingResourcePatternResolver.java:593"$1$"		String jarFileUrl;"
"PathMatchingResourcePatternResolver.java:594"$1$"		String rootEntryPath;"
"PathMatchingResourcePatternResolver.java:595"$1$"		boolean closeJarFile;"
"PathMatchingResourcePatternResolver.java:596"$1$""
"PathMatchingResourcePatternResolver.java:597"$1$"		if (con instanceof JarURLConnection) {"
"PathMatchingResourcePatternResolver.java:598"$0$"			// Should usually be the case for traditional JAR files."
"PathMatchingResourcePatternResolver.java:599"$1$"			JarURLConnection jarCon = (JarURLConnection) con;"
"PathMatchingResourcePatternResolver.java:600"$1$"			ResourceUtils.useCachesIfNecessary(jarCon);"
"PathMatchingResourcePatternResolver.java:601"$1$"			jarFile = jarCon.getJarFile();"
"PathMatchingResourcePatternResolver.java:602"$1$"			jarFileUrl = jarCon.getJarFileURL().toExternalForm();"
"PathMatchingResourcePatternResolver.java:603"$1$"			JarEntry jarEntry = jarCon.getJarEntry();"
"PathMatchingResourcePatternResolver.java:604"$1$"			rootEntryPath = (jarEntry != null ? jarEntry.getName() : """");"
"PathMatchingResourcePatternResolver.java:605"$1$"			closeJarFile = !jarCon.getUseCaches();"
"PathMatchingResourcePatternResolver.java:606"$1$"		}"
"PathMatchingResourcePatternResolver.java:607"$1$"		else {"
"PathMatchingResourcePatternResolver.java:608"$0$"			// No JarURLConnection -> need to resort to URL file parsing."
"PathMatchingResourcePatternResolver.java:609"$0$"			// We'll assume URLs of the format ""jar:path!/entry"", with the protocol"
"PathMatchingResourcePatternResolver.java:610"$0$"			// being arbitrary as long as following the entry format."
"PathMatchingResourcePatternResolver.java:611"$0$"			// We'll also handle paths with and without leading ""file:"" prefix."
"PathMatchingResourcePatternResolver.java:612"$1$"			String urlFile = rootDirURL.getFile();"
"PathMatchingResourcePatternResolver.java:613"$1$"			try {"
"PathMatchingResourcePatternResolver.java:614"$1$"				int separatorIndex = urlFile.indexOf(ResourceUtils.WAR_URL_SEPARATOR);"
"PathMatchingResourcePatternResolver.java:615"$1$"				if (separatorIndex == -1) {"
"PathMatchingResourcePatternResolver.java:616"$1$"					separatorIndex = urlFile.indexOf(ResourceUtils.JAR_URL_SEPARATOR);"
"PathMatchingResourcePatternResolver.java:617"$1$"				}"
"PathMatchingResourcePatternResolver.java:618"$1$"				if (separatorIndex != -1) {"
"PathMatchingResourcePatternResolver.java:619"$1$"					jarFileUrl = urlFile.substring(0, separatorIndex);"
"PathMatchingResourcePatternResolver.java:620"$1$"					rootEntryPath = urlFile.substring(separatorIndex + 2);  // both separators are 2 chars"
"PathMatchingResourcePatternResolver.java:621"$1$"					jarFile = getJarFile(jarFileUrl);"
"PathMatchingResourcePatternResolver.java:622"$1$"				}"
"PathMatchingResourcePatternResolver.java:623"$1$"				else {"
"PathMatchingResourcePatternResolver.java:624"$1$"					jarFile = new JarFile(urlFile);"
"PathMatchingResourcePatternResolver.java:625"$1$"					jarFileUrl = urlFile;"
"PathMatchingResourcePatternResolver.java:626"$1$"					rootEntryPath = """";"
"PathMatchingResourcePatternResolver.java:627"$1$"				}"
"PathMatchingResourcePatternResolver.java:628"$0$"				closeJarFile = true;"
"PathMatchingResourcePatternResolver.java:629"$0$"			}"
"PathMatchingResourcePatternResolver.java:630"$1$"			catch (ZipException ex) {"
"PathMatchingResourcePatternResolver.java:631"$1$"				if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:632"$1$"					logger.debug(""Skipping invalid jar classpath entry ["" + urlFile + ""]"");"
"PathMatchingResourcePatternResolver.java:633"$1$"				}"
"PathMatchingResourcePatternResolver.java:634"$0$"				return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:635"$0$"			}"
"PathMatchingResourcePatternResolver.java:636"$0$"		}"
"PathMatchingResourcePatternResolver.java:637"$0$""
"PathMatchingResourcePatternResolver.java:638"$1$"		try {"
"PathMatchingResourcePatternResolver.java:639"$1$"			if (logger.isTraceEnabled()) {"
"PathMatchingResourcePatternResolver.java:640"$1$"				logger.trace(""Looking for matching resources in jar file ["" + jarFileUrl + ""]"");"
"PathMatchingResourcePatternResolver.java:641"$1$"			}"
"PathMatchingResourcePatternResolver.java:642"$1$"			if (!"""".equals(rootEntryPath) && !rootEntryPath.endsWith(""/"")) {"
"PathMatchingResourcePatternResolver.java:643"$0$"				// Root entry path must end with slash to allow for proper matching."
"PathMatchingResourcePatternResolver.java:644"$0$"				// The Sun JRE does not return a slash here, but BEA JRockit does."
"PathMatchingResourcePatternResolver.java:645"$1$"				rootEntryPath = rootEntryPath + ""/"";"
"PathMatchingResourcePatternResolver.java:646"$1$"			}"
"PathMatchingResourcePatternResolver.java:647"$0$"			Set<Resource> result = new LinkedHashSet<>(8);"
"PathMatchingResourcePatternResolver.java:648"$1$"			for (Enumeration<JarEntry> entries = jarFile.entries(); entries.hasMoreElements();) {"
"PathMatchingResourcePatternResolver.java:649"$1$"				JarEntry entry = entries.nextElement();"
"PathMatchingResourcePatternResolver.java:650"$1$"				String entryPath = entry.getName();"
"PathMatchingResourcePatternResolver.java:651"$1$"				if (entryPath.startsWith(rootEntryPath)) {"
"PathMatchingResourcePatternResolver.java:652"$1$"					String relativePath = entryPath.substring(rootEntryPath.length());"
"PathMatchingResourcePatternResolver.java:653"$1$"					if (getPathMatcher().match(subPattern, relativePath)) {"
"PathMatchingResourcePatternResolver.java:654"$1$"						result.add(rootDirResource.createRelative(relativePath));"
"PathMatchingResourcePatternResolver.java:655"$1$"					}"
"PathMatchingResourcePatternResolver.java:656"$0$"				}"
"PathMatchingResourcePatternResolver.java:657"$0$"			}"
"PathMatchingResourcePatternResolver.java:658"$0$"			return result;"
"PathMatchingResourcePatternResolver.java:659"$0$"		}"
"PathMatchingResourcePatternResolver.java:660"$1$"		finally {"
"PathMatchingResourcePatternResolver.java:661"$1$"			if (closeJarFile) {"
"PathMatchingResourcePatternResolver.java:662"$1$"				jarFile.close();"
"PathMatchingResourcePatternResolver.java:663"$1$"			}"
"PathMatchingResourcePatternResolver.java:664"$0$"		}"
"PathMatchingResourcePatternResolver.java:665"$0$"	}"
"PathMatchingResourcePatternResolver.java:666"$0$""
"PathMatchingResourcePatternResolver.java:667"$0$"	/**"
"PathMatchingResourcePatternResolver.java:668"$0$"	 * Resolve the given jar file URL into a JarFile object."
"PathMatchingResourcePatternResolver.java:669"$0$"	 */"
"PathMatchingResourcePatternResolver.java:670"$1$"	protected JarFile getJarFile(String jarFileUrl) throws IOException {"
"PathMatchingResourcePatternResolver.java:671"$1$"		if (jarFileUrl.startsWith(ResourceUtils.FILE_URL_PREFIX)) {"
"PathMatchingResourcePatternResolver.java:672"$1$"			try {"
"PathMatchingResourcePatternResolver.java:673"$1$"				return new JarFile(ResourceUtils.toURI(jarFileUrl).getSchemeSpecificPart());"
"PathMatchingResourcePatternResolver.java:674"$1$"			}"
"PathMatchingResourcePatternResolver.java:675"$1$"			catch (URISyntaxException ex) {"
"PathMatchingResourcePatternResolver.java:676"$0$"				// Fallback for URLs that are not valid URIs (should hardly ever happen)."
"PathMatchingResourcePatternResolver.java:677"$1$"				return new JarFile(jarFileUrl.substring(ResourceUtils.FILE_URL_PREFIX.length()));"
"PathMatchingResourcePatternResolver.java:678"$1$"			}"
"PathMatchingResourcePatternResolver.java:679"$0$"		}"
"PathMatchingResourcePatternResolver.java:680"$1$"		else {"
"PathMatchingResourcePatternResolver.java:681"$1$"			return new JarFile(jarFileUrl);"
"PathMatchingResourcePatternResolver.java:682"$1$"		}"
"PathMatchingResourcePatternResolver.java:683"$0$"	}"
"PathMatchingResourcePatternResolver.java:684"$0$""
"PathMatchingResourcePatternResolver.java:685"$0$"	/**"
"PathMatchingResourcePatternResolver.java:686"$0$"	 * Find all resources in the file system that match the given location pattern"
"PathMatchingResourcePatternResolver.java:687"$0$"	 * via the Ant-style PathMatcher."
"PathMatchingResourcePatternResolver.java:688"$0$"	 * @param rootDirResource the root directory as Resource"
"PathMatchingResourcePatternResolver.java:689"$0$"	 * @param subPattern the sub pattern to match (below the root directory)"
"PathMatchingResourcePatternResolver.java:690"$0$"	 * @return a mutable Set of matching Resource instances"
"PathMatchingResourcePatternResolver.java:691"$0$"	 * @throws IOException in case of I/O errors"
"PathMatchingResourcePatternResolver.java:692"$0$"	 * @see #retrieveMatchingFiles"
"PathMatchingResourcePatternResolver.java:693"$0$"	 * @see org.springframework.util.PathMatcher"
"PathMatchingResourcePatternResolver.java:694"$0$"	 */"
"PathMatchingResourcePatternResolver.java:695"$0$"	protected Set<Resource> doFindPathMatchingFileResources(Resource rootDirResource, String subPattern)"
"PathMatchingResourcePatternResolver.java:696"$1$"			throws IOException {"
"PathMatchingResourcePatternResolver.java:697"$1$""
"PathMatchingResourcePatternResolver.java:698"$1$"		File rootDir;"
"PathMatchingResourcePatternResolver.java:699"$1$"		try {"
"PathMatchingResourcePatternResolver.java:700"$1$"			rootDir = rootDirResource.getFile().getAbsoluteFile();"
"PathMatchingResourcePatternResolver.java:701"$1$"		}"
"PathMatchingResourcePatternResolver.java:702"$1$"		catch (FileNotFoundException ex) {"
"PathMatchingResourcePatternResolver.java:703"$1$"			if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:704"$1$"				logger.debug(""Cannot search for matching files underneath "" + rootDirResource +"
"PathMatchingResourcePatternResolver.java:705"$1$"						"" in the file system: "" + ex.getMessage());"
"PathMatchingResourcePatternResolver.java:706"$1$"			}"
"PathMatchingResourcePatternResolver.java:707"$0$"			return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:708"$0$"		}"
"PathMatchingResourcePatternResolver.java:709"$1$"		catch (Exception ex) {"
"PathMatchingResourcePatternResolver.java:710"$1$"			if (logger.isInfoEnabled()) {"
"PathMatchingResourcePatternResolver.java:711"$1$"				logger.info(""Failed to resolve "" + rootDirResource + "" in the file system: "" + ex);"
"PathMatchingResourcePatternResolver.java:712"$1$"			}"
"PathMatchingResourcePatternResolver.java:713"$0$"			return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:714"$0$"		}"
"PathMatchingResourcePatternResolver.java:715"$0$"		return doFindMatchingFileSystemResources(rootDir, subPattern);"
"PathMatchingResourcePatternResolver.java:716"$0$"	}"
"PathMatchingResourcePatternResolver.java:717"$0$""
"PathMatchingResourcePatternResolver.java:718"$0$"	/**"
"PathMatchingResourcePatternResolver.java:719"$0$"	 * Find all resources in the file system that match the given location pattern"
"PathMatchingResourcePatternResolver.java:720"$0$"	 * via the Ant-style PathMatcher."
"PathMatchingResourcePatternResolver.java:721"$0$"	 * @param rootDir the root directory in the file system"
"PathMatchingResourcePatternResolver.java:722"$0$"	 * @param subPattern the sub pattern to match (below the root directory)"
"PathMatchingResourcePatternResolver.java:723"$0$"	 * @return a mutable Set of matching Resource instances"
"PathMatchingResourcePatternResolver.java:724"$0$"	 * @throws IOException in case of I/O errors"
"PathMatchingResourcePatternResolver.java:725"$0$"	 * @see #retrieveMatchingFiles"
"PathMatchingResourcePatternResolver.java:726"$0$"	 * @see org.springframework.util.PathMatcher"
"PathMatchingResourcePatternResolver.java:727"$0$"	 */"
"PathMatchingResourcePatternResolver.java:728"$1$"	protected Set<Resource> doFindMatchingFileSystemResources(File rootDir, String subPattern) throws IOException {"
"PathMatchingResourcePatternResolver.java:729"$1$"		if (logger.isTraceEnabled()) {"
"PathMatchingResourcePatternResolver.java:730"$1$"			logger.trace(""Looking for matching resources in directory tree ["" + rootDir.getPath() + ""]"");"
"PathMatchingResourcePatternResolver.java:731"$1$"		}"
"PathMatchingResourcePatternResolver.java:732"$0$"		Set<File> matchingFiles = retrieveMatchingFiles(rootDir, subPattern);"
"PathMatchingResourcePatternResolver.java:733"$0$"		Set<Resource> result = new LinkedHashSet<>(matchingFiles.size());"
"PathMatchingResourcePatternResolver.java:734"$1$"		for (File file : matchingFiles) {"
"PathMatchingResourcePatternResolver.java:735"$1$"			result.add(new FileSystemResource(file));"
"PathMatchingResourcePatternResolver.java:736"$1$"		}"
"PathMatchingResourcePatternResolver.java:737"$0$"		return result;"
"PathMatchingResourcePatternResolver.java:738"$0$"	}"
"PathMatchingResourcePatternResolver.java:739"$0$""
"PathMatchingResourcePatternResolver.java:740"$0$"	/**"
"PathMatchingResourcePatternResolver.java:741"$0$"	 * Retrieve files that match the given path pattern,"
"PathMatchingResourcePatternResolver.java:742"$0$"	 * checking the given directory and its subdirectories."
"PathMatchingResourcePatternResolver.java:743"$0$"	 * @param rootDir the directory to start from"
"PathMatchingResourcePatternResolver.java:744"$0$"	 * @param pattern the pattern to match against,"
"PathMatchingResourcePatternResolver.java:745"$0$"	 * relative to the root directory"
"PathMatchingResourcePatternResolver.java:746"$0$"	 * @return a mutable Set of matching Resource instances"
"PathMatchingResourcePatternResolver.java:747"$0$"	 * @throws IOException if directory contents could not be retrieved"
"PathMatchingResourcePatternResolver.java:748"$0$"	 */"
"PathMatchingResourcePatternResolver.java:749"$1$"	protected Set<File> retrieveMatchingFiles(File rootDir, String pattern) throws IOException {"
"PathMatchingResourcePatternResolver.java:750"$1$"		if (!rootDir.exists()) {"
"PathMatchingResourcePatternResolver.java:751"$0$"			// Silently skip non-existing directories."
"PathMatchingResourcePatternResolver.java:752"$1$"			if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:753"$1$"				logger.debug(""Skipping ["" + rootDir.getAbsolutePath() + ""] because it does not exist"");"
"PathMatchingResourcePatternResolver.java:754"$1$"			}"
"PathMatchingResourcePatternResolver.java:755"$0$"			return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:756"$0$"		}"
"PathMatchingResourcePatternResolver.java:757"$1$"		if (!rootDir.isDirectory()) {"
"PathMatchingResourcePatternResolver.java:758"$0$"			// Complain louder if it exists but is no directory."
"PathMatchingResourcePatternResolver.java:759"$1$"			if (logger.isInfoEnabled()) {"
"PathMatchingResourcePatternResolver.java:760"$1$"				logger.info(""Skipping ["" + rootDir.getAbsolutePath() + ""] because it does not denote a directory"");"
"PathMatchingResourcePatternResolver.java:761"$1$"			}"
"PathMatchingResourcePatternResolver.java:762"$0$"			return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:763"$0$"		}"
"PathMatchingResourcePatternResolver.java:764"$1$"		if (!rootDir.canRead()) {"
"PathMatchingResourcePatternResolver.java:765"$1$"			if (logger.isInfoEnabled()) {"
"PathMatchingResourcePatternResolver.java:766"$1$"				logger.info(""Skipping search for matching files underneath directory ["" + rootDir.getAbsolutePath() +"
"PathMatchingResourcePatternResolver.java:767"$1$"						""] because the application is not allowed to read the directory"");"
"PathMatchingResourcePatternResolver.java:768"$1$"			}"
"PathMatchingResourcePatternResolver.java:769"$0$"			return Collections.emptySet();"
"PathMatchingResourcePatternResolver.java:770"$0$"		}"
"PathMatchingResourcePatternResolver.java:771"$0$"		String fullPattern = StringUtils.replace(rootDir.getAbsolutePath(), File.separator, ""/"");"
"PathMatchingResourcePatternResolver.java:772"$1$"		if (!pattern.startsWith(""/"")) {"
"PathMatchingResourcePatternResolver.java:773"$1$"			fullPattern += ""/"";"
"PathMatchingResourcePatternResolver.java:774"$1$"		}"
"PathMatchingResourcePatternResolver.java:775"$0$"		fullPattern = fullPattern + StringUtils.replace(pattern, File.separator, ""/"");"
"PathMatchingResourcePatternResolver.java:776"$0$"		Set<File> result = new LinkedHashSet<>(8);"
"PathMatchingResourcePatternResolver.java:777"$0$"		doRetrieveMatchingFiles(fullPattern, rootDir, result);"
"PathMatchingResourcePatternResolver.java:778"$0$"		return result;"
"PathMatchingResourcePatternResolver.java:779"$0$"	}"
"PathMatchingResourcePatternResolver.java:780"$0$""
"PathMatchingResourcePatternResolver.java:781"$0$"	/**"
"PathMatchingResourcePatternResolver.java:782"$0$"	 * Recursively retrieve files that match the given pattern,"
"PathMatchingResourcePatternResolver.java:783"$0$"	 * adding them to the given result list."
"PathMatchingResourcePatternResolver.java:784"$0$"	 * @param fullPattern the pattern to match against,"
"PathMatchingResourcePatternResolver.java:785"$0$"	 * with prepended root directory path"
"PathMatchingResourcePatternResolver.java:786"$0$"	 * @param dir the current directory"
"PathMatchingResourcePatternResolver.java:787"$0$"	 * @param result the Set of matching File instances to add to"
"PathMatchingResourcePatternResolver.java:788"$0$"	 * @throws IOException if directory contents could not be retrieved"
"PathMatchingResourcePatternResolver.java:789"$0$"	 */"
"PathMatchingResourcePatternResolver.java:790"$1$"	protected void doRetrieveMatchingFiles(String fullPattern, File dir, Set<File> result) throws IOException {"
"PathMatchingResourcePatternResolver.java:791"$1$"		if (logger.isTraceEnabled()) {"
"PathMatchingResourcePatternResolver.java:792"$1$"			logger.trace(""Searching directory ["" + dir.getAbsolutePath() +"
"PathMatchingResourcePatternResolver.java:793"$1$"					""] for files matching pattern ["" + fullPattern + ""]"");"
"PathMatchingResourcePatternResolver.java:794"$1$"		}"
"PathMatchingResourcePatternResolver.java:795"$1$"		for (File content : listDirectory(dir)) {"
"PathMatchingResourcePatternResolver.java:796"$1$"			String currPath = StringUtils.replace(content.getAbsolutePath(), File.separator, ""/"");"
"PathMatchingResourcePatternResolver.java:797"$1$"			if (content.isDirectory() && getPathMatcher().matchStart(fullPattern, currPath + ""/"")) {"
"PathMatchingResourcePatternResolver.java:798"$1$"				if (!content.canRead()) {"
"PathMatchingResourcePatternResolver.java:799"$1$"					if (logger.isDebugEnabled()) {"
"PathMatchingResourcePatternResolver.java:800"$1$"						logger.debug(""Skipping subdirectory ["" + dir.getAbsolutePath() +"
"PathMatchingResourcePatternResolver.java:801"$1$"								""] because the application is not allowed to read the directory"");"
"PathMatchingResourcePatternResolver.java:802"$1$"					}"
"PathMatchingResourcePatternResolver.java:803"$0$"				}"
"PathMatchingResourcePatternResolver.java:804"$1$"				else {"
"PathMatchingResourcePatternResolver.java:805"$1$"					doRetrieveMatchingFiles(fullPattern, content, result);"
"PathMatchingResourcePatternResolver.java:806"$1$"				}"
"PathMatchingResourcePatternResolver.java:807"$0$"			}"
"PathMatchingResourcePatternResolver.java:808"$1$"			if (getPathMatcher().match(fullPattern, currPath)) {"
"PathMatchingResourcePatternResolver.java:809"$1$"				result.add(content);"
"PathMatchingResourcePatternResolver.java:810"$1$"			}"
"PathMatchingResourcePatternResolver.java:811"$0$"		}"
"PathMatchingResourcePatternResolver.java:812"$0$"	}"
"PathMatchingResourcePatternResolver.java:813"$0$""
"PathMatchingResourcePatternResolver.java:814"$0$"	/**"
"PathMatchingResourcePatternResolver.java:815"$0$"	 * Determine a sorted list of files in the given directory."
"PathMatchingResourcePatternResolver.java:816"$0$"	 * @param dir the directory to introspect"
"PathMatchingResourcePatternResolver.java:817"$0$"	 * @return the sorted list of files (by default in alphabetical order)"
"PathMatchingResourcePatternResolver.java:818"$0$"	 * @since 5.1"
"PathMatchingResourcePatternResolver.java:819"$0$"	 * @see File#listFiles()"
"PathMatchingResourcePatternResolver.java:820"$0$"	 */"
"PathMatchingResourcePatternResolver.java:821"$1$"	protected File[] listDirectory(File dir) {"
"PathMatchingResourcePatternResolver.java:822"$1$"		File[] files = dir.listFiles();"
"PathMatchingResourcePatternResolver.java:823"$1$"		if (files == null) {"
"PathMatchingResourcePatternResolver.java:824"$1$"			if (logger.isInfoEnabled()) {"
"PathMatchingResourcePatternResolver.java:825"$1$"				logger.info(""Could not retrieve contents of directory ["" + dir.getAbsolutePath() + ""]"");"
"PathMatchingResourcePatternResolver.java:826"$1$"			}"
"PathMatchingResourcePatternResolver.java:827"$0$"			return new File[0];"
"PathMatchingResourcePatternResolver.java:828"$0$"		}"
"PathMatchingResourcePatternResolver.java:829"$0$"		Arrays.sort(files, Comparator.comparing(File::getName));"
"PathMatchingResourcePatternResolver.java:830"$0$"		return files;"
"PathMatchingResourcePatternResolver.java:831"$0$"	}"
"PathMatchingResourcePatternResolver.java:832"$0$""
"PathMatchingResourcePatternResolver.java:833"$0$""
"PathMatchingResourcePatternResolver.java:834"$0$"	/**"
"PathMatchingResourcePatternResolver.java:835"$0$"	 * Inner delegate class, avoiding a hard JBoss VFS API dependency at runtime."
"PathMatchingResourcePatternResolver.java:836"$0$"	 */"
"PathMatchingResourcePatternResolver.java:837"$1$"	private static class VfsResourceMatchingDelegate {"
"PathMatchingResourcePatternResolver.java:838"$1$""
"PathMatchingResourcePatternResolver.java:839"$1$"		public static Set<Resource> findMatchingResources("
"PathMatchingResourcePatternResolver.java:840"$1$"				URL rootDirURL, String locationPattern, PathMatcher pathMatcher) throws IOException {"
"PathMatchingResourcePatternResolver.java:841"$1$""
"PathMatchingResourcePatternResolver.java:842"$1$"			Object root = VfsPatternUtils.findRoot(rootDirURL);"
"PathMatchingResourcePatternResolver.java:843"$1$"			PatternVirtualFileVisitor visitor ="
"PathMatchingResourcePatternResolver.java:844"$1$"					new PatternVirtualFileVisitor(VfsPatternUtils.getPath(root), locationPattern, pathMatcher);"
"PathMatchingResourcePatternResolver.java:845"$1$"			VfsPatternUtils.visit(root, visitor);"
"PathMatchingResourcePatternResolver.java:846"$1$"			return visitor.getResources();"
"PathMatchingResourcePatternResolver.java:847"$1$"		}"
"PathMatchingResourcePatternResolver.java:848"$0$"	}"
"PathMatchingResourcePatternResolver.java:849"$0$""
"PathMatchingResourcePatternResolver.java:850"$0$""
"PathMatchingResourcePatternResolver.java:851"$0$"	/**"
"PathMatchingResourcePatternResolver.java:852"$0$"	 * VFS visitor for path matching purposes."
"PathMatchingResourcePatternResolver.java:853"$0$"	 */"
"PathMatchingResourcePatternResolver.java:854"$0$"	@SuppressWarnings(""unused"")"
"PathMatchingResourcePatternResolver.java:855"$1$"	private static class PatternVirtualFileVisitor implements InvocationHandler {"
"PathMatchingResourcePatternResolver.java:856"$1$""
"PathMatchingResourcePatternResolver.java:857"$1$"		private final String subPattern;"
"PathMatchingResourcePatternResolver.java:858"$1$""
"PathMatchingResourcePatternResolver.java:859"$1$"		private final PathMatcher pathMatcher;"
"PathMatchingResourcePatternResolver.java:860"$1$""
"PathMatchingResourcePatternResolver.java:861"$1$"		private final String rootPath;"
"PathMatchingResourcePatternResolver.java:862"$1$""
"PathMatchingResourcePatternResolver.java:863"$1$"		private final Set<Resource> resources = new LinkedHashSet<>();"
"PathMatchingResourcePatternResolver.java:864"$1$""
"PathMatchingResourcePatternResolver.java:865"$1$"		public PatternVirtualFileVisitor(String rootPath, String subPattern, PathMatcher pathMatcher) {"
"PathMatchingResourcePatternResolver.java:866"$1$"			this.subPattern = subPattern;"
"PathMatchingResourcePatternResolver.java:867"$1$"			this.pathMatcher = pathMatcher;"
"PathMatchingResourcePatternResolver.java:868"$1$"			this.rootPath = (rootPath.isEmpty() || rootPath.endsWith(""/"") ? rootPath : rootPath + ""/"");"
"PathMatchingResourcePatternResolver.java:869"$1$"		}"
"PathMatchingResourcePatternResolver.java:870"$0$""
"PathMatchingResourcePatternResolver.java:871"$0$"		@Override"
"PathMatchingResourcePatternResolver.java:872"$0$"		@Nullable"
"PathMatchingResourcePatternResolver.java:873"$1$"		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {"
"PathMatchingResourcePatternResolver.java:874"$1$"			String methodName = method.getName();"
"PathMatchingResourcePatternResolver.java:875"$1$"			if (Object.class == method.getDeclaringClass()) {"
"PathMatchingResourcePatternResolver.java:876"$1$"				if (methodName.equals(""equals"")) {"
"PathMatchingResourcePatternResolver.java:877"$0$"					// Only consider equal when proxies are identical."
"PathMatchingResourcePatternResolver.java:878"$1$"					return (proxy == args[0]);"
"PathMatchingResourcePatternResolver.java:879"$1$"				}"
"PathMatchingResourcePatternResolver.java:880"$1$"				else if (methodName.equals(""hashCode"")) {"
"PathMatchingResourcePatternResolver.java:881"$1$"					return System.identityHashCode(proxy);"
"PathMatchingResourcePatternResolver.java:882"$1$"				}"
"PathMatchingResourcePatternResolver.java:883"$0$"			}"
"PathMatchingResourcePatternResolver.java:884"$1$"			else if (""getAttributes"".equals(methodName)) {"
"PathMatchingResourcePatternResolver.java:885"$1$"				return getAttributes();"
"PathMatchingResourcePatternResolver.java:886"$1$"			}"
"PathMatchingResourcePatternResolver.java:887"$1$"			else if (""visit"".equals(methodName)) {"
"PathMatchingResourcePatternResolver.java:888"$1$"				visit(args[0]);"
"PathMatchingResourcePatternResolver.java:889"$1$"				return null;"
"PathMatchingResourcePatternResolver.java:890"$1$"			}"
"PathMatchingResourcePatternResolver.java:891"$1$"			else if (""toString"".equals(methodName)) {"
"PathMatchingResourcePatternResolver.java:892"$1$"				return toString();"
"PathMatchingResourcePatternResolver.java:893"$1$"			}"
"PathMatchingResourcePatternResolver.java:894"$0$""
"PathMatchingResourcePatternResolver.java:895"$0$"			throw new IllegalStateException(""Unexpected method invocation: "" + method);"
"PathMatchingResourcePatternResolver.java:896"$0$"		}"
"PathMatchingResourcePatternResolver.java:897"$0$""
"PathMatchingResourcePatternResolver.java:898"$1$"		public void visit(Object vfsResource) {"
"PathMatchingResourcePatternResolver.java:899"$1$"			if (this.pathMatcher.match(this.subPattern,"
"PathMatchingResourcePatternResolver.java:900"$1$"					VfsPatternUtils.getPath(vfsResource).substring(this.rootPath.length()))) {"
"PathMatchingResourcePatternResolver.java:901"$1$"				this.resources.add(new VfsResource(vfsResource));"
"PathMatchingResourcePatternResolver.java:902"$1$"			}"
"PathMatchingResourcePatternResolver.java:903"$0$"		}"
"PathMatchingResourcePatternResolver.java:904"$0$""
"PathMatchingResourcePatternResolver.java:905"$0$"		@Nullable"
"PathMatchingResourcePatternResolver.java:906"$1$"		public Object getAttributes() {"
"PathMatchingResourcePatternResolver.java:907"$1$"			return VfsPatternUtils.getVisitorAttributes();"
"PathMatchingResourcePatternResolver.java:908"$1$"		}"
"PathMatchingResourcePatternResolver.java:909"$0$""
"PathMatchingResourcePatternResolver.java:910"$1$"		public Set<Resource> getResources() {"
"PathMatchingResourcePatternResolver.java:911"$1$"			return this.resources;"
"PathMatchingResourcePatternResolver.java:912"$1$"		}"
"PathMatchingResourcePatternResolver.java:913"$0$""
"PathMatchingResourcePatternResolver.java:914"$1$"		public int size() {"
"PathMatchingResourcePatternResolver.java:915"$1$"			return this.resources.size();"
"PathMatchingResourcePatternResolver.java:916"$1$"		}"
"PathMatchingResourcePatternResolver.java:917"$0$""
"PathMatchingResourcePatternResolver.java:918"$0$"		@Override"
"PathMatchingResourcePatternResolver.java:919"$1$"		public String toString() {"
"PathMatchingResourcePatternResolver.java:920"$1$"			return ""sub-pattern: "" + this.subPattern + "", resources: "" + this.resources;"
"PathMatchingResourcePatternResolver.java:921"$1$"		}"
"PathMatchingResourcePatternResolver.java:922"$0$"	}"
"PathMatchingResourcePatternResolver.java:923"$0$""
"PathMatchingResourcePatternResolver.java:924"$0$"}"
"LocalVariableTableParameterNameDiscoverer.java:1"$0$"/*"
"LocalVariableTableParameterNameDiscoverer.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"LocalVariableTableParameterNameDiscoverer.java:3"$0$" *"
"LocalVariableTableParameterNameDiscoverer.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"LocalVariableTableParameterNameDiscoverer.java:5"$0$" * you may not use this file except in compliance with the License."
"LocalVariableTableParameterNameDiscoverer.java:6"$0$" * You may obtain a copy of the License at"
"LocalVariableTableParameterNameDiscoverer.java:7"$0$" *"
"LocalVariableTableParameterNameDiscoverer.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"LocalVariableTableParameterNameDiscoverer.java:9"$0$" *"
"LocalVariableTableParameterNameDiscoverer.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"LocalVariableTableParameterNameDiscoverer.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"LocalVariableTableParameterNameDiscoverer.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"LocalVariableTableParameterNameDiscoverer.java:13"$0$" * See the License for the specific language governing permissions and"
"LocalVariableTableParameterNameDiscoverer.java:14"$0$" * limitations under the License."
"LocalVariableTableParameterNameDiscoverer.java:15"$0$" */"
"LocalVariableTableParameterNameDiscoverer.java:16"$0$""
"LocalVariableTableParameterNameDiscoverer.java:17"$0$"package org.springframework.core;"
"LocalVariableTableParameterNameDiscoverer.java:18"$0$""
"LocalVariableTableParameterNameDiscoverer.java:19"$0$"import java.io.IOException;"
"LocalVariableTableParameterNameDiscoverer.java:20"$0$"import java.io.InputStream;"
"LocalVariableTableParameterNameDiscoverer.java:21"$0$"import java.lang.reflect.Constructor;"
"LocalVariableTableParameterNameDiscoverer.java:22"$0$"import java.lang.reflect.Executable;"
"LocalVariableTableParameterNameDiscoverer.java:23"$0$"import java.lang.reflect.Method;"
"LocalVariableTableParameterNameDiscoverer.java:24"$0$"import java.util.Collections;"
"LocalVariableTableParameterNameDiscoverer.java:25"$0$"import java.util.Map;"
"LocalVariableTableParameterNameDiscoverer.java:26"$0$"import java.util.concurrent.ConcurrentHashMap;"
"LocalVariableTableParameterNameDiscoverer.java:27"$0$""
"LocalVariableTableParameterNameDiscoverer.java:28"$0$"import org.apache.commons.logging.Log;"
"LocalVariableTableParameterNameDiscoverer.java:29"$0$"import org.apache.commons.logging.LogFactory;"
"LocalVariableTableParameterNameDiscoverer.java:30"$0$""
"LocalVariableTableParameterNameDiscoverer.java:31"$0$"import org.springframework.asm.ClassReader;"
"LocalVariableTableParameterNameDiscoverer.java:32"$0$"import org.springframework.asm.ClassVisitor;"
"LocalVariableTableParameterNameDiscoverer.java:33"$0$"import org.springframework.asm.Label;"
"LocalVariableTableParameterNameDiscoverer.java:34"$0$"import org.springframework.asm.MethodVisitor;"
"LocalVariableTableParameterNameDiscoverer.java:35"$0$"import org.springframework.asm.Opcodes;"
"LocalVariableTableParameterNameDiscoverer.java:36"$0$"import org.springframework.asm.SpringAsmInfo;"
"LocalVariableTableParameterNameDiscoverer.java:37"$0$"import org.springframework.asm.Type;"
"LocalVariableTableParameterNameDiscoverer.java:38"$0$"import org.springframework.lang.Nullable;"
"LocalVariableTableParameterNameDiscoverer.java:39"$0$"import org.springframework.util.ClassUtils;"
"LocalVariableTableParameterNameDiscoverer.java:40"$0$""
"LocalVariableTableParameterNameDiscoverer.java:41"$0$"/**"
"LocalVariableTableParameterNameDiscoverer.java:42"$1$" * Implementation of {@link ParameterNameDiscoverer} that uses the LocalVariableTable"
"LocalVariableTableParameterNameDiscoverer.java:43"$0$" * information in the method attributes to discover parameter names. Returns"
"LocalVariableTableParameterNameDiscoverer.java:44"$1$" * {@code null} if the class file was compiled without debug information."
"LocalVariableTableParameterNameDiscoverer.java:45"$0$" *"
"LocalVariableTableParameterNameDiscoverer.java:46"$0$" * <p>Uses ObjectWeb's ASM library for analyzing class files. Each discoverer instance"
"LocalVariableTableParameterNameDiscoverer.java:47"$0$" * caches the ASM discovered information for each introspected Class, in a thread-safe"
"LocalVariableTableParameterNameDiscoverer.java:48"$0$" * manner. It is recommended to reuse ParameterNameDiscoverer instances as far as possible."
"LocalVariableTableParameterNameDiscoverer.java:49"$0$" *"
"LocalVariableTableParameterNameDiscoverer.java:50"$0$" * @author Adrian Colyer"
"LocalVariableTableParameterNameDiscoverer.java:51"$0$" * @author Costin Leau"
"LocalVariableTableParameterNameDiscoverer.java:52"$0$" * @author Juergen Hoeller"
"LocalVariableTableParameterNameDiscoverer.java:53"$0$" * @author Chris Beams"
"LocalVariableTableParameterNameDiscoverer.java:54"$0$" * @author Sam Brannen"
"LocalVariableTableParameterNameDiscoverer.java:55"$0$" * @since 2.0"
"LocalVariableTableParameterNameDiscoverer.java:56"$0$" */"
"LocalVariableTableParameterNameDiscoverer.java:57"$1$"public class LocalVariableTableParameterNameDiscoverer implements ParameterNameDiscoverer {"
"LocalVariableTableParameterNameDiscoverer.java:58"$1$""
"LocalVariableTableParameterNameDiscoverer.java:59"$1$"	private static final Log logger = LogFactory.getLog(LocalVariableTableParameterNameDiscoverer.class);"
"LocalVariableTableParameterNameDiscoverer.java:60"$1$""
"LocalVariableTableParameterNameDiscoverer.java:61"$0$"	// marker object for classes that do not have any debug info"
"LocalVariableTableParameterNameDiscoverer.java:62"$1$"	private static final Map<Executable, String[]> NO_DEBUG_INFO_MAP = Collections.emptyMap();"
"LocalVariableTableParameterNameDiscoverer.java:63"$1$""
"LocalVariableTableParameterNameDiscoverer.java:64"$0$"	// the cache uses a nested index (value is a map) to keep the top level cache relatively small in size"
"LocalVariableTableParameterNameDiscoverer.java:65"$1$"	private final Map<Class<?>, Map<Executable, String[]>> parameterNamesCache = new ConcurrentHashMap<>(32);"
"LocalVariableTableParameterNameDiscoverer.java:66"$1$""
"LocalVariableTableParameterNameDiscoverer.java:67"$1$""
"LocalVariableTableParameterNameDiscoverer.java:68"$1$"	@Override"
"LocalVariableTableParameterNameDiscoverer.java:69"$1$"	@Nullable"
"LocalVariableTableParameterNameDiscoverer.java:70"$1$"	public String[] getParameterNames(Method method) {"
"LocalVariableTableParameterNameDiscoverer.java:71"$1$"		Method originalMethod = BridgeMethodResolver.findBridgedMethod(method);"
"LocalVariableTableParameterNameDiscoverer.java:72"$1$"		return doGetParameterNames(originalMethod);"
"LocalVariableTableParameterNameDiscoverer.java:73"$1$"	}"
"LocalVariableTableParameterNameDiscoverer.java:74"$0$""
"LocalVariableTableParameterNameDiscoverer.java:75"$0$"	@Override"
"LocalVariableTableParameterNameDiscoverer.java:76"$0$"	@Nullable"
"LocalVariableTableParameterNameDiscoverer.java:77"$1$"	public String[] getParameterNames(Constructor<?> ctor) {"
"LocalVariableTableParameterNameDiscoverer.java:78"$1$"		return doGetParameterNames(ctor);"
"LocalVariableTableParameterNameDiscoverer.java:79"$1$"	}"
"LocalVariableTableParameterNameDiscoverer.java:80"$0$""
"LocalVariableTableParameterNameDiscoverer.java:81"$0$"	@Nullable"
"LocalVariableTableParameterNameDiscoverer.java:82"$1$"	private String[] doGetParameterNames(Executable executable) {"
"LocalVariableTableParameterNameDiscoverer.java:83"$1$"		Class<?> declaringClass = executable.getDeclaringClass();"
"LocalVariableTableParameterNameDiscoverer.java:84"$1$"		Map<Executable, String[]> map = this.parameterNamesCache.computeIfAbsent(declaringClass, this::inspectClass);"
"LocalVariableTableParameterNameDiscoverer.java:85"$1$"		return (map != NO_DEBUG_INFO_MAP ? map.get(executable) : null);"
"LocalVariableTableParameterNameDiscoverer.java:86"$1$"	}"
"LocalVariableTableParameterNameDiscoverer.java:87"$0$""
"LocalVariableTableParameterNameDiscoverer.java:88"$0$"	/**"
"LocalVariableTableParameterNameDiscoverer.java:89"$0$"	 * Inspects the target class."
"LocalVariableTableParameterNameDiscoverer.java:90"$0$"	 * <p>Exceptions will be logged, and a marker map returned to indicate the"
"LocalVariableTableParameterNameDiscoverer.java:91"$0$"	 * lack of debug information."
"LocalVariableTableParameterNameDiscoverer.java:92"$0$"	 */"
"LocalVariableTableParameterNameDiscoverer.java:93"$1$"	private Map<Executable, String[]> inspectClass(Class<?> clazz) {"
"LocalVariableTableParameterNameDiscoverer.java:94"$1$"		InputStream is = clazz.getResourceAsStream(ClassUtils.getClassFileName(clazz));"
"LocalVariableTableParameterNameDiscoverer.java:95"$1$"		if (is == null) {"
"LocalVariableTableParameterNameDiscoverer.java:96"$0$"			// We couldn't load the class file, which is not fatal as it"
"LocalVariableTableParameterNameDiscoverer.java:97"$0$"			// simply means this method of discovering parameter names won't work."
"LocalVariableTableParameterNameDiscoverer.java:98"$1$"			if (logger.isDebugEnabled()) {"
"LocalVariableTableParameterNameDiscoverer.java:99"$1$"				logger.debug(""Cannot find '.class' file for class ["" + clazz +"
"LocalVariableTableParameterNameDiscoverer.java:100"$1$"						""] - unable to determine constructor/method parameter names"");"
"LocalVariableTableParameterNameDiscoverer.java:101"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:102"$0$"			return NO_DEBUG_INFO_MAP;"
"LocalVariableTableParameterNameDiscoverer.java:103"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:104"$1$"		try {"
"LocalVariableTableParameterNameDiscoverer.java:105"$1$"			ClassReader classReader = new ClassReader(is);"
"LocalVariableTableParameterNameDiscoverer.java:106"$1$"			Map<Executable, String[]> map = new ConcurrentHashMap<>(32);"
"LocalVariableTableParameterNameDiscoverer.java:107"$1$"			classReader.accept(new ParameterNameDiscoveringVisitor(clazz, map), 0);"
"LocalVariableTableParameterNameDiscoverer.java:108"$1$"			return map;"
"LocalVariableTableParameterNameDiscoverer.java:109"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:110"$1$"		catch (IOException ex) {"
"LocalVariableTableParameterNameDiscoverer.java:111"$1$"			if (logger.isDebugEnabled()) {"
"LocalVariableTableParameterNameDiscoverer.java:112"$1$"				logger.debug(""Exception thrown while reading '.class' file for class ["" + clazz +"
"LocalVariableTableParameterNameDiscoverer.java:113"$1$"						""] - unable to determine constructor/method parameter names"", ex);"
"LocalVariableTableParameterNameDiscoverer.java:114"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:115"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:116"$1$"		catch (IllegalArgumentException ex) {"
"LocalVariableTableParameterNameDiscoverer.java:117"$1$"			if (logger.isDebugEnabled()) {"
"LocalVariableTableParameterNameDiscoverer.java:118"$1$"				logger.debug(""ASM ClassReader failed to parse class file ["" + clazz +"
"LocalVariableTableParameterNameDiscoverer.java:119"$1$"						""], probably due to a new Java class file version that isn't supported yet "" +"
"LocalVariableTableParameterNameDiscoverer.java:120"$1$"						""- unable to determine constructor/method parameter names"", ex);"
"LocalVariableTableParameterNameDiscoverer.java:121"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:122"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:123"$1$"		finally {"
"LocalVariableTableParameterNameDiscoverer.java:124"$1$"			try {"
"LocalVariableTableParameterNameDiscoverer.java:125"$1$"				is.close();"
"LocalVariableTableParameterNameDiscoverer.java:126"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:127"$1$"			catch (IOException ex) {"
"LocalVariableTableParameterNameDiscoverer.java:128"$0$"				// ignore"
"LocalVariableTableParameterNameDiscoverer.java:129"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:130"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:131"$0$"		return NO_DEBUG_INFO_MAP;"
"LocalVariableTableParameterNameDiscoverer.java:132"$0$"	}"
"LocalVariableTableParameterNameDiscoverer.java:133"$0$""
"LocalVariableTableParameterNameDiscoverer.java:134"$0$""
"LocalVariableTableParameterNameDiscoverer.java:135"$0$"	/**"
"LocalVariableTableParameterNameDiscoverer.java:136"$0$"	 * Helper class that inspects all methods and constructors and then"
"LocalVariableTableParameterNameDiscoverer.java:137"$1$"	 * attempts to find the parameter names for the given {@link Executable}."
"LocalVariableTableParameterNameDiscoverer.java:138"$0$"	 */"
"LocalVariableTableParameterNameDiscoverer.java:139"$1$"	private static class ParameterNameDiscoveringVisitor extends ClassVisitor {"
"LocalVariableTableParameterNameDiscoverer.java:140"$1$""
"LocalVariableTableParameterNameDiscoverer.java:141"$1$"		private static final String STATIC_CLASS_INIT = ""<clinit>"";"
"LocalVariableTableParameterNameDiscoverer.java:142"$1$""
"LocalVariableTableParameterNameDiscoverer.java:143"$1$"		private final Class<?> clazz;"
"LocalVariableTableParameterNameDiscoverer.java:144"$1$""
"LocalVariableTableParameterNameDiscoverer.java:145"$1$"		private final Map<Executable, String[]> executableMap;"
"LocalVariableTableParameterNameDiscoverer.java:146"$1$""
"LocalVariableTableParameterNameDiscoverer.java:147"$1$"		public ParameterNameDiscoveringVisitor(Class<?> clazz, Map<Executable, String[]> executableMap) {"
"LocalVariableTableParameterNameDiscoverer.java:148"$1$"			super(SpringAsmInfo.ASM_VERSION);"
"LocalVariableTableParameterNameDiscoverer.java:149"$1$"			this.clazz = clazz;"
"LocalVariableTableParameterNameDiscoverer.java:150"$1$"			this.executableMap = executableMap;"
"LocalVariableTableParameterNameDiscoverer.java:151"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:152"$0$""
"LocalVariableTableParameterNameDiscoverer.java:153"$0$"		@Override"
"LocalVariableTableParameterNameDiscoverer.java:154"$0$"		@Nullable"
"LocalVariableTableParameterNameDiscoverer.java:155"$1$"		public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {"
"LocalVariableTableParameterNameDiscoverer.java:156"$0$"			// exclude synthetic + bridged && static class initialization"
"LocalVariableTableParameterNameDiscoverer.java:157"$1$"			if (!isSyntheticOrBridged(access) && !STATIC_CLASS_INIT.equals(name)) {"
"LocalVariableTableParameterNameDiscoverer.java:158"$1$"				return new LocalVariableTableVisitor(this.clazz, this.executableMap, name, desc, isStatic(access));"
"LocalVariableTableParameterNameDiscoverer.java:159"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:160"$0$"			return null;"
"LocalVariableTableParameterNameDiscoverer.java:161"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:162"$0$""
"LocalVariableTableParameterNameDiscoverer.java:163"$1$"		private static boolean isSyntheticOrBridged(int access) {"
"LocalVariableTableParameterNameDiscoverer.java:164"$1$"			return (((access & Opcodes.ACC_SYNTHETIC) | (access & Opcodes.ACC_BRIDGE)) > 0);"
"LocalVariableTableParameterNameDiscoverer.java:165"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:166"$0$""
"LocalVariableTableParameterNameDiscoverer.java:167"$1$"		private static boolean isStatic(int access) {"
"LocalVariableTableParameterNameDiscoverer.java:168"$1$"			return ((access & Opcodes.ACC_STATIC) > 0);"
"LocalVariableTableParameterNameDiscoverer.java:169"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:170"$0$"	}"
"LocalVariableTableParameterNameDiscoverer.java:171"$0$""
"LocalVariableTableParameterNameDiscoverer.java:172"$0$""
"LocalVariableTableParameterNameDiscoverer.java:173"$1$"	private static class LocalVariableTableVisitor extends MethodVisitor {"
"LocalVariableTableParameterNameDiscoverer.java:174"$1$""
"LocalVariableTableParameterNameDiscoverer.java:175"$1$"		private static final String CONSTRUCTOR = ""<init>"";"
"LocalVariableTableParameterNameDiscoverer.java:176"$1$""
"LocalVariableTableParameterNameDiscoverer.java:177"$1$"		private final Class<?> clazz;"
"LocalVariableTableParameterNameDiscoverer.java:178"$1$""
"LocalVariableTableParameterNameDiscoverer.java:179"$1$"		private final Map<Executable, String[]> executableMap;"
"LocalVariableTableParameterNameDiscoverer.java:180"$1$""
"LocalVariableTableParameterNameDiscoverer.java:181"$1$"		private final String name;"
"LocalVariableTableParameterNameDiscoverer.java:182"$1$""
"LocalVariableTableParameterNameDiscoverer.java:183"$1$"		private final Type[] args;"
"LocalVariableTableParameterNameDiscoverer.java:184"$1$""
"LocalVariableTableParameterNameDiscoverer.java:185"$1$"		private final String[] parameterNames;"
"LocalVariableTableParameterNameDiscoverer.java:186"$1$""
"LocalVariableTableParameterNameDiscoverer.java:187"$1$"		private final boolean isStatic;"
"LocalVariableTableParameterNameDiscoverer.java:188"$1$""
"LocalVariableTableParameterNameDiscoverer.java:189"$1$"		private boolean hasLvtInfo = false;"
"LocalVariableTableParameterNameDiscoverer.java:190"$1$""
"LocalVariableTableParameterNameDiscoverer.java:191"$1$"		/*"
"LocalVariableTableParameterNameDiscoverer.java:192"$1$"		 * The nth entry contains the slot index of the LVT table entry holding the"
"LocalVariableTableParameterNameDiscoverer.java:193"$1$"		 * argument name for the nth parameter."
"LocalVariableTableParameterNameDiscoverer.java:194"$1$"		 */"
"LocalVariableTableParameterNameDiscoverer.java:195"$1$"		private final int[] lvtSlotIndex;"
"LocalVariableTableParameterNameDiscoverer.java:196"$1$""
"LocalVariableTableParameterNameDiscoverer.java:197"$1$"		public LocalVariableTableVisitor(Class<?> clazz, Map<Executable, String[]> map, String name, String desc, boolean isStatic) {"
"LocalVariableTableParameterNameDiscoverer.java:198"$1$"			super(SpringAsmInfo.ASM_VERSION);"
"LocalVariableTableParameterNameDiscoverer.java:199"$1$"			this.clazz = clazz;"
"LocalVariableTableParameterNameDiscoverer.java:200"$1$"			this.executableMap = map;"
"LocalVariableTableParameterNameDiscoverer.java:201"$1$"			this.name = name;"
"LocalVariableTableParameterNameDiscoverer.java:202"$1$"			this.args = Type.getArgumentTypes(desc);"
"LocalVariableTableParameterNameDiscoverer.java:203"$1$"			this.parameterNames = new String[this.args.length];"
"LocalVariableTableParameterNameDiscoverer.java:204"$1$"			this.isStatic = isStatic;"
"LocalVariableTableParameterNameDiscoverer.java:205"$1$"			this.lvtSlotIndex = computeLvtSlotIndices(isStatic, this.args);"
"LocalVariableTableParameterNameDiscoverer.java:206"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:207"$0$""
"LocalVariableTableParameterNameDiscoverer.java:208"$0$"		@Override"
"LocalVariableTableParameterNameDiscoverer.java:209"$1$"		public void visitLocalVariable(String name, String description, String signature, Label start, Label end, int index) {"
"LocalVariableTableParameterNameDiscoverer.java:210"$1$"			this.hasLvtInfo = true;"
"LocalVariableTableParameterNameDiscoverer.java:211"$1$"			for (int i = 0; i < this.lvtSlotIndex.length; i++) {"
"LocalVariableTableParameterNameDiscoverer.java:212"$1$"				if (this.lvtSlotIndex[i] == index) {"
"LocalVariableTableParameterNameDiscoverer.java:213"$1$"					this.parameterNames[i] = name;"
"LocalVariableTableParameterNameDiscoverer.java:214"$1$"				}"
"LocalVariableTableParameterNameDiscoverer.java:215"$0$"			}"
"LocalVariableTableParameterNameDiscoverer.java:216"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:217"$0$""
"LocalVariableTableParameterNameDiscoverer.java:218"$0$"		@Override"
"LocalVariableTableParameterNameDiscoverer.java:219"$1$"		public void visitEnd() {"
"LocalVariableTableParameterNameDiscoverer.java:220"$1$"			if (this.hasLvtInfo || (this.isStatic && this.parameterNames.length == 0)) {"
"LocalVariableTableParameterNameDiscoverer.java:221"$0$"				// visitLocalVariable will never be called for static no args methods"
"LocalVariableTableParameterNameDiscoverer.java:222"$0$"				// which doesn't use any local variables."
"LocalVariableTableParameterNameDiscoverer.java:223"$0$"				// This means that hasLvtInfo could be false for that kind of methods"
"LocalVariableTableParameterNameDiscoverer.java:224"$0$"				// even if the class has local variable info."
"LocalVariableTableParameterNameDiscoverer.java:225"$1$"				this.executableMap.put(resolveExecutable(), this.parameterNames);"
"LocalVariableTableParameterNameDiscoverer.java:226"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:227"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:228"$0$""
"LocalVariableTableParameterNameDiscoverer.java:229"$1$"		private Executable resolveExecutable() {"
"LocalVariableTableParameterNameDiscoverer.java:230"$1$"			ClassLoader loader = this.clazz.getClassLoader();"
"LocalVariableTableParameterNameDiscoverer.java:231"$1$"			Class<?>[] argTypes = new Class<?>[this.args.length];"
"LocalVariableTableParameterNameDiscoverer.java:232"$1$"			for (int i = 0; i < this.args.length; i++) {"
"LocalVariableTableParameterNameDiscoverer.java:233"$1$"				argTypes[i] = ClassUtils.resolveClassName(this.args[i].getClassName(), loader);"
"LocalVariableTableParameterNameDiscoverer.java:234"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:235"$1$"			try {"
"LocalVariableTableParameterNameDiscoverer.java:236"$1$"				if (CONSTRUCTOR.equals(this.name)) {"
"LocalVariableTableParameterNameDiscoverer.java:237"$1$"					return this.clazz.getDeclaredConstructor(argTypes);"
"LocalVariableTableParameterNameDiscoverer.java:238"$1$"				}"
"LocalVariableTableParameterNameDiscoverer.java:239"$0$"				return this.clazz.getDeclaredMethod(this.name, argTypes);"
"LocalVariableTableParameterNameDiscoverer.java:240"$0$"			}"
"LocalVariableTableParameterNameDiscoverer.java:241"$1$"			catch (NoSuchMethodException ex) {"
"LocalVariableTableParameterNameDiscoverer.java:242"$1$"				throw new IllegalStateException(""Method ["" + this.name +"
"LocalVariableTableParameterNameDiscoverer.java:243"$1$"						""] was discovered in the .class file but cannot be resolved in the class object"", ex);"
"LocalVariableTableParameterNameDiscoverer.java:244"$1$"			}"
"LocalVariableTableParameterNameDiscoverer.java:245"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:246"$0$""
"LocalVariableTableParameterNameDiscoverer.java:247"$1$"		private static int[] computeLvtSlotIndices(boolean isStatic, Type[] paramTypes) {"
"LocalVariableTableParameterNameDiscoverer.java:248"$1$"			int[] lvtIndex = new int[paramTypes.length];"
"LocalVariableTableParameterNameDiscoverer.java:249"$1$"			int nextIndex = (isStatic ? 0 : 1);"
"LocalVariableTableParameterNameDiscoverer.java:250"$1$"			for (int i = 0; i < paramTypes.length; i++) {"
"LocalVariableTableParameterNameDiscoverer.java:251"$1$"				lvtIndex[i] = nextIndex;"
"LocalVariableTableParameterNameDiscoverer.java:252"$1$"				if (isWideType(paramTypes[i])) {"
"LocalVariableTableParameterNameDiscoverer.java:253"$1$"					nextIndex += 2;"
"LocalVariableTableParameterNameDiscoverer.java:254"$1$"				}"
"LocalVariableTableParameterNameDiscoverer.java:255"$1$"				else {"
"LocalVariableTableParameterNameDiscoverer.java:256"$1$"					nextIndex++;"
"LocalVariableTableParameterNameDiscoverer.java:257"$1$"				}"
"LocalVariableTableParameterNameDiscoverer.java:258"$0$"			}"
"LocalVariableTableParameterNameDiscoverer.java:259"$0$"			return lvtIndex;"
"LocalVariableTableParameterNameDiscoverer.java:260"$0$"		}"
"LocalVariableTableParameterNameDiscoverer.java:261"$0$""
"LocalVariableTableParameterNameDiscoverer.java:262"$1$"		private static boolean isWideType(Type aType) {"
"LocalVariableTableParameterNameDiscoverer.java:263"$0$"			// float is not a wide type"
"LocalVariableTableParameterNameDiscoverer.java:264"$1$"			return (aType == Type.LONG_TYPE || aType == Type.DOUBLE_TYPE);"
"LocalVariableTableParameterNameDiscoverer.java:265"$1$"		}"
"LocalVariableTableParameterNameDiscoverer.java:266"$0$"	}"
"LocalVariableTableParameterNameDiscoverer.java:267"$0$""
"LocalVariableTableParameterNameDiscoverer.java:268"$0$"}"
"ParameterizedTypeReference.java:1"$0$"/*"
"ParameterizedTypeReference.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ParameterizedTypeReference.java:3"$0$" *"
"ParameterizedTypeReference.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ParameterizedTypeReference.java:5"$0$" * you may not use this file except in compliance with the License."
"ParameterizedTypeReference.java:6"$0$" * You may obtain a copy of the License at"
"ParameterizedTypeReference.java:7"$0$" *"
"ParameterizedTypeReference.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ParameterizedTypeReference.java:9"$0$" *"
"ParameterizedTypeReference.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ParameterizedTypeReference.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ParameterizedTypeReference.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ParameterizedTypeReference.java:13"$0$" * See the License for the specific language governing permissions and"
"ParameterizedTypeReference.java:14"$0$" * limitations under the License."
"ParameterizedTypeReference.java:15"$0$" */"
"ParameterizedTypeReference.java:16"$0$""
"ParameterizedTypeReference.java:17"$0$""
"ParameterizedTypeReference.java:18"$0$"package org.springframework.core;"
"ParameterizedTypeReference.java:19"$0$""
"ParameterizedTypeReference.java:20"$0$"import java.lang.reflect.ParameterizedType;"
"ParameterizedTypeReference.java:21"$0$"import java.lang.reflect.Type;"
"ParameterizedTypeReference.java:22"$0$""
"ParameterizedTypeReference.java:23"$0$"import org.springframework.lang.Nullable;"
"ParameterizedTypeReference.java:24"$0$"import org.springframework.util.Assert;"
"ParameterizedTypeReference.java:25"$0$""
"ParameterizedTypeReference.java:26"$0$"/**"
"ParameterizedTypeReference.java:27"$0$" * The purpose of this class is to enable capturing and passing a generic"
"ParameterizedTypeReference.java:28"$1$" * {@link Type}. In order to capture the generic type and retain it at runtime,"
"ParameterizedTypeReference.java:29"$0$" * you need to create a subclass (ideally as anonymous inline class) as follows:"
"ParameterizedTypeReference.java:30"$0$" *"
"ParameterizedTypeReference.java:31"$0$" * <pre class=""code"">"
"ParameterizedTypeReference.java:32"$1$" * ParameterizedTypeReference&lt;List&lt;String&gt;&gt; typeRef = new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {};"
"ParameterizedTypeReference.java:33"$0$" * </pre>"
"ParameterizedTypeReference.java:34"$0$" *"
"ParameterizedTypeReference.java:35"$1$" * <p>The resulting {@code typeRef} instance can then be used to obtain a {@link Type}"
"ParameterizedTypeReference.java:36"$0$" * instance that carries the captured parameterized type information at runtime."
"ParameterizedTypeReference.java:37"$0$" * For more information on ""super type tokens"" see the link to Neal Gafter's blog post."
"ParameterizedTypeReference.java:38"$0$" *"
"ParameterizedTypeReference.java:39"$0$" * @author Arjen Poutsma"
"ParameterizedTypeReference.java:40"$0$" * @author Rossen Stoyanchev"
"ParameterizedTypeReference.java:41"$0$" * @since 3.2"
"ParameterizedTypeReference.java:42"$0$" * @param <T> the referenced type"
"ParameterizedTypeReference.java:43"$0$" * @see <a href=""https://gafter.blogspot.nl/2006/12/super-type-tokens.html"">Neal Gafter on Super Type Tokens</a>"
"ParameterizedTypeReference.java:44"$0$" */"
"ParameterizedTypeReference.java:45"$1$"public abstract class ParameterizedTypeReference<T> {"
"ParameterizedTypeReference.java:46"$1$""
"ParameterizedTypeReference.java:47"$1$"	private final Type type;"
"ParameterizedTypeReference.java:48"$1$""
"ParameterizedTypeReference.java:49"$1$""
"ParameterizedTypeReference.java:50"$1$"	protected ParameterizedTypeReference() {"
"ParameterizedTypeReference.java:51"$1$"		Class<?> parameterizedTypeReferenceSubclass = findParameterizedTypeReferenceSubclass(getClass());"
"ParameterizedTypeReference.java:52"$1$"		Type type = parameterizedTypeReferenceSubclass.getGenericSuperclass();"
"ParameterizedTypeReference.java:53"$1$"		Assert.isInstanceOf(ParameterizedType.class, type, ""Type must be a parameterized type"");"
"ParameterizedTypeReference.java:54"$1$"		ParameterizedType parameterizedType = (ParameterizedType) type;"
"ParameterizedTypeReference.java:55"$1$"		Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();"
"ParameterizedTypeReference.java:56"$1$"		Assert.isTrue(actualTypeArguments.length == 1, ""Number of type arguments must be 1"");"
"ParameterizedTypeReference.java:57"$1$"		this.type = actualTypeArguments[0];"
"ParameterizedTypeReference.java:58"$1$"	}"
"ParameterizedTypeReference.java:59"$0$""
"ParameterizedTypeReference.java:60"$1$"	private ParameterizedTypeReference(Type type) {"
"ParameterizedTypeReference.java:61"$1$"		this.type = type;"
"ParameterizedTypeReference.java:62"$1$"	}"
"ParameterizedTypeReference.java:63"$0$""
"ParameterizedTypeReference.java:64"$0$""
"ParameterizedTypeReference.java:65"$1$"	public Type getType() {"
"ParameterizedTypeReference.java:66"$1$"		return this.type;"
"ParameterizedTypeReference.java:67"$1$"	}"
"ParameterizedTypeReference.java:68"$0$""
"ParameterizedTypeReference.java:69"$0$"	@Override"
"ParameterizedTypeReference.java:70"$1$"	public boolean equals(@Nullable Object other) {"
"ParameterizedTypeReference.java:71"$1$"		return (this == other || (other instanceof ParameterizedTypeReference &&"
"ParameterizedTypeReference.java:72"$1$"				this.type.equals(((ParameterizedTypeReference<?>) other).type)));"
"ParameterizedTypeReference.java:73"$1$"	}"
"ParameterizedTypeReference.java:74"$0$""
"ParameterizedTypeReference.java:75"$0$"	@Override"
"ParameterizedTypeReference.java:76"$1$"	public int hashCode() {"
"ParameterizedTypeReference.java:77"$1$"		return this.type.hashCode();"
"ParameterizedTypeReference.java:78"$1$"	}"
"ParameterizedTypeReference.java:79"$0$""
"ParameterizedTypeReference.java:80"$0$"	@Override"
"ParameterizedTypeReference.java:81"$1$"	public String toString() {"
"ParameterizedTypeReference.java:82"$1$"		return ""ParameterizedTypeReference<"" + this.type + "">"";"
"ParameterizedTypeReference.java:83"$1$"	}"
"ParameterizedTypeReference.java:84"$0$""
"ParameterizedTypeReference.java:85"$0$""
"ParameterizedTypeReference.java:86"$0$"	/**"
"ParameterizedTypeReference.java:87"$1$"	 * Build a {@code ParameterizedTypeReference} wrapping the given type."
"ParameterizedTypeReference.java:88"$0$"	 * @param type a generic type (possibly obtained via reflection,"
"ParameterizedTypeReference.java:89"$1$"	 * e.g. from {@link java.lang.reflect.Method#getGenericReturnType()})"
"ParameterizedTypeReference.java:90"$0$"	 * @return a corresponding reference which may be passed into"
"ParameterizedTypeReference.java:91"$1$"	 * {@code ParameterizedTypeReference}-accepting methods"
"ParameterizedTypeReference.java:92"$0$"	 * @since 4.3.12"
"ParameterizedTypeReference.java:93"$0$"	 */"
"ParameterizedTypeReference.java:94"$1$"	public static <T> ParameterizedTypeReference<T> forType(Type type) {"
"ParameterizedTypeReference.java:95"$1$"		return new ParameterizedTypeReference<T>(type) {"
"ParameterizedTypeReference.java:96"$1$"		};"
"ParameterizedTypeReference.java:97"$0$"	}"
"ParameterizedTypeReference.java:98"$0$""
"ParameterizedTypeReference.java:99"$1$"	private static Class<?> findParameterizedTypeReferenceSubclass(Class<?> child) {"
"ParameterizedTypeReference.java:100"$1$"		Class<?> parent = child.getSuperclass();"
"ParameterizedTypeReference.java:101"$1$"		if (Object.class == parent) {"
"ParameterizedTypeReference.java:102"$1$"			throw new IllegalStateException(""Expected ParameterizedTypeReference superclass"");"
"ParameterizedTypeReference.java:103"$1$"		}"
"ParameterizedTypeReference.java:104"$1$"		else if (ParameterizedTypeReference.class == parent) {"
"ParameterizedTypeReference.java:105"$1$"			return child;"
"ParameterizedTypeReference.java:106"$1$"		}"
"ParameterizedTypeReference.java:107"$1$"		else {"
"ParameterizedTypeReference.java:108"$1$"			return findParameterizedTypeReferenceSubclass(parent);"
"ParameterizedTypeReference.java:109"$1$"		}"
"ParameterizedTypeReference.java:110"$0$"	}"
"ParameterizedTypeReference.java:111"$0$""
"ParameterizedTypeReference.java:112"$0$"}"
"SettableListenableFuture.java:1"$0$"/*"
"SettableListenableFuture.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"SettableListenableFuture.java:3"$0$" *"
"SettableListenableFuture.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SettableListenableFuture.java:5"$0$" * you may not use this file except in compliance with the License."
"SettableListenableFuture.java:6"$0$" * You may obtain a copy of the License at"
"SettableListenableFuture.java:7"$0$" *"
"SettableListenableFuture.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SettableListenableFuture.java:9"$0$" *"
"SettableListenableFuture.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SettableListenableFuture.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SettableListenableFuture.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SettableListenableFuture.java:13"$0$" * See the License for the specific language governing permissions and"
"SettableListenableFuture.java:14"$0$" * limitations under the License."
"SettableListenableFuture.java:15"$0$" */"
"SettableListenableFuture.java:16"$0$""
"SettableListenableFuture.java:17"$0$"package org.springframework.util.concurrent;"
"SettableListenableFuture.java:18"$0$""
"SettableListenableFuture.java:19"$0$"import java.util.concurrent.Callable;"
"SettableListenableFuture.java:20"$0$"import java.util.concurrent.CompletableFuture;"
"SettableListenableFuture.java:21"$0$"import java.util.concurrent.ExecutionException;"
"SettableListenableFuture.java:22"$0$"import java.util.concurrent.TimeUnit;"
"SettableListenableFuture.java:23"$0$"import java.util.concurrent.TimeoutException;"
"SettableListenableFuture.java:24"$0$""
"SettableListenableFuture.java:25"$0$"import org.springframework.lang.Nullable;"
"SettableListenableFuture.java:26"$0$"import org.springframework.util.Assert;"
"SettableListenableFuture.java:27"$0$""
"SettableListenableFuture.java:28"$0$"/**"
"SettableListenableFuture.java:29"$1$" * A {@link ListenableFuture} whose value can be set via {@link #set(Object)}"
"SettableListenableFuture.java:30"$1$" * or {@link #setException(Throwable)}. It may also get cancelled."
"SettableListenableFuture.java:31"$0$" *"
"SettableListenableFuture.java:32"$1$" * <p>Inspired by {@code com.google.common.util.concurrent.SettableFuture}."
"SettableListenableFuture.java:33"$0$" *"
"SettableListenableFuture.java:34"$0$" * @author Mattias Severson"
"SettableListenableFuture.java:35"$0$" * @author Rossen Stoyanchev"
"SettableListenableFuture.java:36"$0$" * @author Juergen Hoeller"
"SettableListenableFuture.java:37"$0$" * @since 4.1"
"SettableListenableFuture.java:38"$1$" * @param <T> the result type returned by this Future's {@code get} method"
"SettableListenableFuture.java:39"$0$" */"
"SettableListenableFuture.java:40"$1$"public class SettableListenableFuture<T> implements ListenableFuture<T> {"
"SettableListenableFuture.java:41"$1$""
"SettableListenableFuture.java:42"$1$"	private static final Callable<Object> DUMMY_CALLABLE = () -> {"
"SettableListenableFuture.java:43"$1$"		throw new IllegalStateException(""Should never be called"");"
"SettableListenableFuture.java:44"$1$"	};"
"SettableListenableFuture.java:45"$0$""
"SettableListenableFuture.java:46"$0$""
"SettableListenableFuture.java:47"$0$"	private final SettableTask<T> settableTask = new SettableTask<>();"
"SettableListenableFuture.java:48"$0$""
"SettableListenableFuture.java:49"$0$""
"SettableListenableFuture.java:50"$0$"	/**"
"SettableListenableFuture.java:51"$1$"	 * Set the value of this future. This method will return {@code true} if the"
"SettableListenableFuture.java:52"$1$"	 * value was set successfully, or {@code false} if the future has already been"
"SettableListenableFuture.java:53"$0$"	 * set or cancelled."
"SettableListenableFuture.java:54"$0$"	 * @param value the value that will be set"
"SettableListenableFuture.java:55"$1$"	 * @return {@code true} if the value was successfully set, else {@code false}"
"SettableListenableFuture.java:56"$0$"	 */"
"SettableListenableFuture.java:57"$1$"	public boolean set(@Nullable T value) {"
"SettableListenableFuture.java:58"$1$"		return this.settableTask.setResultValue(value);"
"SettableListenableFuture.java:59"$1$"	}"
"SettableListenableFuture.java:60"$0$""
"SettableListenableFuture.java:61"$0$"	/**"
"SettableListenableFuture.java:62"$1$"	 * Set the exception of this future. This method will return {@code true} if the"
"SettableListenableFuture.java:63"$1$"	 * exception was set successfully, or {@code false} if the future has already been"
"SettableListenableFuture.java:64"$0$"	 * set or cancelled."
"SettableListenableFuture.java:65"$0$"	 * @param exception the value that will be set"
"SettableListenableFuture.java:66"$1$"	 * @return {@code true} if the exception was successfully set, else {@code false}"
"SettableListenableFuture.java:67"$0$"	 */"
"SettableListenableFuture.java:68"$1$"	public boolean setException(Throwable exception) {"
"SettableListenableFuture.java:69"$1$"		Assert.notNull(exception, ""Exception must not be null"");"
"SettableListenableFuture.java:70"$1$"		return this.settableTask.setExceptionResult(exception);"
"SettableListenableFuture.java:71"$1$"	}"
"SettableListenableFuture.java:72"$0$""
"SettableListenableFuture.java:73"$0$""
"SettableListenableFuture.java:74"$0$"	@Override"
"SettableListenableFuture.java:75"$1$"	public void addCallback(ListenableFutureCallback<? super T> callback) {"
"SettableListenableFuture.java:76"$1$"		this.settableTask.addCallback(callback);"
"SettableListenableFuture.java:77"$1$"	}"
"SettableListenableFuture.java:78"$0$""
"SettableListenableFuture.java:79"$0$"	@Override"
"SettableListenableFuture.java:80"$1$"	public void addCallback(SuccessCallback<? super T> successCallback, FailureCallback failureCallback) {"
"SettableListenableFuture.java:81"$1$"		this.settableTask.addCallback(successCallback, failureCallback);"
"SettableListenableFuture.java:82"$1$"	}"
"SettableListenableFuture.java:83"$0$""
"SettableListenableFuture.java:84"$0$"	@Override"
"SettableListenableFuture.java:85"$1$"	public CompletableFuture<T> completable() {"
"SettableListenableFuture.java:86"$1$"		return this.settableTask.completable();"
"SettableListenableFuture.java:87"$1$"	}"
"SettableListenableFuture.java:88"$0$""
"SettableListenableFuture.java:89"$0$""
"SettableListenableFuture.java:90"$0$"	@Override"
"SettableListenableFuture.java:91"$1$"	public boolean cancel(boolean mayInterruptIfRunning) {"
"SettableListenableFuture.java:92"$1$"		boolean cancelled = this.settableTask.cancel(mayInterruptIfRunning);"
"SettableListenableFuture.java:93"$1$"		if (cancelled && mayInterruptIfRunning) {"
"SettableListenableFuture.java:94"$1$"			interruptTask();"
"SettableListenableFuture.java:95"$1$"		}"
"SettableListenableFuture.java:96"$0$"		return cancelled;"
"SettableListenableFuture.java:97"$0$"	}"
"SettableListenableFuture.java:98"$0$""
"SettableListenableFuture.java:99"$0$"	@Override"
"SettableListenableFuture.java:100"$1$"	public boolean isCancelled() {"
"SettableListenableFuture.java:101"$1$"		return this.settableTask.isCancelled();"
"SettableListenableFuture.java:102"$1$"	}"
"SettableListenableFuture.java:103"$0$""
"SettableListenableFuture.java:104"$0$"	@Override"
"SettableListenableFuture.java:105"$1$"	public boolean isDone() {"
"SettableListenableFuture.java:106"$1$"		return this.settableTask.isDone();"
"SettableListenableFuture.java:107"$1$"	}"
"SettableListenableFuture.java:108"$0$""
"SettableListenableFuture.java:109"$0$"	/**"
"SettableListenableFuture.java:110"$0$"	 * Retrieve the value."
"SettableListenableFuture.java:111"$1$"	 * <p>This method returns the value if it has been set via {@link #set(Object)},"
"SettableListenableFuture.java:112"$1$"	 * throws an {@link java.util.concurrent.ExecutionException} if an exception has"
"SettableListenableFuture.java:113"$1$"	 * been set via {@link #setException(Throwable)}, or throws a"
"SettableListenableFuture.java:114"$1$"	 * {@link java.util.concurrent.CancellationException} if the future has been cancelled."
"SettableListenableFuture.java:115"$0$"	 * @return the value associated with this future"
"SettableListenableFuture.java:116"$0$"	 */"
"SettableListenableFuture.java:117"$0$"	@Override"
"SettableListenableFuture.java:118"$1$"	public T get() throws InterruptedException, ExecutionException {"
"SettableListenableFuture.java:119"$1$"		return this.settableTask.get();"
"SettableListenableFuture.java:120"$1$"	}"
"SettableListenableFuture.java:121"$0$""
"SettableListenableFuture.java:122"$0$"	/**"
"SettableListenableFuture.java:123"$0$"	 * Retrieve the value."
"SettableListenableFuture.java:124"$1$"	 * <p>This method returns the value if it has been set via {@link #set(Object)},"
"SettableListenableFuture.java:125"$1$"	 * throws an {@link java.util.concurrent.ExecutionException} if an exception has"
"SettableListenableFuture.java:126"$1$"	 * been set via {@link #setException(Throwable)}, or throws a"
"SettableListenableFuture.java:127"$1$"	 * {@link java.util.concurrent.CancellationException} if the future has been cancelled."
"SettableListenableFuture.java:128"$0$"	 * @param timeout the maximum time to wait"
"SettableListenableFuture.java:129"$0$"	 * @param unit the unit of the timeout argument"
"SettableListenableFuture.java:130"$0$"	 * @return the value associated with this future"
"SettableListenableFuture.java:131"$0$"	 */"
"SettableListenableFuture.java:132"$0$"	@Override"
"SettableListenableFuture.java:133"$1$"	public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {"
"SettableListenableFuture.java:134"$1$"		return this.settableTask.get(timeout, unit);"
"SettableListenableFuture.java:135"$1$"	}"
"SettableListenableFuture.java:136"$0$""
"SettableListenableFuture.java:137"$0$"	/**"
"SettableListenableFuture.java:138"$0$"	 * Subclasses can override this method to implement interruption of the future's"
"SettableListenableFuture.java:139"$0$"	 * computation. The method is invoked automatically by a successful call to"
"SettableListenableFuture.java:140"$1$"	 * {@link #cancel(boolean) cancel(true)}."
"SettableListenableFuture.java:141"$0$"	 * <p>The default implementation is empty."
"SettableListenableFuture.java:142"$0$"	 */"
"SettableListenableFuture.java:143"$1$"	protected void interruptTask() {"
"SettableListenableFuture.java:144"$1$"	}"
"SettableListenableFuture.java:145"$0$""
"SettableListenableFuture.java:146"$0$""
"SettableListenableFuture.java:147"$1$"	private static class SettableTask<T> extends ListenableFutureTask<T> {"
"SettableListenableFuture.java:148"$1$""
"SettableListenableFuture.java:149"$1$"		@Nullable"
"SettableListenableFuture.java:150"$1$"		private volatile Thread completingThread;"
"SettableListenableFuture.java:151"$1$""
"SettableListenableFuture.java:152"$1$"		@SuppressWarnings(""unchecked"")"
"SettableListenableFuture.java:153"$1$"		public SettableTask() {"
"SettableListenableFuture.java:154"$1$"			super((Callable<T>) DUMMY_CALLABLE);"
"SettableListenableFuture.java:155"$1$"		}"
"SettableListenableFuture.java:156"$0$""
"SettableListenableFuture.java:157"$1$"		public boolean setResultValue(@Nullable T value) {"
"SettableListenableFuture.java:158"$1$"			set(value);"
"SettableListenableFuture.java:159"$1$"			return checkCompletingThread();"
"SettableListenableFuture.java:160"$1$"		}"
"SettableListenableFuture.java:161"$0$""
"SettableListenableFuture.java:162"$1$"		public boolean setExceptionResult(Throwable exception) {"
"SettableListenableFuture.java:163"$1$"			setException(exception);"
"SettableListenableFuture.java:164"$1$"			return checkCompletingThread();"
"SettableListenableFuture.java:165"$1$"		}"
"SettableListenableFuture.java:166"$0$""
"SettableListenableFuture.java:167"$0$"		@Override"
"SettableListenableFuture.java:168"$1$"		protected void done() {"
"SettableListenableFuture.java:169"$1$"			if (!isCancelled()) {"
"SettableListenableFuture.java:170"$0$"				// Implicitly invoked by set/setException: store current thread for"
"SettableListenableFuture.java:171"$0$"				// determining whether the given result has actually triggered completion"
"SettableListenableFuture.java:172"$0$"				// (since FutureTask.set/setException unfortunately don't expose that)"
"SettableListenableFuture.java:173"$1$"				this.completingThread = Thread.currentThread();"
"SettableListenableFuture.java:174"$1$"			}"
"SettableListenableFuture.java:175"$0$"			super.done();"
"SettableListenableFuture.java:176"$0$"		}"
"SettableListenableFuture.java:177"$0$""
"SettableListenableFuture.java:178"$1$"		private boolean checkCompletingThread() {"
"SettableListenableFuture.java:179"$1$"			boolean check = (this.completingThread == Thread.currentThread());"
"SettableListenableFuture.java:180"$1$"			if (check) {"
"SettableListenableFuture.java:181"$1$"				this.completingThread = null;  // only first match actually counts"
"SettableListenableFuture.java:182"$1$"			}"
"SettableListenableFuture.java:183"$0$"			return check;"
"SettableListenableFuture.java:184"$0$"		}"
"SettableListenableFuture.java:185"$0$"	}"
"SettableListenableFuture.java:186"$0$""
"SettableListenableFuture.java:187"$0$"}"
"SortedProperties.java:1"$0$"/*"
"SortedProperties.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"SortedProperties.java:3"$0$" *"
"SortedProperties.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SortedProperties.java:5"$0$" * you may not use this file except in compliance with the License."
"SortedProperties.java:6"$0$" * You may obtain a copy of the License at"
"SortedProperties.java:7"$0$" *"
"SortedProperties.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SortedProperties.java:9"$0$" *"
"SortedProperties.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SortedProperties.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SortedProperties.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SortedProperties.java:13"$0$" * See the License for the specific language governing permissions and"
"SortedProperties.java:14"$0$" * limitations under the License."
"SortedProperties.java:15"$0$" */"
"SortedProperties.java:16"$0$""
"SortedProperties.java:17"$0$"package org.springframework.core;"
"SortedProperties.java:18"$0$""
"SortedProperties.java:19"$0$"import java.io.ByteArrayOutputStream;"
"SortedProperties.java:20"$0$"import java.io.IOException;"
"SortedProperties.java:21"$0$"import java.io.OutputStream;"
"SortedProperties.java:22"$0$"import java.io.StringWriter;"
"SortedProperties.java:23"$0$"import java.io.Writer;"
"SortedProperties.java:24"$0$"import java.nio.charset.StandardCharsets;"
"SortedProperties.java:25"$0$"import java.util.Collections;"
"SortedProperties.java:26"$0$"import java.util.Comparator;"
"SortedProperties.java:27"$0$"import java.util.Enumeration;"
"SortedProperties.java:28"$0$"import java.util.Map.Entry;"
"SortedProperties.java:29"$0$"import java.util.Properties;"
"SortedProperties.java:30"$0$"import java.util.Set;"
"SortedProperties.java:31"$0$"import java.util.TreeSet;"
"SortedProperties.java:32"$0$""
"SortedProperties.java:33"$0$"import org.springframework.lang.Nullable;"
"SortedProperties.java:34"$0$""
"SortedProperties.java:35"$0$"/**"
"SortedProperties.java:36"$1$" * Specialization of {@link Properties} that sorts properties alphanumerically"
"SortedProperties.java:37"$0$" * based on their keys."
"SortedProperties.java:38"$0$" *"
"SortedProperties.java:39"$1$" * <p>This can be useful when storing the {@link Properties} instance in a"
"SortedProperties.java:40"$0$" * properties file, since it allows such files to be generated in a repeatable"
"SortedProperties.java:41"$0$" * manner with consistent ordering of properties."
"SortedProperties.java:42"$0$" *"
"SortedProperties.java:43"$0$" * <p>Comments in generated properties files can also be optionally omitted."
"SortedProperties.java:44"$0$" *"
"SortedProperties.java:45"$0$" * @author Sam Brannen"
"SortedProperties.java:46"$0$" * @since 5.2"
"SortedProperties.java:47"$0$" * @see java.util.Properties"
"SortedProperties.java:48"$0$" */"
"SortedProperties.java:49"$0$"SuppressWarnings(""serial"")"
"SortedProperties.java:50"$1$"class SortedProperties extends Properties {"
"SortedProperties.java:51"$1$""
"SortedProperties.java:52"$1$"	static final String EOL = System.lineSeparator();"
"SortedProperties.java:53"$1$""
"SortedProperties.java:54"$1$"	private static final Comparator<Object> keyComparator = Comparator.comparing(String::valueOf);"
"SortedProperties.java:55"$1$""
"SortedProperties.java:56"$1$"	private static final Comparator<Entry<Object, Object>> entryComparator = Entry.comparingByKey(keyComparator);"
"SortedProperties.java:57"$1$""
"SortedProperties.java:58"$1$""
"SortedProperties.java:59"$1$"	private final boolean omitComments;"
"SortedProperties.java:60"$1$""
"SortedProperties.java:61"$1$""
"SortedProperties.java:62"$1$"	/**"
"SortedProperties.java:63"$1$"	 * Construct a new {@code SortedProperties} instance that honors the supplied"
"SortedProperties.java:64"$1$"	 * {@code omitComments} flag."
"SortedProperties.java:65"$1$"	 * @param omitComments {@code true} if comments should be omitted when"
"SortedProperties.java:66"$1$"	 * storing properties in a file"
"SortedProperties.java:67"$1$"	 */"
"SortedProperties.java:68"$1$"	SortedProperties(boolean omitComments) {"
"SortedProperties.java:69"$1$"		this.omitComments = omitComments;"
"SortedProperties.java:70"$1$"	}"
"SortedProperties.java:71"$0$""
"SortedProperties.java:72"$0$"	/**"
"SortedProperties.java:73"$1$"	 * Construct a new {@code SortedProperties} instance with properties populated"
"SortedProperties.java:74"$1$"	 * from the supplied {@link Properties} object and honoring the supplied"
"SortedProperties.java:75"$1$"	 * {@code omitComments} flag."
"SortedProperties.java:76"$1$"	 * <p>Default properties from the supplied {@code Properties} object will"
"SortedProperties.java:77"$0$"	 * not be copied."
"SortedProperties.java:78"$1$"	 * @param properties the {@code Properties} object from which to copy the"
"SortedProperties.java:79"$0$"	 * initial properties"
"SortedProperties.java:80"$1$"	 * @param omitComments {@code true} if comments should be omitted when"
"SortedProperties.java:81"$0$"	 * storing properties in a file"
"SortedProperties.java:82"$0$"	 */"
"SortedProperties.java:83"$1$"	SortedProperties(Properties properties, boolean omitComments) {"
"SortedProperties.java:84"$1$"		this(omitComments);"
"SortedProperties.java:85"$1$"		putAll(properties);"
"SortedProperties.java:86"$1$"	}"
"SortedProperties.java:87"$0$""
"SortedProperties.java:88"$0$""
"SortedProperties.java:89"$0$"	@Override"
"SortedProperties.java:90"$1$"	public void store(OutputStream out, @Nullable String comments) throws IOException {"
"SortedProperties.java:91"$1$"		ByteArrayOutputStream baos = new ByteArrayOutputStream();"
"SortedProperties.java:92"$1$"		super.store(baos, (this.omitComments ? null : comments));"
"SortedProperties.java:93"$1$"		String contents = baos.toString(StandardCharsets.ISO_8859_1.name());"
"SortedProperties.java:94"$1$"		for (String line : contents.split(EOL)) {"
"SortedProperties.java:95"$1$"			if (!(this.omitComments && line.startsWith(""#""))) {"
"SortedProperties.java:96"$1$"				out.write((line + EOL).getBytes(StandardCharsets.ISO_8859_1));"
"SortedProperties.java:97"$1$"			}"
"SortedProperties.java:98"$0$"		}"
"SortedProperties.java:99"$0$"	}"
"SortedProperties.java:100"$0$""
"SortedProperties.java:101"$0$"	@Override"
"SortedProperties.java:102"$1$"	public void store(Writer writer, @Nullable String comments) throws IOException {"
"SortedProperties.java:103"$1$"		StringWriter stringWriter = new StringWriter();"
"SortedProperties.java:104"$1$"		super.store(stringWriter, (this.omitComments ? null : comments));"
"SortedProperties.java:105"$1$"		String contents = stringWriter.toString();"
"SortedProperties.java:106"$1$"		for (String line : contents.split(EOL)) {"
"SortedProperties.java:107"$1$"			if (!(this.omitComments && line.startsWith(""#""))) {"
"SortedProperties.java:108"$1$"				writer.write(line + EOL);"
"SortedProperties.java:109"$1$"			}"
"SortedProperties.java:110"$0$"		}"
"SortedProperties.java:111"$0$"	}"
"SortedProperties.java:112"$0$""
"SortedProperties.java:113"$0$"	@Override"
"SortedProperties.java:114"$1$"	public void storeToXML(OutputStream out, @Nullable String comments) throws IOException {"
"SortedProperties.java:115"$1$"		super.storeToXML(out, (this.omitComments ? null : comments));"
"SortedProperties.java:116"$1$"	}"
"SortedProperties.java:117"$0$""
"SortedProperties.java:118"$0$"	@Override"
"SortedProperties.java:119"$1$"	public void storeToXML(OutputStream out, @Nullable String comments, String encoding) throws IOException {"
"SortedProperties.java:120"$1$"		super.storeToXML(out, (this.omitComments ? null : comments), encoding);"
"SortedProperties.java:121"$1$"	}"
"SortedProperties.java:122"$0$""
"SortedProperties.java:123"$0$"	/**"
"SortedProperties.java:124"$1$"	 * Return a sorted enumeration of the keys in this {@link Properties} object."
"SortedProperties.java:125"$0$"	 * @see #keySet()"
"SortedProperties.java:126"$0$"	 */"
"SortedProperties.java:127"$0$"	@Override"
"SortedProperties.java:128"$1$"	public synchronized Enumeration<Object> keys() {"
"SortedProperties.java:129"$1$"		return Collections.enumeration(keySet());"
"SortedProperties.java:130"$1$"	}"
"SortedProperties.java:131"$0$""
"SortedProperties.java:132"$0$"	/**"
"SortedProperties.java:133"$1$"	 * Return a sorted set of the keys in this {@link Properties} object."
"SortedProperties.java:134"$0$"	 * <p>The keys will be converted to strings if necessary using"
"SortedProperties.java:135"$1$"	 * {@link String#valueOf(Object)} and sorted alphanumerically according to"
"SortedProperties.java:136"$0$"	 * the natural order of strings."
"SortedProperties.java:137"$0$"	 */"
"SortedProperties.java:138"$0$"	@Override"
"SortedProperties.java:139"$1$"	public Set<Object> keySet() {"
"SortedProperties.java:140"$1$"		Set<Object> sortedKeys = new TreeSet<>(keyComparator);"
"SortedProperties.java:141"$1$"		sortedKeys.addAll(super.keySet());"
"SortedProperties.java:142"$1$"		return Collections.synchronizedSet(sortedKeys);"
"SortedProperties.java:143"$1$"	}"
"SortedProperties.java:144"$0$""
"SortedProperties.java:145"$0$"	/**"
"SortedProperties.java:146"$1$"	 * Return a sorted set of the entries in this {@link Properties} object."
"SortedProperties.java:147"$0$"	 * <p>The entries will be sorted based on their keys, and the keys will be"
"SortedProperties.java:148"$1$"	 * converted to strings if necessary using {@link String#valueOf(Object)}"
"SortedProperties.java:149"$0$"	 * and compared alphanumerically according to the natural order of strings."
"SortedProperties.java:150"$0$"	 */"
"SortedProperties.java:151"$0$"	@Override"
"SortedProperties.java:152"$1$"	public Set<Entry<Object, Object>> entrySet() {"
"SortedProperties.java:153"$1$"		Set<Entry<Object, Object>> sortedEntries = new TreeSet<>(entryComparator);"
"SortedProperties.java:154"$1$"		sortedEntries.addAll(super.entrySet());"
"SortedProperties.java:155"$1$"		return Collections.synchronizedSet(sortedEntries);"
"SortedProperties.java:156"$1$"	}"
"SortedProperties.java:157"$0$""
"SortedProperties.java:158"$0$"}"
"StandardMethodMetadata.java:1"$0$"/*"
"StandardMethodMetadata.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"StandardMethodMetadata.java:3"$0$" *"
"StandardMethodMetadata.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StandardMethodMetadata.java:5"$0$" * you may not use this file except in compliance with the License."
"StandardMethodMetadata.java:6"$0$" * You may obtain a copy of the License at"
"StandardMethodMetadata.java:7"$0$" *"
"StandardMethodMetadata.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StandardMethodMetadata.java:9"$0$" *"
"StandardMethodMetadata.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StandardMethodMetadata.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StandardMethodMetadata.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StandardMethodMetadata.java:13"$0$" * See the License for the specific language governing permissions and"
"StandardMethodMetadata.java:14"$0$" * limitations under the License."
"StandardMethodMetadata.java:15"$0$" */"
"StandardMethodMetadata.java:16"$0$""
"StandardMethodMetadata.java:17"$0$"package org.springframework.core.type;"
"StandardMethodMetadata.java:18"$0$""
"StandardMethodMetadata.java:19"$0$"import java.lang.reflect.Method;"
"StandardMethodMetadata.java:20"$0$"import java.lang.reflect.Modifier;"
"StandardMethodMetadata.java:21"$0$"import java.util.Map;"
"StandardMethodMetadata.java:22"$0$""
"StandardMethodMetadata.java:23"$0$"import org.springframework.core.annotation.AnnotatedElementUtils;"
"StandardMethodMetadata.java:24"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"StandardMethodMetadata.java:25"$0$"import org.springframework.core.annotation.MergedAnnotations.SearchStrategy;"
"StandardMethodMetadata.java:26"$0$"import org.springframework.core.annotation.RepeatableContainers;"
"StandardMethodMetadata.java:27"$0$"import org.springframework.lang.Nullable;"
"StandardMethodMetadata.java:28"$0$"import org.springframework.util.Assert;"
"StandardMethodMetadata.java:29"$0$"import org.springframework.util.MultiValueMap;"
"StandardMethodMetadata.java:30"$0$""
"StandardMethodMetadata.java:31"$0$"/**"
"StandardMethodMetadata.java:32"$1$" * {@link MethodMetadata} implementation that uses standard reflection"
"StandardMethodMetadata.java:33"$1$" * to introspect a given {@code Method}."
"StandardMethodMetadata.java:34"$0$" *"
"StandardMethodMetadata.java:35"$0$" * @author Juergen Hoeller"
"StandardMethodMetadata.java:36"$0$" * @author Mark Pollack"
"StandardMethodMetadata.java:37"$0$" * @author Chris Beams"
"StandardMethodMetadata.java:38"$0$" * @author Phillip Webb"
"StandardMethodMetadata.java:39"$0$" * @since 3.0"
"StandardMethodMetadata.java:40"$0$" */"
"StandardMethodMetadata.java:41"$1$"public class StandardMethodMetadata implements MethodMetadata {"
"StandardMethodMetadata.java:42"$1$""
"StandardMethodMetadata.java:43"$1$"	private final Method introspectedMethod;"
"StandardMethodMetadata.java:44"$1$""
"StandardMethodMetadata.java:45"$1$"	private final boolean nestedAnnotationsAsMap;"
"StandardMethodMetadata.java:46"$1$""
"StandardMethodMetadata.java:47"$1$"	private final MergedAnnotations mergedAnnotations;"
"StandardMethodMetadata.java:48"$1$""
"StandardMethodMetadata.java:49"$1$""
"StandardMethodMetadata.java:50"$1$"	/**"
"StandardMethodMetadata.java:51"$1$"	 * Create a new StandardMethodMetadata wrapper for the given Method."
"StandardMethodMetadata.java:52"$1$"	 * @param introspectedMethod the Method to introspect"
"StandardMethodMetadata.java:53"$1$"	 * @deprecated since 5.2 in favor of obtaining instances via {@link AnnotationMetadata}"
"StandardMethodMetadata.java:54"$1$"	 */"
"StandardMethodMetadata.java:55"$1$"	@Deprecated"
"StandardMethodMetadata.java:56"$1$"	public StandardMethodMetadata(Method introspectedMethod) {"
"StandardMethodMetadata.java:57"$1$"		this(introspectedMethod, false);"
"StandardMethodMetadata.java:58"$1$"	}"
"StandardMethodMetadata.java:59"$0$""
"StandardMethodMetadata.java:60"$0$"	/**"
"StandardMethodMetadata.java:61"$0$"	 * Create a new StandardMethodMetadata wrapper for the given Method,"
"StandardMethodMetadata.java:62"$0$"	 * providing the option to return any nested annotations or annotation arrays in the"
"StandardMethodMetadata.java:63"$1$"	 * form of {@link org.springframework.core.annotation.AnnotationAttributes} instead"
"StandardMethodMetadata.java:64"$1$"	 * of actual {@link java.lang.annotation.Annotation} instances."
"StandardMethodMetadata.java:65"$0$"	 * @param introspectedMethod the Method to introspect"
"StandardMethodMetadata.java:66"$0$"	 * @param nestedAnnotationsAsMap return nested annotations and annotation arrays as"
"StandardMethodMetadata.java:67"$1$"	 * {@link org.springframework.core.annotation.AnnotationAttributes} for compatibility"
"StandardMethodMetadata.java:68"$1$"	 * with ASM-based {@link AnnotationMetadata} implementations"
"StandardMethodMetadata.java:69"$0$"	 * @since 3.1.1"
"StandardMethodMetadata.java:70"$1$"	 * @deprecated since 5.2 in favor of obtaining instances via {@link AnnotationMetadata}"
"StandardMethodMetadata.java:71"$0$"	 */"
"StandardMethodMetadata.java:72"$0$"	@Deprecated"
"StandardMethodMetadata.java:73"$1$"	public StandardMethodMetadata(Method introspectedMethod, boolean nestedAnnotationsAsMap) {"
"StandardMethodMetadata.java:74"$1$"		Assert.notNull(introspectedMethod, ""Method must not be null"");"
"StandardMethodMetadata.java:75"$1$"		this.introspectedMethod = introspectedMethod;"
"StandardMethodMetadata.java:76"$1$"		this.nestedAnnotationsAsMap = nestedAnnotationsAsMap;"
"StandardMethodMetadata.java:77"$1$"		this.mergedAnnotations = MergedAnnotations.from("
"StandardMethodMetadata.java:78"$1$"				introspectedMethod, SearchStrategy.DIRECT, RepeatableContainers.none());"
"StandardMethodMetadata.java:79"$1$"	}"
"StandardMethodMetadata.java:80"$0$""
"StandardMethodMetadata.java:81"$0$""
"StandardMethodMetadata.java:82"$0$"	@Override"
"StandardMethodMetadata.java:83"$1$"	public MergedAnnotations getAnnotations() {"
"StandardMethodMetadata.java:84"$1$"		return this.mergedAnnotations;"
"StandardMethodMetadata.java:85"$1$"	}"
"StandardMethodMetadata.java:86"$0$""
"StandardMethodMetadata.java:87"$0$"	/**"
"StandardMethodMetadata.java:88"$0$"	 * Return the underlying Method."
"StandardMethodMetadata.java:89"$0$"	 */"
"StandardMethodMetadata.java:90"$1$"	public final Method getIntrospectedMethod() {"
"StandardMethodMetadata.java:91"$1$"		return this.introspectedMethod;"
"StandardMethodMetadata.java:92"$1$"	}"
"StandardMethodMetadata.java:93"$0$""
"StandardMethodMetadata.java:94"$0$"	@Override"
"StandardMethodMetadata.java:95"$1$"	public String getMethodName() {"
"StandardMethodMetadata.java:96"$1$"		return this.introspectedMethod.getName();"
"StandardMethodMetadata.java:97"$1$"	}"
"StandardMethodMetadata.java:98"$0$""
"StandardMethodMetadata.java:99"$0$"	@Override"
"StandardMethodMetadata.java:100"$1$"	public String getDeclaringClassName() {"
"StandardMethodMetadata.java:101"$1$"		return this.introspectedMethod.getDeclaringClass().getName();"
"StandardMethodMetadata.java:102"$1$"	}"
"StandardMethodMetadata.java:103"$0$""
"StandardMethodMetadata.java:104"$0$"	@Override"
"StandardMethodMetadata.java:105"$1$"	public String getReturnTypeName() {"
"StandardMethodMetadata.java:106"$1$"		return this.introspectedMethod.getReturnType().getName();"
"StandardMethodMetadata.java:107"$1$"	}"
"StandardMethodMetadata.java:108"$0$""
"StandardMethodMetadata.java:109"$0$"	@Override"
"StandardMethodMetadata.java:110"$1$"	public boolean isAbstract() {"
"StandardMethodMetadata.java:111"$1$"		return Modifier.isAbstract(this.introspectedMethod.getModifiers());"
"StandardMethodMetadata.java:112"$1$"	}"
"StandardMethodMetadata.java:113"$0$""
"StandardMethodMetadata.java:114"$0$"	@Override"
"StandardMethodMetadata.java:115"$1$"	public boolean isStatic() {"
"StandardMethodMetadata.java:116"$1$"		return Modifier.isStatic(this.introspectedMethod.getModifiers());"
"StandardMethodMetadata.java:117"$1$"	}"
"StandardMethodMetadata.java:118"$0$""
"StandardMethodMetadata.java:119"$0$"	@Override"
"StandardMethodMetadata.java:120"$1$"	public boolean isFinal() {"
"StandardMethodMetadata.java:121"$1$"		return Modifier.isFinal(this.introspectedMethod.getModifiers());"
"StandardMethodMetadata.java:122"$1$"	}"
"StandardMethodMetadata.java:123"$0$""
"StandardMethodMetadata.java:124"$0$"	@Override"
"StandardMethodMetadata.java:125"$1$"	public boolean isOverridable() {"
"StandardMethodMetadata.java:126"$1$"		return !isStatic() && !isFinal() && !isPrivate();"
"StandardMethodMetadata.java:127"$1$"	}"
"StandardMethodMetadata.java:128"$0$""
"StandardMethodMetadata.java:129"$1$"	private boolean isPrivate() {"
"StandardMethodMetadata.java:130"$1$"		return Modifier.isPrivate(this.introspectedMethod.getModifiers());"
"StandardMethodMetadata.java:131"$1$"	}"
"StandardMethodMetadata.java:132"$0$""
"StandardMethodMetadata.java:133"$0$"	@Override"
"StandardMethodMetadata.java:134"$0$"	@Nullable"
"StandardMethodMetadata.java:135"$1$"	public Map<String, Object> getAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"StandardMethodMetadata.java:136"$1$"		if (this.nestedAnnotationsAsMap) {"
"StandardMethodMetadata.java:137"$1$"			return MethodMetadata.super.getAnnotationAttributes(annotationName, classValuesAsString);"
"StandardMethodMetadata.java:138"$1$"		}"
"StandardMethodMetadata.java:139"$0$"		return AnnotatedElementUtils.getMergedAnnotationAttributes(this.introspectedMethod,"
"StandardMethodMetadata.java:140"$0$"				annotationName, classValuesAsString, false);"
"StandardMethodMetadata.java:141"$0$"	}"
"StandardMethodMetadata.java:142"$0$""
"StandardMethodMetadata.java:143"$0$"	@Override"
"StandardMethodMetadata.java:144"$0$"	@Nullable"
"StandardMethodMetadata.java:145"$1$"	public MultiValueMap<String, Object> getAllAnnotationAttributes(String annotationName, boolean classValuesAsString) {"
"StandardMethodMetadata.java:146"$1$"		if (this.nestedAnnotationsAsMap) {"
"StandardMethodMetadata.java:147"$1$"			return MethodMetadata.super.getAllAnnotationAttributes(annotationName, classValuesAsString);"
"StandardMethodMetadata.java:148"$1$"		}"
"StandardMethodMetadata.java:149"$0$"		return AnnotatedElementUtils.getAllAnnotationAttributes(this.introspectedMethod,"
"StandardMethodMetadata.java:150"$0$"				annotationName, classValuesAsString, false);"
"StandardMethodMetadata.java:151"$0$"	}"
"StandardMethodMetadata.java:152"$0$""
"StandardMethodMetadata.java:153"$0$"}"
"SimpleMethodMetadata.java:1"$0$"/*"
"SimpleMethodMetadata.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SimpleMethodMetadata.java:3"$0$" *"
"SimpleMethodMetadata.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SimpleMethodMetadata.java:5"$0$" * you may not use this file except in compliance with the License."
"SimpleMethodMetadata.java:6"$0$" * You may obtain a copy of the License at"
"SimpleMethodMetadata.java:7"$0$" *"
"SimpleMethodMetadata.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SimpleMethodMetadata.java:9"$0$" *"
"SimpleMethodMetadata.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SimpleMethodMetadata.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SimpleMethodMetadata.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SimpleMethodMetadata.java:13"$0$" * See the License for the specific language governing permissions and"
"SimpleMethodMetadata.java:14"$0$" * limitations under the License."
"SimpleMethodMetadata.java:15"$0$" */"
"SimpleMethodMetadata.java:16"$0$""
"SimpleMethodMetadata.java:17"$0$"package org.springframework.core.type.classreading;"
"SimpleMethodMetadata.java:18"$0$""
"SimpleMethodMetadata.java:19"$0$"import org.springframework.asm.Opcodes;"
"SimpleMethodMetadata.java:20"$0$"import org.springframework.core.annotation.MergedAnnotations;"
"SimpleMethodMetadata.java:21"$0$"import org.springframework.core.type.MethodMetadata;"
"SimpleMethodMetadata.java:22"$0$""
"SimpleMethodMetadata.java:23"$0$"/**"
"SimpleMethodMetadata.java:24"$1$" * {@link MethodMetadata} created from a"
"SimpleMethodMetadata.java:25"$1$" * {@link SimpleMethodMetadataReadingVisitor}."
"SimpleMethodMetadata.java:26"$0$" *"
"SimpleMethodMetadata.java:27"$0$" * @author Phillip Webb"
"SimpleMethodMetadata.java:28"$0$" * @since 5.2"
"SimpleMethodMetadata.java:29"$0$" */"
"SimpleMethodMetadata.java:30"$1$"final class SimpleMethodMetadata implements MethodMetadata {"
"SimpleMethodMetadata.java:31"$1$""
"SimpleMethodMetadata.java:32"$1$"	private final String methodName;"
"SimpleMethodMetadata.java:33"$1$""
"SimpleMethodMetadata.java:34"$1$"	private final int access;"
"SimpleMethodMetadata.java:35"$1$""
"SimpleMethodMetadata.java:36"$1$"	private final String declaringClassName;"
"SimpleMethodMetadata.java:37"$1$""
"SimpleMethodMetadata.java:38"$1$"	private final String returnTypeName;"
"SimpleMethodMetadata.java:39"$1$""
"SimpleMethodMetadata.java:40"$1$"	private final MergedAnnotations annotations;"
"SimpleMethodMetadata.java:41"$1$""
"SimpleMethodMetadata.java:42"$1$""
"SimpleMethodMetadata.java:43"$1$"	public SimpleMethodMetadata(String methodName, int access, String declaringClassName,"
"SimpleMethodMetadata.java:44"$1$"			String returnTypeName, MergedAnnotations annotations) {"
"SimpleMethodMetadata.java:45"$1$""
"SimpleMethodMetadata.java:46"$1$"		this.methodName = methodName;"
"SimpleMethodMetadata.java:47"$1$"		this.access = access;"
"SimpleMethodMetadata.java:48"$1$"		this.declaringClassName = declaringClassName;"
"SimpleMethodMetadata.java:49"$1$"		this.returnTypeName = returnTypeName;"
"SimpleMethodMetadata.java:50"$1$"		this.annotations = annotations;"
"SimpleMethodMetadata.java:51"$1$"	}"
"SimpleMethodMetadata.java:52"$0$""
"SimpleMethodMetadata.java:53"$0$""
"SimpleMethodMetadata.java:54"$0$"	@Override"
"SimpleMethodMetadata.java:55"$1$"	public String getMethodName() {"
"SimpleMethodMetadata.java:56"$1$"		return this.methodName;"
"SimpleMethodMetadata.java:57"$1$"	}"
"SimpleMethodMetadata.java:58"$0$""
"SimpleMethodMetadata.java:59"$0$"	@Override"
"SimpleMethodMetadata.java:60"$1$"	public String getDeclaringClassName() {"
"SimpleMethodMetadata.java:61"$1$"		return this.declaringClassName;"
"SimpleMethodMetadata.java:62"$1$"	}"
"SimpleMethodMetadata.java:63"$0$""
"SimpleMethodMetadata.java:64"$0$"	@Override"
"SimpleMethodMetadata.java:65"$1$"	public String getReturnTypeName() {"
"SimpleMethodMetadata.java:66"$1$"		return this.returnTypeName;"
"SimpleMethodMetadata.java:67"$1$"	}"
"SimpleMethodMetadata.java:68"$0$""
"SimpleMethodMetadata.java:69"$0$"	@Override"
"SimpleMethodMetadata.java:70"$1$"	public boolean isAbstract() {"
"SimpleMethodMetadata.java:71"$1$"		return (this.access & Opcodes.ACC_ABSTRACT) != 0;"
"SimpleMethodMetadata.java:72"$1$"	}"
"SimpleMethodMetadata.java:73"$0$""
"SimpleMethodMetadata.java:74"$0$"	@Override"
"SimpleMethodMetadata.java:75"$1$"	public boolean isStatic() {"
"SimpleMethodMetadata.java:76"$1$"		return (this.access & Opcodes.ACC_STATIC) != 0;"
"SimpleMethodMetadata.java:77"$1$"	}"
"SimpleMethodMetadata.java:78"$0$""
"SimpleMethodMetadata.java:79"$0$"	@Override"
"SimpleMethodMetadata.java:80"$1$"	public boolean isFinal() {"
"SimpleMethodMetadata.java:81"$1$"		return (this.access & Opcodes.ACC_FINAL) != 0;"
"SimpleMethodMetadata.java:82"$1$"	}"
"SimpleMethodMetadata.java:83"$0$""
"SimpleMethodMetadata.java:84"$0$"	@Override"
"SimpleMethodMetadata.java:85"$1$"	public boolean isOverridable() {"
"SimpleMethodMetadata.java:86"$1$"		return !isStatic() && !isFinal() && !isPrivate();"
"SimpleMethodMetadata.java:87"$1$"	}"
"SimpleMethodMetadata.java:88"$0$""
"SimpleMethodMetadata.java:89"$1$"	public boolean isPrivate() {"
"SimpleMethodMetadata.java:90"$1$"		return (this.access & Opcodes.ACC_PRIVATE) != 0;"
"SimpleMethodMetadata.java:91"$1$"	}"
"SimpleMethodMetadata.java:92"$0$""
"SimpleMethodMetadata.java:93"$0$"	@Override"
"SimpleMethodMetadata.java:94"$1$"	public MergedAnnotations getAnnotations() {"
"SimpleMethodMetadata.java:95"$1$"		return this.annotations;"
"SimpleMethodMetadata.java:96"$1$"	}"
"SimpleMethodMetadata.java:97"$0$""
"SimpleMethodMetadata.java:98"$0$"}"
"NullSafeComparator.java:1"$0$"/*"
"NullSafeComparator.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"NullSafeComparator.java:3"$0$" *"
"NullSafeComparator.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"NullSafeComparator.java:5"$0$" * you may not use this file except in compliance with the License."
"NullSafeComparator.java:6"$0$" * You may obtain a copy of the License at"
"NullSafeComparator.java:7"$0$" *"
"NullSafeComparator.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"NullSafeComparator.java:9"$0$" *"
"NullSafeComparator.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"NullSafeComparator.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"NullSafeComparator.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"NullSafeComparator.java:13"$0$" * See the License for the specific language governing permissions and"
"NullSafeComparator.java:14"$0$" * limitations under the License."
"NullSafeComparator.java:15"$0$" */"
"NullSafeComparator.java:16"$0$""
"NullSafeComparator.java:17"$0$"package org.springframework.util.comparator;"
"NullSafeComparator.java:18"$0$""
"NullSafeComparator.java:19"$0$"import java.util.Comparator;"
"NullSafeComparator.java:20"$0$""
"NullSafeComparator.java:21"$0$"import org.springframework.lang.Nullable;"
"NullSafeComparator.java:22"$0$"import org.springframework.util.Assert;"
"NullSafeComparator.java:23"$0$""
"NullSafeComparator.java:24"$0$"/**"
"NullSafeComparator.java:25"$0$" * A Comparator that will safely compare nulls to be lower or higher than"
"NullSafeComparator.java:26"$0$" * other objects. Can decorate a given Comparator or work on Comparables."
"NullSafeComparator.java:27"$0$" *"
"NullSafeComparator.java:28"$0$" * @author Keith Donald"
"NullSafeComparator.java:29"$0$" * @author Juergen Hoeller"
"NullSafeComparator.java:30"$0$" * @since 1.2.2"
"NullSafeComparator.java:31"$0$" * @param <T> the type of objects that may be compared by this comparator"
"NullSafeComparator.java:32"$0$" * @see Comparable"
"NullSafeComparator.java:33"$0$" */"
"NullSafeComparator.java:34"$1$"public class NullSafeComparator<T> implements Comparator<T> {"
"NullSafeComparator.java:35"$1$""
"NullSafeComparator.java:36"$1$"	/**"
"NullSafeComparator.java:37"$1$"	 * A shared default instance of this comparator, treating nulls lower"
"NullSafeComparator.java:38"$1$"	 * than non-null objects."
"NullSafeComparator.java:39"$1$"	 * @see Comparators#nullsLow()"
"NullSafeComparator.java:40"$1$"	 */"
"NullSafeComparator.java:41"$1$"	@SuppressWarnings(""rawtypes"")"
"NullSafeComparator.java:42"$1$"	public static final NullSafeComparator NULLS_LOW = new NullSafeComparator<>(true);"
"NullSafeComparator.java:43"$1$""
"NullSafeComparator.java:44"$1$"	/**"
"NullSafeComparator.java:45"$1$"	 * A shared default instance of this comparator, treating nulls higher"
"NullSafeComparator.java:46"$1$"	 * than non-null objects."
"NullSafeComparator.java:47"$1$"	 * @see Comparators#nullsHigh()"
"NullSafeComparator.java:48"$1$"	 */"
"NullSafeComparator.java:49"$1$"	@SuppressWarnings(""rawtypes"")"
"NullSafeComparator.java:50"$1$"	public static final NullSafeComparator NULLS_HIGH = new NullSafeComparator<>(false);"
"NullSafeComparator.java:51"$1$""
"NullSafeComparator.java:52"$1$""
"NullSafeComparator.java:53"$1$"	private final Comparator<T> nonNullComparator;"
"NullSafeComparator.java:54"$1$""
"NullSafeComparator.java:55"$1$"	private final boolean nullsLow;"
"NullSafeComparator.java:56"$1$""
"NullSafeComparator.java:57"$1$""
"NullSafeComparator.java:58"$1$"	/**"
"NullSafeComparator.java:59"$1$"	 * Create a NullSafeComparator that sorts {@code null} based on"
"NullSafeComparator.java:60"$1$"	 * the provided flag, working on Comparables."
"NullSafeComparator.java:61"$1$"	 * <p>When comparing two non-null objects, their Comparable implementation"
"NullSafeComparator.java:62"$1$"	 * will be used: this means that non-null elements (that this Comparator"
"NullSafeComparator.java:63"$1$"	 * will be applied to) need to implement Comparable."
"NullSafeComparator.java:64"$1$"	 * <p>As a convenience, you can use the default shared instances:"
"NullSafeComparator.java:65"$1$"	 * {@code NullSafeComparator.NULLS_LOW} and"
"NullSafeComparator.java:66"$1$"	 * {@code NullSafeComparator.NULLS_HIGH}."
"NullSafeComparator.java:67"$1$"	 * @param nullsLow whether to treat nulls lower or higher than non-null objects"
"NullSafeComparator.java:68"$1$"	 * @see Comparable"
"NullSafeComparator.java:69"$1$"	 * @see #NULLS_LOW"
"NullSafeComparator.java:70"$1$"	 * @see #NULLS_HIGH"
"NullSafeComparator.java:71"$1$"	 */"
"NullSafeComparator.java:72"$1$"	@SuppressWarnings(""unchecked"")"
"NullSafeComparator.java:73"$1$"	private NullSafeComparator(boolean nullsLow) {"
"NullSafeComparator.java:74"$1$"		this.nonNullComparator = ComparableComparator.INSTANCE;"
"NullSafeComparator.java:75"$1$"		this.nullsLow = nullsLow;"
"NullSafeComparator.java:76"$1$"	}"
"NullSafeComparator.java:77"$0$""
"NullSafeComparator.java:78"$0$"	/**"
"NullSafeComparator.java:79"$1$"	 * Create a NullSafeComparator that sorts {@code null} based on the"
"NullSafeComparator.java:80"$0$"	 * provided flag, decorating the given Comparator."
"NullSafeComparator.java:81"$0$"	 * <p>When comparing two non-null objects, the specified Comparator will be used."
"NullSafeComparator.java:82"$0$"	 * The given underlying Comparator must be able to handle the elements that this"
"NullSafeComparator.java:83"$0$"	 * Comparator will be applied to."
"NullSafeComparator.java:84"$0$"	 * @param comparator the comparator to use when comparing two non-null objects"
"NullSafeComparator.java:85"$0$"	 * @param nullsLow whether to treat nulls lower or higher than non-null objects"
"NullSafeComparator.java:86"$0$"	 */"
"NullSafeComparator.java:87"$1$"	public NullSafeComparator(Comparator<T> comparator, boolean nullsLow) {"
"NullSafeComparator.java:88"$1$"		Assert.notNull(comparator, ""Non-null Comparator is required"");"
"NullSafeComparator.java:89"$1$"		this.nonNullComparator = comparator;"
"NullSafeComparator.java:90"$1$"		this.nullsLow = nullsLow;"
"NullSafeComparator.java:91"$1$"	}"
"NullSafeComparator.java:92"$0$""
"NullSafeComparator.java:93"$0$""
"NullSafeComparator.java:94"$0$"	@Override"
"NullSafeComparator.java:95"$1$"	public int compare(@Nullable T o1, @Nullable T o2) {"
"NullSafeComparator.java:96"$1$"		if (o1 == o2) {"
"NullSafeComparator.java:97"$1$"			return 0;"
"NullSafeComparator.java:98"$1$"		}"
"NullSafeComparator.java:99"$1$"		if (o1 == null) {"
"NullSafeComparator.java:100"$1$"			return (this.nullsLow ? -1 : 1);"
"NullSafeComparator.java:101"$1$"		}"
"NullSafeComparator.java:102"$1$"		if (o2 == null) {"
"NullSafeComparator.java:103"$1$"			return (this.nullsLow ? 1 : -1);"
"NullSafeComparator.java:104"$1$"		}"
"NullSafeComparator.java:105"$0$"		return this.nonNullComparator.compare(o1, o2);"
"NullSafeComparator.java:106"$0$"	}"
"NullSafeComparator.java:107"$0$""
"NullSafeComparator.java:108"$0$""
"NullSafeComparator.java:109"$0$"	@Override"
"NullSafeComparator.java:110"$0$"	@SuppressWarnings(""unchecked"")"
"NullSafeComparator.java:111"$1$"	public boolean equals(@Nullable Object other) {"
"NullSafeComparator.java:112"$1$"		if (this == other) {"
"NullSafeComparator.java:113"$1$"			return true;"
"NullSafeComparator.java:114"$1$"		}"
"NullSafeComparator.java:115"$1$"		if (!(other instanceof NullSafeComparator)) {"
"NullSafeComparator.java:116"$1$"			return false;"
"NullSafeComparator.java:117"$1$"		}"
"NullSafeComparator.java:118"$0$"		NullSafeComparator<T> otherComp = (NullSafeComparator<T>) other;"
"NullSafeComparator.java:119"$0$"		return (this.nonNullComparator.equals(otherComp.nonNullComparator) && this.nullsLow == otherComp.nullsLow);"
"NullSafeComparator.java:120"$0$"	}"
"NullSafeComparator.java:121"$0$""
"NullSafeComparator.java:122"$0$"	@Override"
"NullSafeComparator.java:123"$1$"	public int hashCode() {"
"NullSafeComparator.java:124"$1$"		return this.nonNullComparator.hashCode() * (this.nullsLow ? -1 : 1);"
"NullSafeComparator.java:125"$1$"	}"
"NullSafeComparator.java:126"$0$""
"NullSafeComparator.java:127"$0$"	@Override"
"NullSafeComparator.java:128"$1$"	public String toString() {"
"NullSafeComparator.java:129"$1$"		return ""NullSafeComparator: non-null comparator ["" + this.nonNullComparator + ""]; "" +"
"NullSafeComparator.java:130"$1$"				(this.nullsLow ? ""nulls low"" : ""nulls high"");"
"NullSafeComparator.java:131"$1$"	}"
"NullSafeComparator.java:132"$0$""
"NullSafeComparator.java:133"$0$"}"
"PropertyPlaceholderHelper.java:1"$0$"/*"
"PropertyPlaceholderHelper.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"PropertyPlaceholderHelper.java:3"$0$" *"
"PropertyPlaceholderHelper.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"PropertyPlaceholderHelper.java:5"$0$" * you may not use this file except in compliance with the License."
"PropertyPlaceholderHelper.java:6"$0$" * You may obtain a copy of the License at"
"PropertyPlaceholderHelper.java:7"$0$" *"
"PropertyPlaceholderHelper.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"PropertyPlaceholderHelper.java:9"$0$" *"
"PropertyPlaceholderHelper.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"PropertyPlaceholderHelper.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"PropertyPlaceholderHelper.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"PropertyPlaceholderHelper.java:13"$0$" * See the License for the specific language governing permissions and"
"PropertyPlaceholderHelper.java:14"$0$" * limitations under the License."
"PropertyPlaceholderHelper.java:15"$0$" */"
"PropertyPlaceholderHelper.java:16"$0$""
"PropertyPlaceholderHelper.java:17"$0$"package org.springframework.util;"
"PropertyPlaceholderHelper.java:18"$0$""
"PropertyPlaceholderHelper.java:19"$0$"import java.util.HashMap;"
"PropertyPlaceholderHelper.java:20"$0$"import java.util.HashSet;"
"PropertyPlaceholderHelper.java:21"$0$"import java.util.Map;"
"PropertyPlaceholderHelper.java:22"$0$"import java.util.Properties;"
"PropertyPlaceholderHelper.java:23"$0$"import java.util.Set;"
"PropertyPlaceholderHelper.java:24"$0$""
"PropertyPlaceholderHelper.java:25"$0$"import org.apache.commons.logging.Log;"
"PropertyPlaceholderHelper.java:26"$0$"import org.apache.commons.logging.LogFactory;"
"PropertyPlaceholderHelper.java:27"$0$""
"PropertyPlaceholderHelper.java:28"$0$"import org.springframework.lang.Nullable;"
"PropertyPlaceholderHelper.java:29"$0$""
"PropertyPlaceholderHelper.java:30"$0$"/**"
"PropertyPlaceholderHelper.java:31"$0$" * Utility class for working with Strings that have placeholder values in them. A placeholder takes the form"
"PropertyPlaceholderHelper.java:32"$1$" * {@code ${name}}. Using {@code PropertyPlaceholderHelper} these placeholders can be substituted for"
"PropertyPlaceholderHelper.java:33"$1$" * user-supplied values. <p> Values for substitution can be supplied using a {@link Properties} instance or"
"PropertyPlaceholderHelper.java:34"$1$" * using a {@link PlaceholderResolver}."
"PropertyPlaceholderHelper.java:35"$0$" *"
"PropertyPlaceholderHelper.java:36"$0$" * @author Juergen Hoeller"
"PropertyPlaceholderHelper.java:37"$0$" * @author Rob Harrop"
"PropertyPlaceholderHelper.java:38"$0$" * @since 3.0"
"PropertyPlaceholderHelper.java:39"$0$" */"
"PropertyPlaceholderHelper.java:40"$1$"public class PropertyPlaceholderHelper {"
"PropertyPlaceholderHelper.java:41"$1$""
"PropertyPlaceholderHelper.java:42"$1$"	private static final Log logger = LogFactory.getLog(PropertyPlaceholderHelper.class);"
"PropertyPlaceholderHelper.java:43"$1$""
"PropertyPlaceholderHelper.java:44"$1$"	private static final Map<String, String> wellKnownSimplePrefixes = new HashMap<>(4);"
"PropertyPlaceholderHelper.java:45"$1$""
"PropertyPlaceholderHelper.java:46"$1$"	static {"
"PropertyPlaceholderHelper.java:47"$1$"		wellKnownSimplePrefixes.put(""}"", ""{"");"
"PropertyPlaceholderHelper.java:48"$1$"		wellKnownSimplePrefixes.put(""]"", ""["");"
"PropertyPlaceholderHelper.java:49"$1$"		wellKnownSimplePrefixes.put("")"", ""("");"
"PropertyPlaceholderHelper.java:50"$1$"	}"
"PropertyPlaceholderHelper.java:51"$0$""
"PropertyPlaceholderHelper.java:52"$0$""
"PropertyPlaceholderHelper.java:53"$0$"	private final String placeholderPrefix;"
"PropertyPlaceholderHelper.java:54"$0$""
"PropertyPlaceholderHelper.java:55"$0$"	private final String placeholderSuffix;"
"PropertyPlaceholderHelper.java:56"$0$""
"PropertyPlaceholderHelper.java:57"$0$"	private final String simplePrefix;"
"PropertyPlaceholderHelper.java:58"$0$""
"PropertyPlaceholderHelper.java:59"$0$"	@Nullable"
"PropertyPlaceholderHelper.java:60"$0$"	private final String valueSeparator;"
"PropertyPlaceholderHelper.java:61"$0$""
"PropertyPlaceholderHelper.java:62"$0$"	private final boolean ignoreUnresolvablePlaceholders;"
"PropertyPlaceholderHelper.java:63"$0$""
"PropertyPlaceholderHelper.java:64"$0$""
"PropertyPlaceholderHelper.java:65"$0$"	/**"
"PropertyPlaceholderHelper.java:66"$1$"	 * Creates a new {@code PropertyPlaceholderHelper} that uses the supplied prefix and suffix."
"PropertyPlaceholderHelper.java:67"$0$"	 * Unresolvable placeholders are ignored."
"PropertyPlaceholderHelper.java:68"$0$"	 * @param placeholderPrefix the prefix that denotes the start of a placeholder"
"PropertyPlaceholderHelper.java:69"$0$"	 * @param placeholderSuffix the suffix that denotes the end of a placeholder"
"PropertyPlaceholderHelper.java:70"$0$"	 */"
"PropertyPlaceholderHelper.java:71"$1$"	public PropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix) {"
"PropertyPlaceholderHelper.java:72"$1$"		this(placeholderPrefix, placeholderSuffix, null, true);"
"PropertyPlaceholderHelper.java:73"$1$"	}"
"PropertyPlaceholderHelper.java:74"$0$""
"PropertyPlaceholderHelper.java:75"$0$"	/**"
"PropertyPlaceholderHelper.java:76"$1$"	 * Creates a new {@code PropertyPlaceholderHelper} that uses the supplied prefix and suffix."
"PropertyPlaceholderHelper.java:77"$0$"	 * @param placeholderPrefix the prefix that denotes the start of a placeholder"
"PropertyPlaceholderHelper.java:78"$0$"	 * @param placeholderSuffix the suffix that denotes the end of a placeholder"
"PropertyPlaceholderHelper.java:79"$0$"	 * @param valueSeparator the separating character between the placeholder variable"
"PropertyPlaceholderHelper.java:80"$0$"	 * and the associated default value, if any"
"PropertyPlaceholderHelper.java:81"$0$"	 * @param ignoreUnresolvablePlaceholders indicates whether unresolvable placeholders should"
"PropertyPlaceholderHelper.java:82"$1$"	 * be ignored ({@code true}) or cause an exception ({@code false})"
"PropertyPlaceholderHelper.java:83"$0$"	 */"
"PropertyPlaceholderHelper.java:84"$0$"	public PropertyPlaceholderHelper(String placeholderPrefix, String placeholderSuffix,"
"PropertyPlaceholderHelper.java:85"$1$"			@Nullable String valueSeparator, boolean ignoreUnresolvablePlaceholders) {"
"PropertyPlaceholderHelper.java:86"$1$""
"PropertyPlaceholderHelper.java:87"$1$"		Assert.notNull(placeholderPrefix, ""'placeholderPrefix' must not be null"");"
"PropertyPlaceholderHelper.java:88"$1$"		Assert.notNull(placeholderSuffix, ""'placeholderSuffix' must not be null"");"
"PropertyPlaceholderHelper.java:89"$1$"		this.placeholderPrefix = placeholderPrefix;"
"PropertyPlaceholderHelper.java:90"$1$"		this.placeholderSuffix = placeholderSuffix;"
"PropertyPlaceholderHelper.java:91"$1$"		String simplePrefixForSuffix = wellKnownSimplePrefixes.get(this.placeholderSuffix);"
"PropertyPlaceholderHelper.java:92"$1$"		if (simplePrefixForSuffix != null && this.placeholderPrefix.endsWith(simplePrefixForSuffix)) {"
"PropertyPlaceholderHelper.java:93"$1$"			this.simplePrefix = simplePrefixForSuffix;"
"PropertyPlaceholderHelper.java:94"$1$"		}"
"PropertyPlaceholderHelper.java:95"$1$"		else {"
"PropertyPlaceholderHelper.java:96"$1$"			this.simplePrefix = this.placeholderPrefix;"
"PropertyPlaceholderHelper.java:97"$1$"		}"
"PropertyPlaceholderHelper.java:98"$0$"		this.valueSeparator = valueSeparator;"
"PropertyPlaceholderHelper.java:99"$0$"		this.ignoreUnresolvablePlaceholders = ignoreUnresolvablePlaceholders;"
"PropertyPlaceholderHelper.java:100"$0$"	}"
"PropertyPlaceholderHelper.java:101"$0$""
"PropertyPlaceholderHelper.java:102"$0$""
"PropertyPlaceholderHelper.java:103"$0$"	/**"
"PropertyPlaceholderHelper.java:104"$1$"	 * Replaces all placeholders of format {@code ${name}} with the corresponding"
"PropertyPlaceholderHelper.java:105"$1$"	 * property from the supplied {@link Properties}."
"PropertyPlaceholderHelper.java:106"$0$"	 * @param value the value containing the placeholders to be replaced"
"PropertyPlaceholderHelper.java:107"$1$"	 * @param properties the {@code Properties} to use for replacement"
"PropertyPlaceholderHelper.java:108"$0$"	 * @return the supplied value with placeholders replaced inline"
"PropertyPlaceholderHelper.java:109"$0$"	 */"
"PropertyPlaceholderHelper.java:110"$1$"	public String replacePlaceholders(String value, final Properties properties) {"
"PropertyPlaceholderHelper.java:111"$1$"		Assert.notNull(properties, ""'properties' must not be null"");"
"PropertyPlaceholderHelper.java:112"$1$"		return replacePlaceholders(value, properties::getProperty);"
"PropertyPlaceholderHelper.java:113"$1$"	}"
"PropertyPlaceholderHelper.java:114"$0$""
"PropertyPlaceholderHelper.java:115"$0$"	/**"
"PropertyPlaceholderHelper.java:116"$1$"	 * Replaces all placeholders of format {@code ${name}} with the value returned"
"PropertyPlaceholderHelper.java:117"$1$"	 * from the supplied {@link PlaceholderResolver}."
"PropertyPlaceholderHelper.java:118"$0$"	 * @param value the value containing the placeholders to be replaced"
"PropertyPlaceholderHelper.java:119"$1$"	 * @param placeholderResolver the {@code PlaceholderResolver} to use for replacement"
"PropertyPlaceholderHelper.java:120"$0$"	 * @return the supplied value with placeholders replaced inline"
"PropertyPlaceholderHelper.java:121"$0$"	 */"
"PropertyPlaceholderHelper.java:122"$1$"	public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) {"
"PropertyPlaceholderHelper.java:123"$1$"		Assert.notNull(value, ""'value' must not be null"");"
"PropertyPlaceholderHelper.java:124"$1$"		return parseStringValue(value, placeholderResolver, null);"
"PropertyPlaceholderHelper.java:125"$1$"	}"
"PropertyPlaceholderHelper.java:126"$0$""
"PropertyPlaceholderHelper.java:127"$0$"	protected String parseStringValue("
"PropertyPlaceholderHelper.java:128"$1$"			String value, PlaceholderResolver placeholderResolver, @Nullable Set<String> visitedPlaceholders) {"
"PropertyPlaceholderHelper.java:129"$1$""
"PropertyPlaceholderHelper.java:130"$1$"		int startIndex = value.indexOf(this.placeholderPrefix);"
"PropertyPlaceholderHelper.java:131"$1$"		if (startIndex == -1) {"
"PropertyPlaceholderHelper.java:132"$1$"			return value;"
"PropertyPlaceholderHelper.java:133"$1$"		}"
"PropertyPlaceholderHelper.java:134"$0$""
"PropertyPlaceholderHelper.java:135"$0$"		StringBuilder result = new StringBuilder(value);"
"PropertyPlaceholderHelper.java:136"$1$"		while (startIndex != -1) {"
"PropertyPlaceholderHelper.java:137"$1$"			int endIndex = findPlaceholderEndIndex(result, startIndex);"
"PropertyPlaceholderHelper.java:138"$1$"			if (endIndex != -1) {"
"PropertyPlaceholderHelper.java:139"$1$"				String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex);"
"PropertyPlaceholderHelper.java:140"$1$"				String originalPlaceholder = placeholder;"
"PropertyPlaceholderHelper.java:141"$1$"				if (visitedPlaceholders == null) {"
"PropertyPlaceholderHelper.java:142"$1$"					visitedPlaceholders = new HashSet<>(4);"
"PropertyPlaceholderHelper.java:143"$1$"				}"
"PropertyPlaceholderHelper.java:144"$1$"				if (!visitedPlaceholders.add(originalPlaceholder)) {"
"PropertyPlaceholderHelper.java:145"$1$"					throw new IllegalArgumentException("
"PropertyPlaceholderHelper.java:146"$1$"							""Circular placeholder reference '"" + originalPlaceholder + ""' in property definitions"");"
"PropertyPlaceholderHelper.java:147"$1$"				}"
"PropertyPlaceholderHelper.java:148"$0$"				// Recursive invocation, parsing placeholders contained in the placeholder key."
"PropertyPlaceholderHelper.java:149"$0$"				placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);"
"PropertyPlaceholderHelper.java:150"$0$"				// Now obtain the value for the fully resolved key..."
"PropertyPlaceholderHelper.java:151"$0$"				String propVal = placeholderResolver.resolvePlaceholder(placeholder);"
"PropertyPlaceholderHelper.java:152"$1$"				if (propVal == null && this.valueSeparator != null) {"
"PropertyPlaceholderHelper.java:153"$1$"					int separatorIndex = placeholder.indexOf(this.valueSeparator);"
"PropertyPlaceholderHelper.java:154"$1$"					if (separatorIndex != -1) {"
"PropertyPlaceholderHelper.java:155"$1$"						String actualPlaceholder = placeholder.substring(0, separatorIndex);"
"PropertyPlaceholderHelper.java:156"$1$"						String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length());"
"PropertyPlaceholderHelper.java:157"$1$"						propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);"
"PropertyPlaceholderHelper.java:158"$1$"						if (propVal == null) {"
"PropertyPlaceholderHelper.java:159"$1$"							propVal = defaultValue;"
"PropertyPlaceholderHelper.java:160"$1$"						}"
"PropertyPlaceholderHelper.java:161"$0$"					}"
"PropertyPlaceholderHelper.java:162"$0$"				}"
"PropertyPlaceholderHelper.java:163"$1$"				if (propVal != null) {"
"PropertyPlaceholderHelper.java:164"$0$"					// Recursive invocation, parsing placeholders contained in the"
"PropertyPlaceholderHelper.java:165"$0$"					// previously resolved placeholder value."
"PropertyPlaceholderHelper.java:166"$1$"					propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);"
"PropertyPlaceholderHelper.java:167"$1$"					result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal);"
"PropertyPlaceholderHelper.java:168"$1$"					if (logger.isTraceEnabled()) {"
"PropertyPlaceholderHelper.java:169"$1$"						logger.trace(""Resolved placeholder '"" + placeholder + ""'"");"
"PropertyPlaceholderHelper.java:170"$1$"					}"
"PropertyPlaceholderHelper.java:171"$0$"					startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length());"
"PropertyPlaceholderHelper.java:172"$0$"				}"
"PropertyPlaceholderHelper.java:173"$1$"				else if (this.ignoreUnresolvablePlaceholders) {"
"PropertyPlaceholderHelper.java:174"$0$"					// Proceed with unprocessed value."
"PropertyPlaceholderHelper.java:175"$1$"					startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length());"
"PropertyPlaceholderHelper.java:176"$1$"				}"
"PropertyPlaceholderHelper.java:177"$1$"				else {"
"PropertyPlaceholderHelper.java:178"$1$"					throw new IllegalArgumentException(""Could not resolve placeholder '"" +"
"PropertyPlaceholderHelper.java:179"$1$"							placeholder + ""'"" + "" in value \"""" + value + ""\"""");"
"PropertyPlaceholderHelper.java:180"$1$"				}"
"PropertyPlaceholderHelper.java:181"$0$"				visitedPlaceholders.remove(originalPlaceholder);"
"PropertyPlaceholderHelper.java:182"$0$"			}"
"PropertyPlaceholderHelper.java:183"$1$"			else {"
"PropertyPlaceholderHelper.java:184"$1$"				startIndex = -1;"
"PropertyPlaceholderHelper.java:185"$1$"			}"
"PropertyPlaceholderHelper.java:186"$0$"		}"
"PropertyPlaceholderHelper.java:187"$0$"		return result.toString();"
"PropertyPlaceholderHelper.java:188"$0$"	}"
"PropertyPlaceholderHelper.java:189"$0$""
"PropertyPlaceholderHelper.java:190"$1$"	private int findPlaceholderEndIndex(CharSequence buf, int startIndex) {"
"PropertyPlaceholderHelper.java:191"$1$"		int index = startIndex + this.placeholderPrefix.length();"
"PropertyPlaceholderHelper.java:192"$1$"		int withinNestedPlaceholder = 0;"
"PropertyPlaceholderHelper.java:193"$1$"		while (index < buf.length()) {"
"PropertyPlaceholderHelper.java:194"$1$"			if (StringUtils.substringMatch(buf, index, this.placeholderSuffix)) {"
"PropertyPlaceholderHelper.java:195"$1$"				if (withinNestedPlaceholder > 0) {"
"PropertyPlaceholderHelper.java:196"$1$"					withinNestedPlaceholder--;"
"PropertyPlaceholderHelper.java:197"$1$"					index = index + this.placeholderSuffix.length();"
"PropertyPlaceholderHelper.java:198"$1$"				}"
"PropertyPlaceholderHelper.java:199"$1$"				else {"
"PropertyPlaceholderHelper.java:200"$1$"					return index;"
"PropertyPlaceholderHelper.java:201"$1$"				}"
"PropertyPlaceholderHelper.java:202"$0$"			}"
"PropertyPlaceholderHelper.java:203"$1$"			else if (StringUtils.substringMatch(buf, index, this.simplePrefix)) {"
"PropertyPlaceholderHelper.java:204"$1$"				withinNestedPlaceholder++;"
"PropertyPlaceholderHelper.java:205"$1$"				index = index + this.simplePrefix.length();"
"PropertyPlaceholderHelper.java:206"$1$"			}"
"PropertyPlaceholderHelper.java:207"$1$"			else {"
"PropertyPlaceholderHelper.java:208"$1$"				index++;"
"PropertyPlaceholderHelper.java:209"$1$"			}"
"PropertyPlaceholderHelper.java:210"$0$"		}"
"PropertyPlaceholderHelper.java:211"$0$"		return -1;"
"PropertyPlaceholderHelper.java:212"$0$"	}"
"PropertyPlaceholderHelper.java:213"$0$""
"PropertyPlaceholderHelper.java:214"$0$""
"PropertyPlaceholderHelper.java:215"$0$"	/**"
"PropertyPlaceholderHelper.java:216"$0$"	 * Strategy interface used to resolve replacement values for placeholders contained in Strings."
"PropertyPlaceholderHelper.java:217"$0$"	 */"
"PropertyPlaceholderHelper.java:218"$0$"	@FunctionalInterface"
"PropertyPlaceholderHelper.java:219"$1$"	public interface PlaceholderResolver {"
"PropertyPlaceholderHelper.java:220"$1$""
"PropertyPlaceholderHelper.java:221"$1$"		/**"
"PropertyPlaceholderHelper.java:222"$1$"		 * Resolve the supplied placeholder name to the replacement value."
"PropertyPlaceholderHelper.java:223"$1$"		 * @param placeholderName the name of the placeholder to resolve"
"PropertyPlaceholderHelper.java:224"$1$"		 * @return the replacement value, or {@code null} if no replacement is to be made"
"PropertyPlaceholderHelper.java:225"$1$"		 */"
"PropertyPlaceholderHelper.java:226"$1$"		@Nullable"
"PropertyPlaceholderHelper.java:227"$1$"		String resolvePlaceholder(String placeholderName);"
"PropertyPlaceholderHelper.java:228"$1$"	}"
"PropertyPlaceholderHelper.java:229"$0$""
"PropertyPlaceholderHelper.java:230"$0$"}"
"StringDecoder.java:1"$0$"/*"
"StringDecoder.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"StringDecoder.java:3"$0$" *"
"StringDecoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"StringDecoder.java:5"$0$" * you may not use this file except in compliance with the License."
"StringDecoder.java:6"$0$" * You may obtain a copy of the License at"
"StringDecoder.java:7"$0$" *"
"StringDecoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"StringDecoder.java:9"$0$" *"
"StringDecoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"StringDecoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"StringDecoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"StringDecoder.java:13"$0$" * See the License for the specific language governing permissions and"
"StringDecoder.java:14"$0$" * limitations under the License."
"StringDecoder.java:15"$0$" */"
"StringDecoder.java:16"$0$""
"StringDecoder.java:17"$0$"package org.springframework.core.codec;"
"StringDecoder.java:18"$0$""
"StringDecoder.java:19"$0$"import java.nio.CharBuffer;"
"StringDecoder.java:20"$0$"import java.nio.charset.Charset;"
"StringDecoder.java:21"$0$"import java.nio.charset.StandardCharsets;"
"StringDecoder.java:22"$0$"import java.util.ArrayList;"
"StringDecoder.java:23"$0$"import java.util.Arrays;"
"StringDecoder.java:24"$0$"import java.util.List;"
"StringDecoder.java:25"$0$"import java.util.Map;"
"StringDecoder.java:26"$0$"import java.util.concurrent.ConcurrentHashMap;"
"StringDecoder.java:27"$0$"import java.util.concurrent.ConcurrentMap;"
"StringDecoder.java:28"$0$"import java.util.function.Consumer;"
"StringDecoder.java:29"$0$""
"StringDecoder.java:30"$0$"import org.reactivestreams.Publisher;"
"StringDecoder.java:31"$0$"import reactor.core.publisher.Flux;"
"StringDecoder.java:32"$0$""
"StringDecoder.java:33"$0$"import org.springframework.core.ResolvableType;"
"StringDecoder.java:34"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"StringDecoder.java:35"$0$"import org.springframework.core.io.buffer.DataBufferLimitException;"
"StringDecoder.java:36"$0$"import org.springframework.core.io.buffer.DataBufferUtils;"
"StringDecoder.java:37"$0$"import org.springframework.core.io.buffer.DataBufferWrapper;"
"StringDecoder.java:38"$0$"import org.springframework.core.io.buffer.DefaultDataBufferFactory;"
"StringDecoder.java:39"$0$"import org.springframework.core.io.buffer.LimitedDataBufferList;"
"StringDecoder.java:40"$0$"import org.springframework.core.io.buffer.PooledDataBuffer;"
"StringDecoder.java:41"$0$"import org.springframework.core.log.LogFormatUtils;"
"StringDecoder.java:42"$0$"import org.springframework.lang.Nullable;"
"StringDecoder.java:43"$0$"import org.springframework.util.Assert;"
"StringDecoder.java:44"$0$"import org.springframework.util.MimeType;"
"StringDecoder.java:45"$0$"import org.springframework.util.MimeTypeUtils;"
"StringDecoder.java:46"$0$""
"StringDecoder.java:47"$0$"/**"
"StringDecoder.java:48"$1$" * Decode from a data buffer stream to a {@code String} stream. Before decoding, this decoder"
"StringDecoder.java:49"$0$" * realigns the incoming data buffers so that each buffer ends with a newline."
"StringDecoder.java:50"$0$" * This is to make sure that multibyte characters are decoded properly, and do not cross buffer"
"StringDecoder.java:51"$1$" * boundaries. The default delimiters ({@code \n}, {@code \r\n})can be customized."
"StringDecoder.java:52"$0$" *"
"StringDecoder.java:53"$1$" * <p>Partially inspired by Netty's {@code DelimiterBasedFrameDecoder}."
"StringDecoder.java:54"$0$" *"
"StringDecoder.java:55"$0$" * @author Sebastien Deleuze"
"StringDecoder.java:56"$0$" * @author Brian Clozel"
"StringDecoder.java:57"$0$" * @author Arjen Poutsma"
"StringDecoder.java:58"$0$" * @author Mark Paluch"
"StringDecoder.java:59"$0$" * @since 5.0"
"StringDecoder.java:60"$0$" * @see CharSequenceEncoder"
"StringDecoder.java:61"$0$" */"
"StringDecoder.java:62"$1$"public final class StringDecoder extends AbstractDataBufferDecoder<String> {"
"StringDecoder.java:63"$1$""
"StringDecoder.java:64"$1$"	/** The default charset to use, i.e. ""UTF-8"". */"
"StringDecoder.java:65"$1$"	public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;"
"StringDecoder.java:66"$1$""
"StringDecoder.java:67"$1$"	/** The default delimiter strings to use, i.e. {@code \r\n} and {@code \n}. */"
"StringDecoder.java:68"$1$"	public static final List<String> DEFAULT_DELIMITERS = Arrays.asList(""\r\n"", ""\n"");"
"StringDecoder.java:69"$1$""
"StringDecoder.java:70"$1$""
"StringDecoder.java:71"$1$"	private final List<String> delimiters;"
"StringDecoder.java:72"$1$""
"StringDecoder.java:73"$1$"	private final boolean stripDelimiter;"
"StringDecoder.java:74"$1$""
"StringDecoder.java:75"$1$"	private final ConcurrentMap<Charset, byte[][]> delimitersCache = new ConcurrentHashMap<>();"
"StringDecoder.java:76"$1$""
"StringDecoder.java:77"$1$""
"StringDecoder.java:78"$1$"	private StringDecoder(List<String> delimiters, boolean stripDelimiter, MimeType... mimeTypes) {"
"StringDecoder.java:79"$1$"		super(mimeTypes);"
"StringDecoder.java:80"$1$"		Assert.notEmpty(delimiters, ""'delimiters' must not be empty"");"
"StringDecoder.java:81"$1$"		this.delimiters = new ArrayList<>(delimiters);"
"StringDecoder.java:82"$1$"		this.stripDelimiter = stripDelimiter;"
"StringDecoder.java:83"$1$"	}"
"StringDecoder.java:84"$0$""
"StringDecoder.java:85"$0$""
"StringDecoder.java:86"$0$"	@Override"
"StringDecoder.java:87"$1$"	public boolean canDecode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"StringDecoder.java:88"$1$"		return (elementType.resolve() == String.class && super.canDecode(elementType, mimeType));"
"StringDecoder.java:89"$1$"	}"
"StringDecoder.java:90"$0$""
"StringDecoder.java:91"$0$"	@Override"
"StringDecoder.java:92"$0$"	public Flux<String> decode(Publisher<DataBuffer> input, ResolvableType elementType,"
"StringDecoder.java:93"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"StringDecoder.java:94"$1$""
"StringDecoder.java:95"$1$"		byte[][] delimiterBytes = getDelimiterBytes(mimeType);"
"StringDecoder.java:96"$1$""
"StringDecoder.java:97"$1$"		Flux<DataBuffer> inputFlux = Flux.defer(() -> {"
"StringDecoder.java:98"$1$"			DataBufferUtils.Matcher matcher = DataBufferUtils.matcher(delimiterBytes);"
"StringDecoder.java:99"$1$""
"StringDecoder.java:100"$1$"			@SuppressWarnings(""MismatchedQueryAndUpdateOfCollection"")"
"StringDecoder.java:101"$1$"			LimitChecker limiter = new LimitChecker(getMaxInMemorySize());"
"StringDecoder.java:102"$1$""
"StringDecoder.java:103"$1$"			return Flux.from(input)"
"StringDecoder.java:104"$1$"					.concatMapIterable(buffer -> endFrameAfterDelimiter(buffer, matcher))"
"StringDecoder.java:105"$1$"					.doOnNext(limiter)"
"StringDecoder.java:106"$1$"					.bufferUntil(buffer -> buffer instanceof EndFrameBuffer)"
"StringDecoder.java:107"$1$"					.map(list -> joinAndStrip(list, this.stripDelimiter))"
"StringDecoder.java:108"$1$"					.doOnDiscard(PooledDataBuffer.class, DataBufferUtils::release);"
"StringDecoder.java:109"$1$"		});"
"StringDecoder.java:110"$0$""
"StringDecoder.java:111"$0$"		return super.decode(inputFlux, elementType, mimeType, hints);"
"StringDecoder.java:112"$0$"	}"
"StringDecoder.java:113"$0$""
"StringDecoder.java:114"$1$"	private byte[][] getDelimiterBytes(@Nullable MimeType mimeType) {"
"StringDecoder.java:115"$1$"		return this.delimitersCache.computeIfAbsent(getCharset(mimeType), charset -> {"
"StringDecoder.java:116"$1$"			byte[][] result = new byte[this.delimiters.size()][];"
"StringDecoder.java:117"$1$"			for (int i = 0; i < this.delimiters.size(); i++) {"
"StringDecoder.java:118"$1$"				result[i] = this.delimiters.get(i).getBytes(charset);"
"StringDecoder.java:119"$1$"			}"
"StringDecoder.java:120"$0$"			return result;"
"StringDecoder.java:121"$0$"		});"
"StringDecoder.java:122"$0$"	}"
"StringDecoder.java:123"$0$""
"StringDecoder.java:124"$0$"	@Override"
"StringDecoder.java:125"$0$"	public String decode(DataBuffer dataBuffer, ResolvableType elementType,"
"StringDecoder.java:126"$1$"			@Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"StringDecoder.java:127"$1$""
"StringDecoder.java:128"$1$"		Charset charset = getCharset(mimeType);"
"StringDecoder.java:129"$1$"		CharBuffer charBuffer = charset.decode(dataBuffer.asByteBuffer());"
"StringDecoder.java:130"$1$"		DataBufferUtils.release(dataBuffer);"
"StringDecoder.java:131"$1$"		String value = charBuffer.toString();"
"StringDecoder.java:132"$1$"		LogFormatUtils.traceDebug(logger, traceOn -> {"
"StringDecoder.java:133"$1$"			String formatted = LogFormatUtils.formatValue(value, !traceOn);"
"StringDecoder.java:134"$1$"			return Hints.getLogPrefix(hints) + ""Decoded "" + formatted;"
"StringDecoder.java:135"$1$"		});"
"StringDecoder.java:136"$0$"		return value;"
"StringDecoder.java:137"$0$"	}"
"StringDecoder.java:138"$0$""
"StringDecoder.java:139"$1$"	private static Charset getCharset(@Nullable MimeType mimeType) {"
"StringDecoder.java:140"$1$"		if (mimeType != null && mimeType.getCharset() != null) {"
"StringDecoder.java:141"$1$"			return mimeType.getCharset();"
"StringDecoder.java:142"$1$"		}"
"StringDecoder.java:143"$1$"		else {"
"StringDecoder.java:144"$1$"			return DEFAULT_CHARSET;"
"StringDecoder.java:145"$1$"		}"
"StringDecoder.java:146"$0$"	}"
"StringDecoder.java:147"$0$""
"StringDecoder.java:148"$0$"	/**"
"StringDecoder.java:149"$1$"	 * Finds the first match and longest delimiter, {@link EndFrameBuffer} just after it."
"StringDecoder.java:150"$0$"	 *"
"StringDecoder.java:151"$0$"	 * @param dataBuffer the buffer to find delimiters in"
"StringDecoder.java:152"$0$"	 * @param matcher used to find the first delimiters"
"StringDecoder.java:153"$1$"	 * @return a flux of buffers, containing {@link EndFrameBuffer} after each delimiter that was"
"StringDecoder.java:154"$1$"	 * found in {@code dataBuffer}. Returns  Flux, because returning List (w/ flatMapIterable)"
"StringDecoder.java:155"$0$"	 * results in memory leaks due to pre-fetching."
"StringDecoder.java:156"$0$"	 */"
"StringDecoder.java:157"$1$"	private static List<DataBuffer> endFrameAfterDelimiter(DataBuffer dataBuffer, DataBufferUtils.Matcher matcher) {"
"StringDecoder.java:158"$1$"		List<DataBuffer> result = new ArrayList<>();"
"StringDecoder.java:159"$1$"		try {"
"StringDecoder.java:160"$1$"			do {"
"StringDecoder.java:161"$1$"				int endIdx = matcher.match(dataBuffer);"
"StringDecoder.java:162"$1$"				if (endIdx != -1) {"
"StringDecoder.java:163"$1$"					int readPosition = dataBuffer.readPosition();"
"StringDecoder.java:164"$1$"					int length = (endIdx - readPosition + 1);"
"StringDecoder.java:165"$1$"					DataBuffer slice = dataBuffer.retainedSlice(readPosition, length);"
"StringDecoder.java:166"$1$"					result.add(slice);"
"StringDecoder.java:167"$1$"					result.add(new EndFrameBuffer(matcher.delimiter()));"
"StringDecoder.java:168"$1$"					dataBuffer.readPosition(endIdx + 1);"
"StringDecoder.java:169"$1$"				}"
"StringDecoder.java:170"$1$"				else {"
"StringDecoder.java:171"$1$"					result.add(DataBufferUtils.retain(dataBuffer));"
"StringDecoder.java:172"$1$"					break;"
"StringDecoder.java:173"$1$"				}"
"StringDecoder.java:174"$0$"			}"
"StringDecoder.java:175"$0$"			while (dataBuffer.readableByteCount() > 0);"
"StringDecoder.java:176"$0$"		}"
"StringDecoder.java:177"$1$"		finally {"
"StringDecoder.java:178"$1$"			DataBufferUtils.release(dataBuffer);"
"StringDecoder.java:179"$1$"		}"
"StringDecoder.java:180"$0$"		return result;"
"StringDecoder.java:181"$0$"	}"
"StringDecoder.java:182"$0$""
"StringDecoder.java:183"$0$"	/**"
"StringDecoder.java:184"$1$"	 * Joins the given list of buffers. If the list ends with a {@link EndFrameBuffer}, it is"
"StringDecoder.java:185"$1$"	 * removed. If {@code stripDelimiter} is {@code true} and the resulting buffer ends with"
"StringDecoder.java:186"$0$"	 * a delimiter, it is removed."
"StringDecoder.java:187"$0$"	 * @param dataBuffers the data buffers to join"
"StringDecoder.java:188"$0$"	 * @param stripDelimiter whether to strip the delimiter"
"StringDecoder.java:189"$0$"	 * @return the joined buffer"
"StringDecoder.java:190"$0$"	 */"
"StringDecoder.java:191"$1$"	private static DataBuffer joinAndStrip(List<DataBuffer> dataBuffers, boolean stripDelimiter) {"
"StringDecoder.java:192"$1$"		Assert.state(!dataBuffers.isEmpty(), ""DataBuffers should not be empty"");"
"StringDecoder.java:193"$1$""
"StringDecoder.java:194"$1$"		byte[] matchingDelimiter = null;"
"StringDecoder.java:195"$1$""
"StringDecoder.java:196"$1$"		int lastIdx = dataBuffers.size() - 1;"
"StringDecoder.java:197"$1$"		DataBuffer lastBuffer = dataBuffers.get(lastIdx);"
"StringDecoder.java:198"$1$"		if (lastBuffer instanceof EndFrameBuffer) {"
"StringDecoder.java:199"$1$"			matchingDelimiter = ((EndFrameBuffer) lastBuffer).delimiter();"
"StringDecoder.java:200"$1$"			dataBuffers.remove(lastIdx);"
"StringDecoder.java:201"$1$"		}"
"StringDecoder.java:202"$0$""
"StringDecoder.java:203"$0$"		DataBuffer result = dataBuffers.get(0).factory().join(dataBuffers);"
"StringDecoder.java:204"$0$""
"StringDecoder.java:205"$1$"		if (stripDelimiter && matchingDelimiter != null) {"
"StringDecoder.java:206"$1$"			result.writePosition(result.writePosition() - matchingDelimiter.length);"
"StringDecoder.java:207"$1$"		}"
"StringDecoder.java:208"$0$"		return result;"
"StringDecoder.java:209"$0$"	}"
"StringDecoder.java:210"$0$""
"StringDecoder.java:211"$0$""
"StringDecoder.java:212"$0$""
"StringDecoder.java:213"$0$""
"StringDecoder.java:214"$0$"	/**"
"StringDecoder.java:215"$1$"	 * Create a {@code StringDecoder} for {@code ""text/plain""}."
"StringDecoder.java:216"$0$"	 * @param stripDelimiter this flag is ignored"
"StringDecoder.java:217"$1$"	 * @deprecated as of Spring 5.0.4, in favor of {@link #textPlainOnly()} or"
"StringDecoder.java:218"$1$"	 * {@link #textPlainOnly(List, boolean)}"
"StringDecoder.java:219"$0$"	 */"
"StringDecoder.java:220"$0$"	@Deprecated"
"StringDecoder.java:221"$1$"	public static StringDecoder textPlainOnly(boolean stripDelimiter) {"
"StringDecoder.java:222"$1$"		return textPlainOnly();"
"StringDecoder.java:223"$1$"	}"
"StringDecoder.java:224"$0$""
"StringDecoder.java:225"$0$"	/**"
"StringDecoder.java:226"$1$"	 * Create a {@code StringDecoder} for {@code ""text/plain""}."
"StringDecoder.java:227"$0$"	 */"
"StringDecoder.java:228"$1$"	public static StringDecoder textPlainOnly() {"
"StringDecoder.java:229"$1$"		return textPlainOnly(DEFAULT_DELIMITERS, true);"
"StringDecoder.java:230"$1$"	}"
"StringDecoder.java:231"$0$""
"StringDecoder.java:232"$0$"	/**"
"StringDecoder.java:233"$1$"	 * Create a {@code StringDecoder} for {@code ""text/plain""}."
"StringDecoder.java:234"$0$"	 * @param delimiters delimiter strings to use to split the input stream"
"StringDecoder.java:235"$0$"	 * @param stripDelimiter whether to remove delimiters from the resulting"
"StringDecoder.java:236"$0$"	 * input strings"
"StringDecoder.java:237"$0$"	 */"
"StringDecoder.java:238"$1$"	public static StringDecoder textPlainOnly(List<String> delimiters, boolean stripDelimiter) {"
"StringDecoder.java:239"$1$"		return new StringDecoder(delimiters, stripDelimiter, new MimeType(""text"", ""plain"", DEFAULT_CHARSET));"
"StringDecoder.java:240"$1$"	}"
"StringDecoder.java:241"$0$""
"StringDecoder.java:242"$0$"	/**"
"StringDecoder.java:243"$1$"	 * Create a {@code StringDecoder} that supports all MIME types."
"StringDecoder.java:244"$0$"	 * @param stripDelimiter this flag is ignored"
"StringDecoder.java:245"$1$"	 * @deprecated as of Spring 5.0.4, in favor of {@link #allMimeTypes()} or"
"StringDecoder.java:246"$1$"	 * {@link #allMimeTypes(List, boolean)}"
"StringDecoder.java:247"$0$"	 */"
"StringDecoder.java:248"$0$"	@Deprecated"
"StringDecoder.java:249"$1$"	public static StringDecoder allMimeTypes(boolean stripDelimiter) {"
"StringDecoder.java:250"$1$"		return allMimeTypes();"
"StringDecoder.java:251"$1$"	}"
"StringDecoder.java:252"$0$""
"StringDecoder.java:253"$0$"	/**"
"StringDecoder.java:254"$1$"	 * Create a {@code StringDecoder} that supports all MIME types."
"StringDecoder.java:255"$0$"	 */"
"StringDecoder.java:256"$1$"	public static StringDecoder allMimeTypes() {"
"StringDecoder.java:257"$1$"		return allMimeTypes(DEFAULT_DELIMITERS, true);"
"StringDecoder.java:258"$1$"	}"
"StringDecoder.java:259"$0$""
"StringDecoder.java:260"$0$"	/**"
"StringDecoder.java:261"$1$"	 * Create a {@code StringDecoder} that supports all MIME types."
"StringDecoder.java:262"$0$"	 * @param delimiters delimiter strings to use to split the input stream"
"StringDecoder.java:263"$0$"	 * @param stripDelimiter whether to remove delimiters from the resulting"
"StringDecoder.java:264"$0$"	 * input strings"
"StringDecoder.java:265"$0$"	 */"
"StringDecoder.java:266"$1$"	public static StringDecoder allMimeTypes(List<String> delimiters, boolean stripDelimiter) {"
"StringDecoder.java:267"$1$"		return new StringDecoder(delimiters, stripDelimiter,"
"StringDecoder.java:268"$1$"				new MimeType(""text"", ""plain"", DEFAULT_CHARSET), MimeTypeUtils.ALL);"
"StringDecoder.java:269"$1$"	}"
"StringDecoder.java:270"$0$""
"StringDecoder.java:271"$0$""
"StringDecoder.java:272"$1$"	private static class EndFrameBuffer extends DataBufferWrapper {"
"StringDecoder.java:273"$1$""
"StringDecoder.java:274"$1$"		private static final DataBuffer BUFFER = new DefaultDataBufferFactory().wrap(new byte[0]);"
"StringDecoder.java:275"$1$""
"StringDecoder.java:276"$1$"		private byte[] delimiter;"
"StringDecoder.java:277"$1$""
"StringDecoder.java:278"$1$""
"StringDecoder.java:279"$1$"		public EndFrameBuffer(byte[] delimiter) {"
"StringDecoder.java:280"$1$"			super(BUFFER);"
"StringDecoder.java:281"$1$"			this.delimiter = delimiter;"
"StringDecoder.java:282"$1$"		}"
"StringDecoder.java:283"$0$""
"StringDecoder.java:284"$1$"		public byte[] delimiter() {"
"StringDecoder.java:285"$1$"			return this.delimiter;"
"StringDecoder.java:286"$1$"		}"
"StringDecoder.java:287"$0$""
"StringDecoder.java:288"$0$"	}"
"StringDecoder.java:289"$0$""
"StringDecoder.java:290"$0$""
"StringDecoder.java:291"$1$"	private static class LimitChecker implements Consumer<DataBuffer> {"
"StringDecoder.java:292"$1$""
"StringDecoder.java:293"$1$"		@SuppressWarnings(""MismatchedQueryAndUpdateOfCollection"")"
"StringDecoder.java:294"$1$"		private final LimitedDataBufferList list;"
"StringDecoder.java:295"$1$""
"StringDecoder.java:296"$1$""
"StringDecoder.java:297"$1$"		LimitChecker(int maxInMemorySize) {"
"StringDecoder.java:298"$1$"			this.list = new LimitedDataBufferList(maxInMemorySize);"
"StringDecoder.java:299"$1$"		}"
"StringDecoder.java:300"$0$""
"StringDecoder.java:301"$0$"		@Override"
"StringDecoder.java:302"$1$"		public void accept(DataBuffer buffer) {"
"StringDecoder.java:303"$1$"			if (buffer instanceof EndFrameBuffer) {"
"StringDecoder.java:304"$1$"				this.list.clear();"
"StringDecoder.java:305"$1$"			}"
"StringDecoder.java:306"$1$"			try {"
"StringDecoder.java:307"$1$"				this.list.add(buffer);"
"StringDecoder.java:308"$1$"			}"
"StringDecoder.java:309"$1$"			catch (DataBufferLimitException ex) {"
"StringDecoder.java:310"$1$"				DataBufferUtils.release(buffer);"
"StringDecoder.java:311"$1$"				throw ex;"
"StringDecoder.java:312"$1$"			}"
"StringDecoder.java:313"$0$"		}"
"StringDecoder.java:314"$0$"	}"
"StringDecoder.java:315"$0$""
"StringDecoder.java:316"$0$"}"
"MergedAnnotations.java:1"$0$"/*"
"MergedAnnotations.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"MergedAnnotations.java:3"$0$" *"
"MergedAnnotations.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"MergedAnnotations.java:5"$0$" * you may not use this file except in compliance with the License."
"MergedAnnotations.java:6"$0$" * You may obtain a copy of the License at"
"MergedAnnotations.java:7"$0$" *"
"MergedAnnotations.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"MergedAnnotations.java:9"$0$" *"
"MergedAnnotations.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"MergedAnnotations.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"MergedAnnotations.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"MergedAnnotations.java:13"$0$" * See the License for the specific language governing permissions and"
"MergedAnnotations.java:14"$0$" * limitations under the License."
"MergedAnnotations.java:15"$0$" */"
"MergedAnnotations.java:16"$0$""
"MergedAnnotations.java:17"$0$"package org.springframework.core.annotation;"
"MergedAnnotations.java:18"$0$""
"MergedAnnotations.java:19"$0$"import java.lang.annotation.Annotation;"
"MergedAnnotations.java:20"$0$"import java.lang.annotation.Inherited;"
"MergedAnnotations.java:21"$0$"import java.lang.reflect.AnnotatedElement;"
"MergedAnnotations.java:22"$0$"import java.lang.reflect.Method;"
"MergedAnnotations.java:23"$0$"import java.util.Collection;"
"MergedAnnotations.java:24"$0$"import java.util.function.Predicate;"
"MergedAnnotations.java:25"$0$"import java.util.stream.Stream;"
"MergedAnnotations.java:26"$0$""
"MergedAnnotations.java:27"$0$"import org.springframework.lang.Nullable;"
"MergedAnnotations.java:28"$0$""
"MergedAnnotations.java:29"$0$"/**"
"MergedAnnotations.java:30"$0$" * Provides access to a collection of merged annotations, usually obtained"
"MergedAnnotations.java:31"$1$" * from a source such as a {@link Class} or {@link Method}."
"MergedAnnotations.java:32"$0$" *"
"MergedAnnotations.java:33"$0$" * <p>Each merged annotation represents a view where the attribute values may be"
"MergedAnnotations.java:34"$0$" * ""merged"" from different source values, typically:"
"MergedAnnotations.java:35"$0$" *"
"MergedAnnotations.java:36"$0$" * <ul>"
"MergedAnnotations.java:37"$1$" * <li>Explicit and Implicit {@link AliasFor @AliasFor} declarations on one or"
"MergedAnnotations.java:38"$0$" * more attributes within the annotation</li>"
"MergedAnnotations.java:39"$1$" * <li>Explicit {@link AliasFor @AliasFor} declarations for a meta-annotation</li>"
"MergedAnnotations.java:40"$0$" * <li>Convention based attribute aliases for a meta-annotation</li>"
"MergedAnnotations.java:41"$0$" * <li>From a meta-annotation declaration</li>"
"MergedAnnotations.java:42"$0$" * </ul>"
"MergedAnnotations.java:43"$0$" *"
"MergedAnnotations.java:44"$1$" * <p>For example, a {@code @PostMapping} annotation might be defined as follows:"
"MergedAnnotations.java:45"$0$" *"
"MergedAnnotations.java:46"$0$" * <pre class=""code"">"
"MergedAnnotations.java:47"$0$" * &#064;Retention(RetentionPolicy.RUNTIME)"
"MergedAnnotations.java:48"$0$" * &#064;RequestMapping(method = RequestMethod.POST)"
"MergedAnnotations.java:49"$1$" * public &#064;interface PostMapping {"
"MergedAnnotations.java:50"$1$" *"
"MergedAnnotations.java:51"$1$" *     &#064;AliasFor(attribute = ""path"")"
"MergedAnnotations.java:52"$1$" *     String[] value() default {};"
"MergedAnnotations.java:53"$1$" *"
"MergedAnnotations.java:54"$1$" *     &#064;AliasFor(attribute = ""value"")"
"MergedAnnotations.java:55"$1$" *     String[] path() default {};"
"MergedAnnotations.java:56"$1$" * }"
"MergedAnnotations.java:57"$0$" * </pre>"
"MergedAnnotations.java:58"$0$" *"
"MergedAnnotations.java:59"$1$" * <p>If a method is annotated with {@code @PostMapping(""/home"")} it will contain"
"MergedAnnotations.java:60"$1$" * merged annotations for both {@code @PostMapping} and the meta-annotation"
"MergedAnnotations.java:61"$1$" * {@code @RequestMapping}. The merged view of the {@code @RequestMapping}"
"MergedAnnotations.java:62"$0$" * annotation will contain the following attributes:"
"MergedAnnotations.java:63"$0$" *"
"MergedAnnotations.java:64"$0$" * <p><table border=""1"">"
"MergedAnnotations.java:65"$0$" * <tr>"
"MergedAnnotations.java:66"$0$" * <th>Name</th>"
"MergedAnnotations.java:67"$0$" * <th>Value</th>"
"MergedAnnotations.java:68"$0$" * <th>Source</th>"
"MergedAnnotations.java:69"$0$" * </tr>"
"MergedAnnotations.java:70"$0$" * <tr>"
"MergedAnnotations.java:71"$0$" * <td>value</td>"
"MergedAnnotations.java:72"$0$" * <td>""/home""</td>"
"MergedAnnotations.java:73"$1$" * <td>Declared in {@code @PostMapping}</td>"
"MergedAnnotations.java:74"$0$" * </tr>"
"MergedAnnotations.java:75"$0$" * <tr>"
"MergedAnnotations.java:76"$0$" * <td>path</td>"
"MergedAnnotations.java:77"$0$" * <td>""/home""</td>"
"MergedAnnotations.java:78"$1$" * <td>Explicit {@code @AliasFor}</td>"
"MergedAnnotations.java:79"$0$" * </tr>"
"MergedAnnotations.java:80"$0$" * <tr>"
"MergedAnnotations.java:81"$0$" * <td>method</td>"
"MergedAnnotations.java:82"$0$" * <td>RequestMethod.POST</td>"
"MergedAnnotations.java:83"$0$" * <td>Declared in meta-annotation</td>"
"MergedAnnotations.java:84"$0$" * </tr>"
"MergedAnnotations.java:85"$0$" * </table>"
"MergedAnnotations.java:86"$0$" *"
"MergedAnnotations.java:87"$1$" * <p>{@link MergedAnnotations} can be obtained {@linkplain #from(AnnotatedElement)"
"MergedAnnotations.java:88"$1$" * from} any Java {@link AnnotatedElement}. They may also be used for sources that"
"MergedAnnotations.java:89"$0$" * don't use reflection (such as those that directly parse bytecode)."
"MergedAnnotations.java:90"$0$" *"
"MergedAnnotations.java:91"$1$" * <p>Different {@linkplain SearchStrategy search strategies} can be used to locate"
"MergedAnnotations.java:92"$0$" * related source elements that contain the annotations to be aggregated. For"
"MergedAnnotations.java:93"$1$" * example, {@link SearchStrategy#TYPE_HIERARCHY} will search both superclasses and"
"MergedAnnotations.java:94"$0$" * implemented interfaces."
"MergedAnnotations.java:95"$0$" *"
"MergedAnnotations.java:96"$1$" * <p>From a {@link MergedAnnotations} instance you can either"
"MergedAnnotations.java:97"$1$" * {@linkplain #get(String) get} a single annotation, or {@linkplain #stream()"
"MergedAnnotations.java:98"$1$" * stream all annotations} or just those that match {@linkplain #stream(String)"
"MergedAnnotations.java:99"$0$" * a specific type}. You can also quickly tell if an annotation"
"MergedAnnotations.java:100"$1$" * {@linkplain #isPresent(String) is present}."
"MergedAnnotations.java:101"$0$" *"
"MergedAnnotations.java:102"$0$" * <p>Here are some typical examples:"
"MergedAnnotations.java:103"$0$" *"
"MergedAnnotations.java:104"$0$" * <pre class=""code"">"
"MergedAnnotations.java:105"$0$" * // is an annotation present or meta-present?"
"MergedAnnotations.java:106"$0$" * mergedAnnotations.isPresent(ExampleAnnotation.class);"
"MergedAnnotations.java:107"$0$" *"
"MergedAnnotations.java:108"$0$" * // get the merged ""value"" attribute of ExampleAnnotation (either directly or"
"MergedAnnotations.java:109"$0$" * // meta-present)"
"MergedAnnotations.java:110"$0$" * mergedAnnotations.get(ExampleAnnotation.class).getString(""value"");"
"MergedAnnotations.java:111"$0$" *"
"MergedAnnotations.java:112"$0$" * // get all meta-annotations but no directly present annotations"
"MergedAnnotations.java:113"$0$" * mergedAnnotations.stream().filter(MergedAnnotation::isMetaPresent);"
"MergedAnnotations.java:114"$0$" *"
"MergedAnnotations.java:115"$0$" * // get all ExampleAnnotation declarations (including any meta-annotations) and"
"MergedAnnotations.java:116"$0$" * // print the merged ""value"" attributes"
"MergedAnnotations.java:117"$0$" * mergedAnnotations.stream(ExampleAnnotation.class)"
"MergedAnnotations.java:118"$0$" *     .map(mergedAnnotation -&gt; mergedAnnotation.getString(""value""))"
"MergedAnnotations.java:119"$0$" *     .forEach(System.out::println);"
"MergedAnnotations.java:120"$0$" * </pre>"
"MergedAnnotations.java:121"$0$" *"
"MergedAnnotations.java:122"$0$" * @author Phillip Webb"
"MergedAnnotations.java:123"$0$" * @author Sam Brannen"
"MergedAnnotations.java:124"$0$" * @since 5.2"
"MergedAnnotations.java:125"$0$" * @see MergedAnnotation"
"MergedAnnotations.java:126"$0$" * @see MergedAnnotationCollectors"
"MergedAnnotations.java:127"$0$" * @see MergedAnnotationPredicates"
"MergedAnnotations.java:128"$0$" * @see MergedAnnotationSelectors"
"MergedAnnotations.java:129"$0$" */"
"MergedAnnotations.java:130"$1$"public interface MergedAnnotations extends Iterable<MergedAnnotation<Annotation>> {"
"MergedAnnotations.java:131"$1$""
"MergedAnnotations.java:132"$1$"	/**"
"MergedAnnotations.java:133"$1$"	 * Determine if the specified annotation is either directly present or"
"MergedAnnotations.java:134"$1$"	 * meta-present."
"MergedAnnotations.java:135"$1$"	 * <p>Equivalent to calling {@code get(annotationType).isPresent()}."
"MergedAnnotations.java:136"$1$"	 * @param annotationType the annotation type to check"
"MergedAnnotations.java:137"$1$"	 * @return {@code true} if the annotation is present"
"MergedAnnotations.java:138"$1$"	 */"
"MergedAnnotations.java:139"$1$"	<A extends Annotation> boolean isPresent(Class<A> annotationType);"
"MergedAnnotations.java:140"$1$""
"MergedAnnotations.java:141"$1$"	/**"
"MergedAnnotations.java:142"$1$"	 * Determine if the specified annotation is either directly present or"
"MergedAnnotations.java:143"$1$"	 * meta-present."
"MergedAnnotations.java:144"$1$"	 * <p>Equivalent to calling {@code get(annotationType).isPresent()}."
"MergedAnnotations.java:145"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:146"$1$"	 * to check"
"MergedAnnotations.java:147"$1$"	 * @return {@code true} if the annotation is present"
"MergedAnnotations.java:148"$1$"	 */"
"MergedAnnotations.java:149"$1$"	boolean isPresent(String annotationType);"
"MergedAnnotations.java:150"$1$""
"MergedAnnotations.java:151"$1$"	/**"
"MergedAnnotations.java:152"$1$"	 * Determine if the specified annotation is directly present."
"MergedAnnotations.java:153"$1$"	 * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}."
"MergedAnnotations.java:154"$1$"	 * @param annotationType the annotation type to check"
"MergedAnnotations.java:155"$1$"	 * @return {@code true} if the annotation is directly present"
"MergedAnnotations.java:156"$1$"	 */"
"MergedAnnotations.java:157"$1$"	<A extends Annotation> boolean isDirectlyPresent(Class<A> annotationType);"
"MergedAnnotations.java:158"$1$""
"MergedAnnotations.java:159"$1$"	/**"
"MergedAnnotations.java:160"$1$"	 * Determine if the specified annotation is directly present."
"MergedAnnotations.java:161"$1$"	 * <p>Equivalent to calling {@code get(annotationType).isDirectlyPresent()}."
"MergedAnnotations.java:162"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:163"$1$"	 * to check"
"MergedAnnotations.java:164"$1$"	 * @return {@code true} if the annotation is directly present"
"MergedAnnotations.java:165"$1$"	 */"
"MergedAnnotations.java:166"$1$"	boolean isDirectlyPresent(String annotationType);"
"MergedAnnotations.java:167"$1$""
"MergedAnnotations.java:168"$1$"	/**"
"MergedAnnotations.java:169"$1$"	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching"
"MergedAnnotations.java:170"$1$"	 * annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:171"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:172"$1$"	 * @param annotationType the annotation type to get"
"MergedAnnotations.java:173"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:174"$1$"	 */"
"MergedAnnotations.java:175"$1$"	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType);"
"MergedAnnotations.java:176"$1$""
"MergedAnnotations.java:177"$1$"	/**"
"MergedAnnotations.java:178"$1$"	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching"
"MergedAnnotations.java:179"$1$"	 * annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:180"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:181"$1$"	 * @param annotationType the annotation type to get"
"MergedAnnotations.java:182"$1$"	 * @param predicate a predicate that must match, or {@code null} if only"
"MergedAnnotations.java:183"$1$"	 * type matching is required"
"MergedAnnotations.java:184"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:185"$1$"	 * @see MergedAnnotationPredicates"
"MergedAnnotations.java:186"$1$"	 */"
"MergedAnnotations.java:187"$1$"	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,"
"MergedAnnotations.java:188"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate);"
"MergedAnnotations.java:189"$1$""
"MergedAnnotations.java:190"$1$"	/**"
"MergedAnnotations.java:191"$1$"	 * Get a matching annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:192"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:193"$1$"	 * @param annotationType the annotation type to get"
"MergedAnnotations.java:194"$1$"	 * @param predicate a predicate that must match, or {@code null} if only"
"MergedAnnotations.java:195"$1$"	 * type matching is required"
"MergedAnnotations.java:196"$1$"	 * @param selector a selector used to choose the most appropriate annotation"
"MergedAnnotations.java:197"$1$"	 * within an aggregate, or {@code null} to select the"
"MergedAnnotations.java:198"$1$"	 * {@linkplain MergedAnnotationSelectors#nearest() nearest}"
"MergedAnnotations.java:199"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:200"$1$"	 * @see MergedAnnotationPredicates"
"MergedAnnotations.java:201"$1$"	 * @see MergedAnnotationSelectors"
"MergedAnnotations.java:202"$1$"	 */"
"MergedAnnotations.java:203"$1$"	<A extends Annotation> MergedAnnotation<A> get(Class<A> annotationType,"
"MergedAnnotations.java:204"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate,"
"MergedAnnotations.java:205"$1$"			@Nullable MergedAnnotationSelector<A> selector);"
"MergedAnnotations.java:206"$1$""
"MergedAnnotations.java:207"$1$"	/**"
"MergedAnnotations.java:208"$1$"	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching"
"MergedAnnotations.java:209"$1$"	 * annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:210"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:211"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:212"$1$"	 * to get"
"MergedAnnotations.java:213"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:214"$1$"	 */"
"MergedAnnotations.java:215"$1$"	<A extends Annotation> MergedAnnotation<A> get(String annotationType);"
"MergedAnnotations.java:216"$1$""
"MergedAnnotations.java:217"$1$"	/**"
"MergedAnnotations.java:218"$1$"	 * Get the {@linkplain MergedAnnotationSelectors#nearest() nearest} matching"
"MergedAnnotations.java:219"$1$"	 * annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:220"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:221"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:222"$1$"	 * to get"
"MergedAnnotations.java:223"$1$"	 * @param predicate a predicate that must match, or {@code null} if only"
"MergedAnnotations.java:224"$1$"	 * type matching is required"
"MergedAnnotations.java:225"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:226"$1$"	 * @see MergedAnnotationPredicates"
"MergedAnnotations.java:227"$1$"	 */"
"MergedAnnotations.java:228"$1$"	<A extends Annotation> MergedAnnotation<A> get(String annotationType,"
"MergedAnnotations.java:229"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate);"
"MergedAnnotations.java:230"$1$""
"MergedAnnotations.java:231"$1$"	/**"
"MergedAnnotations.java:232"$1$"	 * Get a matching annotation or meta-annotation of the specified type, or"
"MergedAnnotations.java:233"$1$"	 * {@link MergedAnnotation#missing()} if none is present."
"MergedAnnotations.java:234"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:235"$1$"	 * to get"
"MergedAnnotations.java:236"$1$"	 * @param predicate a predicate that must match, or {@code null} if only"
"MergedAnnotations.java:237"$1$"	 * type matching is required"
"MergedAnnotations.java:238"$1$"	 * @param selector a selector used to choose the most appropriate annotation"
"MergedAnnotations.java:239"$1$"	 * within an aggregate, or {@code null} to select the"
"MergedAnnotations.java:240"$1$"	 * {@linkplain MergedAnnotationSelectors#nearest() nearest}"
"MergedAnnotations.java:241"$1$"	 * @return a {@link MergedAnnotation} instance"
"MergedAnnotations.java:242"$1$"	 * @see MergedAnnotationPredicates"
"MergedAnnotations.java:243"$1$"	 * @see MergedAnnotationSelectors"
"MergedAnnotations.java:244"$1$"	 */"
"MergedAnnotations.java:245"$1$"	<A extends Annotation> MergedAnnotation<A> get(String annotationType,"
"MergedAnnotations.java:246"$1$"			@Nullable Predicate<? super MergedAnnotation<A>> predicate,"
"MergedAnnotations.java:247"$1$"			@Nullable MergedAnnotationSelector<A> selector);"
"MergedAnnotations.java:248"$1$""
"MergedAnnotations.java:249"$1$"	/**"
"MergedAnnotations.java:250"$1$"	 * Stream all annotations and meta-annotations that match the specified"
"MergedAnnotations.java:251"$1$"	 * type. The resulting stream follows the same ordering rules as"
"MergedAnnotations.java:252"$1$"	 * {@link #stream()}."
"MergedAnnotations.java:253"$1$"	 * @param annotationType the annotation type to match"
"MergedAnnotations.java:254"$1$"	 * @return a stream of matching annotations"
"MergedAnnotations.java:255"$1$"	 */"
"MergedAnnotations.java:256"$1$"	<A extends Annotation> Stream<MergedAnnotation<A>> stream(Class<A> annotationType);"
"MergedAnnotations.java:257"$1$""
"MergedAnnotations.java:258"$1$"	/**"
"MergedAnnotations.java:259"$1$"	 * Stream all annotations and meta-annotations that match the specified"
"MergedAnnotations.java:260"$1$"	 * type. The resulting stream follows the same ordering rules as"
"MergedAnnotations.java:261"$1$"	 * {@link #stream()}."
"MergedAnnotations.java:262"$1$"	 * @param annotationType the fully qualified class name of the annotation type"
"MergedAnnotations.java:263"$1$"	 * to match"
"MergedAnnotations.java:264"$1$"	 * @return a stream of matching annotations"
"MergedAnnotations.java:265"$1$"	 */"
"MergedAnnotations.java:266"$1$"	<A extends Annotation> Stream<MergedAnnotation<A>> stream(String annotationType);"
"MergedAnnotations.java:267"$1$""
"MergedAnnotations.java:268"$1$"	/**"
"MergedAnnotations.java:269"$1$"	 * Stream all annotations and meta-annotations contained in this collection."
"MergedAnnotations.java:270"$1$"	 * The resulting stream is ordered first by the"
"MergedAnnotations.java:271"$1$"	 * {@linkplain MergedAnnotation#getAggregateIndex() aggregate index} and then"
"MergedAnnotations.java:272"$1$"	 * by the annotation distance (with the closest annotations first). This ordering"
"MergedAnnotations.java:273"$1$"	 * means that, for most use-cases, the most suitable annotations appear"
"MergedAnnotations.java:274"$1$"	 * earliest in the stream."
"MergedAnnotations.java:275"$1$"	 * @return a stream of annotations"
"MergedAnnotations.java:276"$1$"	 */"
"MergedAnnotations.java:277"$1$"	Stream<MergedAnnotation<Annotation>> stream();"
"MergedAnnotations.java:278"$1$""
"MergedAnnotations.java:279"$1$""
"MergedAnnotations.java:280"$1$"	/**"
"MergedAnnotations.java:281"$1$"	 * Create a new {@link MergedAnnotations} instance containing all"
"MergedAnnotations.java:282"$1$"	 * annotations and meta-annotations from the specified element. The"
"MergedAnnotations.java:283"$1$"	 * resulting instance will not include any inherited annotations. If you"
"MergedAnnotations.java:284"$1$"	 * want to include those as well you should use"
"MergedAnnotations.java:285"$1$"	 * {@link #from(AnnotatedElement, SearchStrategy)} with an appropriate"
"MergedAnnotations.java:286"$1$"	 * {@link SearchStrategy}."
"MergedAnnotations.java:287"$1$"	 * @param element the source element"
"MergedAnnotations.java:288"$1$"	 * @return a {@link MergedAnnotations} instance containing the element's"
"MergedAnnotations.java:289"$1$"	 * annotations"
"MergedAnnotations.java:290"$1$"	 */"
"MergedAnnotations.java:291"$1$"	static MergedAnnotations from(AnnotatedElement element) {"
"MergedAnnotations.java:292"$1$"		return from(element, SearchStrategy.DIRECT);"
"MergedAnnotations.java:293"$1$"	}"
"MergedAnnotations.java:294"$0$""
"MergedAnnotations.java:295"$0$"	/**"
"MergedAnnotations.java:296"$1$"	 * Create a new {@link MergedAnnotations} instance containing all"
"MergedAnnotations.java:297"$0$"	 * annotations and meta-annotations from the specified element and,"
"MergedAnnotations.java:298"$1$"	 * depending on the {@link SearchStrategy}, related inherited elements."
"MergedAnnotations.java:299"$0$"	 * @param element the source element"
"MergedAnnotations.java:300"$0$"	 * @param searchStrategy the search strategy to use"
"MergedAnnotations.java:301"$1$"	 * @return a {@link MergedAnnotations} instance containing the merged"
"MergedAnnotations.java:302"$0$"	 * element annotations"
"MergedAnnotations.java:303"$0$"	 */"
"MergedAnnotations.java:304"$1$"	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy) {"
"MergedAnnotations.java:305"$1$"		return from(element, searchStrategy, RepeatableContainers.standardRepeatables());"
"MergedAnnotations.java:306"$1$"	}"
"MergedAnnotations.java:307"$0$""
"MergedAnnotations.java:308"$0$"	/**"
"MergedAnnotations.java:309"$1$"	 * Create a new {@link MergedAnnotations} instance containing all"
"MergedAnnotations.java:310"$0$"	 * annotations and meta-annotations from the specified element and,"
"MergedAnnotations.java:311"$1$"	 * depending on the {@link SearchStrategy}, related inherited elements."
"MergedAnnotations.java:312"$0$"	 * @param element the source element"
"MergedAnnotations.java:313"$0$"	 * @param searchStrategy the search strategy to use"
"MergedAnnotations.java:314"$0$"	 * @param repeatableContainers the repeatable containers that may be used by"
"MergedAnnotations.java:315"$0$"	 * the element annotations or the meta-annotations"
"MergedAnnotations.java:316"$1$"	 * @return a {@link MergedAnnotations} instance containing the merged"
"MergedAnnotations.java:317"$0$"	 * element annotations"
"MergedAnnotations.java:318"$0$"	 */"
"MergedAnnotations.java:319"$0$"	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,"
"MergedAnnotations.java:320"$1$"			RepeatableContainers repeatableContainers) {"
"MergedAnnotations.java:321"$1$""
"MergedAnnotations.java:322"$1$"		return TypeMappedAnnotations.from(element, searchStrategy, repeatableContainers, AnnotationFilter.PLAIN);"
"MergedAnnotations.java:323"$1$"	}"
"MergedAnnotations.java:324"$0$""
"MergedAnnotations.java:325"$0$"	/**"
"MergedAnnotations.java:326"$1$"	 * Create a new {@link MergedAnnotations} instance containing all"
"MergedAnnotations.java:327"$0$"	 * annotations and meta-annotations from the specified element and,"
"MergedAnnotations.java:328"$1$"	 * depending on the {@link SearchStrategy}, related inherited elements."
"MergedAnnotations.java:329"$0$"	 * @param element the source element"
"MergedAnnotations.java:330"$0$"	 * @param searchStrategy the search strategy to use"
"MergedAnnotations.java:331"$0$"	 * @param repeatableContainers the repeatable containers that may be used by"
"MergedAnnotations.java:332"$0$"	 * the element annotations or the meta-annotations"
"MergedAnnotations.java:333"$0$"	 * @param annotationFilter an annotation filter used to restrict the"
"MergedAnnotations.java:334"$0$"	 * annotations considered"
"MergedAnnotations.java:335"$1$"	 * @return a {@link MergedAnnotations} instance containing the merged"
"MergedAnnotations.java:336"$0$"	 * element annotations"
"MergedAnnotations.java:337"$0$"	 */"
"MergedAnnotations.java:338"$0$"	static MergedAnnotations from(AnnotatedElement element, SearchStrategy searchStrategy,"
"MergedAnnotations.java:339"$1$"			RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {"
"MergedAnnotations.java:340"$1$""
"MergedAnnotations.java:341"$1$"		return TypeMappedAnnotations.from(element, searchStrategy, repeatableContainers, annotationFilter);"
"MergedAnnotations.java:342"$1$"	}"
"MergedAnnotations.java:343"$0$""
"MergedAnnotations.java:344"$0$"	/**"
"MergedAnnotations.java:345"$1$"	 * Create a new {@link MergedAnnotations} instance from the specified"
"MergedAnnotations.java:346"$0$"	 * annotations."
"MergedAnnotations.java:347"$0$"	 * @param annotations the annotations to include"
"MergedAnnotations.java:348"$1$"	 * @return a {@link MergedAnnotations} instance containing the annotations"
"MergedAnnotations.java:349"$0$"	 * @see #from(Object, Annotation...)"
"MergedAnnotations.java:350"$0$"	 */"
"MergedAnnotations.java:351"$1$"	static MergedAnnotations from(Annotation... annotations) {"
"MergedAnnotations.java:352"$1$"		return from(annotations, annotations);"
"MergedAnnotations.java:353"$1$"	}"
"MergedAnnotations.java:354"$0$""
"MergedAnnotations.java:355"$0$"	/**"
"MergedAnnotations.java:356"$1$"	 * Create a new {@link MergedAnnotations} instance from the specified"
"MergedAnnotations.java:357"$0$"	 * annotations."
"MergedAnnotations.java:358"$0$"	 * @param source the source for the annotations. This source is used only"
"MergedAnnotations.java:359"$0$"	 * for information and logging. It does not need to <em>actually</em>"
"MergedAnnotations.java:360"$0$"	 * contain the specified annotations, and it will not be searched."
"MergedAnnotations.java:361"$0$"	 * @param annotations the annotations to include"
"MergedAnnotations.java:362"$1$"	 * @return a {@link MergedAnnotations} instance containing the annotations"
"MergedAnnotations.java:363"$0$"	 * @see #from(Annotation...)"
"MergedAnnotations.java:364"$0$"	 * @see #from(AnnotatedElement)"
"MergedAnnotations.java:365"$0$"	 */"
"MergedAnnotations.java:366"$1$"	static MergedAnnotations from(Object source, Annotation... annotations) {"
"MergedAnnotations.java:367"$1$"		return from(source, annotations, RepeatableContainers.standardRepeatables());"
"MergedAnnotations.java:368"$1$"	}"
"MergedAnnotations.java:369"$0$""
"MergedAnnotations.java:370"$0$"	/**"
"MergedAnnotations.java:371"$1$"	 * Create a new {@link MergedAnnotations} instance from the specified"
"MergedAnnotations.java:372"$0$"	 * annotations."
"MergedAnnotations.java:373"$0$"	 * @param source the source for the annotations. This source is used only"
"MergedAnnotations.java:374"$0$"	 * for information and logging. It does not need to <em>actually</em>"
"MergedAnnotations.java:375"$0$"	 * contain the specified annotations, and it will not be searched."
"MergedAnnotations.java:376"$0$"	 * @param annotations the annotations to include"
"MergedAnnotations.java:377"$0$"	 * @param repeatableContainers the repeatable containers that may be used by"
"MergedAnnotations.java:378"$0$"	 * meta-annotations"
"MergedAnnotations.java:379"$1$"	 * @return a {@link MergedAnnotations} instance containing the annotations"
"MergedAnnotations.java:380"$0$"	 */"
"MergedAnnotations.java:381"$1$"	static MergedAnnotations from(Object source, Annotation[] annotations, RepeatableContainers repeatableContainers) {"
"MergedAnnotations.java:382"$1$"		return TypeMappedAnnotations.from(source, annotations, repeatableContainers, AnnotationFilter.PLAIN);"
"MergedAnnotations.java:383"$1$"	}"
"MergedAnnotations.java:384"$0$""
"MergedAnnotations.java:385"$0$"	/**"
"MergedAnnotations.java:386"$1$"	 * Create a new {@link MergedAnnotations} instance from the specified"
"MergedAnnotations.java:387"$0$"	 * annotations."
"MergedAnnotations.java:388"$0$"	 * @param source the source for the annotations. This source is used only"
"MergedAnnotations.java:389"$0$"	 * for information and logging. It does not need to <em>actually</em>"
"MergedAnnotations.java:390"$0$"	 * contain the specified annotations, and it will not be searched."
"MergedAnnotations.java:391"$0$"	 * @param annotations the annotations to include"
"MergedAnnotations.java:392"$0$"	 * @param repeatableContainers the repeatable containers that may be used by"
"MergedAnnotations.java:393"$0$"	 * meta-annotations"
"MergedAnnotations.java:394"$0$"	 * @param annotationFilter an annotation filter used to restrict the"
"MergedAnnotations.java:395"$0$"	 * annotations considered"
"MergedAnnotations.java:396"$1$"	 * @return a {@link MergedAnnotations} instance containing the annotations"
"MergedAnnotations.java:397"$0$"	 */"
"MergedAnnotations.java:398"$0$"	static MergedAnnotations from(Object source, Annotation[] annotations,"
"MergedAnnotations.java:399"$1$"			RepeatableContainers repeatableContainers, AnnotationFilter annotationFilter) {"
"MergedAnnotations.java:400"$1$""
"MergedAnnotations.java:401"$1$"		return TypeMappedAnnotations.from(source, annotations, repeatableContainers, annotationFilter);"
"MergedAnnotations.java:402"$1$"	}"
"MergedAnnotations.java:403"$0$""
"MergedAnnotations.java:404"$0$"	/**"
"MergedAnnotations.java:405"$1$"	 * Create a new {@link MergedAnnotations} instance from the specified"
"MergedAnnotations.java:406"$0$"	 * collection of directly present annotations. This method allows a"
"MergedAnnotations.java:407"$1$"	 * {@link MergedAnnotations} instance to be created from annotations that"
"MergedAnnotations.java:408"$0$"	 * are not necessarily loaded using reflection. The provided annotations"
"MergedAnnotations.java:409"$1$"	 * must all be {@link MergedAnnotation#isDirectlyPresent() directly present}"
"MergedAnnotations.java:410"$1$"	 * and must have a {@link MergedAnnotation#getAggregateIndex() aggregate"
"MergedAnnotations.java:411"$1$"	 * index} of {@code 0}."
"MergedAnnotations.java:412"$1$"	 * <p>"
"MergedAnnotations.java:413"$1$"	 * The resulting {@link MergedAnnotations} instance will contain both the"
"MergedAnnotations.java:414"$1$"	 * specified annotations, and any meta-annotations that can be read using"
"MergedAnnotations.java:415"$1$"	 * reflection."
"MergedAnnotations.java:416"$1$"	 * @param annotations the annotations to include"
"MergedAnnotations.java:417"$1$"	 * @return a {@link MergedAnnotations} instance containing the annotations"
"MergedAnnotations.java:418"$1$"	 * @see MergedAnnotation#of(ClassLoader, Object, Class, java.util.Map)"
"MergedAnnotations.java:419"$1$"	 */"
"MergedAnnotations.java:420"$1$"	static MergedAnnotations of(Collection<MergedAnnotation<?>> annotations) {"
"MergedAnnotations.java:421"$1$"		return MergedAnnotationsCollection.of(annotations);"
"MergedAnnotations.java:422"$1$"	}"
"MergedAnnotations.java:423"$0$""
"MergedAnnotations.java:424"$0$""
"MergedAnnotations.java:425"$0$"	/**"
"MergedAnnotations.java:426"$0$"	 * Search strategies supported by"
"MergedAnnotations.java:427"$1$"	 * {@link MergedAnnotations#from(AnnotatedElement, SearchStrategy)}."
"MergedAnnotations.java:428"$0$"	 *"
"MergedAnnotations.java:429"$0$"	 * <p>Each strategy creates a different set of aggregates that will be"
"MergedAnnotations.java:430"$1$"	 * combined to create the final {@link MergedAnnotations}."
"MergedAnnotations.java:431"$0$"	 */"
"MergedAnnotations.java:432"$1$"	enum SearchStrategy {"
"MergedAnnotations.java:433"$1$""
"MergedAnnotations.java:434"$1$"		/**"
"MergedAnnotations.java:435"$1$"		 * Find only directly declared annotations, without considering"
"MergedAnnotations.java:436"$1$"		 * {@link Inherited @Inherited} annotations and without searching"
"MergedAnnotations.java:437"$1$"		 * superclasses or implemented interfaces."
"MergedAnnotations.java:438"$1$"		 */"
"MergedAnnotations.java:439"$1$"		DIRECT,"
"MergedAnnotations.java:440"$1$""
"MergedAnnotations.java:441"$1$"		/**"
"MergedAnnotations.java:442"$1$"		 * Find all directly declared annotations as well as any"
"MergedAnnotations.java:443"$1$"		 * {@link Inherited @Inherited} superclass annotations. This strategy"
"MergedAnnotations.java:444"$1$"		 * is only really useful when used with {@link Class} types since the"
"MergedAnnotations.java:445"$1$"		 * {@link Inherited @Inherited} annotation is ignored for all other"
"MergedAnnotations.java:446"$1$"		 * {@linkplain AnnotatedElement annotated elements}. This strategy does"
"MergedAnnotations.java:447"$1$"		 * not search implemented interfaces."
"MergedAnnotations.java:448"$1$"		 */"
"MergedAnnotations.java:449"$1$"		INHERITED_ANNOTATIONS,"
"MergedAnnotations.java:450"$1$""
"MergedAnnotations.java:451"$1$"		/**"
"MergedAnnotations.java:452"$1$"		 * Find all directly declared and superclass annotations. This strategy"
"MergedAnnotations.java:453"$1$"		 * is similar to {@link #INHERITED_ANNOTATIONS} except the annotations"
"MergedAnnotations.java:454"$1$"		 * do not need to be meta-annotated with {@link Inherited @Inherited}."
"MergedAnnotations.java:455"$1$"		 * This strategy does not search implemented interfaces."
"MergedAnnotations.java:456"$1$"		 */"
"MergedAnnotations.java:457"$1$"		SUPERCLASS,"
"MergedAnnotations.java:458"$1$""
"MergedAnnotations.java:459"$1$"		/**"
"MergedAnnotations.java:460"$1$"		 * Perform a full search of the entire type hierarchy, including"
"MergedAnnotations.java:461"$1$"		 * superclasses and implemented interfaces. Superclass annotations do"
"MergedAnnotations.java:462"$1$"		 * not need to be meta-annotated with {@link Inherited @Inherited}."
"MergedAnnotations.java:463"$1$"		 */"
"MergedAnnotations.java:464"$1$"		TYPE_HIERARCHY,"
"MergedAnnotations.java:465"$1$""
"MergedAnnotations.java:466"$1$"		/**"
"MergedAnnotations.java:467"$1$"		 * Perform a full search of the entire type hierarchy on the source"
"MergedAnnotations.java:468"$1$"		 * <em>and</em> any enclosing classes. This strategy is similar to"
"MergedAnnotations.java:469"$1$"		 * {@link #TYPE_HIERARCHY} except that {@linkplain Class#getEnclosingClass()"
"MergedAnnotations.java:470"$1$"		 * enclosing classes} are also searched. Superclass annotations do not"
"MergedAnnotations.java:471"$1$"		 * need to be meta-annotated with {@link Inherited @Inherited}. When"
"MergedAnnotations.java:472"$1$"		 * searching a {@link Method} source, this strategy is identical to"
"MergedAnnotations.java:473"$1$"		 * {@link #TYPE_HIERARCHY}."
"MergedAnnotations.java:474"$0$"		 */"
"MergedAnnotations.java:475"$0$"		TYPE_HIERARCHY_AND_ENCLOSING_CLASSES"
"MergedAnnotations.java:476"$0$"	}"
"MergedAnnotations.java:477"$0$""
"MergedAnnotations.java:478"$0$"}"
"ByteBufferEncoder.java:1"$0$"/*"
"ByteBufferEncoder.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"ByteBufferEncoder.java:3"$0$" *"
"ByteBufferEncoder.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ByteBufferEncoder.java:5"$0$" * you may not use this file except in compliance with the License."
"ByteBufferEncoder.java:6"$0$" * You may obtain a copy of the License at"
"ByteBufferEncoder.java:7"$0$" *"
"ByteBufferEncoder.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ByteBufferEncoder.java:9"$0$" *"
"ByteBufferEncoder.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ByteBufferEncoder.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ByteBufferEncoder.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ByteBufferEncoder.java:13"$0$" * See the License for the specific language governing permissions and"
"ByteBufferEncoder.java:14"$0$" * limitations under the License."
"ByteBufferEncoder.java:15"$0$" */"
"ByteBufferEncoder.java:16"$0$""
"ByteBufferEncoder.java:17"$0$"package org.springframework.core.codec;"
"ByteBufferEncoder.java:18"$0$""
"ByteBufferEncoder.java:19"$0$"import java.nio.ByteBuffer;"
"ByteBufferEncoder.java:20"$0$"import java.util.Map;"
"ByteBufferEncoder.java:21"$0$""
"ByteBufferEncoder.java:22"$0$"import org.reactivestreams.Publisher;"
"ByteBufferEncoder.java:23"$0$"import reactor.core.publisher.Flux;"
"ByteBufferEncoder.java:24"$0$""
"ByteBufferEncoder.java:25"$0$"import org.springframework.core.ResolvableType;"
"ByteBufferEncoder.java:26"$0$"import org.springframework.core.io.buffer.DataBuffer;"
"ByteBufferEncoder.java:27"$0$"import org.springframework.core.io.buffer.DataBufferFactory;"
"ByteBufferEncoder.java:28"$0$"import org.springframework.lang.Nullable;"
"ByteBufferEncoder.java:29"$0$"import org.springframework.util.MimeType;"
"ByteBufferEncoder.java:30"$0$"import org.springframework.util.MimeTypeUtils;"
"ByteBufferEncoder.java:31"$0$""
"ByteBufferEncoder.java:32"$0$"/**"
"ByteBufferEncoder.java:33"$1$" * Encoder for {@link ByteBuffer ByteBuffers}."
"ByteBufferEncoder.java:34"$0$" *"
"ByteBufferEncoder.java:35"$0$" * @author Sebastien Deleuze"
"ByteBufferEncoder.java:36"$0$" * @since 5.0"
"ByteBufferEncoder.java:37"$0$" */"
"ByteBufferEncoder.java:38"$1$"public class ByteBufferEncoder extends AbstractEncoder<ByteBuffer> {"
"ByteBufferEncoder.java:39"$1$""
"ByteBufferEncoder.java:40"$1$"	public ByteBufferEncoder() {"
"ByteBufferEncoder.java:41"$1$"		super(MimeTypeUtils.ALL);"
"ByteBufferEncoder.java:42"$1$"	}"
"ByteBufferEncoder.java:43"$0$""
"ByteBufferEncoder.java:44"$0$""
"ByteBufferEncoder.java:45"$0$"	@Override"
"ByteBufferEncoder.java:46"$1$"	public boolean canEncode(ResolvableType elementType, @Nullable MimeType mimeType) {"
"ByteBufferEncoder.java:47"$1$"		Class<?> clazz = elementType.toClass();"
"ByteBufferEncoder.java:48"$1$"		return super.canEncode(elementType, mimeType) && ByteBuffer.class.isAssignableFrom(clazz);"
"ByteBufferEncoder.java:49"$1$"	}"
"ByteBufferEncoder.java:50"$0$""
"ByteBufferEncoder.java:51"$0$"	@Override"
"ByteBufferEncoder.java:52"$0$"	public Flux<DataBuffer> encode(Publisher<? extends ByteBuffer> inputStream,"
"ByteBufferEncoder.java:53"$0$"			DataBufferFactory bufferFactory, ResolvableType elementType, @Nullable MimeType mimeType,"
"ByteBufferEncoder.java:54"$1$"			@Nullable Map<String, Object> hints) {"
"ByteBufferEncoder.java:55"$1$""
"ByteBufferEncoder.java:56"$1$"		return Flux.from(inputStream).map(byteBuffer ->"
"ByteBufferEncoder.java:57"$1$"				encodeValue(byteBuffer, bufferFactory, elementType, mimeType, hints));"
"ByteBufferEncoder.java:58"$1$"	}"
"ByteBufferEncoder.java:59"$0$""
"ByteBufferEncoder.java:60"$0$"	@Override"
"ByteBufferEncoder.java:61"$0$"	public DataBuffer encodeValue(ByteBuffer byteBuffer, DataBufferFactory bufferFactory,"
"ByteBufferEncoder.java:62"$1$"			ResolvableType valueType, @Nullable MimeType mimeType, @Nullable Map<String, Object> hints) {"
"ByteBufferEncoder.java:63"$1$""
"ByteBufferEncoder.java:64"$1$"		DataBuffer dataBuffer = bufferFactory.wrap(byteBuffer);"
"ByteBufferEncoder.java:65"$1$"		if (logger.isDebugEnabled() && !Hints.isLoggingSuppressed(hints)) {"
"ByteBufferEncoder.java:66"$1$"			String logPrefix = Hints.getLogPrefix(hints);"
"ByteBufferEncoder.java:67"$1$"			logger.debug(logPrefix + ""Writing "" + dataBuffer.readableByteCount() + "" bytes"");"
"ByteBufferEncoder.java:68"$1$"		}"
"ByteBufferEncoder.java:69"$0$"		return dataBuffer;"
"ByteBufferEncoder.java:70"$0$"	}"
"ByteBufferEncoder.java:71"$0$""
"ByteBufferEncoder.java:72"$0$"}"
"TypeMappedAnnotation.java:1"$0$"/*"
"TypeMappedAnnotation.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"TypeMappedAnnotation.java:3"$0$" *"
"TypeMappedAnnotation.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"TypeMappedAnnotation.java:5"$0$" * you may not use this file except in compliance with the License."
"TypeMappedAnnotation.java:6"$0$" * You may obtain a copy of the License at"
"TypeMappedAnnotation.java:7"$0$" *"
"TypeMappedAnnotation.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"TypeMappedAnnotation.java:9"$0$" *"
"TypeMappedAnnotation.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"TypeMappedAnnotation.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"TypeMappedAnnotation.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"TypeMappedAnnotation.java:13"$0$" * See the License for the specific language governing permissions and"
"TypeMappedAnnotation.java:14"$0$" * limitations under the License."
"TypeMappedAnnotation.java:15"$0$" */"
"TypeMappedAnnotation.java:16"$0$""
"TypeMappedAnnotation.java:17"$0$"package org.springframework.core.annotation;"
"TypeMappedAnnotation.java:18"$0$""
"TypeMappedAnnotation.java:19"$0$"import java.lang.annotation.Annotation;"
"TypeMappedAnnotation.java:20"$0$"import java.lang.reflect.Array;"
"TypeMappedAnnotation.java:21"$0$"import java.lang.reflect.Member;"
"TypeMappedAnnotation.java:22"$0$"import java.lang.reflect.Method;"
"TypeMappedAnnotation.java:23"$0$"import java.util.Collections;"
"TypeMappedAnnotation.java:24"$0$"import java.util.HashMap;"
"TypeMappedAnnotation.java:25"$0$"import java.util.LinkedHashMap;"
"TypeMappedAnnotation.java:26"$0$"import java.util.List;"
"TypeMappedAnnotation.java:27"$0$"import java.util.Map;"
"TypeMappedAnnotation.java:28"$0$"import java.util.NoSuchElementException;"
"TypeMappedAnnotation.java:29"$0$"import java.util.Optional;"
"TypeMappedAnnotation.java:30"$0$"import java.util.function.Function;"
"TypeMappedAnnotation.java:31"$0$"import java.util.function.Predicate;"
"TypeMappedAnnotation.java:32"$0$""
"TypeMappedAnnotation.java:33"$0$"import org.springframework.lang.Nullable;"
"TypeMappedAnnotation.java:34"$0$"import org.springframework.util.Assert;"
"TypeMappedAnnotation.java:35"$0$"import org.springframework.util.ClassUtils;"
"TypeMappedAnnotation.java:36"$0$"import org.springframework.util.ReflectionUtils;"
"TypeMappedAnnotation.java:37"$0$""
"TypeMappedAnnotation.java:38"$0$"/**"
"TypeMappedAnnotation.java:39"$1$" * {@link MergedAnnotation} that adapts attributes from a root annotation by"
"TypeMappedAnnotation.java:40"$1$" * applying the mapping and mirroring rules of an {@link AnnotationTypeMapping}."
"TypeMappedAnnotation.java:41"$0$" *"
"TypeMappedAnnotation.java:42"$0$" * <p>Root attribute values are extracted from a source object using a supplied"
"TypeMappedAnnotation.java:43"$1$" * {@code BiFunction}. This allows various different annotation models to be"
"TypeMappedAnnotation.java:44"$0$" * supported by the same class. For example, the attributes source might be an"
"TypeMappedAnnotation.java:45"$1$" * actual {@link Annotation} instance where methods on the annotation instance"
"TypeMappedAnnotation.java:46"$1$" * are {@linkplain ReflectionUtils#invokeMethod(Method, Object) invoked} to extract"
"TypeMappedAnnotation.java:47"$1$" * values. Equally, the source could be a simple {@link Map} with values"
"TypeMappedAnnotation.java:48"$1$" * extracted using {@link Map#get(Object)}."
"TypeMappedAnnotation.java:49"$0$" *"
"TypeMappedAnnotation.java:50"$0$" * <p>Extracted root attribute values must be compatible with the attribute"
"TypeMappedAnnotation.java:51"$0$" * return type, namely:"
"TypeMappedAnnotation.java:52"$0$" *"
"TypeMappedAnnotation.java:53"$0$" * <p><table border=""1"">"
"TypeMappedAnnotation.java:54"$0$" * <tr><th>Return Type</th><th>Extracted Type</th></tr>"
"TypeMappedAnnotation.java:55"$0$" * <tr><td>Class</td><td>Class or String</td></tr>"
"TypeMappedAnnotation.java:56"$0$" * <tr><td>Class[]</td><td>Class[] or String[]</td></tr>"
"TypeMappedAnnotation.java:57"$0$" * <tr><td>Annotation</td><td>Annotation, Map, or Object compatible with the value"
"TypeMappedAnnotation.java:58"$0$" * extractor</td></tr>"
"TypeMappedAnnotation.java:59"$0$" * <tr><td>Annotation[]</td><td>Annotation[], Map[], or Object[] where elements are"
"TypeMappedAnnotation.java:60"$0$" * compatible with the value extractor</td></tr>"
"TypeMappedAnnotation.java:61"$0$" * <tr><td>Other types</td><td>An exact match or the appropriate primitive wrapper</td></tr>"
"TypeMappedAnnotation.java:62"$0$" * </table>"
"TypeMappedAnnotation.java:63"$0$" *"
"TypeMappedAnnotation.java:64"$0$" * @author Phillip Webb"
"TypeMappedAnnotation.java:65"$0$" * @author Juergen Hoeller"
"TypeMappedAnnotation.java:66"$0$" * @author Sam Brannen"
"TypeMappedAnnotation.java:67"$0$" * @since 5.2"
"TypeMappedAnnotation.java:68"$0$" * @param <A> the annotation type"
"TypeMappedAnnotation.java:69"$0$" * @see TypeMappedAnnotations"
"TypeMappedAnnotation.java:70"$0$" */"
"TypeMappedAnnotation.java:71"$1$"final class TypeMappedAnnotation<A extends Annotation> extends AbstractMergedAnnotation<A> {"
"TypeMappedAnnotation.java:72"$1$""
"TypeMappedAnnotation.java:73"$1$"	private static final Map<Class<?>, Object> EMPTY_ARRAYS;"
"TypeMappedAnnotation.java:74"$1$"	static {"
"TypeMappedAnnotation.java:75"$1$"		Map<Class<?>, Object> emptyArrays = new HashMap<>();"
"TypeMappedAnnotation.java:76"$1$"		emptyArrays.put(String.class, new String[] {});"
"TypeMappedAnnotation.java:77"$1$"		emptyArrays.put(boolean.class, new boolean[] {});"
"TypeMappedAnnotation.java:78"$1$"		emptyArrays.put(byte.class, new byte[] {});"
"TypeMappedAnnotation.java:79"$1$"		emptyArrays.put(char.class, new char[] {});"
"TypeMappedAnnotation.java:80"$1$"		emptyArrays.put(double.class, new double[] {});"
"TypeMappedAnnotation.java:81"$1$"		emptyArrays.put(float.class, new float[] {});"
"TypeMappedAnnotation.java:82"$1$"		emptyArrays.put(int.class, new int[] {});"
"TypeMappedAnnotation.java:83"$1$"		emptyArrays.put(long.class, new long[] {});"
"TypeMappedAnnotation.java:84"$1$"		emptyArrays.put(short.class, new short[] {});"
"TypeMappedAnnotation.java:85"$1$"		EMPTY_ARRAYS = Collections.unmodifiableMap(emptyArrays);"
"TypeMappedAnnotation.java:86"$1$"	}"
"TypeMappedAnnotation.java:87"$0$""
"TypeMappedAnnotation.java:88"$0$"	private final AnnotationTypeMapping mapping;"
"TypeMappedAnnotation.java:89"$0$""
"TypeMappedAnnotation.java:90"$0$"	@Nullable"
"TypeMappedAnnotation.java:91"$0$"	private final ClassLoader classLoader;"
"TypeMappedAnnotation.java:92"$0$""
"TypeMappedAnnotation.java:93"$0$"	@Nullable"
"TypeMappedAnnotation.java:94"$0$"	private final Object source;"
"TypeMappedAnnotation.java:95"$0$""
"TypeMappedAnnotation.java:96"$0$"	@Nullable"
"TypeMappedAnnotation.java:97"$0$"	private final Object rootAttributes;"
"TypeMappedAnnotation.java:98"$0$""
"TypeMappedAnnotation.java:99"$0$"	private final ValueExtractor valueExtractor;"
"TypeMappedAnnotation.java:100"$0$""
"TypeMappedAnnotation.java:101"$0$"	private final int aggregateIndex;"
"TypeMappedAnnotation.java:102"$0$""
"TypeMappedAnnotation.java:103"$0$"	private final boolean useMergedValues;"
"TypeMappedAnnotation.java:104"$0$""
"TypeMappedAnnotation.java:105"$0$"	@Nullable"
"TypeMappedAnnotation.java:106"$0$"	private final Predicate<String> attributeFilter;"
"TypeMappedAnnotation.java:107"$0$""
"TypeMappedAnnotation.java:108"$0$"	private final int[] resolvedRootMirrors;"
"TypeMappedAnnotation.java:109"$0$""
"TypeMappedAnnotation.java:110"$0$"	private final int[] resolvedMirrors;"
"TypeMappedAnnotation.java:111"$0$""
"TypeMappedAnnotation.java:112"$0$"	@Nullable"
"TypeMappedAnnotation.java:113"$0$"	private String string;"
"TypeMappedAnnotation.java:114"$0$""
"TypeMappedAnnotation.java:115"$0$""
"TypeMappedAnnotation.java:116"$0$"	private TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,"
"TypeMappedAnnotation.java:117"$0$"			@Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor,"
"TypeMappedAnnotation.java:118"$1$"			int aggregateIndex) {"
"TypeMappedAnnotation.java:119"$1$""
"TypeMappedAnnotation.java:120"$1$"		this(mapping, classLoader, source, rootAttributes, valueExtractor, aggregateIndex, null);"
"TypeMappedAnnotation.java:121"$1$"	}"
"TypeMappedAnnotation.java:122"$0$""
"TypeMappedAnnotation.java:123"$0$"	private TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,"
"TypeMappedAnnotation.java:124"$0$"			@Nullable Object source, @Nullable Object rootAttributes, ValueExtractor valueExtractor,"
"TypeMappedAnnotation.java:125"$1$"			int aggregateIndex, @Nullable int[] resolvedRootMirrors) {"
"TypeMappedAnnotation.java:126"$1$""
"TypeMappedAnnotation.java:127"$1$"		this.mapping = mapping;"
"TypeMappedAnnotation.java:128"$1$"		this.classLoader = classLoader;"
"TypeMappedAnnotation.java:129"$1$"		this.source = source;"
"TypeMappedAnnotation.java:130"$1$"		this.rootAttributes = rootAttributes;"
"TypeMappedAnnotation.java:131"$1$"		this.valueExtractor = valueExtractor;"
"TypeMappedAnnotation.java:132"$1$"		this.aggregateIndex = aggregateIndex;"
"TypeMappedAnnotation.java:133"$1$"		this.useMergedValues = true;"
"TypeMappedAnnotation.java:134"$1$"		this.attributeFilter = null;"
"TypeMappedAnnotation.java:135"$1$"		this.resolvedRootMirrors = (resolvedRootMirrors != null ? resolvedRootMirrors :"
"TypeMappedAnnotation.java:136"$1$"				mapping.getRoot().getMirrorSets().resolve(source, rootAttributes, this.valueExtractor));"
"TypeMappedAnnotation.java:137"$1$"		this.resolvedMirrors = (getDistance() == 0 ? this.resolvedRootMirrors :"
"TypeMappedAnnotation.java:138"$1$"				mapping.getMirrorSets().resolve(source, this, this::getValueForMirrorResolution));"
"TypeMappedAnnotation.java:139"$1$"	}"
"TypeMappedAnnotation.java:140"$0$""
"TypeMappedAnnotation.java:141"$0$"	private TypeMappedAnnotation(AnnotationTypeMapping mapping, @Nullable ClassLoader classLoader,"
"TypeMappedAnnotation.java:142"$0$"			@Nullable Object source, @Nullable Object rootAnnotation, ValueExtractor valueExtractor,"
"TypeMappedAnnotation.java:143"$0$"			int aggregateIndex, boolean useMergedValues, @Nullable Predicate<String> attributeFilter,"
"TypeMappedAnnotation.java:144"$1$"			int[] resolvedRootMirrors, int[] resolvedMirrors) {"
"TypeMappedAnnotation.java:145"$1$""
"TypeMappedAnnotation.java:146"$1$"		this.classLoader = classLoader;"
"TypeMappedAnnotation.java:147"$1$"		this.source = source;"
"TypeMappedAnnotation.java:148"$1$"		this.rootAttributes = rootAnnotation;"
"TypeMappedAnnotation.java:149"$1$"		this.valueExtractor = valueExtractor;"
"TypeMappedAnnotation.java:150"$1$"		this.mapping = mapping;"
"TypeMappedAnnotation.java:151"$1$"		this.aggregateIndex = aggregateIndex;"
"TypeMappedAnnotation.java:152"$1$"		this.useMergedValues = useMergedValues;"
"TypeMappedAnnotation.java:153"$1$"		this.attributeFilter = attributeFilter;"
"TypeMappedAnnotation.java:154"$1$"		this.resolvedRootMirrors = resolvedRootMirrors;"
"TypeMappedAnnotation.java:155"$1$"		this.resolvedMirrors = resolvedMirrors;"
"TypeMappedAnnotation.java:156"$1$"	}"
"TypeMappedAnnotation.java:157"$0$""
"TypeMappedAnnotation.java:158"$0$""
"TypeMappedAnnotation.java:159"$0$"	@Override"
"TypeMappedAnnotation.java:160"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:161"$1$"	public Class<A> getType() {"
"TypeMappedAnnotation.java:162"$1$"		return (Class<A>) this.mapping.getAnnotationType();"
"TypeMappedAnnotation.java:163"$1$"	}"
"TypeMappedAnnotation.java:164"$0$""
"TypeMappedAnnotation.java:165"$0$"	@Override"
"TypeMappedAnnotation.java:166"$1$"	public List<Class<? extends Annotation>> getMetaTypes() {"
"TypeMappedAnnotation.java:167"$1$"		return this.mapping.getMetaTypes();"
"TypeMappedAnnotation.java:168"$1$"	}"
"TypeMappedAnnotation.java:169"$0$""
"TypeMappedAnnotation.java:170"$0$"	@Override"
"TypeMappedAnnotation.java:171"$1$"	public boolean isPresent() {"
"TypeMappedAnnotation.java:172"$1$"		return true;"
"TypeMappedAnnotation.java:173"$1$"	}"
"TypeMappedAnnotation.java:174"$0$""
"TypeMappedAnnotation.java:175"$0$"	@Override"
"TypeMappedAnnotation.java:176"$1$"	public int getDistance() {"
"TypeMappedAnnotation.java:177"$1$"		return this.mapping.getDistance();"
"TypeMappedAnnotation.java:178"$1$"	}"
"TypeMappedAnnotation.java:179"$0$""
"TypeMappedAnnotation.java:180"$0$"	@Override"
"TypeMappedAnnotation.java:181"$1$"	public int getAggregateIndex() {"
"TypeMappedAnnotation.java:182"$1$"		return this.aggregateIndex;"
"TypeMappedAnnotation.java:183"$1$"	}"
"TypeMappedAnnotation.java:184"$0$""
"TypeMappedAnnotation.java:185"$0$"	@Override"
"TypeMappedAnnotation.java:186"$0$"	@Nullable"
"TypeMappedAnnotation.java:187"$1$"	public Object getSource() {"
"TypeMappedAnnotation.java:188"$1$"		return this.source;"
"TypeMappedAnnotation.java:189"$1$"	}"
"TypeMappedAnnotation.java:190"$0$""
"TypeMappedAnnotation.java:191"$0$"	@Override"
"TypeMappedAnnotation.java:192"$0$"	@Nullable"
"TypeMappedAnnotation.java:193"$1$"	public MergedAnnotation<?> getMetaSource() {"
"TypeMappedAnnotation.java:194"$1$"		AnnotationTypeMapping metaSourceMapping = this.mapping.getSource();"
"TypeMappedAnnotation.java:195"$1$"		if (metaSourceMapping == null) {"
"TypeMappedAnnotation.java:196"$1$"			return null;"
"TypeMappedAnnotation.java:197"$1$"		}"
"TypeMappedAnnotation.java:198"$0$"		return new TypeMappedAnnotation<>(metaSourceMapping, this.classLoader, this.source,"
"TypeMappedAnnotation.java:199"$0$"				this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);"
"TypeMappedAnnotation.java:200"$0$"	}"
"TypeMappedAnnotation.java:201"$0$""
"TypeMappedAnnotation.java:202"$0$"	@Override"
"TypeMappedAnnotation.java:203"$1$"	public MergedAnnotation<?> getRoot() {"
"TypeMappedAnnotation.java:204"$1$"		if (getDistance() == 0) {"
"TypeMappedAnnotation.java:205"$1$"			return this;"
"TypeMappedAnnotation.java:206"$1$"		}"
"TypeMappedAnnotation.java:207"$0$"		AnnotationTypeMapping rootMapping = this.mapping.getRoot();"
"TypeMappedAnnotation.java:208"$0$"		return new TypeMappedAnnotation<>(rootMapping, this.classLoader, this.source,"
"TypeMappedAnnotation.java:209"$0$"				this.rootAttributes, this.valueExtractor, this.aggregateIndex, this.resolvedRootMirrors);"
"TypeMappedAnnotation.java:210"$0$"	}"
"TypeMappedAnnotation.java:211"$0$""
"TypeMappedAnnotation.java:212"$0$"	@Override"
"TypeMappedAnnotation.java:213"$1$"	public boolean hasDefaultValue(String attributeName) {"
"TypeMappedAnnotation.java:214"$1$"		int attributeIndex = getAttributeIndex(attributeName, true);"
"TypeMappedAnnotation.java:215"$1$"		Object value = getValue(attributeIndex, true, false);"
"TypeMappedAnnotation.java:216"$1$"		return (value == null || this.mapping.isEquivalentToDefaultValue(attributeIndex, value, this.valueExtractor));"
"TypeMappedAnnotation.java:217"$1$"	}"
"TypeMappedAnnotation.java:218"$0$""
"TypeMappedAnnotation.java:219"$0$"	@Override"
"TypeMappedAnnotation.java:220"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:221"$0$"	public <T extends Annotation> MergedAnnotation<T> getAnnotation(String attributeName, Class<T> type)"
"TypeMappedAnnotation.java:222"$1$"			throws NoSuchElementException {"
"TypeMappedAnnotation.java:223"$1$""
"TypeMappedAnnotation.java:224"$1$"		int attributeIndex = getAttributeIndex(attributeName, true);"
"TypeMappedAnnotation.java:225"$1$"		Method attribute = this.mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:226"$1$"		Assert.notNull(type, ""Type must not be null"");"
"TypeMappedAnnotation.java:227"$1$"		Assert.isAssignable(type, attribute.getReturnType(),"
"TypeMappedAnnotation.java:228"$1$"				() -> ""Attribute "" + attributeName + "" type mismatch:"");"
"TypeMappedAnnotation.java:229"$1$"		return (MergedAnnotation<T>) getRequiredValue(attributeIndex, attributeName);"
"TypeMappedAnnotation.java:230"$1$"	}"
"TypeMappedAnnotation.java:231"$0$""
"TypeMappedAnnotation.java:232"$0$"	@Override"
"TypeMappedAnnotation.java:233"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:234"$0$"	public <T extends Annotation> MergedAnnotation<T>[] getAnnotationArray("
"TypeMappedAnnotation.java:235"$1$"			String attributeName, Class<T> type) throws NoSuchElementException {"
"TypeMappedAnnotation.java:236"$1$""
"TypeMappedAnnotation.java:237"$1$"		int attributeIndex = getAttributeIndex(attributeName, true);"
"TypeMappedAnnotation.java:238"$1$"		Method attribute = this.mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:239"$1$"		Class<?> componentType = attribute.getReturnType().getComponentType();"
"TypeMappedAnnotation.java:240"$1$"		Assert.notNull(type, ""Type must not be null"");"
"TypeMappedAnnotation.java:241"$1$"		Assert.notNull(componentType, () -> ""Attribute "" + attributeName + "" is not an array"");"
"TypeMappedAnnotation.java:242"$1$"		Assert.isAssignable(type, componentType, () -> ""Attribute "" + attributeName + "" component type mismatch:"");"
"TypeMappedAnnotation.java:243"$1$"		return (MergedAnnotation<T>[]) getRequiredValue(attributeIndex, attributeName);"
"TypeMappedAnnotation.java:244"$1$"	}"
"TypeMappedAnnotation.java:245"$0$""
"TypeMappedAnnotation.java:246"$0$"	@Override"
"TypeMappedAnnotation.java:247"$1$"	public <T> Optional<T> getDefaultValue(String attributeName, Class<T> type) {"
"TypeMappedAnnotation.java:248"$1$"		int attributeIndex = getAttributeIndex(attributeName, false);"
"TypeMappedAnnotation.java:249"$1$"		if (attributeIndex == -1) {"
"TypeMappedAnnotation.java:250"$1$"			return Optional.empty();"
"TypeMappedAnnotation.java:251"$1$"		}"
"TypeMappedAnnotation.java:252"$0$"		Method attribute = this.mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:253"$0$"		return Optional.ofNullable(adapt(attribute, attribute.getDefaultValue(), type));"
"TypeMappedAnnotation.java:254"$0$"	}"
"TypeMappedAnnotation.java:255"$0$""
"TypeMappedAnnotation.java:256"$0$"	@Override"
"TypeMappedAnnotation.java:257"$1$"	public MergedAnnotation<A> filterAttributes(Predicate<String> predicate) {"
"TypeMappedAnnotation.java:258"$1$"		if (this.attributeFilter != null) {"
"TypeMappedAnnotation.java:259"$1$"			predicate = this.attributeFilter.and(predicate);"
"TypeMappedAnnotation.java:260"$1$"		}"
"TypeMappedAnnotation.java:261"$0$"		return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes,"
"TypeMappedAnnotation.java:262"$0$"				this.valueExtractor, this.aggregateIndex, this.useMergedValues, predicate,"
"TypeMappedAnnotation.java:263"$0$"				this.resolvedRootMirrors, this.resolvedMirrors);"
"TypeMappedAnnotation.java:264"$0$"	}"
"TypeMappedAnnotation.java:265"$0$""
"TypeMappedAnnotation.java:266"$0$"	@Override"
"TypeMappedAnnotation.java:267"$1$"	public MergedAnnotation<A> withNonMergedAttributes() {"
"TypeMappedAnnotation.java:268"$1$"		return new TypeMappedAnnotation<>(this.mapping, this.classLoader, this.source, this.rootAttributes,"
"TypeMappedAnnotation.java:269"$1$"				this.valueExtractor, this.aggregateIndex, false, this.attributeFilter,"
"TypeMappedAnnotation.java:270"$1$"				this.resolvedRootMirrors, this.resolvedMirrors);"
"TypeMappedAnnotation.java:271"$1$"	}"
"TypeMappedAnnotation.java:272"$0$""
"TypeMappedAnnotation.java:273"$0$"	@Override"
"TypeMappedAnnotation.java:274"$1$"	public Map<String, Object> asMap(Adapt... adaptations) {"
"TypeMappedAnnotation.java:275"$1$"		return Collections.unmodifiableMap(asMap(mergedAnnotation -> new LinkedHashMap<>(), adaptations));"
"TypeMappedAnnotation.java:276"$1$"	}"
"TypeMappedAnnotation.java:277"$0$""
"TypeMappedAnnotation.java:278"$0$"	@Override"
"TypeMappedAnnotation.java:279"$1$"	public <T extends Map<String, Object>> T asMap(Function<MergedAnnotation<?>, T> factory, Adapt... adaptations) {"
"TypeMappedAnnotation.java:280"$1$"		T map = factory.apply(this);"
"TypeMappedAnnotation.java:281"$1$"		Assert.state(map != null, ""Factory used to create MergedAnnotation Map must not return null"");"
"TypeMappedAnnotation.java:282"$1$"		AttributeMethods attributes = this.mapping.getAttributes();"
"TypeMappedAnnotation.java:283"$1$"		for (int i = 0; i < attributes.size(); i++) {"
"TypeMappedAnnotation.java:284"$1$"			Method attribute = attributes.get(i);"
"TypeMappedAnnotation.java:285"$1$"			Object value = (isFiltered(attribute.getName()) ? null :"
"TypeMappedAnnotation.java:286"$1$"					getValue(i, getTypeForMapOptions(attribute, adaptations)));"
"TypeMappedAnnotation.java:287"$1$"			if (value != null) {"
"TypeMappedAnnotation.java:288"$1$"				map.put(attribute.getName(),"
"TypeMappedAnnotation.java:289"$1$"						adaptValueForMapOptions(attribute, value, map.getClass(), factory, adaptations));"
"TypeMappedAnnotation.java:290"$1$"			}"
"TypeMappedAnnotation.java:291"$0$"		}"
"TypeMappedAnnotation.java:292"$0$"		return map;"
"TypeMappedAnnotation.java:293"$0$"	}"
"TypeMappedAnnotation.java:294"$0$""
"TypeMappedAnnotation.java:295"$1$"	private Class<?> getTypeForMapOptions(Method attribute, Adapt[] adaptations) {"
"TypeMappedAnnotation.java:296"$1$"		Class<?> attributeType = attribute.getReturnType();"
"TypeMappedAnnotation.java:297"$1$"		Class<?> componentType = (attributeType.isArray() ? attributeType.getComponentType() : attributeType);"
"TypeMappedAnnotation.java:298"$1$"		if (Adapt.CLASS_TO_STRING.isIn(adaptations) && componentType == Class.class) {"
"TypeMappedAnnotation.java:299"$1$"			return (attributeType.isArray() ? String[].class : String.class);"
"TypeMappedAnnotation.java:300"$1$"		}"
"TypeMappedAnnotation.java:301"$0$"		return Object.class;"
"TypeMappedAnnotation.java:302"$0$"	}"
"TypeMappedAnnotation.java:303"$0$""
"TypeMappedAnnotation.java:304"$0$"	private <T extends Map<String, Object>> Object adaptValueForMapOptions(Method attribute, Object value,"
"TypeMappedAnnotation.java:305"$1$"			Class<?> mapType, Function<MergedAnnotation<?>, T> factory, Adapt[] adaptations) {"
"TypeMappedAnnotation.java:306"$1$""
"TypeMappedAnnotation.java:307"$1$"		if (value instanceof MergedAnnotation) {"
"TypeMappedAnnotation.java:308"$1$"			MergedAnnotation<?> annotation = (MergedAnnotation<?>) value;"
"TypeMappedAnnotation.java:309"$1$"			return (Adapt.ANNOTATION_TO_MAP.isIn(adaptations) ?"
"TypeMappedAnnotation.java:310"$1$"					annotation.asMap(factory, adaptations) : annotation.synthesize());"
"TypeMappedAnnotation.java:311"$1$"		}"
"TypeMappedAnnotation.java:312"$1$"		if (value instanceof MergedAnnotation[]) {"
"TypeMappedAnnotation.java:313"$1$"			MergedAnnotation<?>[] annotations = (MergedAnnotation<?>[]) value;"
"TypeMappedAnnotation.java:314"$1$"			if (Adapt.ANNOTATION_TO_MAP.isIn(adaptations)) {"
"TypeMappedAnnotation.java:315"$1$"				Object result = Array.newInstance(mapType, annotations.length);"
"TypeMappedAnnotation.java:316"$1$"				for (int i = 0; i < annotations.length; i++) {"
"TypeMappedAnnotation.java:317"$1$"					Array.set(result, i, annotations[i].asMap(factory, adaptations));"
"TypeMappedAnnotation.java:318"$1$"				}"
"TypeMappedAnnotation.java:319"$0$"				return result;"
"TypeMappedAnnotation.java:320"$0$"			}"
"TypeMappedAnnotation.java:321"$0$"			Object result = Array.newInstance("
"TypeMappedAnnotation.java:322"$0$"					attribute.getReturnType().getComponentType(), annotations.length);"
"TypeMappedAnnotation.java:323"$1$"			for (int i = 0; i < annotations.length; i++) {"
"TypeMappedAnnotation.java:324"$1$"				Array.set(result, i, annotations[i].synthesize());"
"TypeMappedAnnotation.java:325"$1$"			}"
"TypeMappedAnnotation.java:326"$0$"			return result;"
"TypeMappedAnnotation.java:327"$0$"		}"
"TypeMappedAnnotation.java:328"$0$"		return value;"
"TypeMappedAnnotation.java:329"$0$"	}"
"TypeMappedAnnotation.java:330"$0$""
"TypeMappedAnnotation.java:331"$0$"	@Override"
"TypeMappedAnnotation.java:332"$1$"	protected A createSynthesized() {"
"TypeMappedAnnotation.java:333"$1$"		return SynthesizedMergedAnnotationInvocationHandler.createProxy(this, getType());"
"TypeMappedAnnotation.java:334"$1$"	}"
"TypeMappedAnnotation.java:335"$0$""
"TypeMappedAnnotation.java:336"$0$"	@Override"
"TypeMappedAnnotation.java:337"$1$"	public String toString() {"
"TypeMappedAnnotation.java:338"$1$"		String string = this.string;"
"TypeMappedAnnotation.java:339"$1$"		if (string == null) {"
"TypeMappedAnnotation.java:340"$1$"			StringBuilder builder = new StringBuilder();"
"TypeMappedAnnotation.java:341"$1$"			builder.append(""@"");"
"TypeMappedAnnotation.java:342"$1$"			builder.append(getType().getName());"
"TypeMappedAnnotation.java:343"$1$"			builder.append(""("");"
"TypeMappedAnnotation.java:344"$1$"			for (int i = 0; i < this.mapping.getAttributes().size(); i++) {"
"TypeMappedAnnotation.java:345"$1$"				Method attribute = this.mapping.getAttributes().get(i);"
"TypeMappedAnnotation.java:346"$1$"				builder.append(i == 0 ? """" : "", "");"
"TypeMappedAnnotation.java:347"$1$"				builder.append(attribute.getName());"
"TypeMappedAnnotation.java:348"$1$"				builder.append(""="");"
"TypeMappedAnnotation.java:349"$1$"				builder.append(toString(getValue(i, Object.class)));"
"TypeMappedAnnotation.java:350"$1$"			}"
"TypeMappedAnnotation.java:351"$0$"			builder.append("")"");"
"TypeMappedAnnotation.java:352"$0$"			string = builder.toString();"
"TypeMappedAnnotation.java:353"$0$"			this.string = string;"
"TypeMappedAnnotation.java:354"$0$"		}"
"TypeMappedAnnotation.java:355"$0$"		return string;"
"TypeMappedAnnotation.java:356"$0$"	}"
"TypeMappedAnnotation.java:357"$0$""
"TypeMappedAnnotation.java:358"$1$"	private Object toString(@Nullable Object value) {"
"TypeMappedAnnotation.java:359"$1$"		if (value == null) {"
"TypeMappedAnnotation.java:360"$1$"			return """";"
"TypeMappedAnnotation.java:361"$1$"		}"
"TypeMappedAnnotation.java:362"$1$"		if (value instanceof Class) {"
"TypeMappedAnnotation.java:363"$1$"			return ((Class<?>) value).getName();"
"TypeMappedAnnotation.java:364"$1$"		}"
"TypeMappedAnnotation.java:365"$1$"		if (value.getClass().isArray()) {"
"TypeMappedAnnotation.java:366"$1$"			StringBuilder builder = new StringBuilder();"
"TypeMappedAnnotation.java:367"$1$"			builder.append(""["");"
"TypeMappedAnnotation.java:368"$1$"			for (int i = 0; i < Array.getLength(value); i++) {"
"TypeMappedAnnotation.java:369"$1$"				builder.append(i == 0 ? """" : "", "");"
"TypeMappedAnnotation.java:370"$1$"				builder.append(toString(Array.get(value, i)));"
"TypeMappedAnnotation.java:371"$1$"			}"
"TypeMappedAnnotation.java:372"$0$"			builder.append(""]"");"
"TypeMappedAnnotation.java:373"$0$"			return builder.toString();"
"TypeMappedAnnotation.java:374"$0$"		}"
"TypeMappedAnnotation.java:375"$0$"		return String.valueOf(value);"
"TypeMappedAnnotation.java:376"$0$"	}"
"TypeMappedAnnotation.java:377"$0$""
"TypeMappedAnnotation.java:378"$0$"	@Override"
"TypeMappedAnnotation.java:379"$0$"	@Nullable"
"TypeMappedAnnotation.java:380"$1$"	protected <T> T getAttributeValue(String attributeName, Class<T> type) {"
"TypeMappedAnnotation.java:381"$1$"		int attributeIndex = getAttributeIndex(attributeName, false);"
"TypeMappedAnnotation.java:382"$1$"		return (attributeIndex != -1 ? getValue(attributeIndex, type) : null);"
"TypeMappedAnnotation.java:383"$1$"	}"
"TypeMappedAnnotation.java:384"$0$""
"TypeMappedAnnotation.java:385"$1$"	private Object getRequiredValue(int attributeIndex, String attributeName) {"
"TypeMappedAnnotation.java:386"$1$"		Object value = getValue(attributeIndex, Object.class);"
"TypeMappedAnnotation.java:387"$1$"		if (value == null) {"
"TypeMappedAnnotation.java:388"$1$"			throw new NoSuchElementException(""No element at attribute index """
"TypeMappedAnnotation.java:389"$1$"					+ attributeIndex + "" for name "" + attributeName);"
"TypeMappedAnnotation.java:390"$1$"		}"
"TypeMappedAnnotation.java:391"$0$"		return value;"
"TypeMappedAnnotation.java:392"$0$"	}"
"TypeMappedAnnotation.java:393"$0$""
"TypeMappedAnnotation.java:394"$0$"	@Nullable"
"TypeMappedAnnotation.java:395"$1$"	private <T> T getValue(int attributeIndex, Class<T> type) {"
"TypeMappedAnnotation.java:396"$1$"		Method attribute = this.mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:397"$1$"		Object value = getValue(attributeIndex, true, false);"
"TypeMappedAnnotation.java:398"$1$"		if (value == null) {"
"TypeMappedAnnotation.java:399"$1$"			value = attribute.getDefaultValue();"
"TypeMappedAnnotation.java:400"$1$"		}"
"TypeMappedAnnotation.java:401"$0$"		return adapt(attribute, value, type);"
"TypeMappedAnnotation.java:402"$0$"	}"
"TypeMappedAnnotation.java:403"$0$""
"TypeMappedAnnotation.java:404"$0$"	@Nullable"
"TypeMappedAnnotation.java:405"$1$"	private Object getValue(int attributeIndex, boolean useConventionMapping, boolean forMirrorResolution) {"
"TypeMappedAnnotation.java:406"$1$"		AnnotationTypeMapping mapping = this.mapping;"
"TypeMappedAnnotation.java:407"$1$"		if (this.useMergedValues) {"
"TypeMappedAnnotation.java:408"$1$"			int mappedIndex = this.mapping.getAliasMapping(attributeIndex);"
"TypeMappedAnnotation.java:409"$1$"			if (mappedIndex == -1 && useConventionMapping) {"
"TypeMappedAnnotation.java:410"$1$"				mappedIndex = this.mapping.getConventionMapping(attributeIndex);"
"TypeMappedAnnotation.java:411"$1$"			}"
"TypeMappedAnnotation.java:412"$1$"			if (mappedIndex != -1) {"
"TypeMappedAnnotation.java:413"$1$"				mapping = mapping.getRoot();"
"TypeMappedAnnotation.java:414"$1$"				attributeIndex = mappedIndex;"
"TypeMappedAnnotation.java:415"$1$"			}"
"TypeMappedAnnotation.java:416"$0$"		}"
"TypeMappedAnnotation.java:417"$1$"		if (!forMirrorResolution) {"
"TypeMappedAnnotation.java:418"$1$"			attributeIndex = (mapping.getDistance() != 0 ?"
"TypeMappedAnnotation.java:419"$1$"					this.resolvedMirrors :"
"TypeMappedAnnotation.java:420"$1$"					this.resolvedRootMirrors)[attributeIndex];"
"TypeMappedAnnotation.java:421"$1$"		}"
"TypeMappedAnnotation.java:422"$1$"		if (attributeIndex == -1) {"
"TypeMappedAnnotation.java:423"$1$"			return null;"
"TypeMappedAnnotation.java:424"$1$"		}"
"TypeMappedAnnotation.java:425"$1$"		if (mapping.getDistance() == 0) {"
"TypeMappedAnnotation.java:426"$1$"			Method attribute = mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:427"$1$"			Object result = this.valueExtractor.extract(attribute, this.rootAttributes);"
"TypeMappedAnnotation.java:428"$1$"			return (result != null) ? result : attribute.getDefaultValue();"
"TypeMappedAnnotation.java:429"$1$"		}"
"TypeMappedAnnotation.java:430"$0$"		return getValueFromMetaAnnotation(attributeIndex, forMirrorResolution);"
"TypeMappedAnnotation.java:431"$0$"	}"
"TypeMappedAnnotation.java:432"$0$""
"TypeMappedAnnotation.java:433"$0$"	@Nullable"
"TypeMappedAnnotation.java:434"$0$"	private Object getValueFromMetaAnnotation(int attributeIndex,"
"TypeMappedAnnotation.java:435"$1$"			boolean forMirrorResolution) {"
"TypeMappedAnnotation.java:436"$1$""
"TypeMappedAnnotation.java:437"$1$"		Object value = null;"
"TypeMappedAnnotation.java:438"$1$"		if (this.useMergedValues || forMirrorResolution) {"
"TypeMappedAnnotation.java:439"$1$"			value = this.mapping.getMappedAnnotationValue(attributeIndex, forMirrorResolution);"
"TypeMappedAnnotation.java:440"$1$"		}"
"TypeMappedAnnotation.java:441"$1$"		if (value == null) {"
"TypeMappedAnnotation.java:442"$1$"			Method attribute = this.mapping.getAttributes().get(attributeIndex);"
"TypeMappedAnnotation.java:443"$1$"			value = ReflectionUtils.invokeMethod(attribute, this.mapping.getAnnotation());"
"TypeMappedAnnotation.java:444"$1$"		}"
"TypeMappedAnnotation.java:445"$0$"		return value;"
"TypeMappedAnnotation.java:446"$0$"	}"
"TypeMappedAnnotation.java:447"$0$""
"TypeMappedAnnotation.java:448"$0$"	@Nullable"
"TypeMappedAnnotation.java:449"$1$"	private Object getValueForMirrorResolution(Method attribute, Object annotation) {"
"TypeMappedAnnotation.java:450"$1$"		int attributeIndex = this.mapping.getAttributes().indexOf(attribute);"
"TypeMappedAnnotation.java:451"$1$"		boolean valueAttribute = VALUE.equals(attribute.getName());"
"TypeMappedAnnotation.java:452"$1$"		return getValue(attributeIndex, !valueAttribute, true);"
"TypeMappedAnnotation.java:453"$1$"	}"
"TypeMappedAnnotation.java:454"$0$""
"TypeMappedAnnotation.java:455"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:456"$0$"	@Nullable"
"TypeMappedAnnotation.java:457"$1$"	private <T> T adapt(Method attribute, @Nullable Object value, Class<T> type) {"
"TypeMappedAnnotation.java:458"$1$"		if (value == null) {"
"TypeMappedAnnotation.java:459"$1$"			return null;"
"TypeMappedAnnotation.java:460"$1$"		}"
"TypeMappedAnnotation.java:461"$0$"		value = adaptForAttribute(attribute, value);"
"TypeMappedAnnotation.java:462"$0$"		type = getAdaptType(attribute, type);"
"TypeMappedAnnotation.java:463"$1$"		if (value instanceof Class && type == String.class) {"
"TypeMappedAnnotation.java:464"$1$"			value = ((Class<?>) value).getName();"
"TypeMappedAnnotation.java:465"$1$"		}"
"TypeMappedAnnotation.java:466"$1$"		else if (value instanceof String && type == Class.class) {"
"TypeMappedAnnotation.java:467"$1$"			value = ClassUtils.resolveClassName((String) value, getClassLoader());"
"TypeMappedAnnotation.java:468"$1$"		}"
"TypeMappedAnnotation.java:469"$1$"		else if (value instanceof Class[] && type == String[].class) {"
"TypeMappedAnnotation.java:470"$1$"			Class<?>[] classes = (Class[]) value;"
"TypeMappedAnnotation.java:471"$1$"			String[] names = new String[classes.length];"
"TypeMappedAnnotation.java:472"$1$"			for (int i = 0; i < classes.length; i++) {"
"TypeMappedAnnotation.java:473"$1$"				names[i] = classes[i].getName();"
"TypeMappedAnnotation.java:474"$1$"			}"
"TypeMappedAnnotation.java:475"$0$"			value = names;"
"TypeMappedAnnotation.java:476"$0$"		}"
"TypeMappedAnnotation.java:477"$1$"		else if (value instanceof String[] && type == Class[].class) {"
"TypeMappedAnnotation.java:478"$1$"			String[] names = (String[]) value;"
"TypeMappedAnnotation.java:479"$1$"			Class<?>[] classes = new Class<?>[names.length];"
"TypeMappedAnnotation.java:480"$1$"			for (int i = 0; i < names.length; i++) {"
"TypeMappedAnnotation.java:481"$1$"				classes[i] = ClassUtils.resolveClassName(names[i], getClassLoader());"
"TypeMappedAnnotation.java:482"$1$"			}"
"TypeMappedAnnotation.java:483"$0$"			value = classes;"
"TypeMappedAnnotation.java:484"$0$"		}"
"TypeMappedAnnotation.java:485"$1$"		else if (value instanceof MergedAnnotation && type.isAnnotation()) {"
"TypeMappedAnnotation.java:486"$1$"			MergedAnnotation<?> annotation = (MergedAnnotation<?>) value;"
"TypeMappedAnnotation.java:487"$1$"			value = annotation.synthesize();"
"TypeMappedAnnotation.java:488"$1$"		}"
"TypeMappedAnnotation.java:489"$1$"		else if (value instanceof MergedAnnotation[] && type.isArray() && type.getComponentType().isAnnotation()) {"
"TypeMappedAnnotation.java:490"$1$"			MergedAnnotation<?>[] annotations = (MergedAnnotation<?>[]) value;"
"TypeMappedAnnotation.java:491"$1$"			Object array = Array.newInstance(type.getComponentType(), annotations.length);"
"TypeMappedAnnotation.java:492"$1$"			for (int i = 0; i < annotations.length; i++) {"
"TypeMappedAnnotation.java:493"$1$"				Array.set(array, i, annotations[i].synthesize());"
"TypeMappedAnnotation.java:494"$1$"			}"
"TypeMappedAnnotation.java:495"$0$"			value = array;"
"TypeMappedAnnotation.java:496"$0$"		}"
"TypeMappedAnnotation.java:497"$1$"		if (!type.isInstance(value)) {"
"TypeMappedAnnotation.java:498"$1$"			throw new IllegalArgumentException(""Unable to adapt value of type "" +"
"TypeMappedAnnotation.java:499"$1$"					value.getClass().getName() + "" to "" + type.getName());"
"TypeMappedAnnotation.java:500"$1$"		}"
"TypeMappedAnnotation.java:501"$0$"		return (T) value;"
"TypeMappedAnnotation.java:502"$0$"	}"
"TypeMappedAnnotation.java:503"$0$""
"TypeMappedAnnotation.java:504"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:505"$1$"	private Object adaptForAttribute(Method attribute, Object value) {"
"TypeMappedAnnotation.java:506"$1$"		Class<?> attributeType = ClassUtils.resolvePrimitiveIfNecessary(attribute.getReturnType());"
"TypeMappedAnnotation.java:507"$1$"		if (attributeType.isArray() && !value.getClass().isArray()) {"
"TypeMappedAnnotation.java:508"$1$"			Object array = Array.newInstance(value.getClass(), 1);"
"TypeMappedAnnotation.java:509"$1$"			Array.set(array, 0, value);"
"TypeMappedAnnotation.java:510"$1$"			return adaptForAttribute(attribute, array);"
"TypeMappedAnnotation.java:511"$1$"		}"
"TypeMappedAnnotation.java:512"$1$"		if (attributeType.isAnnotation()) {"
"TypeMappedAnnotation.java:513"$1$"			return adaptToMergedAnnotation(value,(Class<? extends Annotation>) attributeType);"
"TypeMappedAnnotation.java:514"$1$"		}"
"TypeMappedAnnotation.java:515"$0$"		if (attributeType.isArray() && attributeType.getComponentType().isAnnotation() &&"
"TypeMappedAnnotation.java:516"$1$"				value.getClass().isArray()) {"
"TypeMappedAnnotation.java:517"$1$"			MergedAnnotation<?>[] result = new MergedAnnotation<?>[Array.getLength(value)];"
"TypeMappedAnnotation.java:518"$1$"			for (int i = 0; i < result.length; i++) {"
"TypeMappedAnnotation.java:519"$1$"				result[i] = adaptToMergedAnnotation(Array.get(value, i),"
"TypeMappedAnnotation.java:520"$1$"						(Class<? extends Annotation>) attributeType.getComponentType());"
"TypeMappedAnnotation.java:521"$1$"			}"
"TypeMappedAnnotation.java:522"$0$"			return result;"
"TypeMappedAnnotation.java:523"$0$"		}"
"TypeMappedAnnotation.java:524"$0$"		if ((attributeType == Class.class && value instanceof String) ||"
"TypeMappedAnnotation.java:525"$0$"				(attributeType == Class[].class && value instanceof String[]) ||"
"TypeMappedAnnotation.java:526"$0$"				(attributeType == String.class && value instanceof Class) ||"
"TypeMappedAnnotation.java:527"$1$"				(attributeType == String[].class && value instanceof Class[])) {"
"TypeMappedAnnotation.java:528"$1$"			return value;"
"TypeMappedAnnotation.java:529"$1$"		}"
"TypeMappedAnnotation.java:530"$1$"		if (attributeType.isArray() && isEmptyObjectArray(value)) {"
"TypeMappedAnnotation.java:531"$1$"			return emptyArray(attributeType.getComponentType());"
"TypeMappedAnnotation.java:532"$1$"		}"
"TypeMappedAnnotation.java:533"$1$"		if (!attributeType.isInstance(value)) {"
"TypeMappedAnnotation.java:534"$1$"			throw new IllegalStateException(""Attribute '"" + attribute.getName() +"
"TypeMappedAnnotation.java:535"$1$"					""' in annotation "" + getType().getName() + "" should be compatible with "" +"
"TypeMappedAnnotation.java:536"$1$"					attributeType.getName() + "" but a "" + value.getClass().getName() +"
"TypeMappedAnnotation.java:537"$1$"					"" value was returned"");"
"TypeMappedAnnotation.java:538"$1$"		}"
"TypeMappedAnnotation.java:539"$0$"		return value;"
"TypeMappedAnnotation.java:540"$0$"	}"
"TypeMappedAnnotation.java:541"$0$""
"TypeMappedAnnotation.java:542"$1$"	private boolean isEmptyObjectArray(Object value) {"
"TypeMappedAnnotation.java:543"$1$"		return (value instanceof Object[] && ((Object[]) value).length == 0);"
"TypeMappedAnnotation.java:544"$1$"	}"
"TypeMappedAnnotation.java:545"$0$""
"TypeMappedAnnotation.java:546"$1$"	private Object emptyArray(Class<?> componentType) {"
"TypeMappedAnnotation.java:547"$1$"		Object result = EMPTY_ARRAYS.get(componentType);"
"TypeMappedAnnotation.java:548"$1$"		if (result == null) {"
"TypeMappedAnnotation.java:549"$1$"			result = Array.newInstance(componentType, 0);"
"TypeMappedAnnotation.java:550"$1$"		}"
"TypeMappedAnnotation.java:551"$0$"		return result;"
"TypeMappedAnnotation.java:552"$0$"	}"
"TypeMappedAnnotation.java:553"$0$""
"TypeMappedAnnotation.java:554"$1$"	private MergedAnnotation<?> adaptToMergedAnnotation(Object value, Class<? extends Annotation> annotationType) {"
"TypeMappedAnnotation.java:555"$1$"		if (value instanceof MergedAnnotation) {"
"TypeMappedAnnotation.java:556"$1$"			return (MergedAnnotation<?>) value;"
"TypeMappedAnnotation.java:557"$1$"		}"
"TypeMappedAnnotation.java:558"$0$"		AnnotationTypeMapping mapping = AnnotationTypeMappings.forAnnotationType(annotationType).get(0);"
"TypeMappedAnnotation.java:559"$0$"		return new TypeMappedAnnotation<>("
"TypeMappedAnnotation.java:560"$0$"				mapping, null, this.source, value, getValueExtractor(value), this.aggregateIndex);"
"TypeMappedAnnotation.java:561"$0$"	}"
"TypeMappedAnnotation.java:562"$0$""
"TypeMappedAnnotation.java:563"$1$"	private ValueExtractor getValueExtractor(Object value) {"
"TypeMappedAnnotation.java:564"$1$"		if (value instanceof Annotation) {"
"TypeMappedAnnotation.java:565"$1$"			return ReflectionUtils::invokeMethod;"
"TypeMappedAnnotation.java:566"$1$"		}"
"TypeMappedAnnotation.java:567"$1$"		if (value instanceof Map) {"
"TypeMappedAnnotation.java:568"$1$"			return TypeMappedAnnotation::extractFromMap;"
"TypeMappedAnnotation.java:569"$1$"		}"
"TypeMappedAnnotation.java:570"$0$"		return this.valueExtractor;"
"TypeMappedAnnotation.java:571"$0$"	}"
"TypeMappedAnnotation.java:572"$0$""
"TypeMappedAnnotation.java:573"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:574"$1$"	private <T> Class<T> getAdaptType(Method attribute, Class<T> type) {"
"TypeMappedAnnotation.java:575"$1$"		if (type != Object.class) {"
"TypeMappedAnnotation.java:576"$1$"			return type;"
"TypeMappedAnnotation.java:577"$1$"		}"
"TypeMappedAnnotation.java:578"$0$"		Class<?> attributeType = attribute.getReturnType();"
"TypeMappedAnnotation.java:579"$1$"		if (attributeType.isAnnotation()) {"
"TypeMappedAnnotation.java:580"$1$"			return (Class<T>) MergedAnnotation.class;"
"TypeMappedAnnotation.java:581"$1$"		}"
"TypeMappedAnnotation.java:582"$1$"		if (attributeType.isArray() && attributeType.getComponentType().isAnnotation()) {"
"TypeMappedAnnotation.java:583"$1$"			return (Class<T>) MergedAnnotation[].class;"
"TypeMappedAnnotation.java:584"$1$"		}"
"TypeMappedAnnotation.java:585"$0$"		return (Class<T>) ClassUtils.resolvePrimitiveIfNecessary(attributeType);"
"TypeMappedAnnotation.java:586"$0$"	}"
"TypeMappedAnnotation.java:587"$0$""
"TypeMappedAnnotation.java:588"$1$"	private int getAttributeIndex(String attributeName, boolean required) {"
"TypeMappedAnnotation.java:589"$1$"		Assert.hasText(attributeName, ""Attribute name must not be null"");"
"TypeMappedAnnotation.java:590"$1$"		int attributeIndex = (isFiltered(attributeName) ? -1 :"
"TypeMappedAnnotation.java:591"$1$"				this.mapping.getAttributes().indexOf(attributeName));"
"TypeMappedAnnotation.java:592"$1$"		if (attributeIndex == -1 && required) {"
"TypeMappedAnnotation.java:593"$1$"			throw new NoSuchElementException(""No attribute named '"" + attributeName +"
"TypeMappedAnnotation.java:594"$1$"					""' present in merged annotation "" + getType().getName());"
"TypeMappedAnnotation.java:595"$1$"		}"
"TypeMappedAnnotation.java:596"$0$"		return attributeIndex;"
"TypeMappedAnnotation.java:597"$0$"	}"
"TypeMappedAnnotation.java:598"$0$""
"TypeMappedAnnotation.java:599"$1$"	private boolean isFiltered(String attributeName) {"
"TypeMappedAnnotation.java:600"$1$"		if (this.attributeFilter != null) {"
"TypeMappedAnnotation.java:601"$1$"			return !this.attributeFilter.test(attributeName);"
"TypeMappedAnnotation.java:602"$1$"		}"
"TypeMappedAnnotation.java:603"$0$"		return false;"
"TypeMappedAnnotation.java:604"$0$"	}"
"TypeMappedAnnotation.java:605"$0$""
"TypeMappedAnnotation.java:606"$0$"	@Nullable"
"TypeMappedAnnotation.java:607"$1$"	private ClassLoader getClassLoader() {"
"TypeMappedAnnotation.java:608"$1$"		if (this.classLoader != null) {"
"TypeMappedAnnotation.java:609"$1$"			return this.classLoader;"
"TypeMappedAnnotation.java:610"$1$"		}"
"TypeMappedAnnotation.java:611"$1$"		if (this.source != null) {"
"TypeMappedAnnotation.java:612"$1$"			if (this.source instanceof Class) {"
"TypeMappedAnnotation.java:613"$1$"				return ((Class<?>) source).getClassLoader();"
"TypeMappedAnnotation.java:614"$1$"			}"
"TypeMappedAnnotation.java:615"$1$"			if (this.source instanceof Member) {"
"TypeMappedAnnotation.java:616"$1$"				((Member) this.source).getDeclaringClass().getClassLoader();"
"TypeMappedAnnotation.java:617"$1$"			}"
"TypeMappedAnnotation.java:618"$0$"		}"
"TypeMappedAnnotation.java:619"$0$"		return null;"
"TypeMappedAnnotation.java:620"$0$"	}"
"TypeMappedAnnotation.java:621"$0$""
"TypeMappedAnnotation.java:622"$0$""
"TypeMappedAnnotation.java:623"$1$"	static <A extends Annotation> MergedAnnotation<A> from(@Nullable Object source, A annotation) {"
"TypeMappedAnnotation.java:624"$1$"		Assert.notNull(annotation, ""Annotation must not be null"");"
"TypeMappedAnnotation.java:625"$1$"		AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotation.annotationType());"
"TypeMappedAnnotation.java:626"$1$"		return new TypeMappedAnnotation<>(mappings.get(0), null, source, annotation, ReflectionUtils::invokeMethod, 0);"
"TypeMappedAnnotation.java:627"$1$"	}"
"TypeMappedAnnotation.java:628"$0$""
"TypeMappedAnnotation.java:629"$0$"	static <A extends Annotation> MergedAnnotation<A> of("
"TypeMappedAnnotation.java:630"$0$"			@Nullable ClassLoader classLoader, @Nullable Object source,"
"TypeMappedAnnotation.java:631"$1$"			Class<A> annotationType, @Nullable Map<String, ?> attributes) {"
"TypeMappedAnnotation.java:632"$1$""
"TypeMappedAnnotation.java:633"$1$"		Assert.notNull(annotationType, ""Annotation type must not be null"");"
"TypeMappedAnnotation.java:634"$1$"		AnnotationTypeMappings mappings = AnnotationTypeMappings.forAnnotationType(annotationType);"
"TypeMappedAnnotation.java:635"$1$"		return new TypeMappedAnnotation<>("
"TypeMappedAnnotation.java:636"$1$"				mappings.get(0), classLoader, source, attributes, TypeMappedAnnotation::extractFromMap, 0);"
"TypeMappedAnnotation.java:637"$1$"	}"
"TypeMappedAnnotation.java:638"$0$""
"TypeMappedAnnotation.java:639"$0$"	@Nullable"
"TypeMappedAnnotation.java:640"$0$"	static <A extends Annotation> TypeMappedAnnotation<A> createIfPossible("
"TypeMappedAnnotation.java:641"$1$"			AnnotationTypeMapping mapping, MergedAnnotation<?> annotation, IntrospectionFailureLogger logger) {"
"TypeMappedAnnotation.java:642"$1$"		if (annotation instanceof TypeMappedAnnotation) {"
"TypeMappedAnnotation.java:643"$1$"			TypeMappedAnnotation<?> typeMappedAnnotation = (TypeMappedAnnotation<?>) annotation;"
"TypeMappedAnnotation.java:644"$1$"			return createIfPossible(mapping, typeMappedAnnotation.source,"
"TypeMappedAnnotation.java:645"$1$"					typeMappedAnnotation.rootAttributes,"
"TypeMappedAnnotation.java:646"$1$"					typeMappedAnnotation.valueExtractor,"
"TypeMappedAnnotation.java:647"$1$"					typeMappedAnnotation.aggregateIndex, logger);"
"TypeMappedAnnotation.java:648"$1$"		}"
"TypeMappedAnnotation.java:649"$0$"		return createIfPossible(mapping, annotation.getSource(), annotation.synthesize(),"
"TypeMappedAnnotation.java:650"$0$"				annotation.getAggregateIndex(), logger);"
"TypeMappedAnnotation.java:651"$0$"	}"
"TypeMappedAnnotation.java:652"$0$""
"TypeMappedAnnotation.java:653"$0$"	@Nullable"
"TypeMappedAnnotation.java:654"$0$"	static <A extends Annotation> TypeMappedAnnotation<A> createIfPossible("
"TypeMappedAnnotation.java:655"$0$"			AnnotationTypeMapping mapping, @Nullable Object source, Annotation annotation,"
"TypeMappedAnnotation.java:656"$1$"			int aggregateIndex, IntrospectionFailureLogger logger) {"
"TypeMappedAnnotation.java:657"$1$""
"TypeMappedAnnotation.java:658"$1$"		return createIfPossible(mapping, source, annotation,"
"TypeMappedAnnotation.java:659"$1$"				ReflectionUtils::invokeMethod, aggregateIndex, logger);"
"TypeMappedAnnotation.java:660"$1$"	}"
"TypeMappedAnnotation.java:661"$0$""
"TypeMappedAnnotation.java:662"$0$"	@Nullable"
"TypeMappedAnnotation.java:663"$0$"	private static <A extends Annotation> TypeMappedAnnotation<A> createIfPossible("
"TypeMappedAnnotation.java:664"$0$"			AnnotationTypeMapping mapping, @Nullable Object source, @Nullable Object rootAttribute,"
"TypeMappedAnnotation.java:665"$1$"			ValueExtractor valueExtractor, int aggregateIndex, IntrospectionFailureLogger logger) {"
"TypeMappedAnnotation.java:666"$1$""
"TypeMappedAnnotation.java:667"$1$"		try {"
"TypeMappedAnnotation.java:668"$1$"			return new TypeMappedAnnotation<>(mapping, null, source, rootAttribute,"
"TypeMappedAnnotation.java:669"$1$"					valueExtractor, aggregateIndex);"
"TypeMappedAnnotation.java:670"$1$"		}"
"TypeMappedAnnotation.java:671"$1$"		catch (Exception ex) {"
"TypeMappedAnnotation.java:672"$1$"			AnnotationUtils.rethrowAnnotationConfigurationException(ex);"
"TypeMappedAnnotation.java:673"$1$"			if (logger.isEnabled()) {"
"TypeMappedAnnotation.java:674"$1$"				String type = mapping.getAnnotationType().getName();"
"TypeMappedAnnotation.java:675"$1$"				String item = (mapping.getDistance() == 0 ? ""annotation "" + type :"
"TypeMappedAnnotation.java:676"$1$"						""meta-annotation "" + type + "" from "" + mapping.getRoot().getAnnotationType().getName());"
"TypeMappedAnnotation.java:677"$1$"				logger.log(""Failed to introspect "" + item, source, ex);"
"TypeMappedAnnotation.java:678"$1$"			}"
"TypeMappedAnnotation.java:679"$0$"			return null;"
"TypeMappedAnnotation.java:680"$0$"		}"
"TypeMappedAnnotation.java:681"$0$"	}"
"TypeMappedAnnotation.java:682"$0$""
"TypeMappedAnnotation.java:683"$0$"	@SuppressWarnings(""unchecked"")"
"TypeMappedAnnotation.java:684"$0$"	@Nullable"
"TypeMappedAnnotation.java:685"$1$"	static Object extractFromMap(Method attribute, @Nullable Object map) {"
"TypeMappedAnnotation.java:686"$1$"		return (map != null ? ((Map<String, ?>) map).get(attribute.getName()) : null);"
"TypeMappedAnnotation.java:687"$1$"	}"
"TypeMappedAnnotation.java:688"$0$""
"TypeMappedAnnotation.java:689"$0$"}"
"SynthesizingMethodParameter.java:1"$0$"/*"
"SynthesizingMethodParameter.java:2"$0$" * Copyright 2002-2019 the original author or authors."
"SynthesizingMethodParameter.java:3"$0$" *"
"SynthesizingMethodParameter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"SynthesizingMethodParameter.java:5"$0$" * you may not use this file except in compliance with the License."
"SynthesizingMethodParameter.java:6"$0$" * You may obtain a copy of the License at"
"SynthesizingMethodParameter.java:7"$0$" *"
"SynthesizingMethodParameter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"SynthesizingMethodParameter.java:9"$0$" *"
"SynthesizingMethodParameter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"SynthesizingMethodParameter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"SynthesizingMethodParameter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"SynthesizingMethodParameter.java:13"$0$" * See the License for the specific language governing permissions and"
"SynthesizingMethodParameter.java:14"$0$" * limitations under the License."
"SynthesizingMethodParameter.java:15"$0$" */"
"SynthesizingMethodParameter.java:16"$0$""
"SynthesizingMethodParameter.java:17"$0$"package org.springframework.core.annotation;"
"SynthesizingMethodParameter.java:18"$0$""
"SynthesizingMethodParameter.java:19"$0$"import java.lang.annotation.Annotation;"
"SynthesizingMethodParameter.java:20"$0$"import java.lang.reflect.Constructor;"
"SynthesizingMethodParameter.java:21"$0$"import java.lang.reflect.Executable;"
"SynthesizingMethodParameter.java:22"$0$"import java.lang.reflect.Method;"
"SynthesizingMethodParameter.java:23"$0$"import java.lang.reflect.Parameter;"
"SynthesizingMethodParameter.java:24"$0$""
"SynthesizingMethodParameter.java:25"$0$"import org.springframework.core.MethodParameter;"
"SynthesizingMethodParameter.java:26"$0$""
"SynthesizingMethodParameter.java:27"$0$"/**"
"SynthesizingMethodParameter.java:28"$1$" * A {@link MethodParameter} variant which synthesizes annotations that"
"SynthesizingMethodParameter.java:29"$1$" * declare attribute aliases via {@link AliasFor @AliasFor}."
"SynthesizingMethodParameter.java:30"$0$" *"
"SynthesizingMethodParameter.java:31"$0$" * @author Juergen Hoeller"
"SynthesizingMethodParameter.java:32"$0$" * @author Sam Brannen"
"SynthesizingMethodParameter.java:33"$0$" * @since 4.2"
"SynthesizingMethodParameter.java:34"$0$" * @see AnnotationUtils#synthesizeAnnotation"
"SynthesizingMethodParameter.java:35"$0$" * @see AnnotationUtils#synthesizeAnnotationArray"
"SynthesizingMethodParameter.java:36"$0$" */"
"SynthesizingMethodParameter.java:37"$1$"public class SynthesizingMethodParameter extends MethodParameter {"
"SynthesizingMethodParameter.java:38"$1$""
"SynthesizingMethodParameter.java:39"$1$"	/**"
"SynthesizingMethodParameter.java:40"$1$"	 * Create a new {@code SynthesizingMethodParameter} for the given method,"
"SynthesizingMethodParameter.java:41"$1$"	 * with nesting level 1."
"SynthesizingMethodParameter.java:42"$1$"	 * @param method the Method to specify a parameter for"
"SynthesizingMethodParameter.java:43"$1$"	 * @param parameterIndex the index of the parameter: -1 for the method"
"SynthesizingMethodParameter.java:44"$1$"	 * return type; 0 for the first method parameter; 1 for the second method"
"SynthesizingMethodParameter.java:45"$1$"	 * parameter, etc."
"SynthesizingMethodParameter.java:46"$1$"	 */"
"SynthesizingMethodParameter.java:47"$1$"	public SynthesizingMethodParameter(Method method, int parameterIndex) {"
"SynthesizingMethodParameter.java:48"$1$"		super(method, parameterIndex);"
"SynthesizingMethodParameter.java:49"$1$"	}"
"SynthesizingMethodParameter.java:50"$0$""
"SynthesizingMethodParameter.java:51"$0$"	/**"
"SynthesizingMethodParameter.java:52"$1$"	 * Create a new {@code SynthesizingMethodParameter} for the given method."
"SynthesizingMethodParameter.java:53"$0$"	 * @param method the Method to specify a parameter for"
"SynthesizingMethodParameter.java:54"$0$"	 * @param parameterIndex the index of the parameter: -1 for the method"
"SynthesizingMethodParameter.java:55"$0$"	 * return type; 0 for the first method parameter; 1 for the second method"
"SynthesizingMethodParameter.java:56"$0$"	 * parameter, etc."
"SynthesizingMethodParameter.java:57"$0$"	 * @param nestingLevel the nesting level of the target type"
"SynthesizingMethodParameter.java:58"$0$"	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the"
"SynthesizingMethodParameter.java:59"$0$"	 * nested List, whereas 2 would indicate the element of the nested List)"
"SynthesizingMethodParameter.java:60"$0$"	 */"
"SynthesizingMethodParameter.java:61"$1$"	public SynthesizingMethodParameter(Method method, int parameterIndex, int nestingLevel) {"
"SynthesizingMethodParameter.java:62"$1$"		super(method, parameterIndex, nestingLevel);"
"SynthesizingMethodParameter.java:63"$1$"	}"
"SynthesizingMethodParameter.java:64"$0$""
"SynthesizingMethodParameter.java:65"$0$"	/**"
"SynthesizingMethodParameter.java:66"$1$"	 * Create a new {@code SynthesizingMethodParameter} for the given constructor,"
"SynthesizingMethodParameter.java:67"$0$"	 * with nesting level 1."
"SynthesizingMethodParameter.java:68"$0$"	 * @param constructor the Constructor to specify a parameter for"
"SynthesizingMethodParameter.java:69"$0$"	 * @param parameterIndex the index of the parameter"
"SynthesizingMethodParameter.java:70"$0$"	 */"
"SynthesizingMethodParameter.java:71"$1$"	public SynthesizingMethodParameter(Constructor<?> constructor, int parameterIndex) {"
"SynthesizingMethodParameter.java:72"$1$"		super(constructor, parameterIndex);"
"SynthesizingMethodParameter.java:73"$1$"	}"
"SynthesizingMethodParameter.java:74"$0$""
"SynthesizingMethodParameter.java:75"$0$"	/**"
"SynthesizingMethodParameter.java:76"$1$"	 * Create a new {@code SynthesizingMethodParameter} for the given constructor."
"SynthesizingMethodParameter.java:77"$0$"	 * @param constructor the Constructor to specify a parameter for"
"SynthesizingMethodParameter.java:78"$0$"	 * @param parameterIndex the index of the parameter"
"SynthesizingMethodParameter.java:79"$0$"	 * @param nestingLevel the nesting level of the target type"
"SynthesizingMethodParameter.java:80"$0$"	 * (typically 1; e.g. in case of a List of Lists, 1 would indicate the"
"SynthesizingMethodParameter.java:81"$0$"	 * nested List, whereas 2 would indicate the element of the nested List)"
"SynthesizingMethodParameter.java:82"$0$"	 */"
"SynthesizingMethodParameter.java:83"$1$"	public SynthesizingMethodParameter(Constructor<?> constructor, int parameterIndex, int nestingLevel) {"
"SynthesizingMethodParameter.java:84"$1$"		super(constructor, parameterIndex, nestingLevel);"
"SynthesizingMethodParameter.java:85"$1$"	}"
"SynthesizingMethodParameter.java:86"$0$""
"SynthesizingMethodParameter.java:87"$0$"	/**"
"SynthesizingMethodParameter.java:88"$1$"	 * Copy constructor, resulting in an independent {@code SynthesizingMethodParameter}"
"SynthesizingMethodParameter.java:89"$0$"	 * based on the same metadata and cache state that the original object was in."
"SynthesizingMethodParameter.java:90"$0$"	 * @param original the original SynthesizingMethodParameter object to copy from"
"SynthesizingMethodParameter.java:91"$0$"	 */"
"SynthesizingMethodParameter.java:92"$1$"	protected SynthesizingMethodParameter(SynthesizingMethodParameter original) {"
"SynthesizingMethodParameter.java:93"$1$"		super(original);"
"SynthesizingMethodParameter.java:94"$1$"	}"
"SynthesizingMethodParameter.java:95"$0$""
"SynthesizingMethodParameter.java:96"$0$""
"SynthesizingMethodParameter.java:97"$0$"	@Override"
"SynthesizingMethodParameter.java:98"$1$"	protected <A extends Annotation> A adaptAnnotation(A annotation) {"
"SynthesizingMethodParameter.java:99"$1$"		return AnnotationUtils.synthesizeAnnotation(annotation, getAnnotatedElement());"
"SynthesizingMethodParameter.java:100"$1$"	}"
"SynthesizingMethodParameter.java:101"$0$""
"SynthesizingMethodParameter.java:102"$0$"	@Override"
"SynthesizingMethodParameter.java:103"$1$"	protected Annotation[] adaptAnnotationArray(Annotation[] annotations) {"
"SynthesizingMethodParameter.java:104"$1$"		return AnnotationUtils.synthesizeAnnotationArray(annotations, getAnnotatedElement());"
"SynthesizingMethodParameter.java:105"$1$"	}"
"SynthesizingMethodParameter.java:106"$0$""
"SynthesizingMethodParameter.java:107"$0$"	@Override"
"SynthesizingMethodParameter.java:108"$1$"	public SynthesizingMethodParameter clone() {"
"SynthesizingMethodParameter.java:109"$1$"		return new SynthesizingMethodParameter(this);"
"SynthesizingMethodParameter.java:110"$1$"	}"
"SynthesizingMethodParameter.java:111"$0$""
"SynthesizingMethodParameter.java:112"$0$""
"SynthesizingMethodParameter.java:113"$0$"	/**"
"SynthesizingMethodParameter.java:114"$0$"	 * Create a new SynthesizingMethodParameter for the given method or constructor."
"SynthesizingMethodParameter.java:115"$0$"	 * <p>This is a convenience factory method for scenarios where a"
"SynthesizingMethodParameter.java:116"$0$"	 * Method or Constructor reference is treated in a generic fashion."
"SynthesizingMethodParameter.java:117"$0$"	 * @param executable the Method or Constructor to specify a parameter for"
"SynthesizingMethodParameter.java:118"$0$"	 * @param parameterIndex the index of the parameter"
"SynthesizingMethodParameter.java:119"$0$"	 * @return the corresponding SynthesizingMethodParameter instance"
"SynthesizingMethodParameter.java:120"$0$"	 * @since 5.0"
"SynthesizingMethodParameter.java:121"$0$"	 */"
"SynthesizingMethodParameter.java:122"$1$"	public static SynthesizingMethodParameter forExecutable(Executable executable, int parameterIndex) {"
"SynthesizingMethodParameter.java:123"$1$"		if (executable instanceof Method) {"
"SynthesizingMethodParameter.java:124"$1$"			return new SynthesizingMethodParameter((Method) executable, parameterIndex);"
"SynthesizingMethodParameter.java:125"$1$"		}"
"SynthesizingMethodParameter.java:126"$1$"		else if (executable instanceof Constructor) {"
"SynthesizingMethodParameter.java:127"$1$"			return new SynthesizingMethodParameter((Constructor<?>) executable, parameterIndex);"
"SynthesizingMethodParameter.java:128"$1$"		}"
"SynthesizingMethodParameter.java:129"$1$"		else {"
"SynthesizingMethodParameter.java:130"$1$"			throw new IllegalArgumentException(""Not a Method/Constructor: "" + executable);"
"SynthesizingMethodParameter.java:131"$1$"		}"
"SynthesizingMethodParameter.java:132"$0$"	}"
"SynthesizingMethodParameter.java:133"$0$""
"SynthesizingMethodParameter.java:134"$0$"	/**"
"SynthesizingMethodParameter.java:135"$0$"	 * Create a new SynthesizingMethodParameter for the given parameter descriptor."
"SynthesizingMethodParameter.java:136"$0$"	 * <p>This is a convenience factory method for scenarios where a"
"SynthesizingMethodParameter.java:137"$1$"	 * Java 8 {@link Parameter} descriptor is already available."
"SynthesizingMethodParameter.java:138"$0$"	 * @param parameter the parameter descriptor"
"SynthesizingMethodParameter.java:139"$0$"	 * @return the corresponding SynthesizingMethodParameter instance"
"SynthesizingMethodParameter.java:140"$0$"	 * @since 5.0"
"SynthesizingMethodParameter.java:141"$0$"	 */"
"SynthesizingMethodParameter.java:142"$1$"	public static SynthesizingMethodParameter forParameter(Parameter parameter) {"
"SynthesizingMethodParameter.java:143"$1$"		return forExecutable(parameter.getDeclaringExecutable(), findParameterIndex(parameter));"
"SynthesizingMethodParameter.java:144"$1$"	}"
"SynthesizingMethodParameter.java:145"$0$""
"SynthesizingMethodParameter.java:146"$0$"}"
"DigestUtils.java:1"$0$"/*"
"DigestUtils.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"DigestUtils.java:3"$0$" *"
"DigestUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"DigestUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"DigestUtils.java:6"$0$" * You may obtain a copy of the License at"
"DigestUtils.java:7"$0$" *"
"DigestUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"DigestUtils.java:9"$0$" *"
"DigestUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"DigestUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"DigestUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"DigestUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"DigestUtils.java:14"$0$" * limitations under the License."
"DigestUtils.java:15"$0$" */"
"DigestUtils.java:16"$0$""
"DigestUtils.java:17"$0$"package org.springframework.util;"
"DigestUtils.java:18"$0$""
"DigestUtils.java:19"$0$"import java.io.IOException;"
"DigestUtils.java:20"$0$"import java.io.InputStream;"
"DigestUtils.java:21"$0$"import java.security.MessageDigest;"
"DigestUtils.java:22"$0$"import java.security.NoSuchAlgorithmException;"
"DigestUtils.java:23"$0$""
"DigestUtils.java:24"$0$"/**"
"DigestUtils.java:25"$0$" * Miscellaneous methods for calculating digests."
"DigestUtils.java:26"$0$" *"
"DigestUtils.java:27"$0$" * <p>Mainly for internal use within the framework; consider"
"DigestUtils.java:28"$0$" * <a href=""https://commons.apache.org/codec/"">Apache Commons Codec</a>"
"DigestUtils.java:29"$0$" * for a more comprehensive suite of digest utilities."
"DigestUtils.java:30"$0$" *"
"DigestUtils.java:31"$0$" * @author Arjen Poutsma"
"DigestUtils.java:32"$0$" * @author Juergen Hoeller"
"DigestUtils.java:33"$0$" * @author Craig Andrews"
"DigestUtils.java:34"$0$" * @since 3.0"
"DigestUtils.java:35"$0$" */"
"DigestUtils.java:36"$1$"public abstract class DigestUtils {"
"DigestUtils.java:37"$1$""
"DigestUtils.java:38"$1$"	private static final String MD5_ALGORITHM_NAME = ""MD5"";"
"DigestUtils.java:39"$1$""
"DigestUtils.java:40"$1$"	private static final char[] HEX_CHARS ="
"DigestUtils.java:41"$1$"			{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};"
"DigestUtils.java:42"$1$""
"DigestUtils.java:43"$1$""
"DigestUtils.java:44"$1$"	/**"
"DigestUtils.java:45"$1$"	 * Calculate the MD5 digest of the given bytes."
"DigestUtils.java:46"$1$"	 * @param bytes the bytes to calculate the digest over"
"DigestUtils.java:47"$1$"	 * @return the digest"
"DigestUtils.java:48"$1$"	 */"
"DigestUtils.java:49"$1$"	public static byte[] md5Digest(byte[] bytes) {"
"DigestUtils.java:50"$1$"		return digest(MD5_ALGORITHM_NAME, bytes);"
"DigestUtils.java:51"$1$"	}"
"DigestUtils.java:52"$0$""
"DigestUtils.java:53"$0$"	/**"
"DigestUtils.java:54"$0$"	 * Calculate the MD5 digest of the given stream."
"DigestUtils.java:55"$0$"	 * <p>This method does <strong>not</strong> close the input stream."
"DigestUtils.java:56"$0$"	 * @param inputStream the InputStream to calculate the digest over"
"DigestUtils.java:57"$0$"	 * @return the digest"
"DigestUtils.java:58"$0$"	 * @since 4.2"
"DigestUtils.java:59"$0$"	 */"
"DigestUtils.java:60"$1$"	public static byte[] md5Digest(InputStream inputStream) throws IOException {"
"DigestUtils.java:61"$1$"		return digest(MD5_ALGORITHM_NAME, inputStream);"
"DigestUtils.java:62"$1$"	}"
"DigestUtils.java:63"$0$""
"DigestUtils.java:64"$0$"	/**"
"DigestUtils.java:65"$0$"	 * Return a hexadecimal string representation of the MD5 digest of the given bytes."
"DigestUtils.java:66"$0$"	 * @param bytes the bytes to calculate the digest over"
"DigestUtils.java:67"$0$"	 * @return a hexadecimal digest string"
"DigestUtils.java:68"$0$"	 */"
"DigestUtils.java:69"$1$"	public static String md5DigestAsHex(byte[] bytes) {"
"DigestUtils.java:70"$1$"		return digestAsHexString(MD5_ALGORITHM_NAME, bytes);"
"DigestUtils.java:71"$1$"	}"
"DigestUtils.java:72"$0$""
"DigestUtils.java:73"$0$"	/**"
"DigestUtils.java:74"$0$"	 * Return a hexadecimal string representation of the MD5 digest of the given stream."
"DigestUtils.java:75"$0$"	 * <p>This method does <strong>not</strong> close the input stream."
"DigestUtils.java:76"$0$"	 * @param inputStream the InputStream to calculate the digest over"
"DigestUtils.java:77"$0$"	 * @return a hexadecimal digest string"
"DigestUtils.java:78"$0$"	 * @since 4.2"
"DigestUtils.java:79"$0$"	 */"
"DigestUtils.java:80"$1$"	public static String md5DigestAsHex(InputStream inputStream) throws IOException {"
"DigestUtils.java:81"$1$"		return digestAsHexString(MD5_ALGORITHM_NAME, inputStream);"
"DigestUtils.java:82"$1$"	}"
"DigestUtils.java:83"$0$""
"DigestUtils.java:84"$0$"	/**"
"DigestUtils.java:85"$0$"	 * Append a hexadecimal string representation of the MD5 digest of the given"
"DigestUtils.java:86"$1$"	 * bytes to the given {@link StringBuilder}."
"DigestUtils.java:87"$0$"	 * @param bytes the bytes to calculate the digest over"
"DigestUtils.java:88"$0$"	 * @param builder the string builder to append the digest to"
"DigestUtils.java:89"$0$"	 * @return the given string builder"
"DigestUtils.java:90"$0$"	 */"
"DigestUtils.java:91"$1$"	public static StringBuilder appendMd5DigestAsHex(byte[] bytes, StringBuilder builder) {"
"DigestUtils.java:92"$1$"		return appendDigestAsHex(MD5_ALGORITHM_NAME, bytes, builder);"
"DigestUtils.java:93"$1$"	}"
"DigestUtils.java:94"$0$""
"DigestUtils.java:95"$0$"	/**"
"DigestUtils.java:96"$0$"	 * Append a hexadecimal string representation of the MD5 digest of the given"
"DigestUtils.java:97"$1$"	 * inputStream to the given {@link StringBuilder}."
"DigestUtils.java:98"$0$"	 * <p>This method does <strong>not</strong> close the input stream."
"DigestUtils.java:99"$0$"	 * @param inputStream the inputStream to calculate the digest over"
"DigestUtils.java:100"$0$"	 * @param builder the string builder to append the digest to"
"DigestUtils.java:101"$0$"	 * @return the given string builder"
"DigestUtils.java:102"$0$"	 * @since 4.2"
"DigestUtils.java:103"$0$"	 */"
"DigestUtils.java:104"$1$"	public static StringBuilder appendMd5DigestAsHex(InputStream inputStream, StringBuilder builder) throws IOException {"
"DigestUtils.java:105"$1$"		return appendDigestAsHex(MD5_ALGORITHM_NAME, inputStream, builder);"
"DigestUtils.java:106"$1$"	}"
"DigestUtils.java:107"$0$""
"DigestUtils.java:108"$0$""
"DigestUtils.java:109"$0$"	/**"
"DigestUtils.java:110"$1$"	 * Create a new {@link MessageDigest} with the given algorithm."
"DigestUtils.java:111"$1$"	 * <p>Necessary because {@code MessageDigest} is not thread-safe."
"DigestUtils.java:112"$0$"	 */"
"DigestUtils.java:113"$1$"	private static MessageDigest getDigest(String algorithm) {"
"DigestUtils.java:114"$1$"		try {"
"DigestUtils.java:115"$1$"			return MessageDigest.getInstance(algorithm);"
"DigestUtils.java:116"$1$"		}"
"DigestUtils.java:117"$1$"		catch (NoSuchAlgorithmException ex) {"
"DigestUtils.java:118"$1$"			throw new IllegalStateException(""Could not find MessageDigest with algorithm \"""" + algorithm + ""\"""", ex);"
"DigestUtils.java:119"$1$"		}"
"DigestUtils.java:120"$0$"	}"
"DigestUtils.java:121"$0$""
"DigestUtils.java:122"$1$"	private static byte[] digest(String algorithm, byte[] bytes) {"
"DigestUtils.java:123"$1$"		return getDigest(algorithm).digest(bytes);"
"DigestUtils.java:124"$1$"	}"
"DigestUtils.java:125"$0$""
"DigestUtils.java:126"$1$"	private static byte[] digest(String algorithm, InputStream inputStream) throws IOException {"
"DigestUtils.java:127"$1$"		MessageDigest messageDigest = getDigest(algorithm);"
"DigestUtils.java:128"$1$"		if (inputStream instanceof UpdateMessageDigestInputStream){"
"DigestUtils.java:129"$1$"			((UpdateMessageDigestInputStream) inputStream).updateMessageDigest(messageDigest);"
"DigestUtils.java:130"$1$"			return messageDigest.digest();"
"DigestUtils.java:131"$1$"		}"
"DigestUtils.java:132"$1$"		else {"
"DigestUtils.java:133"$1$"			final byte[] buffer = new byte[StreamUtils.BUFFER_SIZE];"
"DigestUtils.java:134"$1$"			int bytesRead = -1;"
"DigestUtils.java:135"$1$"			while ((bytesRead = inputStream.read(buffer)) != -1) {"
"DigestUtils.java:136"$1$"				messageDigest.update(buffer, 0, bytesRead);"
"DigestUtils.java:137"$1$"			}"
"DigestUtils.java:138"$0$"			return messageDigest.digest();"
"DigestUtils.java:139"$0$"		}"
"DigestUtils.java:140"$0$"	}"
"DigestUtils.java:141"$0$""
"DigestUtils.java:142"$1$"	private static String digestAsHexString(String algorithm, byte[] bytes) {"
"DigestUtils.java:143"$1$"		char[] hexDigest = digestAsHexChars(algorithm, bytes);"
"DigestUtils.java:144"$1$"		return new String(hexDigest);"
"DigestUtils.java:145"$1$"	}"
"DigestUtils.java:146"$0$""
"DigestUtils.java:147"$1$"	private static String digestAsHexString(String algorithm, InputStream inputStream) throws IOException {"
"DigestUtils.java:148"$1$"		char[] hexDigest = digestAsHexChars(algorithm, inputStream);"
"DigestUtils.java:149"$1$"		return new String(hexDigest);"
"DigestUtils.java:150"$1$"	}"
"DigestUtils.java:151"$0$""
"DigestUtils.java:152"$1$"	private static StringBuilder appendDigestAsHex(String algorithm, byte[] bytes, StringBuilder builder) {"
"DigestUtils.java:153"$1$"		char[] hexDigest = digestAsHexChars(algorithm, bytes);"
"DigestUtils.java:154"$1$"		return builder.append(hexDigest);"
"DigestUtils.java:155"$1$"	}"
"DigestUtils.java:156"$0$""
"DigestUtils.java:157"$0$"	private static StringBuilder appendDigestAsHex(String algorithm, InputStream inputStream, StringBuilder builder)"
"DigestUtils.java:158"$1$"			throws IOException {"
"DigestUtils.java:159"$1$""
"DigestUtils.java:160"$1$"		char[] hexDigest = digestAsHexChars(algorithm, inputStream);"
"DigestUtils.java:161"$1$"		return builder.append(hexDigest);"
"DigestUtils.java:162"$1$"	}"
"DigestUtils.java:163"$0$""
"DigestUtils.java:164"$1$"	private static char[] digestAsHexChars(String algorithm, byte[] bytes) {"
"DigestUtils.java:165"$1$"		byte[] digest = digest(algorithm, bytes);"
"DigestUtils.java:166"$1$"		return encodeHex(digest);"
"DigestUtils.java:167"$1$"	}"
"DigestUtils.java:168"$0$""
"DigestUtils.java:169"$1$"	private static char[] digestAsHexChars(String algorithm, InputStream inputStream) throws IOException {"
"DigestUtils.java:170"$1$"		byte[] digest = digest(algorithm, inputStream);"
"DigestUtils.java:171"$1$"		return encodeHex(digest);"
"DigestUtils.java:172"$1$"	}"
"DigestUtils.java:173"$0$""
"DigestUtils.java:174"$1$"	private static char[] encodeHex(byte[] bytes) {"
"DigestUtils.java:175"$1$"		char[] chars = new char[32];"
"DigestUtils.java:176"$1$"		for (int i = 0; i < chars.length; i = i + 2) {"
"DigestUtils.java:177"$1$"			byte b = bytes[i / 2];"
"DigestUtils.java:178"$1$"			chars[i] = HEX_CHARS[(b >>> 0x4) & 0xf];"
"DigestUtils.java:179"$1$"			chars[i + 1] = HEX_CHARS[b & 0xf];"
"DigestUtils.java:180"$1$"		}"
"DigestUtils.java:181"$0$"		return chars;"
"DigestUtils.java:182"$0$"	}"
"DigestUtils.java:183"$0$""
"DigestUtils.java:184"$0$"}"
"InstanceFilter.java:1"$0$"/*"
"InstanceFilter.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"InstanceFilter.java:3"$0$" *"
"InstanceFilter.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"InstanceFilter.java:5"$0$" * you may not use this file except in compliance with the License."
"InstanceFilter.java:6"$0$" * You may obtain a copy of the License at"
"InstanceFilter.java:7"$0$" *"
"InstanceFilter.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"InstanceFilter.java:9"$0$" *"
"InstanceFilter.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"InstanceFilter.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"InstanceFilter.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"InstanceFilter.java:13"$0$" * See the License for the specific language governing permissions and"
"InstanceFilter.java:14"$0$" * limitations under the License."
"InstanceFilter.java:15"$0$" */"
"InstanceFilter.java:16"$0$""
"InstanceFilter.java:17"$0$"package org.springframework.util;"
"InstanceFilter.java:18"$0$""
"InstanceFilter.java:19"$0$"import java.util.Collection;"
"InstanceFilter.java:20"$0$"import java.util.Collections;"
"InstanceFilter.java:21"$0$""
"InstanceFilter.java:22"$0$"import org.springframework.lang.Nullable;"
"InstanceFilter.java:23"$0$""
"InstanceFilter.java:24"$0$"/**"
"InstanceFilter.java:25"$0$" * A simple instance filter that checks if a given instance match based on"
"InstanceFilter.java:26"$0$" * a collection of includes and excludes element."
"InstanceFilter.java:27"$0$" *"
"InstanceFilter.java:28"$1$" * <p>Subclasses may want to override {@link #match(Object, Object)} to provide"
"InstanceFilter.java:29"$0$" * a custom matching algorithm."
"InstanceFilter.java:30"$0$" *"
"InstanceFilter.java:31"$0$" * @author Stephane Nicoll"
"InstanceFilter.java:32"$0$" * @since 4.1"
"InstanceFilter.java:33"$0$" * @param <T> the instance type"
"InstanceFilter.java:34"$0$" */"
"InstanceFilter.java:35"$1$"public class InstanceFilter<T> {"
"InstanceFilter.java:36"$1$""
"InstanceFilter.java:37"$1$"	private final Collection<? extends T> includes;"
"InstanceFilter.java:38"$1$""
"InstanceFilter.java:39"$1$"	private final Collection<? extends T> excludes;"
"InstanceFilter.java:40"$1$""
"InstanceFilter.java:41"$1$"	private final boolean matchIfEmpty;"
"InstanceFilter.java:42"$1$""
"InstanceFilter.java:43"$1$""
"InstanceFilter.java:44"$1$"	/**"
"InstanceFilter.java:45"$1$"	 * Create a new instance based on includes/excludes collections."
"InstanceFilter.java:46"$1$"	 * <p>A particular element will match if it ""matches"" the one of the element in the"
"InstanceFilter.java:47"$1$"	 * includes list and  does not match one of the element in the excludes list."
"InstanceFilter.java:48"$1$"	 * <p>Subclasses may redefine what matching means. By default, an element match with"
"InstanceFilter.java:49"$1$"	 * another if it is equals according to {@link Object#equals(Object)}"
"InstanceFilter.java:50"$1$"	 * <p>If both collections are empty, {@code matchIfEmpty} defines if"
"InstanceFilter.java:51"$1$"	 * an element matches or not."
"InstanceFilter.java:52"$1$"	 * @param includes the collection of includes"
"InstanceFilter.java:53"$1$"	 * @param excludes the collection of excludes"
"InstanceFilter.java:54"$1$"	 * @param matchIfEmpty the matching result if both the includes and the excludes"
"InstanceFilter.java:55"$1$"	 * collections are empty"
"InstanceFilter.java:56"$1$"	 */"
"InstanceFilter.java:57"$1$"	public InstanceFilter(@Nullable Collection<? extends T> includes,"
"InstanceFilter.java:58"$1$"			@Nullable Collection<? extends T> excludes, boolean matchIfEmpty) {"
"InstanceFilter.java:59"$1$""
"InstanceFilter.java:60"$1$"		this.includes = (includes != null ? includes : Collections.emptyList());"
"InstanceFilter.java:61"$1$"		this.excludes = (excludes != null ? excludes : Collections.emptyList());"
"InstanceFilter.java:62"$1$"		this.matchIfEmpty = matchIfEmpty;"
"InstanceFilter.java:63"$1$"	}"
"InstanceFilter.java:64"$0$""
"InstanceFilter.java:65"$0$""
"InstanceFilter.java:66"$0$"	/**"
"InstanceFilter.java:67"$1$"	 * Determine if the specified {code instance} matches this filter."
"InstanceFilter.java:68"$0$"	 */"
"InstanceFilter.java:69"$1$"	public boolean match(T instance) {"
"InstanceFilter.java:70"$1$"		Assert.notNull(instance, ""Instance to match must not be null"");"
"InstanceFilter.java:71"$1$""
"InstanceFilter.java:72"$1$"		boolean includesSet = !this.includes.isEmpty();"
"InstanceFilter.java:73"$1$"		boolean excludesSet = !this.excludes.isEmpty();"
"InstanceFilter.java:74"$1$"		if (!includesSet && !excludesSet) {"
"InstanceFilter.java:75"$1$"			return this.matchIfEmpty;"
"InstanceFilter.java:76"$1$"		}"
"InstanceFilter.java:77"$0$""
"InstanceFilter.java:78"$0$"		boolean matchIncludes = match(instance, this.includes);"
"InstanceFilter.java:79"$0$"		boolean matchExcludes = match(instance, this.excludes);"
"InstanceFilter.java:80"$1$"		if (!includesSet) {"
"InstanceFilter.java:81"$1$"			return !matchExcludes;"
"InstanceFilter.java:82"$1$"		}"
"InstanceFilter.java:83"$1$"		if (!excludesSet) {"
"InstanceFilter.java:84"$1$"			return matchIncludes;"
"InstanceFilter.java:85"$1$"		}"
"InstanceFilter.java:86"$0$"		return matchIncludes && !matchExcludes;"
"InstanceFilter.java:87"$0$"	}"
"InstanceFilter.java:88"$0$""
"InstanceFilter.java:89"$0$"	/**"
"InstanceFilter.java:90"$1$"	 * Determine if the specified {@code instance} is equal to the"
"InstanceFilter.java:91"$1$"	 * specified {@code candidate}."
"InstanceFilter.java:92"$0$"	 * @param instance the instance to handle"
"InstanceFilter.java:93"$0$"	 * @param candidate a candidate defined by this filter"
"InstanceFilter.java:94"$1$"	 * @return {@code true} if the instance matches the candidate"
"InstanceFilter.java:95"$0$"	 */"
"InstanceFilter.java:96"$1$"	protected boolean match(T instance, T candidate) {"
"InstanceFilter.java:97"$1$"		return instance.equals(candidate);"
"InstanceFilter.java:98"$1$"	}"
"InstanceFilter.java:99"$0$""
"InstanceFilter.java:100"$0$"	/**"
"InstanceFilter.java:101"$1$"	 * Determine if the specified {@code instance} matches one of the candidates."
"InstanceFilter.java:102"$1$"	 * <p>If the candidates collection is {@code null}, returns {@code false}."
"InstanceFilter.java:103"$0$"	 * @param instance the instance to check"
"InstanceFilter.java:104"$0$"	 * @param candidates a list of candidates"
"InstanceFilter.java:105"$1$"	 * @return {@code true} if the instance match or the candidates collection is null"
"InstanceFilter.java:106"$0$"	 */"
"InstanceFilter.java:107"$1$"	protected boolean match(T instance, Collection<? extends T> candidates) {"
"InstanceFilter.java:108"$1$"		for (T candidate : candidates) {"
"InstanceFilter.java:109"$1$"			if (match(instance, candidate)) {"
"InstanceFilter.java:110"$1$"				return true;"
"InstanceFilter.java:111"$1$"			}"
"InstanceFilter.java:112"$0$"		}"
"InstanceFilter.java:113"$0$"		return false;"
"InstanceFilter.java:114"$0$"	}"
"InstanceFilter.java:115"$0$""
"InstanceFilter.java:116"$0$"	@Override"
"InstanceFilter.java:117"$1$"	public String toString() {"
"InstanceFilter.java:118"$1$"		StringBuilder sb = new StringBuilder(getClass().getSimpleName());"
"InstanceFilter.java:119"$1$"		sb.append("": includes="").append(this.includes);"
"InstanceFilter.java:120"$1$"		sb.append("", excludes="").append(this.excludes);"
"InstanceFilter.java:121"$1$"		sb.append("", matchIfEmpty="").append(this.matchIfEmpty);"
"InstanceFilter.java:122"$1$"		return sb.toString();"
"InstanceFilter.java:123"$1$"	}"
"InstanceFilter.java:124"$0$""
"InstanceFilter.java:125"$0$"}"
"ReactiveAdapterRegistry.java:1"$0$"/*"
"ReactiveAdapterRegistry.java:2"$0$" * Copyright 2002-2020 the original author or authors."
"ReactiveAdapterRegistry.java:3"$0$" *"
"ReactiveAdapterRegistry.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ReactiveAdapterRegistry.java:5"$0$" * you may not use this file except in compliance with the License."
"ReactiveAdapterRegistry.java:6"$0$" * You may obtain a copy of the License at"
"ReactiveAdapterRegistry.java:7"$0$" *"
"ReactiveAdapterRegistry.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ReactiveAdapterRegistry.java:9"$0$" *"
"ReactiveAdapterRegistry.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ReactiveAdapterRegistry.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ReactiveAdapterRegistry.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ReactiveAdapterRegistry.java:13"$0$" * See the License for the specific language governing permissions and"
"ReactiveAdapterRegistry.java:14"$0$" * limitations under the License."
"ReactiveAdapterRegistry.java:15"$0$" */"
"ReactiveAdapterRegistry.java:16"$0$""
"ReactiveAdapterRegistry.java:17"$0$"package org.springframework.core;"
"ReactiveAdapterRegistry.java:18"$0$""
"ReactiveAdapterRegistry.java:19"$0$"import java.lang.reflect.Method;"
"ReactiveAdapterRegistry.java:20"$0$"import java.util.ArrayList;"
"ReactiveAdapterRegistry.java:21"$0$"import java.util.List;"
"ReactiveAdapterRegistry.java:22"$0$"import java.util.Optional;"
"ReactiveAdapterRegistry.java:23"$0$"import java.util.concurrent.CompletableFuture;"
"ReactiveAdapterRegistry.java:24"$0$"import java.util.concurrent.CompletionStage;"
"ReactiveAdapterRegistry.java:25"$0$"import java.util.function.Function;"
"ReactiveAdapterRegistry.java:26"$0$""
"ReactiveAdapterRegistry.java:27"$0$"import io.reactivex.BackpressureStrategy;"
"ReactiveAdapterRegistry.java:28"$0$"import io.reactivex.Flowable;"
"ReactiveAdapterRegistry.java:29"$0$"import kotlinx.coroutines.CompletableDeferredKt;"
"ReactiveAdapterRegistry.java:30"$0$"import kotlinx.coroutines.Deferred;"
"ReactiveAdapterRegistry.java:31"$0$"import org.reactivestreams.Publisher;"
"ReactiveAdapterRegistry.java:32"$0$"import reactor.blockhound.BlockHound;"
"ReactiveAdapterRegistry.java:33"$0$"import reactor.blockhound.integration.BlockHoundIntegration;"
"ReactiveAdapterRegistry.java:34"$0$"import reactor.core.publisher.Flux;"
"ReactiveAdapterRegistry.java:35"$0$"import reactor.core.publisher.Mono;"
"ReactiveAdapterRegistry.java:36"$0$"import rx.RxReactiveStreams;"
"ReactiveAdapterRegistry.java:37"$0$""
"ReactiveAdapterRegistry.java:38"$0$"import org.springframework.lang.Nullable;"
"ReactiveAdapterRegistry.java:39"$0$"import org.springframework.util.ClassUtils;"
"ReactiveAdapterRegistry.java:40"$0$"import org.springframework.util.ConcurrentReferenceHashMap;"
"ReactiveAdapterRegistry.java:41"$0$"import org.springframework.util.ReflectionUtils;"
"ReactiveAdapterRegistry.java:42"$0$""
"ReactiveAdapterRegistry.java:43"$0$"/**"
"ReactiveAdapterRegistry.java:44"$1$" * A registry of adapters to adapt Reactive Streams {@link Publisher} to/from"
"ReactiveAdapterRegistry.java:45"$1$" * various async/reactive types such as {@code CompletableFuture}, RxJava"
"ReactiveAdapterRegistry.java:46"$1$" * {@code Observable}, and others."
"ReactiveAdapterRegistry.java:47"$0$" *"
"ReactiveAdapterRegistry.java:48"$0$" * <p>By default, depending on classpath availability, adapters are registered"
"ReactiveAdapterRegistry.java:49"$1$" * for Reactor, RxJava 1, RxJava 2 types, {@link CompletableFuture}, Java 9+"
"ReactiveAdapterRegistry.java:50"$1$" * {@code Flow.Publisher} and Kotlin Coroutines {@code Deferred} and {@code Flow}."
"ReactiveAdapterRegistry.java:51"$0$" *"
"ReactiveAdapterRegistry.java:52"$0$" * @author Rossen Stoyanchev"
"ReactiveAdapterRegistry.java:53"$0$" * @author Sebastien Deleuze"
"ReactiveAdapterRegistry.java:54"$0$" * @since 5.0"
"ReactiveAdapterRegistry.java:55"$0$" */"
"ReactiveAdapterRegistry.java:56"$1$"public class ReactiveAdapterRegistry {"
"ReactiveAdapterRegistry.java:57"$1$""
"ReactiveAdapterRegistry.java:58"$1$"	@Nullable"
"ReactiveAdapterRegistry.java:59"$1$"	private static volatile ReactiveAdapterRegistry sharedInstance;"
"ReactiveAdapterRegistry.java:60"$1$""
"ReactiveAdapterRegistry.java:61"$1$"	private final boolean reactorPresent;"
"ReactiveAdapterRegistry.java:62"$1$""
"ReactiveAdapterRegistry.java:63"$1$"	private final List<ReactiveAdapter> adapters = new ArrayList<>();"
"ReactiveAdapterRegistry.java:64"$1$""
"ReactiveAdapterRegistry.java:65"$1$""
"ReactiveAdapterRegistry.java:66"$1$"	/**"
"ReactiveAdapterRegistry.java:67"$1$"	 * Create a registry and auto-register default adapters."
"ReactiveAdapterRegistry.java:68"$1$"	 * @see #getSharedInstance()"
"ReactiveAdapterRegistry.java:69"$1$"	 */"
"ReactiveAdapterRegistry.java:70"$1$"	public ReactiveAdapterRegistry() {"
"ReactiveAdapterRegistry.java:71"$1$"		ClassLoader classLoader = ReactiveAdapterRegistry.class.getClassLoader();"
"ReactiveAdapterRegistry.java:72"$1$""
"ReactiveAdapterRegistry.java:73"$0$"		// Reactor"
"ReactiveAdapterRegistry.java:74"$1$"		boolean reactorRegistered = false;"
"ReactiveAdapterRegistry.java:75"$1$"		if (ClassUtils.isPresent(""reactor.core.publisher.Flux"", classLoader)) {"
"ReactiveAdapterRegistry.java:76"$1$"			new ReactorRegistrar().registerAdapters(this);"
"ReactiveAdapterRegistry.java:77"$1$"			reactorRegistered = true;"
"ReactiveAdapterRegistry.java:78"$1$"		}"
"ReactiveAdapterRegistry.java:79"$0$"		this.reactorPresent = reactorRegistered;"
"ReactiveAdapterRegistry.java:80"$0$""
"ReactiveAdapterRegistry.java:81"$0$"		// RxJava1"
"ReactiveAdapterRegistry.java:82"$0$"		if (ClassUtils.isPresent(""rx.Observable"", classLoader) &&"
"ReactiveAdapterRegistry.java:83"$1$"				ClassUtils.isPresent(""rx.RxReactiveStreams"", classLoader)) {"
"ReactiveAdapterRegistry.java:84"$1$"			new RxJava1Registrar().registerAdapters(this);"
"ReactiveAdapterRegistry.java:85"$1$"		}"
"ReactiveAdapterRegistry.java:86"$0$""
"ReactiveAdapterRegistry.java:87"$0$"		// RxJava2"
"ReactiveAdapterRegistry.java:88"$1$"		if (ClassUtils.isPresent(""io.reactivex.Flowable"", classLoader)) {"
"ReactiveAdapterRegistry.java:89"$1$"			new RxJava2Registrar().registerAdapters(this);"
"ReactiveAdapterRegistry.java:90"$1$"		}"
"ReactiveAdapterRegistry.java:91"$0$""
"ReactiveAdapterRegistry.java:92"$0$"		// Java 9+ Flow.Publisher"
"ReactiveAdapterRegistry.java:93"$1$"		if (ClassUtils.isPresent(""java.util.concurrent.Flow.Publisher"", classLoader)) {"
"ReactiveAdapterRegistry.java:94"$1$"			new ReactorJdkFlowAdapterRegistrar().registerAdapter(this);"
"ReactiveAdapterRegistry.java:95"$1$"		}"
"ReactiveAdapterRegistry.java:96"$0$"		// If not present, do nothing for the time being..."
"ReactiveAdapterRegistry.java:97"$0$"		// We can fall back on ""reactive-streams-flow-bridge"" (once released)"
"ReactiveAdapterRegistry.java:98"$0$""
"ReactiveAdapterRegistry.java:99"$0$"		// Coroutines"
"ReactiveAdapterRegistry.java:100"$1$"		if (this.reactorPresent && ClassUtils.isPresent(""kotlinx.coroutines.reactor.MonoKt"", classLoader)) {"
"ReactiveAdapterRegistry.java:101"$1$"			new CoroutinesRegistrar().registerAdapters(this);"
"ReactiveAdapterRegistry.java:102"$1$"		}"
"ReactiveAdapterRegistry.java:103"$0$"	}"
"ReactiveAdapterRegistry.java:104"$0$""
"ReactiveAdapterRegistry.java:105"$0$""
"ReactiveAdapterRegistry.java:106"$0$"	/**"
"ReactiveAdapterRegistry.java:107"$0$"	 * Whether the registry has any adapters which would be the case if any of"
"ReactiveAdapterRegistry.java:108"$0$"	 * Reactor, RxJava 2, or RxJava 1 (+ RxJava Reactive Streams bridge) are"
"ReactiveAdapterRegistry.java:109"$0$"	 * present on the classpath."
"ReactiveAdapterRegistry.java:110"$0$"	 */"
"ReactiveAdapterRegistry.java:111"$1$"	public boolean hasAdapters() {"
"ReactiveAdapterRegistry.java:112"$1$"		return !this.adapters.isEmpty();"
"ReactiveAdapterRegistry.java:113"$1$"	}"
"ReactiveAdapterRegistry.java:114"$0$""
"ReactiveAdapterRegistry.java:115"$0$"	/**"
"ReactiveAdapterRegistry.java:116"$0$"	 * Register a reactive type along with functions to adapt to and from a"
"ReactiveAdapterRegistry.java:117"$1$"	 * Reactive Streams {@link Publisher}. The function arguments assume that"
"ReactiveAdapterRegistry.java:118"$1$"	 * their input is neither {@code null} nor {@link Optional}."
"ReactiveAdapterRegistry.java:119"$0$"	 */"
"ReactiveAdapterRegistry.java:120"$0$"	public void registerReactiveType(ReactiveTypeDescriptor descriptor,"
"ReactiveAdapterRegistry.java:121"$1$"			Function<Object, Publisher<?>> toAdapter, Function<Publisher<?>, Object> fromAdapter) {"
"ReactiveAdapterRegistry.java:122"$1$""
"ReactiveAdapterRegistry.java:123"$1$"		if (this.reactorPresent) {"
"ReactiveAdapterRegistry.java:124"$1$"			this.adapters.add(new ReactorAdapter(descriptor, toAdapter, fromAdapter));"
"ReactiveAdapterRegistry.java:125"$1$"		}"
"ReactiveAdapterRegistry.java:126"$1$"		else {"
"ReactiveAdapterRegistry.java:127"$1$"			this.adapters.add(new ReactiveAdapter(descriptor, toAdapter, fromAdapter));"
"ReactiveAdapterRegistry.java:128"$1$"		}"
"ReactiveAdapterRegistry.java:129"$0$"	}"
"ReactiveAdapterRegistry.java:130"$0$""
"ReactiveAdapterRegistry.java:131"$0$"	/**"
"ReactiveAdapterRegistry.java:132"$0$"	 * Get the adapter for the given reactive type."
"ReactiveAdapterRegistry.java:133"$1$"	 * @return the corresponding adapter, or {@code null} if none available"
"ReactiveAdapterRegistry.java:134"$0$"	 */"
"ReactiveAdapterRegistry.java:135"$0$"	@Nullable"
"ReactiveAdapterRegistry.java:136"$1$"	public ReactiveAdapter getAdapter(Class<?> reactiveType) {"
"ReactiveAdapterRegistry.java:137"$1$"		return getAdapter(reactiveType, null);"
"ReactiveAdapterRegistry.java:138"$1$"	}"
"ReactiveAdapterRegistry.java:139"$0$""
"ReactiveAdapterRegistry.java:140"$0$"	/**"
"ReactiveAdapterRegistry.java:141"$0$"	 * Get the adapter for the given reactive type. Or if a ""source"" object is"
"ReactiveAdapterRegistry.java:142"$0$"	 * provided, its actual type is used instead."
"ReactiveAdapterRegistry.java:143"$0$"	 * @param reactiveType the reactive type"
"ReactiveAdapterRegistry.java:144"$1$"	 * (may be {@code null} if a concrete source object is given)"
"ReactiveAdapterRegistry.java:145"$0$"	 * @param source an instance of the reactive type"
"ReactiveAdapterRegistry.java:146"$1$"	 * (i.e. to adapt from; may be {@code null} if the reactive type is specified)"
"ReactiveAdapterRegistry.java:147"$1$"	 * @return the corresponding adapter, or {@code null} if none available"
"ReactiveAdapterRegistry.java:148"$0$"	 */"
"ReactiveAdapterRegistry.java:149"$0$"	@Nullable"
"ReactiveAdapterRegistry.java:150"$1$"	public ReactiveAdapter getAdapter(@Nullable Class<?> reactiveType, @Nullable Object source) {"
"ReactiveAdapterRegistry.java:151"$1$"		if (this.adapters.isEmpty()) {"
"ReactiveAdapterRegistry.java:152"$1$"			return null;"
"ReactiveAdapterRegistry.java:153"$1$"		}"
"ReactiveAdapterRegistry.java:154"$0$""
"ReactiveAdapterRegistry.java:155"$0$"		Object sourceToUse = (source instanceof Optional ? ((Optional<?>) source).orElse(null) : source);"
"ReactiveAdapterRegistry.java:156"$0$"		Class<?> clazz = (sourceToUse != null ? sourceToUse.getClass() : reactiveType);"
"ReactiveAdapterRegistry.java:157"$1$"		if (clazz == null) {"
"ReactiveAdapterRegistry.java:158"$1$"			return null;"
"ReactiveAdapterRegistry.java:159"$1$"		}"
"ReactiveAdapterRegistry.java:160"$1$"		for (ReactiveAdapter adapter : this.adapters) {"
"ReactiveAdapterRegistry.java:161"$1$"			if (adapter.getReactiveType() == clazz) {"
"ReactiveAdapterRegistry.java:162"$1$"				return adapter;"
"ReactiveAdapterRegistry.java:163"$1$"			}"
"ReactiveAdapterRegistry.java:164"$0$"		}"
"ReactiveAdapterRegistry.java:165"$1$"		for (ReactiveAdapter adapter : this.adapters) {"
"ReactiveAdapterRegistry.java:166"$1$"			if (adapter.getReactiveType().isAssignableFrom(clazz)) {"
"ReactiveAdapterRegistry.java:167"$1$"				return adapter;"
"ReactiveAdapterRegistry.java:168"$1$"			}"
"ReactiveAdapterRegistry.java:169"$0$"		}"
"ReactiveAdapterRegistry.java:170"$0$"		return null;"
"ReactiveAdapterRegistry.java:171"$0$"	}"
"ReactiveAdapterRegistry.java:172"$0$""
"ReactiveAdapterRegistry.java:173"$0$""
"ReactiveAdapterRegistry.java:174"$0$"	/**"
"ReactiveAdapterRegistry.java:175"$1$"	 * Return a shared default {@code ReactiveAdapterRegistry} instance,"
"ReactiveAdapterRegistry.java:176"$0$"	 * lazily building it once needed."
"ReactiveAdapterRegistry.java:177"$0$"	 * <p><b>NOTE:</b> We highly recommend passing a long-lived, pre-configured"
"ReactiveAdapterRegistry.java:178"$1$"	 * {@code ReactiveAdapterRegistry} instance for customization purposes."
"ReactiveAdapterRegistry.java:179"$0$"	 * This accessor is only meant as a fallback for code paths that want to"
"ReactiveAdapterRegistry.java:180"$0$"	 * fall back on a default instance if one isn't provided."
"ReactiveAdapterRegistry.java:181"$1$"	 * @return the shared {@code ReactiveAdapterRegistry} instance"
"ReactiveAdapterRegistry.java:182"$0$"	 * @since 5.0.2"
"ReactiveAdapterRegistry.java:183"$0$"	 */"
"ReactiveAdapterRegistry.java:184"$1$"	public static ReactiveAdapterRegistry getSharedInstance() {"
"ReactiveAdapterRegistry.java:185"$1$"		ReactiveAdapterRegistry registry = sharedInstance;"
"ReactiveAdapterRegistry.java:186"$1$"		if (registry == null) {"
"ReactiveAdapterRegistry.java:187"$1$"			synchronized (ReactiveAdapterRegistry.class) {"
"ReactiveAdapterRegistry.java:188"$1$"				registry = sharedInstance;"
"ReactiveAdapterRegistry.java:189"$1$"				if (registry == null) {"
"ReactiveAdapterRegistry.java:190"$1$"					registry = new ReactiveAdapterRegistry();"
"ReactiveAdapterRegistry.java:191"$1$"					sharedInstance = registry;"
"ReactiveAdapterRegistry.java:192"$1$"				}"
"ReactiveAdapterRegistry.java:193"$0$"			}"
"ReactiveAdapterRegistry.java:194"$0$"		}"
"ReactiveAdapterRegistry.java:195"$0$"		return registry;"
"ReactiveAdapterRegistry.java:196"$0$"	}"
"ReactiveAdapterRegistry.java:197"$0$""
"ReactiveAdapterRegistry.java:198"$0$""
"ReactiveAdapterRegistry.java:199"$1$"	private static class ReactorRegistrar {"
"ReactiveAdapterRegistry.java:200"$1$""
"ReactiveAdapterRegistry.java:201"$1$"		void registerAdapters(ReactiveAdapterRegistry registry) {"
"ReactiveAdapterRegistry.java:202"$0$"			// Register Flux and Mono before Publisher..."
"ReactiveAdapterRegistry.java:203"$1$""
"ReactiveAdapterRegistry.java:204"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:205"$1$"					ReactiveTypeDescriptor.singleOptionalValue(Mono.class, Mono::empty),"
"ReactiveAdapterRegistry.java:206"$1$"					source -> (Mono<?>) source,"
"ReactiveAdapterRegistry.java:207"$1$"					Mono::from"
"ReactiveAdapterRegistry.java:208"$1$"			);"
"ReactiveAdapterRegistry.java:209"$1$""
"ReactiveAdapterRegistry.java:210"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:211"$1$"					ReactiveTypeDescriptor.multiValue(Flux.class, Flux::empty),"
"ReactiveAdapterRegistry.java:212"$1$"					source -> (Flux<?>) source,"
"ReactiveAdapterRegistry.java:213"$1$"					Flux::from);"
"ReactiveAdapterRegistry.java:214"$1$""
"ReactiveAdapterRegistry.java:215"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:216"$1$"					ReactiveTypeDescriptor.multiValue(Publisher.class, Flux::empty),"
"ReactiveAdapterRegistry.java:217"$1$"					source -> (Publisher<?>) source,"
"ReactiveAdapterRegistry.java:218"$1$"					source -> source);"
"ReactiveAdapterRegistry.java:219"$1$""
"ReactiveAdapterRegistry.java:220"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:221"$1$"					ReactiveTypeDescriptor.singleOptionalValue(CompletionStage.class, EmptyCompletableFuture::new),"
"ReactiveAdapterRegistry.java:222"$1$"					source -> Mono.fromCompletionStage((CompletionStage<?>) source),"
"ReactiveAdapterRegistry.java:223"$1$"					source -> Mono.from(source).toFuture()"
"ReactiveAdapterRegistry.java:224"$1$"			);"
"ReactiveAdapterRegistry.java:225"$1$"		}"
"ReactiveAdapterRegistry.java:226"$0$"	}"
"ReactiveAdapterRegistry.java:227"$0$""
"ReactiveAdapterRegistry.java:228"$0$""
"ReactiveAdapterRegistry.java:229"$1$"	private static class RxJava1Registrar {"
"ReactiveAdapterRegistry.java:230"$1$""
"ReactiveAdapterRegistry.java:231"$1$"		void registerAdapters(ReactiveAdapterRegistry registry) {"
"ReactiveAdapterRegistry.java:232"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:233"$1$"					ReactiveTypeDescriptor.multiValue(rx.Observable.class, rx.Observable::empty),"
"ReactiveAdapterRegistry.java:234"$1$"					source -> RxReactiveStreams.toPublisher((rx.Observable<?>) source),"
"ReactiveAdapterRegistry.java:235"$1$"					RxReactiveStreams::toObservable"
"ReactiveAdapterRegistry.java:236"$1$"			);"
"ReactiveAdapterRegistry.java:237"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:238"$1$"					ReactiveTypeDescriptor.singleRequiredValue(rx.Single.class),"
"ReactiveAdapterRegistry.java:239"$1$"					source -> RxReactiveStreams.toPublisher((rx.Single<?>) source),"
"ReactiveAdapterRegistry.java:240"$1$"					RxReactiveStreams::toSingle"
"ReactiveAdapterRegistry.java:241"$1$"			);"
"ReactiveAdapterRegistry.java:242"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:243"$1$"					ReactiveTypeDescriptor.noValue(rx.Completable.class, rx.Completable::complete),"
"ReactiveAdapterRegistry.java:244"$1$"					source -> RxReactiveStreams.toPublisher((rx.Completable) source),"
"ReactiveAdapterRegistry.java:245"$1$"					RxReactiveStreams::toCompletable"
"ReactiveAdapterRegistry.java:246"$1$"			);"
"ReactiveAdapterRegistry.java:247"$1$"		}"
"ReactiveAdapterRegistry.java:248"$0$"	}"
"ReactiveAdapterRegistry.java:249"$0$""
"ReactiveAdapterRegistry.java:250"$0$""
"ReactiveAdapterRegistry.java:251"$1$"	private static class RxJava2Registrar {"
"ReactiveAdapterRegistry.java:252"$1$""
"ReactiveAdapterRegistry.java:253"$1$"		void registerAdapters(ReactiveAdapterRegistry registry) {"
"ReactiveAdapterRegistry.java:254"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:255"$1$"					ReactiveTypeDescriptor.multiValue(io.reactivex.Flowable.class, io.reactivex.Flowable::empty),"
"ReactiveAdapterRegistry.java:256"$1$"					source -> (io.reactivex.Flowable<?>) source,"
"ReactiveAdapterRegistry.java:257"$1$"					Flowable::fromPublisher"
"ReactiveAdapterRegistry.java:258"$1$"			);"
"ReactiveAdapterRegistry.java:259"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:260"$1$"					ReactiveTypeDescriptor.multiValue(io.reactivex.Observable.class, io.reactivex.Observable::empty),"
"ReactiveAdapterRegistry.java:261"$1$"					source -> ((io.reactivex.Observable<?>) source).toFlowable(BackpressureStrategy.BUFFER),"
"ReactiveAdapterRegistry.java:262"$1$"					source -> io.reactivex.Flowable.fromPublisher(source).toObservable()"
"ReactiveAdapterRegistry.java:263"$1$"			);"
"ReactiveAdapterRegistry.java:264"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:265"$1$"					ReactiveTypeDescriptor.singleRequiredValue(io.reactivex.Single.class),"
"ReactiveAdapterRegistry.java:266"$1$"					source -> ((io.reactivex.Single<?>) source).toFlowable(),"
"ReactiveAdapterRegistry.java:267"$1$"					source -> io.reactivex.Flowable.fromPublisher(source).toObservable().singleElement().toSingle()"
"ReactiveAdapterRegistry.java:268"$1$"			);"
"ReactiveAdapterRegistry.java:269"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:270"$1$"					ReactiveTypeDescriptor.singleOptionalValue(io.reactivex.Maybe.class, io.reactivex.Maybe::empty),"
"ReactiveAdapterRegistry.java:271"$1$"					source -> ((io.reactivex.Maybe<?>) source).toFlowable(),"
"ReactiveAdapterRegistry.java:272"$1$"					source -> io.reactivex.Flowable.fromPublisher(source).toObservable().singleElement()"
"ReactiveAdapterRegistry.java:273"$1$"			);"
"ReactiveAdapterRegistry.java:274"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:275"$1$"					ReactiveTypeDescriptor.noValue(io.reactivex.Completable.class, io.reactivex.Completable::complete),"
"ReactiveAdapterRegistry.java:276"$1$"					source -> ((io.reactivex.Completable) source).toFlowable(),"
"ReactiveAdapterRegistry.java:277"$1$"					source -> io.reactivex.Flowable.fromPublisher(source).toObservable().ignoreElements()"
"ReactiveAdapterRegistry.java:278"$1$"			);"
"ReactiveAdapterRegistry.java:279"$1$"		}"
"ReactiveAdapterRegistry.java:280"$0$"	}"
"ReactiveAdapterRegistry.java:281"$0$""
"ReactiveAdapterRegistry.java:282"$0$""
"ReactiveAdapterRegistry.java:283"$1$"	private static class ReactorJdkFlowAdapterRegistrar {"
"ReactiveAdapterRegistry.java:284"$1$""
"ReactiveAdapterRegistry.java:285"$1$"		void registerAdapter(ReactiveAdapterRegistry registry) {"
"ReactiveAdapterRegistry.java:286"$0$"			// TODO: remove reflection when build requires JDK 9+"
"ReactiveAdapterRegistry.java:287"$1$""
"ReactiveAdapterRegistry.java:288"$1$"			try {"
"ReactiveAdapterRegistry.java:289"$1$"				String publisherName = ""java.util.concurrent.Flow.Publisher"";"
"ReactiveAdapterRegistry.java:290"$1$"				Class<?> publisherClass = ClassUtils.forName(publisherName, getClass().getClassLoader());"
"ReactiveAdapterRegistry.java:291"$1$""
"ReactiveAdapterRegistry.java:292"$1$"				String adapterName = ""reactor.adapter.JdkFlowAdapter"";"
"ReactiveAdapterRegistry.java:293"$1$"				Class<?> flowAdapterClass = ClassUtils.forName(adapterName,  getClass().getClassLoader());"
"ReactiveAdapterRegistry.java:294"$1$""
"ReactiveAdapterRegistry.java:295"$1$"				Method toFluxMethod = flowAdapterClass.getMethod(""flowPublisherToFlux"", publisherClass);"
"ReactiveAdapterRegistry.java:296"$1$"				Method toFlowMethod = flowAdapterClass.getMethod(""publisherToFlowPublisher"", Publisher.class);"
"ReactiveAdapterRegistry.java:297"$1$"				Object emptyFlow = ReflectionUtils.invokeMethod(toFlowMethod, null, Flux.empty());"
"ReactiveAdapterRegistry.java:298"$1$""
"ReactiveAdapterRegistry.java:299"$1$"				registry.registerReactiveType("
"ReactiveAdapterRegistry.java:300"$1$"						ReactiveTypeDescriptor.multiValue(publisherClass, () -> emptyFlow),"
"ReactiveAdapterRegistry.java:301"$1$"						source -> (Publisher<?>) ReflectionUtils.invokeMethod(toFluxMethod, null, source),"
"ReactiveAdapterRegistry.java:302"$1$"						publisher -> ReflectionUtils.invokeMethod(toFlowMethod, null, publisher)"
"ReactiveAdapterRegistry.java:303"$1$"				);"
"ReactiveAdapterRegistry.java:304"$1$"			}"
"ReactiveAdapterRegistry.java:305"$1$"			catch (Throwable ex) {"
"ReactiveAdapterRegistry.java:306"$0$"				// Ignore"
"ReactiveAdapterRegistry.java:307"$1$"			}"
"ReactiveAdapterRegistry.java:308"$0$"		}"
"ReactiveAdapterRegistry.java:309"$0$"	}"
"ReactiveAdapterRegistry.java:310"$0$""
"ReactiveAdapterRegistry.java:311"$0$""
"ReactiveAdapterRegistry.java:312"$0$"	/**"
"ReactiveAdapterRegistry.java:313"$1$"	 * ReactiveAdapter variant that wraps adapted Publishers as {@link Flux} or"
"ReactiveAdapterRegistry.java:314"$1$"	 * {@link Mono} depending on {@link ReactiveTypeDescriptor#isMultiValue()}."
"ReactiveAdapterRegistry.java:315"$0$"	 * This is important in places where only the stream and stream element type"
"ReactiveAdapterRegistry.java:316"$0$"	 * information is available like encoders and decoders."
"ReactiveAdapterRegistry.java:317"$0$"	 */"
"ReactiveAdapterRegistry.java:318"$1$"	private static class ReactorAdapter extends ReactiveAdapter {"
"ReactiveAdapterRegistry.java:319"$1$""
"ReactiveAdapterRegistry.java:320"$1$"		ReactorAdapter(ReactiveTypeDescriptor descriptor,"
"ReactiveAdapterRegistry.java:321"$1$"				Function<Object, Publisher<?>> toPublisherFunction,"
"ReactiveAdapterRegistry.java:322"$1$"				Function<Publisher<?>, Object> fromPublisherFunction) {"
"ReactiveAdapterRegistry.java:323"$1$""
"ReactiveAdapterRegistry.java:324"$1$"			super(descriptor, toPublisherFunction, fromPublisherFunction);"
"ReactiveAdapterRegistry.java:325"$1$"		}"
"ReactiveAdapterRegistry.java:326"$0$""
"ReactiveAdapterRegistry.java:327"$0$"		@Override"
"ReactiveAdapterRegistry.java:328"$1$"		public <T> Publisher<T> toPublisher(@Nullable Object source) {"
"ReactiveAdapterRegistry.java:329"$1$"			Publisher<T> publisher = super.toPublisher(source);"
"ReactiveAdapterRegistry.java:330"$1$"			return (isMultiValue() ? Flux.from(publisher) : Mono.from(publisher));"
"ReactiveAdapterRegistry.java:331"$1$"		}"
"ReactiveAdapterRegistry.java:332"$0$"	}"
"ReactiveAdapterRegistry.java:333"$0$""
"ReactiveAdapterRegistry.java:334"$0$""
"ReactiveAdapterRegistry.java:335"$1$"	private static class EmptyCompletableFuture<T> extends CompletableFuture<T> {"
"ReactiveAdapterRegistry.java:336"$1$""
"ReactiveAdapterRegistry.java:337"$1$"		EmptyCompletableFuture() {"
"ReactiveAdapterRegistry.java:338"$1$"			complete(null);"
"ReactiveAdapterRegistry.java:339"$1$"		}"
"ReactiveAdapterRegistry.java:340"$0$"	}"
"ReactiveAdapterRegistry.java:341"$0$""
"ReactiveAdapterRegistry.java:342"$0$""
"ReactiveAdapterRegistry.java:343"$1$"	private static class CoroutinesRegistrar {"
"ReactiveAdapterRegistry.java:344"$1$""
"ReactiveAdapterRegistry.java:345"$1$"		@SuppressWarnings(""KotlinInternalInJava"")"
"ReactiveAdapterRegistry.java:346"$1$"		void registerAdapters(ReactiveAdapterRegistry registry) {"
"ReactiveAdapterRegistry.java:347"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:348"$1$"					ReactiveTypeDescriptor.singleOptionalValue(Deferred.class,"
"ReactiveAdapterRegistry.java:349"$1$"							() -> CompletableDeferredKt.CompletableDeferred(null)),"
"ReactiveAdapterRegistry.java:350"$1$"					source -> CoroutinesUtils.deferredToMono((Deferred<?>) source),"
"ReactiveAdapterRegistry.java:351"$1$"					source -> CoroutinesUtils.monoToDeferred(Mono.from(source)));"
"ReactiveAdapterRegistry.java:352"$1$""
"ReactiveAdapterRegistry.java:353"$1$"			registry.registerReactiveType("
"ReactiveAdapterRegistry.java:354"$1$"					ReactiveTypeDescriptor.multiValue(kotlinx.coroutines.flow.Flow.class, kotlinx.coroutines.flow.FlowKt::emptyFlow),"
"ReactiveAdapterRegistry.java:355"$1$"					source -> kotlinx.coroutines.reactor.ReactorFlowKt.asFlux((kotlinx.coroutines.flow.Flow<?>) source),"
"ReactiveAdapterRegistry.java:356"$1$"					kotlinx.coroutines.reactive.ReactiveFlowKt::asFlow"
"ReactiveAdapterRegistry.java:357"$1$"			);"
"ReactiveAdapterRegistry.java:358"$1$"		}"
"ReactiveAdapterRegistry.java:359"$0$"	}"
"ReactiveAdapterRegistry.java:360"$0$""
"ReactiveAdapterRegistry.java:361"$0$""
"ReactiveAdapterRegistry.java:362"$0$"	/**"
"ReactiveAdapterRegistry.java:363"$1$"	 * {@code BlockHoundIntegration} for spring-core classes."
"ReactiveAdapterRegistry.java:364"$0$"	 * <p>Whitelists the following:"
"ReactiveAdapterRegistry.java:365"$0$"	 * <ul>"
"ReactiveAdapterRegistry.java:366"$1$"	 * <li>Reading class info via {@link LocalVariableTableParameterNameDiscoverer}."
"ReactiveAdapterRegistry.java:367"$1$"	 * <li>Locking within {@link ConcurrentReferenceHashMap}."
"ReactiveAdapterRegistry.java:368"$0$"	 * </ul>"
"ReactiveAdapterRegistry.java:369"$0$"	 * @since 5.2.4"
"ReactiveAdapterRegistry.java:370"$0$"	 */"
"ReactiveAdapterRegistry.java:371"$1$"	public static class SpringCoreBlockHoundIntegration implements BlockHoundIntegration {"
"ReactiveAdapterRegistry.java:372"$1$""
"ReactiveAdapterRegistry.java:373"$1$"		@Override"
"ReactiveAdapterRegistry.java:374"$1$"		public void applyTo(BlockHound.Builder builder) {"
"ReactiveAdapterRegistry.java:375"$1$""
"ReactiveAdapterRegistry.java:376"$0$"			// Avoid hard references potentially anywhere in spring-core (no need for structural dependency)"
"ReactiveAdapterRegistry.java:377"$1$""
"ReactiveAdapterRegistry.java:378"$1$"			builder.allowBlockingCallsInside("
"ReactiveAdapterRegistry.java:379"$1$"					""org.springframework.core.LocalVariableTableParameterNameDiscoverer"", ""inspectClass"");"
"ReactiveAdapterRegistry.java:380"$1$""
"ReactiveAdapterRegistry.java:381"$1$"			String className = ""org.springframework.util.ConcurrentReferenceHashMap$Segment"";"
"ReactiveAdapterRegistry.java:382"$1$"			builder.allowBlockingCallsInside(className, ""doTask"");"
"ReactiveAdapterRegistry.java:383"$1$"			builder.allowBlockingCallsInside(className, ""clear"");"
"ReactiveAdapterRegistry.java:384"$1$"			builder.allowBlockingCallsInside(className, ""restructure"");"
"ReactiveAdapterRegistry.java:385"$1$"		}"
"ReactiveAdapterRegistry.java:386"$0$"	}"
"ReactiveAdapterRegistry.java:387"$0$""
"ReactiveAdapterRegistry.java:388"$0$"}"
"ResourceUtils.java:1"$0$"/*"
"ResourceUtils.java:2"$0$" * Copyright 2002-2018 the original author or authors."
"ResourceUtils.java:3"$0$" *"
"ResourceUtils.java:4"$0$" * Licensed under the Apache License, Version 2.0 (the ""License"");"
"ResourceUtils.java:5"$0$" * you may not use this file except in compliance with the License."
"ResourceUtils.java:6"$0$" * You may obtain a copy of the License at"
"ResourceUtils.java:7"$0$" *"
"ResourceUtils.java:8"$0$" *      https://www.apache.org/licenses/LICENSE-2.0"
"ResourceUtils.java:9"$0$" *"
"ResourceUtils.java:10"$0$" * Unless required by applicable law or agreed to in writing, software"
"ResourceUtils.java:11"$0$" * distributed under the License is distributed on an ""AS IS"" BASIS,"
"ResourceUtils.java:12"$0$" * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied."
"ResourceUtils.java:13"$0$" * See the License for the specific language governing permissions and"
"ResourceUtils.java:14"$0$" * limitations under the License."
"ResourceUtils.java:15"$0$" */"
"ResourceUtils.java:16"$0$""
"ResourceUtils.java:17"$0$"package org.springframework.util;"
"ResourceUtils.java:18"$0$""
"ResourceUtils.java:19"$0$"import java.io.File;"
"ResourceUtils.java:20"$0$"import java.io.FileNotFoundException;"
"ResourceUtils.java:21"$0$"import java.net.MalformedURLException;"
"ResourceUtils.java:22"$0$"import java.net.URI;"
"ResourceUtils.java:23"$0$"import java.net.URISyntaxException;"
"ResourceUtils.java:24"$0$"import java.net.URL;"
"ResourceUtils.java:25"$0$"import java.net.URLConnection;"
"ResourceUtils.java:26"$0$""
"ResourceUtils.java:27"$0$"import org.springframework.lang.Nullable;"
"ResourceUtils.java:28"$0$""
"ResourceUtils.java:29"$0$"/**"
"ResourceUtils.java:30"$0$" * Utility methods for resolving resource locations to files in the"
"ResourceUtils.java:31"$0$" * file system. Mainly for internal use within the framework."
"ResourceUtils.java:32"$0$" *"
"ResourceUtils.java:33"$0$" * <p>Consider using Spring's Resource abstraction in the core package"
"ResourceUtils.java:34"$0$" * for handling all kinds of file resources in a uniform manner."
"ResourceUtils.java:35"$1$" * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}"
"ResourceUtils.java:36"$1$" * method can resolve any location to a {@link org.springframework.core.io.Resource}"
"ResourceUtils.java:37"$1$" * object, which in turn allows one to obtain a {@code java.io.File} in the"
"ResourceUtils.java:38"$1$" * file system through its {@code getFile()} method."
"ResourceUtils.java:39"$0$" *"
"ResourceUtils.java:40"$0$" * @author Juergen Hoeller"
"ResourceUtils.java:41"$0$" * @since 1.1.5"
"ResourceUtils.java:42"$0$" * @see org.springframework.core.io.Resource"
"ResourceUtils.java:43"$0$" * @see org.springframework.core.io.ClassPathResource"
"ResourceUtils.java:44"$0$" * @see org.springframework.core.io.FileSystemResource"
"ResourceUtils.java:45"$0$" * @see org.springframework.core.io.UrlResource"
"ResourceUtils.java:46"$0$" * @see org.springframework.core.io.ResourceLoader"
"ResourceUtils.java:47"$0$" */"
"ResourceUtils.java:48"$1$"public abstract class ResourceUtils {"
"ResourceUtils.java:49"$1$""
"ResourceUtils.java:50"$1$"	/** Pseudo URL prefix for loading from the class path: ""classpath:"". */"
"ResourceUtils.java:51"$1$"	public static final String CLASSPATH_URL_PREFIX = ""classpath:"";"
"ResourceUtils.java:52"$1$""
"ResourceUtils.java:53"$1$"	/** URL prefix for loading from the file system: ""file:"". */"
"ResourceUtils.java:54"$1$"	public static final String FILE_URL_PREFIX = ""file:"";"
"ResourceUtils.java:55"$1$""
"ResourceUtils.java:56"$1$"	/** URL prefix for loading from a jar file: ""jar:"". */"
"ResourceUtils.java:57"$1$"	public static final String JAR_URL_PREFIX = ""jar:"";"
"ResourceUtils.java:58"$1$""
"ResourceUtils.java:59"$1$"	/** URL prefix for loading from a war file on Tomcat: ""war:"". */"
"ResourceUtils.java:60"$1$"	public static final String WAR_URL_PREFIX = ""war:"";"
"ResourceUtils.java:61"$1$""
"ResourceUtils.java:62"$1$"	/** URL protocol for a file in the file system: ""file"". */"
"ResourceUtils.java:63"$1$"	public static final String URL_PROTOCOL_FILE = ""file"";"
"ResourceUtils.java:64"$1$""
"ResourceUtils.java:65"$1$"	/** URL protocol for an entry from a jar file: ""jar"". */"
"ResourceUtils.java:66"$1$"	public static final String URL_PROTOCOL_JAR = ""jar"";"
"ResourceUtils.java:67"$1$""
"ResourceUtils.java:68"$1$"	/** URL protocol for an entry from a war file: ""war"". */"
"ResourceUtils.java:69"$1$"	public static final String URL_PROTOCOL_WAR = ""war"";"
"ResourceUtils.java:70"$1$""
"ResourceUtils.java:71"$1$"	/** URL protocol for an entry from a zip file: ""zip"". */"
"ResourceUtils.java:72"$1$"	public static final String URL_PROTOCOL_ZIP = ""zip"";"
"ResourceUtils.java:73"$1$""
"ResourceUtils.java:74"$1$"	/** URL protocol for an entry from a WebSphere jar file: ""wsjar"". */"
"ResourceUtils.java:75"$1$"	public static final String URL_PROTOCOL_WSJAR = ""wsjar"";"
"ResourceUtils.java:76"$1$""
"ResourceUtils.java:77"$1$"	/** URL protocol for an entry from a JBoss jar file: ""vfszip"". */"
"ResourceUtils.java:78"$1$"	public static final String URL_PROTOCOL_VFSZIP = ""vfszip"";"
"ResourceUtils.java:79"$1$""
"ResourceUtils.java:80"$1$"	/** URL protocol for a JBoss file system resource: ""vfsfile"". */"
"ResourceUtils.java:81"$1$"	public static final String URL_PROTOCOL_VFSFILE = ""vfsfile"";"
"ResourceUtils.java:82"$1$""
"ResourceUtils.java:83"$1$"	/** URL protocol for a general JBoss VFS resource: ""vfs"". */"
"ResourceUtils.java:84"$1$"	public static final String URL_PROTOCOL_VFS = ""vfs"";"
"ResourceUtils.java:85"$1$""
"ResourceUtils.java:86"$1$"	/** File extension for a regular jar file: "".jar"". */"
"ResourceUtils.java:87"$1$"	public static final String JAR_FILE_EXTENSION = "".jar"";"
"ResourceUtils.java:88"$1$""
"ResourceUtils.java:89"$1$"	/** Separator between JAR URL and file path within the JAR: ""!/"". */"
"ResourceUtils.java:90"$1$"	public static final String JAR_URL_SEPARATOR = ""!/"";"
"ResourceUtils.java:91"$1$""
"ResourceUtils.java:92"$1$"	/** Special separator between WAR URL and jar part on Tomcat. */"
"ResourceUtils.java:93"$1$"	public static final String WAR_URL_SEPARATOR = ""*/"";"
"ResourceUtils.java:94"$1$""
"ResourceUtils.java:95"$1$""
"ResourceUtils.java:96"$1$"	/**"
"ResourceUtils.java:97"$1$"	 * Return whether the given resource location is a URL:"
"ResourceUtils.java:98"$1$"	 * either a special ""classpath"" pseudo URL or a standard URL."
"ResourceUtils.java:99"$1$"	 * @param resourceLocation the location String to check"
"ResourceUtils.java:100"$1$"	 * @return whether the location qualifies as a URL"
"ResourceUtils.java:101"$1$"	 * @see #CLASSPATH_URL_PREFIX"
"ResourceUtils.java:102"$1$"	 * @see java.net.URL"
"ResourceUtils.java:103"$1$"	 */"
"ResourceUtils.java:104"$1$"	public static boolean isUrl(@Nullable String resourceLocation) {"
"ResourceUtils.java:105"$1$"		if (resourceLocation == null) {"
"ResourceUtils.java:106"$1$"			return false;"
"ResourceUtils.java:107"$1$"		}"
"ResourceUtils.java:108"$1$"		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {"
"ResourceUtils.java:109"$1$"			return true;"
"ResourceUtils.java:110"$1$"		}"
"ResourceUtils.java:111"$1$"		try {"
"ResourceUtils.java:112"$1$"			new URL(resourceLocation);"
"ResourceUtils.java:113"$1$"			return true;"
"ResourceUtils.java:114"$1$"		}"
"ResourceUtils.java:115"$1$"		catch (MalformedURLException ex) {"
"ResourceUtils.java:116"$1$"			return false;"
"ResourceUtils.java:117"$1$"		}"
"ResourceUtils.java:118"$0$"	}"
"ResourceUtils.java:119"$0$""
"ResourceUtils.java:120"$0$"	/**"
"ResourceUtils.java:121"$1$"	 * Resolve the given resource location to a {@code java.net.URL}."
"ResourceUtils.java:122"$0$"	 * <p>Does not check whether the URL actually exists; simply returns"
"ResourceUtils.java:123"$0$"	 * the URL that the given location would correspond to."
"ResourceUtils.java:124"$0$"	 * @param resourceLocation the resource location to resolve: either a"
"ResourceUtils.java:125"$0$"	 * ""classpath:"" pseudo URL, a ""file:"" URL, or a plain file path"
"ResourceUtils.java:126"$0$"	 * @return a corresponding URL object"
"ResourceUtils.java:127"$0$"	 * @throws FileNotFoundException if the resource cannot be resolved to a URL"
"ResourceUtils.java:128"$0$"	 */"
"ResourceUtils.java:129"$1$"	public static URL getURL(String resourceLocation) throws FileNotFoundException {"
"ResourceUtils.java:130"$1$"		Assert.notNull(resourceLocation, ""Resource location must not be null"");"
"ResourceUtils.java:131"$1$"		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {"
"ResourceUtils.java:132"$1$"			String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());"
"ResourceUtils.java:133"$1$"			ClassLoader cl = ClassUtils.getDefaultClassLoader();"
"ResourceUtils.java:134"$1$"			URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));"
"ResourceUtils.java:135"$1$"			if (url == null) {"
"ResourceUtils.java:136"$1$"				String description = ""class path resource ["" + path + ""]"";"
"ResourceUtils.java:137"$1$"				throw new FileNotFoundException(description +"
"ResourceUtils.java:138"$1$"						"" cannot be resolved to URL because it does not exist"");"
"ResourceUtils.java:139"$1$"			}"
"ResourceUtils.java:140"$0$"			return url;"
"ResourceUtils.java:141"$0$"		}"
"ResourceUtils.java:142"$1$"		try {"
"ResourceUtils.java:143"$0$"			// try URL"
"ResourceUtils.java:144"$1$"			return new URL(resourceLocation);"
"ResourceUtils.java:145"$1$"		}"
"ResourceUtils.java:146"$1$"		catch (MalformedURLException ex) {"
"ResourceUtils.java:147"$0$"			// no URL -> treat as file path"
"ResourceUtils.java:148"$1$"			try {"
"ResourceUtils.java:149"$1$"				return new File(resourceLocation).toURI().toURL();"
"ResourceUtils.java:150"$1$"			}"
"ResourceUtils.java:151"$1$"			catch (MalformedURLException ex2) {"
"ResourceUtils.java:152"$1$"				throw new FileNotFoundException(""Resource location ["" + resourceLocation +"
"ResourceUtils.java:153"$1$"						""] is neither a URL not a well-formed file path"");"
"ResourceUtils.java:154"$1$"			}"
"ResourceUtils.java:155"$0$"		}"
"ResourceUtils.java:156"$0$"	}"
"ResourceUtils.java:157"$0$""
"ResourceUtils.java:158"$0$"	/**"
"ResourceUtils.java:159"$1$"	 * Resolve the given resource location to a {@code java.io.File},"
"ResourceUtils.java:160"$0$"	 * i.e. to a file in the file system."
"ResourceUtils.java:161"$0$"	 * <p>Does not check whether the file actually exists; simply returns"
"ResourceUtils.java:162"$0$"	 * the File that the given location would correspond to."
"ResourceUtils.java:163"$0$"	 * @param resourceLocation the resource location to resolve: either a"
"ResourceUtils.java:164"$0$"	 * ""classpath:"" pseudo URL, a ""file:"" URL, or a plain file path"
"ResourceUtils.java:165"$0$"	 * @return a corresponding File object"
"ResourceUtils.java:166"$0$"	 * @throws FileNotFoundException if the resource cannot be resolved to"
"ResourceUtils.java:167"$0$"	 * a file in the file system"
"ResourceUtils.java:168"$0$"	 */"
"ResourceUtils.java:169"$1$"	public static File getFile(String resourceLocation) throws FileNotFoundException {"
"ResourceUtils.java:170"$1$"		Assert.notNull(resourceLocation, ""Resource location must not be null"");"
"ResourceUtils.java:171"$1$"		if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {"
"ResourceUtils.java:172"$1$"			String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());"
"ResourceUtils.java:173"$1$"			String description = ""class path resource ["" + path + ""]"";"
"ResourceUtils.java:174"$1$"			ClassLoader cl = ClassUtils.getDefaultClassLoader();"
"ResourceUtils.java:175"$1$"			URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));"
"ResourceUtils.java:176"$1$"			if (url == null) {"
"ResourceUtils.java:177"$1$"				throw new FileNotFoundException(description +"
"ResourceUtils.java:178"$1$"						"" cannot be resolved to absolute file path because it does not exist"");"
"ResourceUtils.java:179"$1$"			}"
"ResourceUtils.java:180"$0$"			return getFile(url, description);"
"ResourceUtils.java:181"$0$"		}"
"ResourceUtils.java:182"$1$"		try {"
"ResourceUtils.java:183"$0$"			// try URL"
"ResourceUtils.java:184"$1$"			return getFile(new URL(resourceLocation));"
"ResourceUtils.java:185"$1$"		}"
"ResourceUtils.java:186"$1$"		catch (MalformedURLException ex) {"
"ResourceUtils.java:187"$0$"			// no URL -> treat as file path"
"ResourceUtils.java:188"$1$"			return new File(resourceLocation);"
"ResourceUtils.java:189"$1$"		}"
"ResourceUtils.java:190"$0$"	}"
"ResourceUtils.java:191"$0$""
"ResourceUtils.java:192"$0$"	/**"
"ResourceUtils.java:193"$1$"	 * Resolve the given resource URL to a {@code java.io.File},"
"ResourceUtils.java:194"$0$"	 * i.e. to a file in the file system."
"ResourceUtils.java:195"$0$"	 * @param resourceUrl the resource URL to resolve"
"ResourceUtils.java:196"$0$"	 * @return a corresponding File object"
"ResourceUtils.java:197"$0$"	 * @throws FileNotFoundException if the URL cannot be resolved to"
"ResourceUtils.java:198"$0$"	 * a file in the file system"
"ResourceUtils.java:199"$0$"	 */"
"ResourceUtils.java:200"$1$"	public static File getFile(URL resourceUrl) throws FileNotFoundException {"
"ResourceUtils.java:201"$1$"		return getFile(resourceUrl, ""URL"");"
"ResourceUtils.java:202"$1$"	}"
"ResourceUtils.java:203"$0$""
"ResourceUtils.java:204"$0$"	/**"
"ResourceUtils.java:205"$1$"	 * Resolve the given resource URL to a {@code java.io.File},"
"ResourceUtils.java:206"$0$"	 * i.e. to a file in the file system."
"ResourceUtils.java:207"$0$"	 * @param resourceUrl the resource URL to resolve"
"ResourceUtils.java:208"$0$"	 * @param description a description of the original resource that"
"ResourceUtils.java:209"$0$"	 * the URL was created for (for example, a class path location)"
"ResourceUtils.java:210"$0$"	 * @return a corresponding File object"
"ResourceUtils.java:211"$0$"	 * @throws FileNotFoundException if the URL cannot be resolved to"
"ResourceUtils.java:212"$0$"	 * a file in the file system"
"ResourceUtils.java:213"$0$"	 */"
"ResourceUtils.java:214"$1$"	public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {"
"ResourceUtils.java:215"$1$"		Assert.notNull(resourceUrl, ""Resource URL must not be null"");"
"ResourceUtils.java:216"$1$"		if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {"
"ResourceUtils.java:217"$1$"			throw new FileNotFoundException("
"ResourceUtils.java:218"$1$"					description + "" cannot be resolved to absolute file path "" +"
"ResourceUtils.java:219"$1$"					""because it does not reside in the file system: "" + resourceUrl);"
"ResourceUtils.java:220"$1$"		}"
"ResourceUtils.java:221"$1$"		try {"
"ResourceUtils.java:222"$1$"			return new File(toURI(resourceUrl).getSchemeSpecificPart());"
"ResourceUtils.java:223"$1$"		}"
"ResourceUtils.java:224"$1$"		catch (URISyntaxException ex) {"
"ResourceUtils.java:225"$0$"			// Fallback for URLs that are not valid URIs (should hardly ever happen)."
"ResourceUtils.java:226"$1$"			return new File(resourceUrl.getFile());"
"ResourceUtils.java:227"$1$"		}"
"ResourceUtils.java:228"$0$"	}"
"ResourceUtils.java:229"$0$""
"ResourceUtils.java:230"$0$"	/**"
"ResourceUtils.java:231"$1$"	 * Resolve the given resource URI to a {@code java.io.File},"
"ResourceUtils.java:232"$0$"	 * i.e. to a file in the file system."
"ResourceUtils.java:233"$0$"	 * @param resourceUri the resource URI to resolve"
"ResourceUtils.java:234"$0$"	 * @return a corresponding File object"
"ResourceUtils.java:235"$0$"	 * @throws FileNotFoundException if the URL cannot be resolved to"
"ResourceUtils.java:236"$0$"	 * a file in the file system"
"ResourceUtils.java:237"$0$"	 * @since 2.5"
"ResourceUtils.java:238"$0$"	 */"
"ResourceUtils.java:239"$1$"	public static File getFile(URI resourceUri) throws FileNotFoundException {"
"ResourceUtils.java:240"$1$"		return getFile(resourceUri, ""URI"");"
"ResourceUtils.java:241"$1$"	}"
"ResourceUtils.java:242"$0$""
"ResourceUtils.java:243"$0$"	/**"
"ResourceUtils.java:244"$1$"	 * Resolve the given resource URI to a {@code java.io.File},"
"ResourceUtils.java:245"$0$"	 * i.e. to a file in the file system."
"ResourceUtils.java:246"$0$"	 * @param resourceUri the resource URI to resolve"
"ResourceUtils.java:247"$0$"	 * @param description a description of the original resource that"
"ResourceUtils.java:248"$0$"	 * the URI was created for (for example, a class path location)"
"ResourceUtils.java:249"$0$"	 * @return a corresponding File object"
"ResourceUtils.java:250"$0$"	 * @throws FileNotFoundException if the URL cannot be resolved to"
"ResourceUtils.java:251"$0$"	 * a file in the file system"
"ResourceUtils.java:252"$0$"	 * @since 2.5"
"ResourceUtils.java:253"$0$"	 */"
"ResourceUtils.java:254"$1$"	public static File getFile(URI resourceUri, String description) throws FileNotFoundException {"
"ResourceUtils.java:255"$1$"		Assert.notNull(resourceUri, ""Resource URI must not be null"");"
"ResourceUtils.java:256"$1$"		if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {"
"ResourceUtils.java:257"$1$"			throw new FileNotFoundException("
"ResourceUtils.java:258"$1$"					description + "" cannot be resolved to absolute file path "" +"
"ResourceUtils.java:259"$1$"					""because it does not reside in the file system: "" + resourceUri);"
"ResourceUtils.java:260"$1$"		}"
"ResourceUtils.java:261"$0$"		return new File(resourceUri.getSchemeSpecificPart());"
"ResourceUtils.java:262"$0$"	}"
"ResourceUtils.java:263"$0$""
"ResourceUtils.java:264"$0$"	/**"
"ResourceUtils.java:265"$0$"	 * Determine whether the given URL points to a resource in the file system,"
"ResourceUtils.java:266"$0$"	 * i.e. has protocol ""file"", ""vfsfile"" or ""vfs""."
"ResourceUtils.java:267"$0$"	 * @param url the URL to check"
"ResourceUtils.java:268"$0$"	 * @return whether the URL has been identified as a file system URL"
"ResourceUtils.java:269"$0$"	 */"
"ResourceUtils.java:270"$1$"	public static boolean isFileURL(URL url) {"
"ResourceUtils.java:271"$1$"		String protocol = url.getProtocol();"
"ResourceUtils.java:272"$1$"		return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol) ||"
"ResourceUtils.java:273"$1$"				URL_PROTOCOL_VFS.equals(protocol));"
"ResourceUtils.java:274"$1$"	}"
"ResourceUtils.java:275"$0$""
"ResourceUtils.java:276"$0$"	/**"
"ResourceUtils.java:277"$0$"	 * Determine whether the given URL points to a resource in a jar file."
"ResourceUtils.java:278"$0$"	 * i.e. has protocol ""jar"", ""war, """"zip"", ""vfszip"" or ""wsjar""."
"ResourceUtils.java:279"$0$"	 * @param url the URL to check"
"ResourceUtils.java:280"$0$"	 * @return whether the URL has been identified as a JAR URL"
"ResourceUtils.java:281"$0$"	 */"
"ResourceUtils.java:282"$1$"	public static boolean isJarURL(URL url) {"
"ResourceUtils.java:283"$1$"		String protocol = url.getProtocol();"
"ResourceUtils.java:284"$1$"		return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_WAR.equals(protocol) ||"
"ResourceUtils.java:285"$1$"				URL_PROTOCOL_ZIP.equals(protocol) || URL_PROTOCOL_VFSZIP.equals(protocol) ||"
"ResourceUtils.java:286"$1$"				URL_PROTOCOL_WSJAR.equals(protocol));"
"ResourceUtils.java:287"$1$"	}"
"ResourceUtils.java:288"$0$""
"ResourceUtils.java:289"$0$"	/**"
"ResourceUtils.java:290"$0$"	 * Determine whether the given URL points to a jar file itself,"
"ResourceUtils.java:291"$0$"	 * that is, has protocol ""file"" and ends with the "".jar"" extension."
"ResourceUtils.java:292"$0$"	 * @param url the URL to check"
"ResourceUtils.java:293"$0$"	 * @return whether the URL has been identified as a JAR file URL"
"ResourceUtils.java:294"$0$"	 * @since 4.1"
"ResourceUtils.java:295"$0$"	 */"
"ResourceUtils.java:296"$1$"	public static boolean isJarFileURL(URL url) {"
"ResourceUtils.java:297"$1$"		return (URL_PROTOCOL_FILE.equals(url.getProtocol()) &&"
"ResourceUtils.java:298"$1$"				url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION));"
"ResourceUtils.java:299"$1$"	}"
"ResourceUtils.java:300"$0$""
"ResourceUtils.java:301"$0$"	/**"
"ResourceUtils.java:302"$0$"	 * Extract the URL for the actual jar file from the given URL"
"ResourceUtils.java:303"$0$"	 * (which may point to a resource in a jar file or to a jar file itself)."
"ResourceUtils.java:304"$0$"	 * @param jarUrl the original URL"
"ResourceUtils.java:305"$0$"	 * @return the URL for the actual jar file"
"ResourceUtils.java:306"$0$"	 * @throws MalformedURLException if no valid jar file URL could be extracted"
"ResourceUtils.java:307"$0$"	 */"
"ResourceUtils.java:308"$1$"	public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {"
"ResourceUtils.java:309"$1$"		String urlFile = jarUrl.getFile();"
"ResourceUtils.java:310"$1$"		int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);"
"ResourceUtils.java:311"$1$"		if (separatorIndex != -1) {"
"ResourceUtils.java:312"$1$"			String jarFile = urlFile.substring(0, separatorIndex);"
"ResourceUtils.java:313"$1$"			try {"
"ResourceUtils.java:314"$1$"				return new URL(jarFile);"
"ResourceUtils.java:315"$1$"			}"
"ResourceUtils.java:316"$1$"			catch (MalformedURLException ex) {"
"ResourceUtils.java:317"$0$"				// Probably no protocol in original jar URL, like ""jar:C:/mypath/myjar.jar""."
"ResourceUtils.java:318"$0$"				// This usually indicates that the jar file resides in the file system."
"ResourceUtils.java:319"$1$"				if (!jarFile.startsWith(""/"")) {"
"ResourceUtils.java:320"$1$"					jarFile = ""/"" + jarFile;"
"ResourceUtils.java:321"$1$"				}"
"ResourceUtils.java:322"$0$"				return new URL(FILE_URL_PREFIX + jarFile);"
"ResourceUtils.java:323"$0$"			}"
"ResourceUtils.java:324"$0$"		}"
"ResourceUtils.java:325"$1$"		else {"
"ResourceUtils.java:326"$1$"			return jarUrl;"
"ResourceUtils.java:327"$1$"		}"
"ResourceUtils.java:328"$0$"	}"
"ResourceUtils.java:329"$0$""
"ResourceUtils.java:330"$0$"	/**"
"ResourceUtils.java:331"$0$"	 * Extract the URL for the outermost archive from the given jar/war URL"
"ResourceUtils.java:332"$0$"	 * (which may point to a resource in a jar file or to a jar file itself)."
"ResourceUtils.java:333"$0$"	 * <p>In the case of a jar file nested within a war file, this will return"
"ResourceUtils.java:334"$0$"	 * a URL to the war file since that is the one resolvable in the file system."
"ResourceUtils.java:335"$0$"	 * @param jarUrl the original URL"
"ResourceUtils.java:336"$0$"	 * @return the URL for the actual jar file"
"ResourceUtils.java:337"$0$"	 * @throws MalformedURLException if no valid jar file URL could be extracted"
"ResourceUtils.java:338"$0$"	 * @since 4.1.8"
"ResourceUtils.java:339"$0$"	 * @see #extractJarFileURL(URL)"
"ResourceUtils.java:340"$0$"	 */"
"ResourceUtils.java:341"$1$"	public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {"
"ResourceUtils.java:342"$1$"		String urlFile = jarUrl.getFile();"
"ResourceUtils.java:343"$1$""
"ResourceUtils.java:344"$1$"		int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);"
"ResourceUtils.java:345"$1$"		if (endIndex != -1) {"
"ResourceUtils.java:346"$0$"			// Tomcat's ""war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"""
"ResourceUtils.java:347"$1$"			String warFile = urlFile.substring(0, endIndex);"
"ResourceUtils.java:348"$1$"			if (URL_PROTOCOL_WAR.equals(jarUrl.getProtocol())) {"
"ResourceUtils.java:349"$1$"				return new URL(warFile);"
"ResourceUtils.java:350"$1$"			}"
"ResourceUtils.java:351"$0$"			int startIndex = warFile.indexOf(WAR_URL_PREFIX);"
"ResourceUtils.java:352"$1$"			if (startIndex != -1) {"
"ResourceUtils.java:353"$1$"				return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));"
"ResourceUtils.java:354"$1$"			}"
"ResourceUtils.java:355"$0$"		}"
"ResourceUtils.java:356"$0$""
"ResourceUtils.java:357"$0$"		// Regular ""jar:file:...myjar.jar!/myentry.txt"""
"ResourceUtils.java:358"$0$"		return extractJarFileURL(jarUrl);"
"ResourceUtils.java:359"$0$"	}"
"ResourceUtils.java:360"$0$""
"ResourceUtils.java:361"$0$"	/**"
"ResourceUtils.java:362"$0$"	 * Create a URI instance for the given URL,"
"ResourceUtils.java:363"$0$"	 * replacing spaces with ""%20"" URI encoding first."
"ResourceUtils.java:364"$0$"	 * @param url the URL to convert into a URI instance"
"ResourceUtils.java:365"$0$"	 * @return the URI instance"
"ResourceUtils.java:366"$0$"	 * @throws URISyntaxException if the URL wasn't a valid URI"
"ResourceUtils.java:367"$0$"	 * @see java.net.URL#toURI()"
"ResourceUtils.java:368"$0$"	 */"
"ResourceUtils.java:369"$1$"	public static URI toURI(URL url) throws URISyntaxException {"
"ResourceUtils.java:370"$1$"		return toURI(url.toString());"
"ResourceUtils.java:371"$1$"	}"
"ResourceUtils.java:372"$0$""
"ResourceUtils.java:373"$0$"	/**"
"ResourceUtils.java:374"$0$"	 * Create a URI instance for the given location String,"
"ResourceUtils.java:375"$0$"	 * replacing spaces with ""%20"" URI encoding first."
"ResourceUtils.java:376"$0$"	 * @param location the location String to convert into a URI instance"
"ResourceUtils.java:377"$0$"	 * @return the URI instance"
"ResourceUtils.java:378"$0$"	 * @throws URISyntaxException if the location wasn't a valid URI"
"ResourceUtils.java:379"$0$"	 */"
"ResourceUtils.java:380"$1$"	public static URI toURI(String location) throws URISyntaxException {"
"ResourceUtils.java:381"$1$"		return new URI(StringUtils.replace(location, "" "", ""%20""));"
"ResourceUtils.java:382"$1$"	}"
"ResourceUtils.java:383"$0$""
"ResourceUtils.java:384"$0$"	/**"
"ResourceUtils.java:385"$1$"	 * Set the {@link URLConnection#setUseCaches ""useCaches""} flag on the"
"ResourceUtils.java:386"$1$"	 * given connection, preferring {@code false} but leaving the"
"ResourceUtils.java:387"$1$"	 * flag at {@code true} for JNLP based resources."
"ResourceUtils.java:388"$0$"	 * @param con the URLConnection to set the flag on"
"ResourceUtils.java:389"$0$"	 */"
"ResourceUtils.java:390"$1$"	public static void useCachesIfNecessary(URLConnection con) {"
"ResourceUtils.java:391"$1$"		con.setUseCaches(con.getClass().getSimpleName().startsWith(""JNLP""));"
"ResourceUtils.java:392"$1$"	}"
"ResourceUtils.java:393"$0$""
"ResourceUtils.java:394"$0$"}"
